(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Quagga"] = factory();
	else
		root["Quagga"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 67);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(19);

var assertThisInitialized = __webpack_require__(1);

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(140);

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  EPSILON: __webpack_require__(36),
  create: __webpack_require__(37),
  clone: __webpack_require__(72),
  fromValues: __webpack_require__(73),
  copy: __webpack_require__(74),
  set: __webpack_require__(75),
  equals: __webpack_require__(76),
  exactEquals: __webpack_require__(77),
  add: __webpack_require__(78),
  subtract: __webpack_require__(38),
  sub: __webpack_require__(79),
  multiply: __webpack_require__(39),
  mul: __webpack_require__(80),
  divide: __webpack_require__(40),
  div: __webpack_require__(81),
  inverse: __webpack_require__(82),
  min: __webpack_require__(83),
  max: __webpack_require__(84),
  rotate: __webpack_require__(85),
  floor: __webpack_require__(86),
  ceil: __webpack_require__(87),
  round: __webpack_require__(88),
  scale: __webpack_require__(89),
  scaleAndAdd: __webpack_require__(90),
  distance: __webpack_require__(41),
  dist: __webpack_require__(91),
  squaredDistance: __webpack_require__(42),
  sqrDist: __webpack_require__(92),
  length: __webpack_require__(43),
  len: __webpack_require__(93),
  squaredLength: __webpack_require__(44),
  sqrLen: __webpack_require__(94),
  negate: __webpack_require__(95),
  normalize: __webpack_require__(96),
  dot: __webpack_require__(97),
  cross: __webpack_require__(98),
  lerp: __webpack_require__(99),
  random: __webpack_require__(100),
  transformMat2: __webpack_require__(101),
  transformMat2d: __webpack_require__(102),
  transformMat3: __webpack_require__(103),
  transformMat4: __webpack_require__(104),
  forEach: __webpack_require__(105),
  limit: __webpack_require__(106)
};

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "imageRef", function() { return /* binding */ imageRef; });
__webpack_require__.d(__webpack_exports__, "computeIntegralImage2", function() { return /* binding */ computeIntegralImage2; });
__webpack_require__.d(__webpack_exports__, "computeIntegralImage", function() { return /* binding */ computeIntegralImage; });
__webpack_require__.d(__webpack_exports__, "thresholdImage", function() { return /* binding */ thresholdImage; });
__webpack_require__.d(__webpack_exports__, "computeHistogram", function() { return /* binding */ computeHistogram; });
__webpack_require__.d(__webpack_exports__, "sharpenLine", function() { return /* binding */ sharpenLine; });
__webpack_require__.d(__webpack_exports__, "determineOtsuThreshold", function() { return /* binding */ determineOtsuThreshold; });
__webpack_require__.d(__webpack_exports__, "otsuThreshold", function() { return /* binding */ otsuThreshold; });
__webpack_require__.d(__webpack_exports__, "computeBinaryImage", function() { return /* binding */ computeBinaryImage; });
__webpack_require__.d(__webpack_exports__, "cluster", function() { return /* binding */ cv_utils_cluster; });
__webpack_require__.d(__webpack_exports__, "Tracer", function() { return /* binding */ Tracer; });
__webpack_require__.d(__webpack_exports__, "DILATE", function() { return /* binding */ DILATE; });
__webpack_require__.d(__webpack_exports__, "ERODE", function() { return /* binding */ ERODE; });
__webpack_require__.d(__webpack_exports__, "dilate", function() { return /* binding */ dilate; });
__webpack_require__.d(__webpack_exports__, "erode", function() { return /* binding */ erode; });
__webpack_require__.d(__webpack_exports__, "subtract", function() { return /* binding */ subtract; });
__webpack_require__.d(__webpack_exports__, "bitwiseOr", function() { return /* binding */ bitwiseOr; });
__webpack_require__.d(__webpack_exports__, "countNonZero", function() { return /* binding */ countNonZero; });
__webpack_require__.d(__webpack_exports__, "topGeneric", function() { return /* binding */ topGeneric; });
__webpack_require__.d(__webpack_exports__, "grayArrayFromImage", function() { return /* binding */ grayArrayFromImage; });
__webpack_require__.d(__webpack_exports__, "grayArrayFromContext", function() { return /* binding */ grayArrayFromContext; });
__webpack_require__.d(__webpack_exports__, "grayAndHalfSampleFromCanvasData", function() { return /* binding */ grayAndHalfSampleFromCanvasData; });
__webpack_require__.d(__webpack_exports__, "computeGray", function() { return /* binding */ computeGray; });
__webpack_require__.d(__webpack_exports__, "loadImageArray", function() { return /* binding */ loadImageArray; });
__webpack_require__.d(__webpack_exports__, "halfSample", function() { return /* binding */ halfSample; });
__webpack_require__.d(__webpack_exports__, "hsv2rgb", function() { return /* binding */ hsv2rgb; });
__webpack_require__.d(__webpack_exports__, "_computeDivisors", function() { return /* binding */ _computeDivisors; });
__webpack_require__.d(__webpack_exports__, "calculatePatchSize", function() { return /* binding */ calculatePatchSize; });
__webpack_require__.d(__webpack_exports__, "_parseCSSDimensionValues", function() { return /* binding */ _parseCSSDimensionValues; });
__webpack_require__.d(__webpack_exports__, "_dimensionsConverters", function() { return /* binding */ _dimensionsConverters; });
__webpack_require__.d(__webpack_exports__, "computeImageArea", function() { return /* binding */ computeImageArea; });

// EXTERNAL MODULE: ./node_modules/gl-vec2/index.js
var gl_vec2 = __webpack_require__(7);

// EXTERNAL MODULE: ./node_modules/gl-vec3/index.js
var gl_vec3 = __webpack_require__(63);

// CONCATENATED MODULE: ./src/common/cluster.js
// TODO: cluster.js and cv_utils.js are pretty tightly intertwined, making for a complex conversion
// into typescript. be warned. :-)

var vec2 = {
  clone: gl_vec2["clone"],
  dot: gl_vec2["dot"]
};
/**
 * Creates a cluster for grouping similar orientations of datapoints
 */

/* harmony default export */ var cluster = ({
  create: function create(point, threshold) {
    var points = [];
    var center = {
      rad: 0,
      vec: vec2.clone([0, 0])
    };
    var pointMap = {};

    function _add(pointToAdd) {
      pointMap[pointToAdd.id] = pointToAdd;
      points.push(pointToAdd);
    }

    function updateCenter() {
      var i;
      var sum = 0;

      for (i = 0; i < points.length; i++) {
        sum += points[i].rad;
      }

      center.rad = sum / points.length;
      center.vec = vec2.clone([Math.cos(center.rad), Math.sin(center.rad)]);
    }

    function init() {
      _add(point);

      updateCenter();
    }

    init();
    return {
      add: function add(pointToAdd) {
        if (!pointMap[pointToAdd.id]) {
          _add(pointToAdd);

          updateCenter();
        }
      },
      fits: function fits(otherPoint) {
        // check cosine similarity to center-angle
        var similarity = Math.abs(vec2.dot(otherPoint.point.vec, center.vec));

        if (similarity > threshold) {
          return true;
        }

        return false;
      },
      getPoints: function getPoints() {
        return points;
      },
      getCenter: function getCenter() {
        return center;
      }
    };
  },
  createPoint: function createPoint(newPoint, id, property) {
    return {
      rad: newPoint[property],
      point: newPoint,
      id: id
    };
  }
});
// EXTERNAL MODULE: ./src/common/array_helper.ts
var array_helper = __webpack_require__(10);

// CONCATENATED MODULE: ./src/common/cv_utils.js
/* eslint-disable no-mixed-operators */

/* eslint-disable no-bitwise */




var cv_utils_vec2 = {
  clone: gl_vec2["clone"]
};
var vec3 = {
  clone: gl_vec3["clone"]
};
/**
 * @param x x-coordinate
 * @param y y-coordinate
 * @return ImageReference {x,y} Coordinate
 */

function imageRef(x, y) {
  var that = {
    x: x,
    y: y,
    toVec2: function toVec2() {
      return cv_utils_vec2.clone([this.x, this.y]);
    },
    toVec3: function toVec3() {
      return vec3.clone([this.x, this.y, 1]);
    },
    round: function round() {
      this.x = this.x > 0.0 ? Math.floor(this.x + 0.5) : Math.floor(this.x - 0.5);
      this.y = this.y > 0.0 ? Math.floor(this.y + 0.5) : Math.floor(this.y - 0.5);
      return this;
    }
  };
  return that;
}
/**
 * Computes an integral image of a given grayscale image.
 * @param imageDataContainer {ImageDataContainer} the image to be integrated
 */

function computeIntegralImage2(imageWrapper, integralWrapper) {
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0;
  var posA = 0;
  var posB = 0;
  var posC = 0;
  var posD = 0;
  var x;
  var y; // sum up first column

  posB = width;
  sum = 0;

  for (y = 1; y < height; y++) {
    sum += imageData[posA];
    integralImageData[posB] += sum;
    posA += width;
    posB += width;
  }

  posA = 0;
  posB = 1;
  sum = 0;

  for (x = 1; x < width; x++) {
    sum += imageData[posA];
    integralImageData[posB] += sum;
    posA++;
    posB++;
  }

  for (y = 1; y < height; y++) {
    posA = y * width + 1;
    posB = (y - 1) * width + 1;
    posC = y * width;
    posD = (y - 1) * width;

    for (x = 1; x < width; x++) {
      integralImageData[posA] += imageData[posA] + integralImageData[posB] + integralImageData[posC] - integralImageData[posD];
      posA++;
      posB++;
      posC++;
      posD++;
    }
  }
}
function computeIntegralImage(imageWrapper, integralWrapper) {
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0; // sum up first row

  for (var i = 0; i < width; i++) {
    sum += imageData[i];
    integralImageData[i] = sum;
  }

  for (var v = 1; v < height; v++) {
    sum = 0;

    for (var u = 0; u < width; u++) {
      sum += imageData[v * width + u];
      integralImageData[v * width + u] = sum + integralImageData[(v - 1) * width + u];
    }
  }
}
function thresholdImage(imageWrapper, threshold, targetWrapper) {
  if (!targetWrapper) {
    // eslint-disable-next-line no-param-reassign
    targetWrapper = imageWrapper;
  }

  var imageData = imageWrapper.data;
  var length = imageData.length;
  var targetData = targetWrapper.data;

  while (length--) {
    targetData[length] = imageData[length] < threshold ? 1 : 0;
  }
}
function computeHistogram(imageWrapper, bitsPerPixel) {
  if (!bitsPerPixel) {
    // eslint-disable-next-line no-param-reassign
    bitsPerPixel = 8;
  }

  var imageData = imageWrapper.data;
  var length = imageData.length;
  var bitShift = 8 - bitsPerPixel;
  var bucketCnt = 1 << bitsPerPixel;
  var hist = new Int32Array(bucketCnt);

  while (length--) {
    hist[imageData[length] >> bitShift]++;
  }

  return hist;
}
function sharpenLine(line) {
  var i;
  var length = line.length;
  var left = line[0];
  var center = line[1];
  var right;

  for (i = 1; i < length - 1; i++) {
    right = line[i + 1]; //  -1 4 -1 kernel
    // eslint-disable-next-line no-param-reassign

    line[i - 1] = center * 2 - left - right & 255;
    left = center;
    center = right;
  }

  return line;
}
function determineOtsuThreshold(imageWrapper) {
  var bitsPerPixel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var hist;
  var bitShift = 8 - bitsPerPixel;

  function px(init, end) {
    var sum = 0;

    for (var i = init; i <= end; i++) {
      sum += hist[i];
    }

    return sum;
  }

  function mx(init, end) {
    var sum = 0;

    for (var i = init; i <= end; i++) {
      sum += i * hist[i];
    }

    return sum;
  }

  function determineThreshold() {
    var vet = [0];
    var p1;
    var p2;
    var p12;
    var m1;
    var m2;
    var m12;
    var max = (1 << bitsPerPixel) - 1;
    hist = computeHistogram(imageWrapper, bitsPerPixel);

    for (var k = 1; k < max; k++) {
      p1 = px(0, k);
      p2 = px(k + 1, max);
      p12 = p1 * p2;

      if (p12 === 0) {
        p12 = 1;
      }

      m1 = mx(0, k) * p2;
      m2 = mx(k + 1, max) * p1;
      m12 = m1 - m2;
      vet[k] = m12 * m12 / p12;
    }

    return array_helper["a" /* default */].maxIndex(vet);
  }

  var threshold = determineThreshold();
  return threshold << bitShift;
}
function otsuThreshold(imageWrapper, targetWrapper) {
  var threshold = determineOtsuThreshold(imageWrapper);
  thresholdImage(imageWrapper, threshold, targetWrapper);
  return threshold;
} // local thresholding

function computeBinaryImage(imageWrapper, integralWrapper, targetWrapper) {
  computeIntegralImage(imageWrapper, integralWrapper);

  if (!targetWrapper) {
    // eslint-disable-next-line no-param-reassign
    targetWrapper = imageWrapper;
  }

  var imageData = imageWrapper.data;
  var targetData = targetWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0;
  var v;
  var u;
  var kernel = 3;
  var A;
  var B;
  var C;
  var D;
  var avg;
  var size = (kernel * 2 + 1) * (kernel * 2 + 1); // clear out top & bottom-border

  for (v = 0; v <= kernel; v++) {
    for (u = 0; u < width; u++) {
      targetData[v * width + u] = 0;
      targetData[(height - 1 - v) * width + u] = 0;
    }
  } // clear out left & right border


  for (v = kernel; v < height - kernel; v++) {
    for (u = 0; u <= kernel; u++) {
      targetData[v * width + u] = 0;
      targetData[v * width + (width - 1 - u)] = 0;
    }
  }

  for (v = kernel + 1; v < height - kernel - 1; v++) {
    for (u = kernel + 1; u < width - kernel; u++) {
      A = integralImageData[(v - kernel - 1) * width + (u - kernel - 1)];
      B = integralImageData[(v - kernel - 1) * width + (u + kernel)];
      C = integralImageData[(v + kernel) * width + (u - kernel - 1)];
      D = integralImageData[(v + kernel) * width + (u + kernel)];
      sum = D - C - B + A;
      avg = sum / size;
      targetData[v * width + u] = imageData[v * width + u] > avg + 5 ? 0 : 1;
    }
  }
}
function cv_utils_cluster(points, threshold, property) {
  var i;
  var k;
  var thisCluster;
  var point;
  var clusters = [];

  if (!property) {
    // eslint-disable-next-line no-param-reassign
    property = 'rad';
  }

  function addToCluster(newPoint) {
    var found = false;

    for (k = 0; k < clusters.length; k++) {
      thisCluster = clusters[k];

      if (thisCluster.fits(newPoint)) {
        thisCluster.add(newPoint);
        found = true;
      }
    }

    return found;
  } // iterate over each cloud


  for (i = 0; i < points.length; i++) {
    point = cluster.createPoint(points[i], i, property);

    if (!addToCluster(point)) {
      clusters.push(cluster.create(point, threshold));
    }
  }

  return clusters;
}
var Tracer = {
  trace: function trace(points, vec) {
    var iteration;
    var maxIterations = 10;
    var top = [];
    var result = [];
    var centerPos = 0;
    var currentPos = 0;

    function trace(idx, forward) {
      var to;
      var toIdx;
      var predictedPos;
      var thresholdX = 1;
      var thresholdY = Math.abs(vec[1] / 10);
      var found = false;

      function match(pos, predicted) {
        if (pos.x > predicted.x - thresholdX && pos.x < predicted.x + thresholdX && pos.y > predicted.y - thresholdY && pos.y < predicted.y + thresholdY) {
          return true;
        }

        return false;
      } // check if the next index is within the vec specifications
      // if not, check as long as the threshold is met


      var from = points[idx];

      if (forward) {
        predictedPos = {
          x: from.x + vec[0],
          y: from.y + vec[1]
        };
      } else {
        predictedPos = {
          x: from.x - vec[0],
          y: from.y - vec[1]
        };
      }

      toIdx = forward ? idx + 1 : idx - 1;
      to = points[toIdx]; // eslint-disable-next-line no-cond-assign

      while (to && (found = match(to, predictedPos)) !== true && Math.abs(to.y - from.y) < vec[1]) {
        toIdx = forward ? toIdx + 1 : toIdx - 1;
        to = points[toIdx];
      }

      return found ? toIdx : null;
    }

    for (iteration = 0; iteration < maxIterations; iteration++) {
      // randomly select point to start with
      centerPos = Math.floor(Math.random() * points.length); // trace forward

      top = [];
      currentPos = centerPos;
      top.push(points[currentPos]); // eslint-disable-next-line no-cond-assign

      while ((currentPos = trace(currentPos, true)) !== null) {
        top.push(points[currentPos]);
      }

      if (centerPos > 0) {
        currentPos = centerPos; // eslint-disable-next-line no-cond-assign

        while ((currentPos = trace(currentPos, false)) !== null) {
          top.push(points[currentPos]);
        }
      }

      if (top.length > result.length) {
        result = top;
      }
    }

    return result;
  }
};
var DILATE = 1;
var ERODE = 2;
function dilate(inImageWrapper, outImageWrapper) {
  var v;
  var u;
  var inImageData = inImageWrapper.data;
  var outImageData = outImageWrapper.data;
  var height = inImageWrapper.size.y;
  var width = inImageWrapper.size.x;
  var sum;
  var yStart1;
  var yStart2;
  var xStart1;
  var xStart2;

  for (v = 1; v < height - 1; v++) {
    for (u = 1; u < width - 1; u++) {
      yStart1 = v - 1;
      yStart2 = v + 1;
      xStart1 = u - 1;
      xStart2 = u + 1;
      sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
      outImageData[v * width + u] = sum > 0 ? 1 : 0;
    }
  }
}
function erode(inImageWrapper, outImageWrapper) {
  var v;
  var u;
  var inImageData = inImageWrapper.data;
  var outImageData = outImageWrapper.data;
  var height = inImageWrapper.size.y;
  var width = inImageWrapper.size.x;
  var sum;
  var yStart1;
  var yStart2;
  var xStart1;
  var xStart2;

  for (v = 1; v < height - 1; v++) {
    for (u = 1; u < width - 1; u++) {
      yStart1 = v - 1;
      yStart2 = v + 1;
      xStart1 = u - 1;
      xStart2 = u + 1;
      sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
      outImageData[v * width + u] = sum === 5 ? 1 : 0;
    }
  }
}
function subtract(aImageWrapper, bImageWrapper, resultImageWrapper) {
  if (!resultImageWrapper) {
    // eslint-disable-next-line no-param-reassign
    resultImageWrapper = aImageWrapper;
  }

  var length = aImageWrapper.data.length;
  var aImageData = aImageWrapper.data;
  var bImageData = bImageWrapper.data;
  var cImageData = resultImageWrapper.data;

  while (length--) {
    cImageData[length] = aImageData[length] - bImageData[length];
  }
}
function bitwiseOr(aImageWrapper, bImageWrapper, resultImageWrapper) {
  if (!resultImageWrapper) {
    // eslint-disable-next-line no-param-reassign
    resultImageWrapper = aImageWrapper;
  }

  var length = aImageWrapper.data.length;
  var aImageData = aImageWrapper.data;
  var bImageData = bImageWrapper.data;
  var cImageData = resultImageWrapper.data;

  while (length--) {
    cImageData[length] = aImageData[length] || bImageData[length];
  }
}
function countNonZero(imageWrapper) {
  var length = imageWrapper.data.length;
  var data = imageWrapper.data;
  var sum = 0;

  while (length--) {
    sum += data[length];
  }

  return sum;
}
function topGeneric(list, top, scoreFunc) {
  var i;
  var minIdx = 0;
  var min = 0;
  var queue = [];
  var score;
  var hit;
  var pos;

  for (i = 0; i < top; i++) {
    queue[i] = {
      score: 0,
      item: null
    };
  }

  for (i = 0; i < list.length; i++) {
    score = scoreFunc.apply(this, [list[i]]);

    if (score > min) {
      hit = queue[minIdx];
      hit.score = score;
      hit.item = list[i];
      min = Number.MAX_VALUE;

      for (pos = 0; pos < top; pos++) {
        if (queue[pos].score < min) {
          min = queue[pos].score;
          minIdx = pos;
        }
      }
    }
  }

  return queue;
}
function grayArrayFromImage(htmlImage, offsetX, ctx, array) {
  ctx.drawImage(htmlImage, offsetX, 0, htmlImage.width, htmlImage.height);
  var ctxData = ctx.getImageData(offsetX, 0, htmlImage.width, htmlImage.height).data;
  computeGray(ctxData, array);
}
function grayArrayFromContext(ctx, size, offset, array) {
  var ctxData = ctx.getImageData(offset.x, offset.y, size.x, size.y).data;
  computeGray(ctxData, array);
}
function grayAndHalfSampleFromCanvasData(canvasData, size, outArray) {
  var topRowIdx = 0;
  var bottomRowIdx = size.x;
  var endIdx = Math.floor(canvasData.length / 4);
  var outWidth = size.x / 2;
  var outImgIdx = 0;
  var inWidth = size.x;
  var i;

  while (bottomRowIdx < endIdx) {
    for (i = 0; i < outWidth; i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[outImgIdx] = (0.299 * canvasData[topRowIdx * 4 + 0] + 0.587 * canvasData[topRowIdx * 4 + 1] + 0.114 * canvasData[topRowIdx * 4 + 2] + (0.299 * canvasData[(topRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(topRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(topRowIdx + 1) * 4 + 2]) + (0.299 * canvasData[bottomRowIdx * 4 + 0] + 0.587 * canvasData[bottomRowIdx * 4 + 1] + 0.114 * canvasData[bottomRowIdx * 4 + 2]) + (0.299 * canvasData[(bottomRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(bottomRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(bottomRowIdx + 1) * 4 + 2])) / 4;
      outImgIdx++;
      topRowIdx += 2;
      bottomRowIdx += 2;
    }

    topRowIdx += inWidth;
    bottomRowIdx += inWidth;
  }
}
function computeGray(imageData, outArray, config) {
  var l = imageData.length / 4 | 0;
  var singleChannel = config && config.singleChannel === true;

  if (singleChannel) {
    for (var i = 0; i < l; i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[i] = imageData[i * 4 + 0];
    }
  } else {
    for (var _i = 0; _i < l; _i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[_i] = 0.299 * imageData[_i * 4 + 0] + 0.587 * imageData[_i * 4 + 1] + 0.114 * imageData[_i * 4 + 2];
    }
  }
}
function loadImageArray(src, callback) {
  var canvas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document && document.createElement('canvas');
  var img = new Image();
  img.callback = callback;

  img.onload = function () {
    // eslint-disable-next-line no-param-reassign
    canvas.width = this.width; // eslint-disable-next-line no-param-reassign

    canvas.height = this.height;
    var ctx = canvas.getContext('2d');
    ctx.drawImage(this, 0, 0);
    var array = new Uint8Array(this.width * this.height);
    ctx.drawImage(this, 0, 0);

    var _ctx$getImageData = ctx.getImageData(0, 0, this.width, this.height),
        data = _ctx$getImageData.data;

    computeGray(data, array);
    this.callback(array, {
      x: this.width,
      y: this.height
    }, this);
  };

  img.src = src;
}
/**
 * @param inImg {ImageWrapper} input image to be sampled
 * @param outImg {ImageWrapper} to be stored in
 */

function halfSample(inImgWrapper, outImgWrapper) {
  var inImg = inImgWrapper.data;
  var inWidth = inImgWrapper.size.x;
  var outImg = outImgWrapper.data;
  var topRowIdx = 0;
  var bottomRowIdx = inWidth;
  var endIdx = inImg.length;
  var outWidth = inWidth / 2;
  var outImgIdx = 0;

  while (bottomRowIdx < endIdx) {
    for (var i = 0; i < outWidth; i++) {
      outImg[outImgIdx] = Math.floor((inImg[topRowIdx] + inImg[topRowIdx + 1] + inImg[bottomRowIdx] + inImg[bottomRowIdx + 1]) / 4);
      outImgIdx++;
      topRowIdx += 2;
      bottomRowIdx += 2;
    }

    topRowIdx += inWidth;
    bottomRowIdx += inWidth;
  }
}
function hsv2rgb(hsv) {
  var rgb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
  var h = hsv[0];
  var s = hsv[1];
  var v = hsv[2];
  var c = v * s;
  var x = c * (1 - Math.abs(h / 60 % 2 - 1));
  var m = v - c;
  var r = 0;
  var g = 0;
  var b = 0;

  if (h < 60) {
    r = c;
    g = x;
  } else if (h < 120) {
    r = x;
    g = c;
  } else if (h < 180) {
    g = c;
    b = x;
  } else if (h < 240) {
    g = x;
    b = c;
  } else if (h < 300) {
    r = x;
    b = c;
  } else if (h < 360) {
    r = c;
    b = x;
  } // eslint-disable-next-line no-param-reassign


  rgb[0] = (r + m) * 255 | 0; // eslint-disable-next-line no-param-reassign

  rgb[1] = (g + m) * 255 | 0; // eslint-disable-next-line no-param-reassign

  rgb[2] = (b + m) * 255 | 0;
  return rgb;
}
function _computeDivisors(n) {
  var largeDivisors = [];
  var divisors = [];

  for (var i = 1; i < Math.sqrt(n) + 1; i++) {
    if (n % i === 0) {
      divisors.push(i);

      if (i !== n / i) {
        largeDivisors.unshift(Math.floor(n / i));
      }
    }
  }

  return divisors.concat(largeDivisors);
}

function _computeIntersection(arr1, arr2) {
  var i = 0;
  var j = 0;
  var result = [];

  while (i < arr1.length && j < arr2.length) {
    if (arr1[i] === arr2[j]) {
      result.push(arr1[i]);
      i++;
      j++;
    } else if (arr1[i] > arr2[j]) {
      j++;
    } else {
      i++;
    }
  }

  return result;
}

function calculatePatchSize(patchSize, imgSize) {
  var divisorsX = _computeDivisors(imgSize.x);

  var divisorsY = _computeDivisors(imgSize.y);

  var wideSide = Math.max(imgSize.x, imgSize.y);

  var common = _computeIntersection(divisorsX, divisorsY);

  var nrOfPatchesList = [8, 10, 15, 20, 32, 60, 80];
  var nrOfPatchesMap = {
    'x-small': 5,
    small: 4,
    medium: 3,
    large: 2,
    'x-large': 1
  };
  var nrOfPatchesIdx = nrOfPatchesMap[patchSize] || nrOfPatchesMap.medium;
  var nrOfPatches = nrOfPatchesList[nrOfPatchesIdx];
  var desiredPatchSize = Math.floor(wideSide / nrOfPatches);
  var optimalPatchSize;

  function findPatchSizeForDivisors(divisors) {
    var i = 0;
    var found = divisors[Math.floor(divisors.length / 2)];

    while (i < divisors.length - 1 && divisors[i] < desiredPatchSize) {
      i++;
    }

    if (i > 0) {
      if (Math.abs(divisors[i] - desiredPatchSize) > Math.abs(divisors[i - 1] - desiredPatchSize)) {
        found = divisors[i - 1];
      } else {
        found = divisors[i];
      }
    }

    if (desiredPatchSize / found < nrOfPatchesList[nrOfPatchesIdx + 1] / nrOfPatchesList[nrOfPatchesIdx] && desiredPatchSize / found > nrOfPatchesList[nrOfPatchesIdx - 1] / nrOfPatchesList[nrOfPatchesIdx]) {
      return {
        x: found,
        y: found
      };
    }

    return null;
  }

  optimalPatchSize = findPatchSizeForDivisors(common);

  if (!optimalPatchSize) {
    optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(wideSide));

    if (!optimalPatchSize) {
      optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(desiredPatchSize * nrOfPatches));
    }
  }

  return optimalPatchSize;
}
function _parseCSSDimensionValues(value) {
  var dimension = {
    value: parseFloat(value),
    unit: value.indexOf('%') === value.length - 1 ? '%' : '%'
  };
  return dimension;
}
var _dimensionsConverters = {
  top: function top(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.height * (dimension.value / 100)) : null;
  },
  right: function right(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.width - context.width * (dimension.value / 100)) : null;
  },
  bottom: function bottom(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.height - context.height * (dimension.value / 100)) : null;
  },
  left: function left(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.width * (dimension.value / 100)) : null;
  }
};
function computeImageArea(inputWidth, inputHeight, area) {
  var context = {
    width: inputWidth,
    height: inputHeight
  };
  var parsedArea = Object.keys(area).reduce(function (result, key) {
    var value = area[key];

    var parsed = _parseCSSDimensionValues(value);

    var calculated = _dimensionsConverters[key](parsed, context); // eslint-disable-next-line no-param-reassign


    result[key] = calculated;
    return result;
  }, {});
  return {
    sx: parsedArea.left,
    sy: parsedArea.top,
    sw: parsedArea.right - parsedArea.left,
    sh: parsedArea.bottom - parsedArea.top
  };
}

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// TODO: XYPosition should be an XYObject, but that breaks XYDefinition, which breaks drawPath() below.
// XYDefinition tells us which component of a given array or object is the "X" and which is the "Y".
// Usually this is 0 for X and 1 for Y, but might be used as 'x' for x and 'y' for Y.
/* harmony default export */ __webpack_exports__["a"] = ({
  drawRect: function drawRect(pos, size, ctx, style) {
    ctx.strokeStyle = style.color;
    ctx.fillStyle = style.color;
    ctx.lineWidth = style.lineWidth || 1;
    ctx.beginPath();
    ctx.strokeRect(pos.x, pos.y, size.x, size.y);
  },
  drawPath: function drawPath(path, def, ctx, style) {
    ctx.strokeStyle = style.color;
    ctx.fillStyle = style.color;
    ctx.lineWidth = style.lineWidth;
    ctx.beginPath();
    ctx.moveTo(path[0][def.x], path[0][def.y]);

    for (var j = 1; j < path.length; j++) {
      ctx.lineTo(path[j][def.x], path[j][def.y]);
    }

    ctx.closePath();
    ctx.stroke();
  },
  drawImage: function drawImage(imageData, size, ctx) {
    var canvasData = ctx.getImageData(0, 0, size.x, size.y);
    var data = canvasData.data;
    var canvasDataPos = data.length;
    var imageDataPos = imageData.length;

    if (canvasDataPos / imageDataPos !== 4) {
      return false;
    }

    while (imageDataPos--) {
      var value = imageData[imageDataPos];
      data[--canvasDataPos] = 255;
      data[--canvasDataPos] = value;
      data[--canvasDataPos] = value;
      data[--canvasDataPos] = value;
    }

    ctx.putImageData(canvasData, 0, 0);
    return true;
  }
});

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  init: function init(arr, val) {
    // arr.fill(val);
    var l = arr.length;

    while (l--) {
      arr[l] = val;
    }
  },

  /**
   * Shuffles the content of an array
   */
  shuffle: function shuffle(arr) {
    var i = arr.length - 1;

    for (i; i >= 0; i--) {
      var j = Math.floor(Math.random() * i);
      var x = arr[i];
      arr[i] = arr[j];
      arr[j] = x;
    }

    return arr;
  },
  toPointList: function toPointList(arr) {
    var rows = arr.reduce(function (p, n) {
      var row = "[".concat(n.join(','), "]");
      p.push(row);
      return p;
    }, []);
    return "[".concat(rows.join(',\r\n'), "]");
  },

  /**
   * returns the elements which's score is bigger than the threshold
   */
  threshold: function threshold(arr, _threshold, scoreFunc) {
    var queue = arr.reduce(function (prev, next) {
      if (scoreFunc.apply(arr, [next]) >= _threshold) {
        prev.push(next);
      }

      return prev;
    }, []);
    return queue;
  },
  maxIndex: function maxIndex(arr) {
    var max = 0;

    for (var i = 0; i < arr.length; i++) {
      if (arr[i] > arr[max]) {
        max = i;
      }
    }

    return max;
  },
  max: function max(arr) {
    var max = 0;

    for (var i = 0; i < arr.length; i++) {
      if (arr[i] > max) {
        max = arr[i];
      }
    }

    return max;
  },
  sum: function sum(arr) {
    var length = arr.length;
    var sum = 0;

    while (length--) {
      sum += arr[length];
    }

    return sum;
  }
});

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(gl_vec2__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _cv_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8);
/* harmony import */ var _array_helper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10);







var vec2 = {
  clone: gl_vec2__WEBPACK_IMPORTED_MODULE_4__["clone"]
};

function assertNumberPositive(val) {
  if (val < 0) {
    throw new Error("expected positive number, received ".concat(val));
  }
}

var ImageWrapper = /*#__PURE__*/function () {
  // Represents a basic image combining the data and size. In addition, some methods for
  // manipulation are contained within.
  function ImageWrapper(size, data) {
    var ArrayType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Uint8Array;
    var initialize = arguments.length > 3 ? arguments[3] : undefined;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, ImageWrapper);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "data", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "size", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "indexMapping", void 0);

    if (!data) {
      this.data = new ArrayType(size.x * size.y);

      if (initialize) {
        _array_helper__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].init(this.data, 0);
      }
    } else {
      this.data = data;
    }

    this.size = size;
  } // tests if a position is within the image, extended out by a border on each side


  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(ImageWrapper, [{
    key: "inImageWithBorder",
    value: function inImageWithBorder(imgRef) {
      var border = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      assertNumberPositive(border); // TODO: code_128 starts failing miserably when i only allow imgRef to contain positive numbers.
      // TODO: this doesn't make much sense to me, why does it go negative?  Tests are not affected by
      // returning false, but the whole code_128 reader blows up when i throw on negative imgRef.
      // assertNumberPositive(imgRef.x);
      // assertNumberPositive(imgRef.y);

      return imgRef.x >= 0 && imgRef.y >= 0 && imgRef.x < this.size.x + border * 2 && imgRef.y < this.size.y + border * 2;
    } // Copy from THIS ImageWrapper to the new imageWrapper parameter, starting at from, stopping at
    // end of new imageWrapper size.

  }, {
    key: "subImageAsCopy",
    value: function subImageAsCopy(imageWrapper, from) {
      assertNumberPositive(from.x);
      assertNumberPositive(from.y);
      var _imageWrapper$size = imageWrapper.size,
          sizeX = _imageWrapper$size.x,
          sizeY = _imageWrapper$size.y;

      for (var x = 0; x < sizeX; x++) {
        for (var y = 0; y < sizeY; y++) {
          // eslint-disable-next-line no-param-reassign
          imageWrapper.data[y * sizeX + x] = this.data[(from.y + y) * this.size.x + from.x + x];
        }
      }

      return imageWrapper; // TODO: this function really probably should call into ImageWrapper somewhere to make
      // sure that all of it's parameters are set properly, something like
      // ImageWrapper.UpdateFrom()
      // that might take a provided data and size, and make sure there's no invalid indexMapping
      // hanging around, and such.
    } // Retrieve a grayscale value at the given pixel position of the image

  }, {
    key: "get",
    value: function get(x, y) {
      return this.data[y * this.size.x + x];
    } // Retrieve a grayscale value at the given pixel position of the image (safe, whatever that
    // means)

  }, {
    key: "getSafe",
    value: function getSafe(x, y) {
      // cache indexMapping because if we're using it once, we'll probably need it a bunch more
      // too
      if (!this.indexMapping) {
        this.indexMapping = {
          x: [],
          y: []
        };

        for (var i = 0; i < this.size.x; i++) {
          this.indexMapping.x[i] = i;
          this.indexMapping.x[i + this.size.x] = i;
        }

        for (var _i = 0; _i < this.size.y; _i++) {
          this.indexMapping.y[_i] = _i;
          this.indexMapping.y[_i + this.size.y] = _i;
        }
      }

      return this.data[this.indexMapping.y[y + this.size.y] * this.size.x + this.indexMapping.x[x + this.size.x]];
    } // Sets a given pixel position in the image to the given grayscale value

  }, {
    key: "set",
    value: function set(x, y, value) {
      this.data[y * this.size.x + x] = value;
      delete this.indexMapping;
      return this;
    } // Sets the border of the image (1 pixel) to zero

  }, {
    key: "zeroBorder",
    value: function zeroBorder() {
      var _this$size = this.size,
          width = _this$size.x,
          height = _this$size.y;

      for (var i = 0; i < width; i++) {
        // eslint-disable-next-line no-multi-assign
        this.data[i] = this.data[(height - 1) * width + i] = 0;
      }

      for (var _i2 = 1; _i2 < height - 1; _i2++) {
        // eslint-disable-next-line no-multi-assign
        this.data[_i2 * width] = this.data[_i2 * width + (width - 1)] = 0;
      }

      delete this.indexMapping;
      return this;
    } // TODO: this function is entirely too large for me to reason out right at this moment that i'm handling
    // all the rest of it, so this is a verbatim copy of the javascript source, with only tweaks
    // necessary to get it to run, no thought put into it yet.

  }, {
    key: "moments",
    value: function moments(labelCount) {
      var data = this.data;
      var x;
      var y;
      var height = this.size.y;
      var width = this.size.x;
      var val;
      var ysq;
      var labelSum = [];
      var i;
      var label;
      var mu11;
      var mu02;
      var mu20;
      var x_;
      var y_;
      var tmp;
      var result = [];
      var PI = Math.PI;
      var PI_4 = PI / 4;

      if (labelCount <= 0) {
        return result;
      }

      for (i = 0; i < labelCount; i++) {
        labelSum[i] = {
          m00: 0,
          m01: 0,
          m10: 0,
          m11: 0,
          m02: 0,
          m20: 0,
          theta: 0,
          rad: 0
        };
      }

      for (y = 0; y < height; y++) {
        ysq = y * y;

        for (x = 0; x < width; x++) {
          val = data[y * width + x];

          if (val > 0) {
            label = labelSum[val - 1];
            label.m00 += 1;
            label.m01 += y;
            label.m10 += x;
            label.m11 += x * y;
            label.m02 += ysq;
            label.m20 += x * x;
          }
        }
      }

      for (i = 0; i < labelCount; i++) {
        label = labelSum[i]; // eslint-disable-next-line no-restricted-globals

        if (!isNaN(label.m00) && label.m00 !== 0) {
          x_ = label.m10 / label.m00;
          y_ = label.m01 / label.m00;
          mu11 = label.m11 / label.m00 - x_ * y_;
          mu02 = label.m02 / label.m00 - y_ * y_;
          mu20 = label.m20 / label.m00 - x_ * x_;
          tmp = (mu02 - mu20) / (2 * mu11);
          tmp = 0.5 * Math.atan(tmp) + (mu11 >= 0 ? PI_4 : -PI_4) + PI; // eslint-disable-next-line no-mixed-operators

          label.theta = (tmp * 180 / PI + 90) % 180 - 90;

          if (label.theta < 0) {
            label.theta += 180;
          }

          label.rad = tmp > PI ? tmp - PI : tmp;
          label.vec = vec2.clone([Math.cos(tmp), Math.sin(tmp)]);
          result.push(label);
        }
      }

      return result;
    } // return a Uint8ClampedArray containing this grayscale image converted to RGBA form

  }, {
    key: "getAsRGBA",
    value: function getAsRGBA() {
      var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
      var ret = new Uint8ClampedArray(4 * this.size.x * this.size.y);

      for (var y = 0; y < this.size.y; y++) {
        for (var x = 0; x < this.size.x; x++) {
          var pixel = y * this.size.x + x;
          var current = this.get(x, y) * scale;
          ret[pixel * 4 + 0] = current;
          ret[pixel * 4 + 1] = current;
          ret[pixel * 4 + 2] = current;
          ret[pixel * 4 + 3] = 255;
        }
      }

      return ret;
    } // Display this ImageWrapper in a given Canvas element at the specified scale

  }, {
    key: "show",
    value: function show(canvas) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;
      var ctx = canvas.getContext('2d');

      if (!ctx) {
        throw new Error('Unable to get canvas context');
      }

      var frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
      var data = this.getAsRGBA(scale); // eslint-disable-next-line no-param-reassign

      canvas.width = this.size.x; // eslint-disable-next-line no-param-reassign

      canvas.height = this.size.y;
      var newFrame = new ImageData(data, frame.width, frame.height);
      ctx.putImageData(newFrame, 0, 0);
    } // Displays a specified SubImage area in a given canvas. This differs drastically from
    // creating a new SubImage and using it's show() method. Why? I don't have the answer to that
    // yet.  I suspect the HSV/RGB operations involved here are making it significantly different,
    // but until I can visualize these functions side by side, I'm just going to copy the existing
    // implementation.

  }, {
    key: "overlay",
    value: function overlay(canvas, inScale, from) {
      var adjustedScale = inScale < 0 || inScale > 360 ? 360 : inScale;
      var hsv = [0, 1, 1];
      var rgb = [0, 0, 0];
      var whiteRgb = [255, 255, 255];
      var blackRgb = [0, 0, 0];
      var result = [];
      var ctx = canvas.getContext('2d');

      if (!ctx) {
        throw new Error('Unable to get canvas context');
      }

      var frame = ctx.getImageData(from.x, from.y, this.size.x, this.size.y);
      var data = frame.data;
      var length = this.data.length;

      while (length--) {
        hsv[0] = this.data[length] * adjustedScale; // eslint-disable-next-line no-nested-ternary

        result = hsv[0] <= 0 ? whiteRgb : hsv[0] >= 360 ? blackRgb : Object(_cv_utils__WEBPACK_IMPORTED_MODULE_5__["hsv2rgb"])(hsv, rgb);
        var pos = length * 4;
        var _result = result;

        var _result2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_result, 3);

        data[pos] = _result2[0];
        data[pos + 1] = _result2[1];
        data[pos + 2] = _result2[2];
        data[pos + 3] = 255;
      }

      ctx.putImageData(frame, from.x, from.y);
    }
  }]);

  return ImageWrapper;
}();

/* harmony default export */ __webpack_exports__["a"] = (ImageWrapper);

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */;(function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined;/** Used as the semantic version number. */var VERSION='4.17.20';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Error message constants. */var CORE_ERROR_TEXT='Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',FUNC_ERROR_TEXT='Expected a function';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** Used to compose bitmasks for function metadata. */var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256,WRAP_FLIP_FLAG=512;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** Used to associate wrap methods with their bit flags. */var wrapFlags=[['ary',WRAP_ARY_FLAG],['bind',WRAP_BIND_FLAG],['bindKey',WRAP_BIND_KEY_FLAG],['curry',WRAP_CURRY_FLAG],['curryRight',WRAP_CURRY_RIGHT_FLAG],['flip',WRAP_FLIP_FLAG],['partial',WRAP_PARTIAL_FLAG],['partialRight',WRAP_PARTIAL_RIGHT_FLAG],['rearg',WRAP_REARG_FLAG]];/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',domExcTag='[object DOMException]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',promiseTag='[object Promise]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39);/g,reUnescapedHtml=/[&<>"']/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading and trailing whitespace. */var reTrim=/^\s+|\s+$/g,reTrimStart=/^\s+/,reTrimEnd=/\s+$/;/** Used to match wrap detail comments. */var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/,reSplitDetails=/,? & /;/** Used to match words composed of alphanumeric characters. */var reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\n\r\u2028\u2029\\]/g;/** Used to compose unicode character classes. */var rsAstralRange='\\ud800-\\udfff',rsComboMarksRange='\\u0300-\\u036f',reComboHalfMarksRange='\\ufe20-\\ufe2f',rsComboSymbolsRange='\\u20d0-\\u20ff',rsComboRange=rsComboMarksRange+reComboHalfMarksRange+rsComboSymbolsRange,rsDingbatRange='\\u2700-\\u27bf',rsLowerRange='a-z\\xdf-\\xf6\\xf8-\\xff',rsMathOpRange='\\xac\\xb1\\xd7\\xf7',rsNonCharRange='\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',rsPunctuationRange='\\u2000-\\u206f',rsSpaceRange=' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',rsUpperRange='A-Z\\xc0-\\xd6\\xd8-\\xde',rsVarRange='\\ufe0e\\ufe0f',rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos="['\u2019]",rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboRange+']',rsDigits='\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz='\\ud83c[\\udffb-\\udfff]',rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional='(?:\\ud83c[\\udde6-\\uddff]){2}',rsSurrPair='[\\ud800-\\udbff][\\udc00-\\udfff]',rsUpper='['+rsUpperRange+']',rsZWJ='\\u200d';/** Used to compose unicode regexes. */var rsMiscLower='(?:'+rsLower+'|'+rsMisc+')',rsMiscUpper='(?:'+rsUpper+'|'+rsMisc+')',rsOptContrLower='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptContrUpper='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsOrdLower='\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',rsOrdUpper='\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reUnicode=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reUnicodeWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptContrLower+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsMiscUpper+'+'+rsOptContrUpper+'(?='+[rsBreak,rsUpper+rsMiscLower,'$'].join('|')+')',rsUpper+'?'+rsMiscLower+'+'+rsOptContrLower,rsUpper+'+'+rsOptContrUpper,rsOrdUpper,rsOrdLower,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasUnicode=RegExp('['+rsZWJ+rsAstralRange+rsComboRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','clearTimeout','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map Latin Unicode letters to basic Latin letters. */var deburredLetters={// Latin-1 Supplement block.
'\xc0':'A','\xc1':'A','\xc2':'A','\xc3':'A','\xc4':'A','\xc5':'A','\xe0':'a','\xe1':'a','\xe2':'a','\xe3':'a','\xe4':'a','\xe5':'a','\xc7':'C','\xe7':'c','\xd0':'D','\xf0':'d','\xc8':'E','\xc9':'E','\xca':'E','\xcb':'E','\xe8':'e','\xe9':'e','\xea':'e','\xeb':'e','\xcc':'I','\xcd':'I','\xce':'I','\xcf':'I','\xec':'i','\xed':'i','\xee':'i','\xef':'i','\xd1':'N','\xf1':'n','\xd2':'O','\xd3':'O','\xd4':'O','\xd5':'O','\xd6':'O','\xd8':'O','\xf2':'o','\xf3':'o','\xf4':'o','\xf5':'o','\xf6':'o','\xf8':'o','\xd9':'U','\xda':'U','\xdb':'U','\xdc':'U','\xf9':'u','\xfa':'u','\xfb':'u','\xfc':'u','\xdd':'Y','\xfd':'y','\xff':'y','\xc6':'Ae','\xe6':'ae','\xde':'Th','\xfe':'th','\xdf':'ss',// Latin Extended-A block.
'\u0100':'A','\u0102':'A','\u0104':'A','\u0101':'a','\u0103':'a','\u0105':'a','\u0106':'C','\u0108':'C','\u010a':'C','\u010c':'C','\u0107':'c','\u0109':'c','\u010b':'c','\u010d':'c','\u010e':'D','\u0110':'D','\u010f':'d','\u0111':'d','\u0112':'E','\u0114':'E','\u0116':'E','\u0118':'E','\u011a':'E','\u0113':'e','\u0115':'e','\u0117':'e','\u0119':'e','\u011b':'e','\u011c':'G','\u011e':'G','\u0120':'G','\u0122':'G','\u011d':'g','\u011f':'g','\u0121':'g','\u0123':'g','\u0124':'H','\u0126':'H','\u0125':'h','\u0127':'h','\u0128':'I','\u012a':'I','\u012c':'I','\u012e':'I','\u0130':'I','\u0129':'i','\u012b':'i','\u012d':'i','\u012f':'i','\u0131':'i','\u0134':'J','\u0135':'j','\u0136':'K','\u0137':'k','\u0138':'k','\u0139':'L','\u013b':'L','\u013d':'L','\u013f':'L','\u0141':'L','\u013a':'l','\u013c':'l','\u013e':'l','\u0140':'l','\u0142':'l','\u0143':'N','\u0145':'N','\u0147':'N','\u014a':'N','\u0144':'n','\u0146':'n','\u0148':'n','\u014b':'n','\u014c':'O','\u014e':'O','\u0150':'O','\u014d':'o','\u014f':'o','\u0151':'o','\u0154':'R','\u0156':'R','\u0158':'R','\u0155':'r','\u0157':'r','\u0159':'r','\u015a':'S','\u015c':'S','\u015e':'S','\u0160':'S','\u015b':'s','\u015d':'s','\u015f':'s','\u0161':'s','\u0162':'T','\u0164':'T','\u0166':'T','\u0163':'t','\u0165':'t','\u0167':'t','\u0168':'U','\u016a':'U','\u016c':'U','\u016e':'U','\u0170':'U','\u0172':'U','\u0169':'u','\u016b':'u','\u016d':'u','\u016f':'u','\u0171':'u','\u0173':'u','\u0174':'W','\u0175':'w','\u0176':'Y','\u0177':'y','\u0178':'Y','\u0179':'Z','\u017b':'Z','\u017d':'Z','\u017a':'z','\u017c':'z','\u017e':'z','\u0132':'IJ','\u0133':'ij','\u0152':'Oe','\u0153':'oe','\u0149':"'n",'\u017f':'s'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'"','&#39;':"'"};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\':'\\',"'":"'",'\n':'n','\r':'r','\u2028':'u2028','\u2029':'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `global` from Node.js. */var freeGlobal=typeof global=='object'&&global&&global.Object===Object&&global;/** Detect free variable `self`. */var freeSelf=typeof self=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports= true&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&typeof module=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{// Use `util.types` for Node.js 10+.
var types=freeModule&&freeModule.require&&freeModule.require('util').types;if(types){return types;}// Legacy `process.binding('util')` for Node.js < 10.
return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsArrayBuffer=nodeUtil&&nodeUtil.isArrayBuffer,nodeIsDate=nodeUtil&&nodeUtil.isDate,nodeIsMap=nodeUtil&&nodeUtil.isMap,nodeIsRegExp=nodeUtil&&nodeUtil.isRegExp,nodeIsSet=nodeUtil&&nodeUtil.isSet,nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/*--------------------------------------------------------------------------*/ /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEachRight(array,iteratee){var length=array==null?0:array.length;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */function arrayEvery(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludes(array,value){var length=array==null?0:array.length;return!!length&&baseIndexOf(array,value,0)>-1;}/**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array==null?0:array.length;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array==null?0:array.length;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */var asciiSize=baseProperty('length');/**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function asciiToArray(string){return string.split('');}/**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function asciiWords(string){return string.match(reAsciiWord)||[];}/**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return-1;}/**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOf(array,value,fromIndex){return value===value?strictIndexOf(array,value,fromIndex):baseFindIndex(array,baseIsNaN,fromIndex);}/**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return-1;}/**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */function baseIsNaN(value){return value!==value;}/**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */function baseMean(array,iteratee){var length=array==null?0:array.length;return length?baseSum(array,iteratee)/length:NAN;}/**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */function baseProperty(key){return function(object){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */function basePropertyOf(object){return function(key){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined){result=result===undefined?current:result+current;}}return result;}/**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */function baseToPairs(object,props){return arrayMap(props,function(key){return[key,object[key]];});}/**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */function baseUnary(func){return function(value){return func(value);};}/**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */function cacheHas(cache,key){return cache.has(key);}/**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}/**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */var deburrLetter=basePropertyOf(deburredLetters);/**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */var escapeHtmlChar=basePropertyOf(htmlEscapes);/**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */function escapeStringChar(chr){return'\\'+stringEscapes[chr];}/**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */function getValue(object,key){return object==null?undefined:object[key];}/**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */function hasUnicode(string){return reHasUnicode.test(string);}/**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}/**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return-1;}/**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictLastIndexOf(array,value,fromIndex){var index=fromIndex+1;while(index--){if(array[index]===value){return index;}}return index;}/**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}/**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}/**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */var unescapeHtmlChar=basePropertyOf(htmlUnescapes);/**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */function unicodeSize(string){var result=reUnicode.lastIndex=0;while(reUnicode.test(string)){++result;}return result;}/**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function unicodeToArray(string){return string.match(reUnicode)||[];}/**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function unicodeWords(string){return string.match(reUnicodeWord)||[];}/*--------------------------------------------------------------------------*/ /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */var runInContext=function runInContext(context){context=context==null?root:_.defaults(root.Object(),context,_.pick(root,contextProps));/** Built-in constructor references. */var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined,Symbol=context.Symbol,Uint8Array=context.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,spreadableSymbol=Symbol?Symbol.isConcatSpreadable:undefined,symIterator=Symbol?Symbol.iterator:undefined,symToStringTag=Symbol?Symbol.toStringTag:undefined;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/** Mocked built-ins. */var ctxClearTimeout=context.clearTimeout!==root.clearTimeout&&context.clearTimeout,ctxNow=Date&&Date.now!==root.Date.now&&Date.now,ctxSetTimeout=context.setTimeout!==root.setTimeout&&context.setTimeout;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=overArg(Object.keys,Object),nativeMax=Math.max,nativeMin=Math.min,nativeNow=Date.now,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReverse=arrayProto.reverse;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=Symbol?Symbol.prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined,symbolToString=symbolProto?symbolProto.toString:undefined;/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return{};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined;return result;};}();/**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */function baseLodash(){// No operation performed.
}/**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined;}/**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */lodash.templateSettings={/**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'escape':reEscape,/**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'evaluate':reEvaluate,/**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'interpolate':reInterpolate,/**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */'variable':'',/**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */'imports':{/**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.
lodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else{result=this.clone();result.__dir__*=-1;}return result;}/**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||!isRight&&arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else{break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}/**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}/**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*/ /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */function listCacheClear(){this.__data__=[];this.size=0;}/**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}--this.size;return true;}/**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}/**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else{data[index][1]=value;}return this;}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*/ /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*/ /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.
SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*/ /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */function stackClear(){this.__data__=new ListCache();this.size=0;}/**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function stackGet(key){return this.__data__.get(key);}/**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function stackHas(key){return this.__data__.has(key);}/**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.
Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*/ /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
key=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.
isBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.
isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
isIndex(key,length)))){result.push(key);}}return result;}/**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */function arraySample(array){var length=array.length;return length?array[baseRandom(0,length-1)]:undefined;}/**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function arraySampleSize(array,n){return shuffleSelf(copyArray(array),baseClamp(n,0,array.length));}/**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function arrayShuffle(array){return shuffleSelf(copyArray(array));}/**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignMergeValue(object,key,value){if(value!==undefined&&!eq(object[key],value)||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}/**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssignIn(object,source){return object&&copyObject(source,keysIn(source),object);}/**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else{object[key]=value;}}/**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */function baseAt(object,paths){var index=-1,length=paths.length,result=Array(length),skip=object==null;while(++index<length){result[index]=skip?undefined:get(object,paths[index]);}return result;}/**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined){number=number<=upper?number:upper;}if(lower!==undefined){number=number>=lower?number:lower;}}return number;}/**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG,isFull=bitmask&CLONE_SYMBOLS_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else{var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value,baseAssignIn(result,value)):copySymbols(value,baseAssign(result,value));}}else{if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,isDeep);}}// Check for circular references and return its corresponding clone.
stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(isSet(value)){value.forEach(function(subValue){result.add(baseClone(subValue,bitmask,customizer,subValue,value,stack));});}else if(isMap(value)){value.forEach(function(subValue,key){result.set(key,baseClone(subValue,bitmask,customizer,key,value,stack));});}var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined:keysFunc(value);arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
assignValue(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}/**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object,source,props);};}/**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */function baseConformsTo(object,source,props){var length=props.length;if(object==null){return!length;}object=Object(object);while(length--){var key=props[length],predicate=source[key],value=object[key];if(value===undefined&&!(key in object)||!predicate(value)){return false;}}return true;}/**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined,args);},wait);}/**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEach=createBaseEach(baseForOwn);/**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEachRight=createBaseEach(baseForOwnRight,true);/**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).
baseFlatten(value,depth-1,predicate,isStrict,result);}else{arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseFor=createBaseFor();/**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseForRight=createBaseFor(true);/**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined;}/**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */function baseGetTag(value){if(value==null){return value===undefined?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */function baseGt(value,other){return value>other;}/**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHas(object,key){return object!=null&&hasOwnProperty.call(object,key);}/**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */function baseInvoke(object,path,args){path=castPath(path,object);object=parent(object,path);var func=object==null?object:object[toKey(last(path))];return func==null?undefined:apply(func,object,args);}/**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */function baseIsArrayBuffer(value){return isObjectLike(value)&&baseGetTag(value)==arrayBufferTag;}/**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */function baseIsDate(value){return isObjectLike(value)&&baseGetTag(value)==dateTag;}/**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}/**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}/**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return!length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined&&!(key in object)){return false;}}else{var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}/**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */function baseIsRegExp(value){return isObjectLike(value)&&baseGetTag(value)==regexpTag;}/**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
if(typeof value=='function'){return value;}if(value==null){return identity;}if(typeof value=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */function baseLt(value,other){return value<other;}/**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}/**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){stack||(stack=new Stack());if(isObject(srcValue)){baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else{var newValue=customizer?customizer(safeGet(object,key),srcValue,key+'',object,source,stack):undefined;if(newValue===undefined){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=safeGet(object,key),srcValue=safeGet(source,key),stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined;var isCommon=newValue===undefined;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else{newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||isFunction(objValue)){newValue=initCloneObject(srcValue);}}else{isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined;}/**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */function baseOrderBy(collection,iteratees,orders){if(iteratees.length){iteratees=arrayMap(iteratees,function(iteratee){if(isArray(iteratee)){return function(value){return baseGet(value,iteratee.length===1?iteratee[0]:iteratee);};}return iteratee;});}else{iteratees=[identity];}var index=-1;iteratees=arrayMap(iteratees,baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return{'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}/**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}/**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else{baseUnset(array,index);}}}return array;}/**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.
// See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
do{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */function baseSample(collection){return arraySample(values(collection));}/**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function baseSampleSize(collection,n){var array=values(collection);return shuffleSelf(array,baseClamp(n,0,array.length));}/**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(key==='__proto__'||key==='constructor'||key==='prototype'){return object;}if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined;if(newValue===undefined){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}/**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function baseShuffle(collection){return shuffleSelf(values(collection));}/**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return!result;});return!!result;}/**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndex(array,value,retHighest){var low=0,high=array==null?low:array.length;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else{high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndexBy(array,value,iteratee,retHighest){var low=0,high=array==null?0:array.length;if(high===0){return 0;}value=iteratee(value);var valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else{setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else{high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return+value;}/**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
if(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).
return arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else{seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}/**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2){return length?baseUniq(arrays[0]):[];}var index=-1,result=Array(length);while(++index<length){var array=arrays[index],othIndex=-1;while(++othIndex<length){if(othIndex!=index){result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator);}}}return baseUniq(baseFlatten(result,1),iteratee,comparator);}/**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined;assignFunc(result,props[index],value);}return result;}/**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */function castFunction(value){return typeof value=='function'?value:identity;}/**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}/**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */var castRest=baseRest;/**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */function castSlice(array,start,end){var length=array.length;end=end===undefined?length:end;return!start&&end>=length?array:baseSlice(array,start,end);}/**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */var clearTimeout=ctxClearTimeout||function(id){return root.clearTimeout(id);};/**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return-1;}}return 0;}/**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
// that causes it, under certain circumstances, to provide the same value for
// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
// for more details.
//
// This also ensures a stable sort in V8 and other engines.
// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
return object.index-other.index;}/**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;if(newValue===undefined){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else{assignValue(object,key,newValue);}}return object;}/**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object);}/**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee,2),accumulator);};}/**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined,guard=length>2?sources[2]:undefined;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createBind(func,bitmask,thisArg){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */function createCtor(Ctor){return function(){// Use a `switch` statement to work with class constructors. See
// http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
// for more details.
var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.
// See https://es5.github.io/#x13.2.2 for more details.
return isObject(result)?result:thisBinding;};}/**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined,args,holders,undefined,undefined,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate,3);collection=keys(collection);predicate=function(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined;};}/**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else{wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&WRAP_ARY_FLAG,isBind=bitmask&WRAP_BIND_FLAG,isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),isFlip=bitmask&WRAP_FLIP_FLAG,Ctor=isBindKey?undefined:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */function createMathOperation(operator,defaultValue){return function(value,other){var result;if(value===undefined&&other===undefined){return defaultValue;}if(value!==undefined){result=value;}if(other!==undefined){if(result===undefined){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else{value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */function createOver(arrayFunc){return flatRest(function(iteratees){iteratees=arrayMap(iteratees,baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */function createPadding(length,chars){chars=chars===undefined?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */function createPartial(func,bitmask,thisArg,partials){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined;}// Ensure the sign of `-0` is preserved.
start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}step=step===undefined?start<end?1:-1:toFinite(step);return baseRange(start,end,step,fromRight);};}/**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined,newHoldersRight=isCurry?undefined:holders,newPartials=isCurry?partials:undefined,newPartialsRight=isCurry?undefined:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}/**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=precision==null?0:nativeMin(toInteger(precision),292);if(precision&&nativeIsFinite(number)){// Shift with exponential notation to avoid floating-point issues.
// See [MDN](https://mdn.io/round#Examples) for more details.
var pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return+(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined;}ary=ary===undefined?ary:nativeMax(toInteger(ary),0);arity=arity===undefined?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined;}var data=isBindKey?undefined:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else{result=createHybrid.apply(undefined,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}/**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */function customDefaultsAssignIn(objValue,srcValue,key,object){if(objValue===undefined||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */function customDefaultsMerge(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,objValue);baseMerge(objValue,srcValue,undefined,customDefaultsMerge,stack);stack['delete'](srcValue);}return objValue;}/**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */function customOmitClone(value){return isPlainObject(value)?undefined:value;}/**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Check that cyclic values are equal.
var arrStacked=stack.get(array);var othStacked=stack.get(other);if(arrStacked&&othStacked){return arrStacked==other&&othStacked==array;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
// Invalid dates are coerced to `NaN`.
return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
// for more details.
return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).
stack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Check that cyclic values are equal.
var objStacked=stack.get(object);var othStacked=stack.get(other);if(objStacked&&othStacked){return objStacked==other&&othStacked==object;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
if(!(compared===undefined?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */function flatRest(func){return setToString(overRest(func,undefined,flatten),func+'');}/**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}/**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else{delete value[symToStringTag];}}return result;}/**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return[];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};/**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return{'start':start,'end':end};}/**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return!!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}/**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */function initCloneArray(array){var length=array.length,result=new array.constructor(length);// Add properties assigned by `RegExp#exec`.
if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return new Ctor();case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return new Ctor();case symbolTag:return cloneSymbol(object);}}/**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */function insertWrapDetails(source,details){var length=details.length;if(!length){return source;}var lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\n/* [wrapped with '+details+'] */\n');}/**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */function isIndex(value,length){var type=typeof value;length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=typeof index;if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */function isKey(value,object){if(isArray(value)){return false;}var type=typeof value;if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */function isKeyable(value){var type=typeof value;return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return!!data&&func===data[0];}/**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}/**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */var isMaskable=coreJsData?isFunction:stubFalse;/**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */function isStrictComparable(value){return value===value&&!isObject(value);}/**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined||key in Object(object));};}/**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}/**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG|WRAP_ARY_FLAG);var isCombo=srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_CURRY_FLAG||srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(WRAP_ARY_FLAG|WRAP_REARG_FLAG)&&source[7].length<=source[8]&&bitmask==WRAP_CURRY_FLAG;// Exit early if metadata can't be merged.
if(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.
if(srcBitmask&WRAP_BIND_FLAG){data[2]=source[2];// Set when currying a bound function.
newBitmask|=bitmask&WRAP_BIND_FLAG?0:WRAP_CURRY_BOUND_FLAG;}// Compose partial arguments.
var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.
value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.
value=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.
if(srcBitmask&WRAP_ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.
if(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.
data[0]=source[0];data[1]=newBitmask;return data;}/**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */function objectToString(value){return nativeObjectToString.call(value);}/**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */function overRest(func,start,transform){start=nativeMax(start===undefined?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}/**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined;}return array;}/**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */function safeGet(object,key){if(key==='constructor'&&typeof object[key]==='function'){return;}if(key=='__proto__'){return;}return object[key];}/**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var setData=shortOut(baseSetData);/**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */var setTimeout=ctxSetTimeout||function(func,wait){return root.setTimeout(func,wait);};/**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var setToString=shortOut(baseSetToString);/**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */function setWrapToString(wrapper,reference,bitmask){var source=reference+'';return setToString(wrapper,insertWrapDetails(source,updateWrapDetails(getWrapDetails(source),bitmask)));}/**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else{count=0;}return func.apply(undefined,arguments);};}/**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */function shuffleSelf(array,size){var index=-1,length=array.length,lastIndex=length-1;size=size===undefined?length:size;while(++index<size){var rand=baseRandom(index,lastIndex),value=array[rand];array[rand]=array[index];array[index]=value;}array.length=size;return array;}/**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */var stringToPath=memoizeCapped(function(string){var result=[];if(string.charCodeAt(0)===46/* . */){result.push('');}string.replace(rePropName,function(match,number,quote,subString){result.push(quote?subString.replace(reEscapeChar,'$1'):number||match);});return result;});/**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}/**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */function updateWrapDetails(details,bitmask){arrayEach(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!arrayIncludes(details,value)){details.push(value);}});return details.sort();}/**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*/ /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined){size=1;}else{size=nativeMax(toInteger(size),0);}var length=array==null?0:array.length;if(!length||size<1){return[];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */function concat(){var length=arguments.length;if(!length){return[];}var args=Array(length-1),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1));}/**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var differenceBy=baseRest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee,2)):[];});/**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */var differenceWith=baseRest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined,comparator):[];});/**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function drop(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function dropRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */function fill(array,value,start,end){var length=array==null?0:array.length;if(!length){return[];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */function findIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */function findLastIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length-1;if(fromIndex!==undefined){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}/**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */function flattenDeep(array){var length=array==null?0:array.length;return length?baseFlatten(array,INFINITY):[];}/**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */function flattenDepth(array,depth){var length=array==null?0:array.length;if(!length){return[];}depth=depth===undefined?1:toInteger(depth);return baseFlatten(array,depth);}/**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */function head(array){return array&&array.length?array[0]:undefined;}/**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */function indexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */function initial(array){var length=array==null?0:array.length;return length?baseSlice(array,0,-1):[];}/**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined;}else{mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee,2)):[];});/**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */var intersectionWith=baseRest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);comparator=typeof comparator=='function'?comparator:undefined;if(comparator){mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined,comparator):[];});/**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */function join(array,separator){return array==null?'':nativeJoin.call(array,separator);}/**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined;}/**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */function lastIndexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length;if(fromIndex!==undefined){index=toInteger(fromIndex);index=index<0?nativeMax(length+index,0):nativeMin(index,length-1);}return value===value?strictLastIndexOf(array,value,index):baseFindIndex(array,baseIsNaN,index,true);}/**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined;}/**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */var pull=baseRest(pullAll);/**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee,2)):array;}/**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined,comparator):array;}/**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */var pullAt=flatRest(function(array,indexes){var length=array==null?0:array.length,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function reverse(array){return array==null?array:nativeReverse.call(array);}/**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function slice(array,start,end){var length=array==null?0:array.length;if(!length){return[];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else{start=start==null?0:toInteger(start);end=end===undefined?length:toInteger(end);}return baseSlice(array,start,end);}/**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2));}/**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */function sortedIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2),true);}/**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */function sortedLastIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee,2)):[];}/**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */function tail(array){var length=array==null?0:array.length;return length?baseSlice(array,1,length):[];}/**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */function take(array,n,guard){if(!(array&&array.length)){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */function takeRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee,2));});/**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var unionWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined,comparator);});/**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */function uniq(array){return array&&array.length?baseUniq(array):[];}/**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee,2)):[];}/**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */function uniqWith(array,comparator){comparator=typeof comparator=='function'?comparator:undefined;return array&&array.length?baseUniq(array,undefined,comparator):[];}/**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */function unzip(array){if(!(array&&array.length)){return[];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */function unzipWith(array,iteratee){if(!(array&&array.length)){return[];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined,group);});}/**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee,2));});/**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var xorWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined,comparator);});/**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */var zip=baseRest(unzip);/**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */function tap(value,interceptor){interceptor(value);return value;}/**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */function thru(value,interceptor){return interceptor(value);}/**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */var wrapperAt=flatRest(function(paths){var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined);}return array;});});/**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */function wrapperChain(){return chain(this);}/**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */function wrapperNext(){if(this.__values__===undefined){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined:this.__values__[this.__index__++];return{'done':done,'value':value};}/**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */function wrapperToIterator(){return this;}/**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined;if(result){previous.__wrapped__=clone;}else{result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*/ /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */var countBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){++result[key];}else{baseAssignValue(result,key,1);}});/**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */var find=createFind(findIndex);/**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */var findLast=createFind(findLastIndex);/**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else{baseAssignValue(result,key,[value]);}});/**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */var invokeMap=baseRest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){result[++index]=isFunc?apply(path,value,args):baseInvoke(value,path,args);});return result;});/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});/**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */function orderBy(collection,iteratees,orders,guard){if(collection==null){return[];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return[[],[]];});/**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,negate(getIteratee(predicate,3)));}/**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */function sample(collection){var func=isArray(collection)?arraySample:baseSample;return func(collection);}/**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */function sampleSize(collection,n,guard){if(guard?isIterateeCall(collection,n,guard):n===undefined){n=1;}else{n=toInteger(n);}var func=isArray(collection)?arraySampleSize:baseSampleSize;return func(collection,n);}/**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */function shuffle(collection){var func=isArray(collection)?arrayShuffle:baseShuffle;return func(collection);}/**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}return baseKeys(collection).length;}/**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */var sortBy=baseRest(function(collection,iteratees){if(collection==null){return[];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});/*------------------------------------------------------------------------*/ /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */var now=ctxNow||function(){return root.Date.now();};/*------------------------------------------------------------------------*/ /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */function ary(func,n,guard){n=guard?undefined:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined,undefined,undefined,undefined,n);}/**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined;}return result;};}/**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */var bind=baseRest(function(func,thisArg,partials){var bitmask=WRAP_BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(func,bitmask,thisArg,partials,holders);});/**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */var bindKey=baseRest(function(object,key,partials){var bitmask=WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(key,bitmask,object,partials,holders);});/**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */function curry(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curry.placeholder;return result;}/**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */function curryRight(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curryRight.placeholder;return result;}/**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
lastInvokeTime=time;// Start the timer for the trailing edge.
timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,timeWaiting=wait-timeSinceLastCall;return maxing?nativeMin(timeWaiting,maxWait-timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
// trailing edge, the system time has gone backwards and we're treating
// it as the trailing edge, or we've hit the `maxWait` limit.
return lastCallTime===undefined||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined;// Only invoke if we have `lastArgs` which means `func` has been
// debounced at least once.
if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined;return result;}function cancel(){if(timerId!==undefined){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined;}function flush(){return timerId===undefined?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
clearTimeout(timerId);timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */var defer=baseRest(function(func,args){return baseDelay(func,1,args);});/**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */var delay=baseRest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */function flip(func){return createWrap(func,WRAP_FLIP_FLAG);}/**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.
memoize.Cache=MapCache;/**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return!predicate.call(this);case 1:return!predicate.call(this,args[0]);case 2:return!predicate.call(this,args[0],args[1]);case 3:return!predicate.call(this,args[0],args[1],args[2]);}return!predicate.apply(this,args);};}/**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */function once(func){return before(2,func);}/**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */var overArgs=castRest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1),baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */var partial=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrap(func,WRAP_PARTIAL_FLAG,undefined,partials,holders);});/**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */var partialRight=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrap(func,WRAP_PARTIAL_RIGHT_FLAG,undefined,partials,holders);});/**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined,undefined,undefined,indexes);});/**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined?start:toInteger(start);return baseRest(func,start);}/**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start==null?0:nativeMax(toInteger(start),0);return baseRest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */function unary(func){return ary(func,1);}/**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */function wrap(value,wrapper){return partial(castFunction(wrapper),value);}/*------------------------------------------------------------------------*/ /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */function castArray(){if(!arguments.length){return[];}var value=arguments[0];return isArray(value)?value:[value];}/**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */function cloneWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_SYMBOLS_FLAG,customizer);}/**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */function cloneDeepWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG,customizer);}/**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */function conformsTo(object,source){return source==null||baseConformsTo(object,source,keys(source));}/**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */function eq(value,other){return value===other||value!==value&&other!==other;}/**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */var gt=createRelationalOperation(baseGt);/**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */var gte=createRelationalOperation(function(value,other){return value>=other;});/**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */var isArray=Array.isArray;/**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;/**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&baseGetTag(value)==boolTag;}/**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */var isBuffer=nativeIsBuffer||stubFalse;/**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;/**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */function isElement(value){return isObjectLike(value)&&value.nodeType===1&&!isPlainObject(value);}/**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return!value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return!value.size;}if(isPrototype(value)){return!baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}/**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */function isEqual(value,other){return baseIsEqual(value,other);}/**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined;var result=customizer?customizer(value,other):undefined;return result===undefined?baseIsEqual(value,other,undefined,customizer):!!result;}/**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}/**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 9 which returns 'object' for typed arrays and other constructors.
var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */function isObject(value){var type=typeof value;return value!=null&&(type=='object'||type=='function');}/**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */function isObjectLike(value){return value!=null&&typeof value=='object';}/**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;/**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseIsMatch(object,source,getMatchData(source),customizer);}/**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.
// Perform the `toStringTag` check first to avoid errors with some
// ActiveX objects in IE.
return isNumber(value)&&value!=+value;}/**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */function isNative(value){if(isMaskable(value)){throw new Error(CORE_ERROR_TEXT);}return baseIsNative(value);}/**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */function isNull(value){return value===null;}/**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */function isNil(value){return value==null;}/**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&baseGetTag(value)==numberTag;}/**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;/**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;/**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&baseGetTag(value)==stringTag;}/**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */function isSymbol(value){return typeof value=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}/**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */function isUndefined(value){return value===undefined;}/**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */function isWeakSet(value){return isObjectLike(value)&&baseGetTag(value)==weakSetTag;}/**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */var lt=createRelationalOperation(baseLt);/**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */var lte=createRelationalOperation(function(value,other){return value<=other;});/**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */function toArray(value){if(!value){return[];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(symIterator&&value[symIterator]){return iteratorToArray(value[symIterator]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=value.replace(reTrim,'');var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */function toSafeInteger(value){return value?baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER):value===0?value:0;}/**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*/ /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */var assign=createAssigner(function(object,source){if(isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});/**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */var at=flatRest(baseAt);/**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */function create(prototype,properties){var result=baseCreate(prototype);return properties==null?result:baseAssign(result,properties);}/**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var defaults=baseRest(function(object,sources){object=Object(object);var index=-1;var length=sources.length;var guard=length>2?sources[2]:undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){length=1;}while(++index<length){var source=sources[index];var props=keysIn(source);var propsIndex=-1;var propsLength=props.length;while(++propsIndex<propsLength){var key=props[propsIndex];var value=object[key];if(value===undefined||eq(value,objectProto[key])&&!hasOwnProperty.call(object,key)){object[key]=source[key];}}}return object;});/**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */var defaultsDeep=baseRest(function(args){args.push(undefined,customDefaultsMerge);return apply(mergeWith,undefined,args);});/**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */function get(object,path,defaultValue){var result=object==null?undefined:baseGet(object,path);return result===undefined?defaultValue:result;}/**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */var invert=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}result[value]=key;},constant(identity));/**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */var invertBy=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}if(hasOwnProperty.call(result,value)){result[value].push(key);}else{result[value]=[key];}},getIteratee);/**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */var invoke=baseRest(baseInvoke);/**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,iteratee(value,key,object),value);});return result;}/**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}/**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */var omit=flatRest(function(object,paths){var result={};if(object==null){return result;}var isDeep=false;paths=arrayMap(paths,function(path){path=castPath(path,object);isDeep||(isDeep=path.length>1);return path;});copyObject(object,getAllKeysIn(object),result);if(isDeep){result=baseClone(result,CLONE_DEEP_FLAG|CLONE_FLAT_FLAG|CLONE_SYMBOLS_FLAG,customOmitClone);}var length=paths.length;while(length--){baseUnset(result,paths[length]);}return result;});/**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */function omitBy(object,predicate){return pickBy(object,negate(getIteratee(predicate)));}/**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});/**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */function pickBy(object,predicate){if(object==null){return{};}var props=arrayMap(getAllKeysIn(object),function(prop){return[prop];});predicate=getIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}/**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */function result(object,path,defaultValue){path=castPath(path,object);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.
if(!length){length=1;object=undefined;}while(++index<length){var value=object==null?undefined:object[toKey(path[index])];if(value===undefined){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseSet(object,path,value,customizer);}/**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */var toPairs=createToPairs(keys);/**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */var toPairsIn=createToPairs(keysIn);/**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else{accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */function unset(object,path){return object==null?true:baseUnset(object,path);}/**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */function values(object){return object==null?[]:baseValues(object,keys(object));}/**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*/ /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */function clamp(number,lower,upper){if(upper===undefined){upper=lower;lower=undefined;}if(upper!==undefined){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */function inRange(number,start,end){start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}number=toNumber(number);return baseInRange(number,start,end);}/**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined;}if(floating===undefined){if(typeof upper=='boolean'){floating=upper;upper=undefined;}else if(typeof lower=='boolean'){floating=lower;lower=undefined;}}if(lower===undefined&&upper===undefined){lower=0;upper=1;}else{lower=toFinite(lower);if(upper===undefined){upper=lower;lower=0;}else{upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*/ /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */function deburr(string){string=toString(string);return string&&string.replace(reLatin,deburrLetter).replace(reComboMark,'');}/**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined?length:baseClamp(toInteger(position),0,length);var end=position;position-=target.length;return position>=0&&string.slice(position,end)==target;}/**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */var lowerFirst=createCaseFirst('toLowerCase');/**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */function parseInt(string,radix,guard){if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}return nativeParseInt(toString(string).replace(reTrimStart,''),radix||0);}/**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined){n=1;}else{n=toInteger(n);}return baseRepeat(toString(string),n);}/**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:string.replace(args[1],args[2]);}/**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined;}limit=limit===undefined?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return[];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(!separator&&hasUnicode(string)){return castSlice(stringToArray(string),0,limit);}}return string.split(separator,limit);}/**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */function startsWith(string,target,position){string=toString(string);position=position==null?0:baseClamp(toInteger(position),0,string.length);target=baseToString(target);return string.slice(position,position+target.length)==target;}/**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */function template(string,options,guard){// Based on John Resig's `tmpl` implementation
// (http://ejohn.org/blog/javascript-micro-templating/)
// and Laura Doktorova's doT.js (https://github.com/olado/doT).
var settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined;}string=toString(string);options=assignInWith({},options,settings,customDefaultsAssignIn);var imports=assignInWith({},options.imports,settings.imports,customDefaultsAssignIn),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";// Compile the regexp to match each delimiter.
var reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.
// The sourceURL gets injected into the source that's eval-ed, so be careful
// to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
// and escape the comment, thus injecting code that gets evaled.
var sourceURL='//# sourceURL='+(hasOwnProperty.call(options,'sourceURL')?(options.sourceURL+'').replace(/\s/g,' '):'lodash.templateSources['+ ++templateCounter+']')+'\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.
source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.
if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'";}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '";}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in
// order to produce the correct `offset` value.
return match;});source+="';\n";// If `variable` is not specified wrap a with-statement around the generated
// code to add the data object to the top of the scope chain.
var variable=hasOwnProperty.call(options,'variable')&&options.variable;if(!variable){source='with (obj) {\n'+source+'\n}\n';}// Cleanup code by stripping empty strings.
source=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.
source='function('+(variable||'obj')+') {\n'+(variable?'':'obj || (obj = {});\n')+"var __t, __p = ''"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\n'+"function print() { __p += __j.call(arguments, '') }\n":';\n')+source+'return __p\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined,importsValues);});// Provide the compiled function's source by its `toString` method or
// the `source` property as a convenience for inlining compiled templates.
result.source=source;if(isError(result)){throw result;}return result;}/**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */function toLower(value){return toString(value).toLowerCase();}/**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */function toUpper(value){return toString(value).toUpperCase();}/**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrim,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimEnd,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */var upperFirst=createCaseFirst('toUpperCase');/**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined:pattern;if(pattern===undefined){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern)||[];}/*------------------------------------------------------------------------*/ /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */var attempt=baseRest(function(func,args){try{return apply(func,undefined,args);}catch(e){return isError(e)?e:new Error(e);}});/**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */var bindAll=flatRest(function(object,methodNames){arrayEach(methodNames,function(key){key=toKey(key);baseAssignValue(object,key,bind(object[key],object));});return object;});/**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */function cond(pairs){var length=pairs==null?0:pairs.length,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return[toIteratee(pair[0]),pair[1]];});return baseRest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */function conforms(source){return baseConforms(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */function constant(value){return function(){return value;};}/**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}/**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */var flow=createFlow();/**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */var flowRight=createFlow(true);/**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */function identity(value){return value;}/**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */function matches(source){return baseMatches(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,CLONE_DEEP_FLAG));}/**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */var method=baseRest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */var methodOf=baseRest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */function noop(){// No operation performed.
}/**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */function nthArg(n){n=toInteger(n);return baseRest(function(args){return baseNth(args,n);});}/**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */var over=createOver(arrayMap);/**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */var overEvery=createOver(arrayEvery);/**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */var overSome=createOver(arraySome);/**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */function propertyOf(object){return function(path){return object==null?undefined:baseGet(object,path);};}/**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */var range=createRange();/**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */var rangeRight=createRange(true);/**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */function stubArray(){return[];}/**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */function stubFalse(){return false;}/**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */function stubObject(){return{};}/**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */function stubString(){return'';}/**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */function stubTrue(){return true;}/**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return[];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}/**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*/ /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */var add=createMathOperation(function(augend,addend){return augend+addend;},0);/**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */var ceil=createRound('ceil');/**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;},1);/**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */var floor=createRound('floor');/**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined;}/**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseGt):undefined;}/**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */function mean(array){return baseMean(array,identity);}/**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee,2));}/**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined;}/**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseLt):undefined;}/**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;},1);/**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */var round=createRound('round');/**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;},0);/**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee,2)):0;}/*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences.
lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.
lodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.
mixin(lodash,lodash);/*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences.
lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.conformsTo=conformsTo;lodash.deburr=deburr;lodash.defaultTo=defaultTo;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.
lodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*/ /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */lodash.VERSION=VERSION;// Assign default placeholders.
arrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
arrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){n=n===undefined?1:nativeMax(toInteger(n),0);var result=this.__filtered__&&!index?new LazyWrapper(this):this.clone();if(result.__filtered__){result.__takeCount__=nativeMin(n,result.__takeCount__);}else{result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.
arrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.
arrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
arrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=baseRest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a "length" value other than `1`.
isLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.
arrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'';if(!hasOwnProperty.call(realNames,key)){realNames[key]=[];}realNames[key].push({'name':methodName,'func':lodashFunc});}});realNames[createHybrid(undefined,WRAP_BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined}];// Add methods to `LazyWrapper`.
LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.
lodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;// Add lazy aliases.
lodash.prototype.first=lodash.prototype.head;if(symIterator){lodash.prototype[symIterator]=wrapperToIterator;}return lodash;};/*--------------------------------------------------------------------------*/ // Export lodash.
var _=runInContext();// Some AMD build optimizers, like r.js, check for condition patterns like:
if(true){// Expose Lodash on the global object to prevent errors when Lodash is
// loaded by a script tag in the presence of an AMD loader.
// See http://requirejs.org/docs/errors.html#mismatch for more details.
// Use `_.noConflict` to remove Lodash from the global object.
root._=_;// Define as an anonymous module so, through path mapping, it can be
// referenced as the "underscore" module.
!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return _;}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}// Check for `exports` after `define` in case a build optimizer adds it.
else {}}).call(this);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(13), __webpack_require__(141)(module)))

/***/ }),
/* 13 */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 14 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/

var pna = __webpack_require__(24);
/*</replacement>*/

/*<replacement>*/


var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;
/*<replacement>*/

var util = Object.create(__webpack_require__(22));
util.inherits = __webpack_require__(18);
/*</replacement>*/

var Readable = __webpack_require__(57);

var Writable = __webpack_require__(33);

util.inherits(Duplex, Readable);
{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false) this.readable = false;
  if (options && options.writable === false) this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
}); // the no-half-open enforcer

function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();
  pna.nextTick(cb, err);
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(145);

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

module.exports = _get;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(146);

/***/ }),
/* 18 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;

      var TempCtor = function () {};

      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

/***/ }),
/* 19 */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */
var Tracer = {
  searchDirections: [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]],
  create: function create(imageWrapper, labelWrapper) {
    var imageData = imageWrapper.data;
    var labelData = labelWrapper.data;
    var searchDirections = this.searchDirections;
    var width = imageWrapper.size.x;
    var pos;

    function _trace(current, color, label, edgelabel) {
      var i;
      var y;
      var x;

      for (i = 0; i < 7; i++) {
        y = current.cy + searchDirections[current.dir][0];
        x = current.cx + searchDirections[current.dir][1];
        pos = y * width + x;

        if (imageData[pos] === color && (labelData[pos] === 0 || labelData[pos] === label)) {
          labelData[pos] = label;
          current.cy = y;
          current.cx = x;
          return true;
        }

        if (labelData[pos] === 0) {
          labelData[pos] = edgelabel;
        }

        current.dir = (current.dir + 1) % 8;
      }

      return false;
    }

    function vertex2D(x, y, dir) {
      return {
        dir: dir,
        x: x,
        y: y,
        next: null,
        prev: null
      };
    }

    function _contourTracing(sy, sx, label, color, edgelabel) {
      var Fv = null;
      var Cv;
      var P;
      var ldir;
      var current = {
        cx: sx,
        cy: sy,
        dir: 0
      };

      if (_trace(current, color, label, edgelabel)) {
        Fv = vertex2D(sx, sy, current.dir);
        Cv = Fv;
        ldir = current.dir;
        P = vertex2D(current.cx, current.cy, 0);
        P.prev = Cv;
        Cv.next = P;
        P.next = null;
        Cv = P;

        do {
          current.dir = (current.dir + 6) % 8;

          _trace(current, color, label, edgelabel);

          if (ldir !== current.dir) {
            Cv.dir = current.dir;
            P = vertex2D(current.cx, current.cy, 0);
            P.prev = Cv;
            Cv.next = P;
            P.next = null;
            Cv = P;
          } else {
            Cv.dir = ldir;
            Cv.x = current.cx;
            Cv.y = current.cy;
          }

          ldir = current.dir;
        } while (current.cx !== sx || current.cy !== sy);

        Fv.prev = Cv.prev;
        Cv.prev.next = Fv;
      }

      return Fv;
    }

    return {
      trace: function trace(current, color, label, edgelabel) {
        return _trace(current, color, label, edgelabel);
      },
      contourTracing: function contourTracing(sy, sx, label, color, edgelabel) {
        return _contourTracing(sy, sx, label, color, edgelabel);
      }
    };
  }
};
/* harmony default export */ __webpack_exports__["a"] = (Tracer);

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */

/* eslint-disable no-proto */


var base64 = __webpack_require__(159);

var ieee754 = __webpack_require__(160);

var isArray = __webpack_require__(161);

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */

Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
/*
 * Export kMaxLength after typed array support is determined.
 */

exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = {
      __proto__: Uint8Array.prototype,
      foo: function () {
        return 42;
      }
    };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }

    that.length = length;
  }

  return that;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  } // Common case.


  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }

    return allocUnsafe(this, arg);
  }

  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation
// TODO: Legacy, not needed anymore. Remove in next major version.

Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;

  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(that, size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }

  return createBuffer(that, size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }

  return that;
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }

  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }

  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }

      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }

  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }

  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }

  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;

  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }

  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  } // must be an even number of digits


  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;

    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    } // legacy write(string, encoding, offset, length) - remove in v0.13

  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);

    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (code < 256) {
        val = code;
      }
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(13)))

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }

  return objectToString(arg) === '[object Array]';
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return objectToString(e) === '[object Error]' || e instanceof Error;
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(21).Buffer))

/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(gl_vec2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var gl_mat2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28);
/* harmony import */ var gl_mat2__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(gl_mat2__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var _common_cv_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8);
/* harmony import */ var _common_array_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10);
/* harmony import */ var _common_image_debug__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);
/* harmony import */ var _rasterizer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(64);
/* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(20);
/* harmony import */ var _skeletonizer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(65);










var _config;

var _currentImageWrapper;

var _skelImageWrapper;

var _subImageWrapper;

var _labelImageWrapper;

var _patchGrid;

var _patchLabelGrid;

var _imageToPatchGrid;

var _binaryImageWrapper;

var _patchSize;

var _canvasContainer = {
  ctx: {
    binary: null
  },
  dom: {
    binary: null
  }
};
var _numPatches = {
  x: 0,
  y: 0
};

var _inputImageWrapper;

var _skeletonizer;

function initBuffers() {
  if (_config.halfSample) {
    _currentImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]({
      // eslint-disable-next-line no-bitwise
      x: _inputImageWrapper.size.x / 2 | 0,
      // eslint-disable-next-line no-bitwise
      y: _inputImageWrapper.size.y / 2 | 0
    });
  } else {
    _currentImageWrapper = _inputImageWrapper;
  }

  _patchSize = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["calculatePatchSize"])(_config.patchSize, _currentImageWrapper.size); // eslint-disable-next-line no-bitwise

  _numPatches.x = _currentImageWrapper.size.x / _patchSize.x | 0; // eslint-disable-next-line no-bitwise

  _numPatches.y = _currentImageWrapper.size.y / _patchSize.y | 0;
  _binaryImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_currentImageWrapper.size, undefined, Uint8Array, false);
  _labelImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, undefined, Array, true);
  var skeletonImageData = new ArrayBuffer(64 * 1024);
  _subImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, new Uint8Array(skeletonImageData, 0, _patchSize.x * _patchSize.y));
  _skelImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, new Uint8Array(skeletonImageData, _patchSize.x * _patchSize.y * 3, _patchSize.x * _patchSize.y), undefined, true);
  _skeletonizer = Object(_skeletonizer__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : global, {
    size: _patchSize.x
  }, skeletonImageData);
  _imageToPatchGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]({
    // eslint-disable-next-line no-bitwise
    x: _currentImageWrapper.size.x / _subImageWrapper.size.x | 0,
    // eslint-disable-next-line no-bitwise
    y: _currentImageWrapper.size.y / _subImageWrapper.size.y | 0
  }, undefined, Array, true);
  _patchGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_imageToPatchGrid.size, undefined, undefined, true);
  _patchLabelGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_imageToPatchGrid.size, undefined, Int32Array, true);
}

function initCanvas() {
  if (_config.useWorker || typeof document === 'undefined') {
    return;
  }

  _canvasContainer.dom.binary = document.createElement('canvas');
  _canvasContainer.dom.binary.className = 'binaryBuffer';

  if ( true && _config.debug.showCanvas === true) {
    document.querySelector('#debug').appendChild(_canvasContainer.dom.binary);
  }

  _canvasContainer.ctx.binary = _canvasContainer.dom.binary.getContext('2d');
  _canvasContainer.dom.binary.width = _binaryImageWrapper.size.x;
  _canvasContainer.dom.binary.height = _binaryImageWrapper.size.y;
}
/**
 * Creates a bounding box which encloses all the given patches
 * @returns {Array} The minimal bounding box
 */


function boxFromPatches(patches) {
  var overAvg;
  var i;
  var j;
  var patch;
  var transMat;
  var minx = _binaryImageWrapper.size.x;
  var miny = _binaryImageWrapper.size.y;
  var maxx = -_binaryImageWrapper.size.x;
  var maxy = -_binaryImageWrapper.size.y;
  var box;
  var scale; // draw all patches which are to be taken into consideration

  overAvg = 0;

  for (i = 0; i < patches.length; i++) {
    patch = patches[i];
    overAvg += patch.rad;

    if ( true && _config.debug.showPatches) {
      _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
        color: 'red'
      });
    }
  }

  overAvg /= patches.length;
  overAvg = (overAvg * 180 / Math.PI + 90) % 180 - 90;

  if (overAvg < 0) {
    overAvg += 180;
  }

  overAvg = (180 - overAvg) * Math.PI / 180;
  transMat = gl_mat2__WEBPACK_IMPORTED_MODULE_1__["copy"](gl_mat2__WEBPACK_IMPORTED_MODULE_1__["create"](), [Math.cos(overAvg), Math.sin(overAvg), -Math.sin(overAvg), Math.cos(overAvg)]); // iterate over patches and rotate by angle

  for (i = 0; i < patches.length; i++) {
    patch = patches[i];

    for (j = 0; j < 4; j++) {
      gl_vec2__WEBPACK_IMPORTED_MODULE_0__["transformMat2"](patch.box[j], patch.box[j], transMat);
    }

    if ( true && _config.debug.boxFromPatches.showTransformed) {
      _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawPath(patch.box, {
        x: 0,
        y: 1
      }, _canvasContainer.ctx.binary, {
        color: '#99ff00',
        lineWidth: 2
      });
    }
  } // find bounding box


  for (i = 0; i < patches.length; i++) {
    patch = patches[i];

    for (j = 0; j < 4; j++) {
      if (patch.box[j][0] < minx) {
        minx = patch.box[j][0];
      }

      if (patch.box[j][0] > maxx) {
        maxx = patch.box[j][0];
      }

      if (patch.box[j][1] < miny) {
        miny = patch.box[j][1];
      }

      if (patch.box[j][1] > maxy) {
        maxy = patch.box[j][1];
      }
    }
  }

  box = [[minx, miny], [maxx, miny], [maxx, maxy], [minx, maxy]];

  if ( true && _config.debug.boxFromPatches.showTransformedBox) {
    _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawPath(box, {
      x: 0,
      y: 1
    }, _canvasContainer.ctx.binary, {
      color: '#ff0000',
      lineWidth: 2
    });
  }

  scale = _config.halfSample ? 2 : 1; // reverse rotation;

  transMat = gl_mat2__WEBPACK_IMPORTED_MODULE_1__["invert"](transMat, transMat);

  for (j = 0; j < 4; j++) {
    gl_vec2__WEBPACK_IMPORTED_MODULE_0__["transformMat2"](box[j], box[j], transMat);
  }

  if ( true && _config.debug.boxFromPatches.showBB) {
    _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawPath(box, {
      x: 0,
      y: 1
    }, _canvasContainer.ctx.binary, {
      color: '#ff0000',
      lineWidth: 2
    });
  }

  for (j = 0; j < 4; j++) {
    gl_vec2__WEBPACK_IMPORTED_MODULE_0__["scale"](box[j], box[j], scale);
  }

  return box;
}
/**
 * Creates a binary image of the current image
 */


function binarizeImage() {
  Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["otsuThreshold"])(_currentImageWrapper, _binaryImageWrapper);

  _binaryImageWrapper.zeroBorder();

  if ( true && _config.debug.showCanvas) {
    _binaryImageWrapper.show(_canvasContainer.dom.binary, 255);
  }
}
/**
 * Iterate over the entire image
 * extract patches
 */


function findPatches() {
  var i;
  var j;
  var x;
  var y;
  var moments;
  var patchesFound = [];
  var rasterizer;
  var rasterResult;
  var patch;

  for (i = 0; i < _numPatches.x; i++) {
    for (j = 0; j < _numPatches.y; j++) {
      x = _subImageWrapper.size.x * i;
      y = _subImageWrapper.size.y * j; // seperate parts

      skeletonize(x, y); // Rasterize, find individual bars

      _skelImageWrapper.zeroBorder();

      _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_labelImageWrapper.data, 0);
      rasterizer = _rasterizer__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].create(_skelImageWrapper, _labelImageWrapper);
      rasterResult = rasterizer.rasterize(0);

      if ( true && _config.debug.showLabels) {
        _labelImageWrapper.overlay(_canvasContainer.dom.binary, Math.floor(360 / rasterResult.count), {
          x: x,
          y: y
        });
      } // calculate moments from the skeletonized patch


      moments = _labelImageWrapper.moments(rasterResult.count); // extract eligible patches

      patchesFound = patchesFound.concat(describePatch(moments, [i, j], x, y));
    }
  }

  if ( true && _config.debug.showFoundPatches) {
    for (i = 0; i < patchesFound.length; i++) {
      patch = patchesFound[i];
      _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
        color: '#99ff00',
        lineWidth: 2
      });
    }
  }

  return patchesFound;
}
/**
 * Finds those connected areas which contain at least 6 patches
 * and returns them ordered DESC by the number of contained patches
 * @param {Number} maxLabel
 */


function findBiggestConnectedAreas(maxLabel) {
  var i;
  var sum;
  var labelHist = [];
  var topLabels = [];

  for (i = 0; i < maxLabel; i++) {
    labelHist.push(0);
  }

  sum = _patchLabelGrid.data.length;

  while (sum--) {
    if (_patchLabelGrid.data[sum] > 0) {
      labelHist[_patchLabelGrid.data[sum] - 1]++;
    }
  }

  labelHist = labelHist.map(function (val, idx) {
    return {
      val: val,
      label: idx + 1
    };
  });
  labelHist.sort(function (a, b) {
    return b.val - a.val;
  }); // extract top areas with at least 6 patches present

  topLabels = labelHist.filter(function (el) {
    return el.val >= 5;
  });
  return topLabels;
}
/**
 *
 */


function findBoxes(topLabels, maxLabel) {
  var i;
  var j;
  var sum;
  var patches = [];
  var patch;
  var box;
  var boxes = [];
  var hsv = [0, 1, 1];
  var rgb = [0, 0, 0];

  for (i = 0; i < topLabels.length; i++) {
    sum = _patchLabelGrid.data.length;
    patches.length = 0;

    while (sum--) {
      if (_patchLabelGrid.data[sum] === topLabels[i].label) {
        patch = _imageToPatchGrid.data[sum];
        patches.push(patch);
      }
    }

    box = boxFromPatches(patches);

    if (box) {
      boxes.push(box); // draw patch-labels if requested

      if ( true && _config.debug.showRemainingPatchLabels) {
        for (j = 0; j < patches.length; j++) {
          patch = patches[j];
          hsv[0] = topLabels[i].label / (maxLabel + 1) * 360;
          Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["hsv2rgb"])(hsv, rgb);
          _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
            color: "rgb(".concat(rgb.join(','), ")"),
            lineWidth: 2
          });
        }
      }
    }
  }

  return boxes;
}
/**
 * Find similar moments (via cluster)
 * @param {Object} moments
 */


function similarMoments(moments) {
  var clusters = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["cluster"])(moments, 0.90);
  var topCluster = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["topGeneric"])(clusters, 1, function (e) {
    return e.getPoints().length;
  });
  var points = [];
  var result = [];

  if (topCluster.length === 1) {
    points = topCluster[0].item.getPoints();

    for (var i = 0; i < points.length; i++) {
      result.push(points[i].point);
    }
  }

  return result;
}

function skeletonize(x, y) {
  _binaryImageWrapper.subImageAsCopy(_subImageWrapper, Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["imageRef"])(x, y));

  _skeletonizer.skeletonize(); // Show skeleton if requested


  if ( true && _config.debug.showSkeleton) {
    _skelImageWrapper.overlay(_canvasContainer.dom.binary, 360, Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["imageRef"])(x, y));
  }
}
/**
 * Extracts and describes those patches which seem to contain a barcode pattern
 * @param {Array} moments
 * @param {Object} patchPos,
 * @param {Number} x
 * @param {Number} y
 * @returns {Array} list of patches
 */


function describePatch(moments, patchPos, x, y) {
  var k;
  var avg;
  var eligibleMoments = [];
  var matchingMoments;
  var patch;
  var patchesFound = [];
  var minComponentWeight = Math.ceil(_patchSize.x / 3);

  if (moments.length >= 2) {
    // only collect moments which's area covers at least minComponentWeight pixels.
    for (k = 0; k < moments.length; k++) {
      if (moments[k].m00 > minComponentWeight) {
        eligibleMoments.push(moments[k]);
      }
    } // if at least 2 moments are found which have at least minComponentWeights covered


    if (eligibleMoments.length >= 2) {
      matchingMoments = similarMoments(eligibleMoments);
      avg = 0; // determine the similarity of the moments

      for (k = 0; k < matchingMoments.length; k++) {
        avg += matchingMoments[k].rad;
      } // Only two of the moments are allowed not to fit into the equation
      // add the patch to the set


      if (matchingMoments.length > 1 && matchingMoments.length >= eligibleMoments.length / 4 * 3 && matchingMoments.length > moments.length / 4) {
        avg /= matchingMoments.length;
        patch = {
          index: patchPos[1] * _numPatches.x + patchPos[0],
          pos: {
            x: x,
            y: y
          },
          box: [gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x, y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x + _subImageWrapper.size.x, y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x + _subImageWrapper.size.x, y + _subImageWrapper.size.y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x, y + _subImageWrapper.size.y])],
          moments: matchingMoments,
          rad: avg,
          vec: gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([Math.cos(avg), Math.sin(avg)])
        };
        patchesFound.push(patch);
      }
    }
  }

  return patchesFound;
}
/**
 * finds patches which are connected and share the same orientation
 * @param {Object} patchesFound
 */


function rasterizeAngularSimilarity(patchesFound) {
  var label = 0;
  var threshold = 0.95;
  var currIdx = 0;
  var j;
  var patch;
  var hsv = [0, 1, 1];
  var rgb = [0, 0, 0];

  function notYetProcessed() {
    var i;

    for (i = 0; i < _patchLabelGrid.data.length; i++) {
      if (_patchLabelGrid.data[i] === 0 && _patchGrid.data[i] === 1) {
        return i;
      }
    }

    return _patchLabelGrid.length;
  }

  function trace(currentIdx) {
    var x;
    var y;
    var currentPatch;
    var idx;
    var dir;
    var current = {
      x: currentIdx % _patchLabelGrid.size.x,
      y: currentIdx / _patchLabelGrid.size.x | 0
    };
    var similarity;

    if (currentIdx < _patchLabelGrid.data.length) {
      currentPatch = _imageToPatchGrid.data[currentIdx]; // assign label

      _patchLabelGrid.data[currentIdx] = label;

      for (dir = 0; dir < _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections.length; dir++) {
        y = current.y + _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections[dir][0];
        x = current.x + _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections[dir][1];
        idx = y * _patchLabelGrid.size.x + x; // continue if patch empty

        if (_patchGrid.data[idx] === 0) {
          _patchLabelGrid.data[idx] = Number.MAX_VALUE; // eslint-disable-next-line no-continue

          continue;
        }

        if (_patchLabelGrid.data[idx] === 0) {
          similarity = Math.abs(gl_vec2__WEBPACK_IMPORTED_MODULE_0__["dot"](_imageToPatchGrid.data[idx].vec, currentPatch.vec));

          if (similarity > threshold) {
            trace(idx);
          }
        }
      }
    }
  } // prepare for finding the right patches


  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_patchGrid.data, 0);
  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_patchLabelGrid.data, 0);
  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_imageToPatchGrid.data, null);

  for (j = 0; j < patchesFound.length; j++) {
    patch = patchesFound[j];
    _imageToPatchGrid.data[patch.index] = patch;
    _patchGrid.data[patch.index] = 1;
  } // rasterize the patches found to determine area


  _patchGrid.zeroBorder(); // eslint-disable-next-line no-cond-assign


  while ((currIdx = notYetProcessed()) < _patchLabelGrid.data.length) {
    label++;
    trace(currIdx);
  } // draw patch-labels if requested


  if ( true && _config.debug.showPatchLabels) {
    for (j = 0; j < _patchLabelGrid.data.length; j++) {
      if (_patchLabelGrid.data[j] > 0 && _patchLabelGrid.data[j] <= label) {
        patch = _imageToPatchGrid.data[j];
        hsv[0] = _patchLabelGrid.data[j] / (label + 1) * 360;
        Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["hsv2rgb"])(hsv, rgb);
        _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
          color: "rgb(".concat(rgb.join(','), ")"),
          lineWidth: 2
        });
      }
    }
  }

  return label;
}

/* harmony default export */ __webpack_exports__["a"] = ({
  init: function init(inputImageWrapper, config) {
    _config = config;
    _inputImageWrapper = inputImageWrapper;
    initBuffers();
    initCanvas();
  },
  locate: function locate() {
    if (_config.halfSample) {
      Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["halfSample"])(_inputImageWrapper, _currentImageWrapper);
    }

    binarizeImage();
    var patchesFound = findPatches(); // return unless 5% or more patches are found

    if (patchesFound.length < _numPatches.x * _numPatches.y * 0.05) {
      return null;
    } // rasterrize area by comparing angular similarity;


    var maxLabel = rasterizeAngularSimilarity(patchesFound);

    if (maxLabel < 1) {
      return null;
    } // search for area with the most patches (biggest connected area)


    var topLabels = findBiggestConnectedAreas(maxLabel);

    if (topLabels.length === 0) {
      return null;
    }

    var boxes = findBoxes(topLabels, maxLabel);
    return boxes;
  },
  checkImageConstraints: function checkImageConstraints(inputStream, config) {
    var patchSize;
    var width = inputStream.getWidth();
    var height = inputStream.getHeight();
    var thisHalfSample = config.halfSample ? 0.5 : 1;
    var area; // calculate width and height based on area

    if (inputStream.getConfig().area) {
      area = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["computeImageArea"])(width, height, inputStream.getConfig().area);
      inputStream.setTopRight({
        x: area.sx,
        y: area.sy
      });
      inputStream.setCanvasSize({
        x: width,
        y: height
      });
      width = area.sw;
      height = area.sh;
    }

    var size = {
      x: Math.floor(width * thisHalfSample),
      y: Math.floor(height * thisHalfSample)
    };
    patchSize = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["calculatePatchSize"])(config.patchSize, size);

    if (true) {
      console.log("Patch-Size: ".concat(JSON.stringify(patchSize)));
    }

    inputStream.setWidth(Math.floor(Math.floor(size.x / patchSize.x) * (1 / thisHalfSample) * patchSize.x));
    inputStream.setHeight(Math.floor(Math.floor(size.y / patchSize.y) * (1 / thisHalfSample) * patchSize.y));

    if (inputStream.getWidth() % patchSize.x === 0 && inputStream.getHeight() % patchSize.y === 0) {
      return true;
    }

    throw new Error("Image dimensions do not comply with the current settings: Width (".concat(width, " )and height (").concat(height, ") must a multiple of ").concat(patchSize.x));
  }
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(13)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (typeof process === 'undefined' || !process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = {
    nextTick: nextTick
  };
} else {
  module.exports = process;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }

  var len = arguments.length;
  var args, i;

  switch (len) {
    case 0:
    case 1:
      return process.nextTick(fn);

    case 2:
      return process.nextTick(function afterTickOne() {
        fn.call(null, arg1);
      });

    case 3:
      return process.nextTick(function afterTickTwo() {
        fn.call(null, arg1, arg2);
      });

    case 4:
      return process.nextTick(function afterTickThree() {
        fn.call(null, arg1, arg2, arg3);
      });

    default:
      args = new Array(len - 1);
      i = 0;

      while (i < args.length) {
        args[i++] = arguments[i];
      }

      return process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
  }
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(14)))

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(69);

var iterableToArrayLimit = __webpack_require__(70);

var unsupportedIterableToArray = __webpack_require__(34);

var nonIterableRest = __webpack_require__(71);

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(142);

var iterableToArray = __webpack_require__(143);

var unsupportedIterableToArray = __webpack_require__(34);

var nonIterableSpread = __webpack_require__(144);

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),
/* 27 */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  determinant: __webpack_require__(147),
  transpose: __webpack_require__(148),
  multiply: __webpack_require__(149),
  identity: __webpack_require__(150),
  adjoint: __webpack_require__(151),
  rotate: __webpack_require__(152),
  invert: __webpack_require__(153),
  create: __webpack_require__(154),
  scale: __webpack_require__(155),
  copy: __webpack_require__(156),
  frob: __webpack_require__(157),
  ldu: __webpack_require__(158)
};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var iota = __webpack_require__(163);

var isBuffer = __webpack_require__(164);

var hasTypedArrays = typeof Float64Array !== "undefined";

function compare1st(a, b) {
  return a[0] - b[0];
}

function order() {
  var stride = this.stride;
  var terms = new Array(stride.length);
  var i;

  for (i = 0; i < terms.length; ++i) {
    terms[i] = [Math.abs(stride[i]), i];
  }

  terms.sort(compare1st);
  var result = new Array(terms.length);

  for (i = 0; i < result.length; ++i) {
    result[i] = terms[i][1];
  }

  return result;
}

function compileConstructor(dtype, dimension) {
  var className = ["View", dimension, "d", dtype].join("");

  if (dimension < 0) {
    className = "View_Nil" + dtype;
  }

  var useGetters = dtype === "generic";

  if (dimension === -1) {
    //Special case for trivial arrays
    var code = "function " + className + "(a){this.data=a;};\
var proto=" + className + ".prototype;\
proto.dtype='" + dtype + "';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new " + className + "(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_" + className + "(a){return new " + className + "(a);}";
    var procedure = new Function(code);
    return procedure();
  } else if (dimension === 0) {
    //Special case for 0d arrays
    var code = "function " + className + "(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto=" + className + ".prototype;\
proto.dtype='" + dtype + "';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function " + className + "_copy() {\
return new " + className + "(this.data,this.offset)\
};\
proto.pick=function " + className + "_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function " + className + "_get(){\
return " + (useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]") + "};\
proto.set=function " + className + "_set(v){\
return " + (useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") + "\
};\
return function construct_" + className + "(a,b,c,d){return new " + className + "(a,d)}";
    var procedure = new Function("TrivialArray", code);
    return procedure(CACHED_CONSTRUCTORS[dtype][0]);
  }

  var code = ["'use strict'"]; //Create constructor for view

  var indices = iota(dimension);
  var args = indices.map(function (i) {
    return "i" + i;
  });
  var index_str = "this.offset+" + indices.map(function (i) {
    return "this.stride[" + i + "]*i" + i;
  }).join("+");
  var shapeArg = indices.map(function (i) {
    return "b" + i;
  }).join(",");
  var strideArg = indices.map(function (i) {
    return "c" + i;
  }).join(",");
  code.push("function " + className + "(a," + shapeArg + "," + strideArg + ",d){this.data=a", "this.shape=[" + shapeArg + "]", "this.stride=[" + strideArg + "]", "this.offset=d|0}", "var proto=" + className + ".prototype", "proto.dtype='" + dtype + "'", "proto.dimension=" + dimension); //view.size:

  code.push("Object.defineProperty(proto,'size',{get:function " + className + "_size(){\
return " + indices.map(function (i) {
    return "this.shape[" + i + "]";
  }).join("*"), "}})"); //view.order:

  if (dimension === 1) {
    code.push("proto.order=[0]");
  } else {
    code.push("Object.defineProperty(proto,'order',{get:");

    if (dimension < 4) {
      code.push("function " + className + "_order(){");

      if (dimension === 2) {
        code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})");
      } else if (dimension === 3) {
        code.push("var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})");
      }
    } else {
      code.push("ORDER})");
    }
  } //view.set(i0, ..., v):


  code.push("proto.set=function " + className + "_set(" + args.join(",") + ",v){");

  if (useGetters) {
    code.push("return this.data.set(" + index_str + ",v)}");
  } else {
    code.push("return this.data[" + index_str + "]=v}");
  } //view.get(i0, ...):


  code.push("proto.get=function " + className + "_get(" + args.join(",") + "){");

  if (useGetters) {
    code.push("return this.data.get(" + index_str + ")}");
  } else {
    code.push("return this.data[" + index_str + "]}");
  } //view.index:


  code.push("proto.index=function " + className + "_index(", args.join(), "){return " + index_str + "}"); //view.hi():

  code.push("proto.hi=function " + className + "_hi(" + args.join(",") + "){return new " + className + "(this.data," + indices.map(function (i) {
    return ["(typeof i", i, "!=='number'||i", i, "<0)?this.shape[", i, "]:i", i, "|0"].join("");
  }).join(",") + "," + indices.map(function (i) {
    return "this.stride[" + i + "]";
  }).join(",") + ",this.offset)}"); //view.lo():

  var a_vars = indices.map(function (i) {
    return "a" + i + "=this.shape[" + i + "]";
  });
  var c_vars = indices.map(function (i) {
    return "c" + i + "=this.stride[" + i + "]";
  });
  code.push("proto.lo=function " + className + "_lo(" + args.join(",") + "){var b=this.offset,d=0," + a_vars.join(",") + "," + c_vars.join(","));

  for (var i = 0; i < dimension; ++i) {
    code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){\
d=i" + i + "|0;\
b+=c" + i + "*d;\
a" + i + "-=d}");
  }

  code.push("return new " + className + "(this.data," + indices.map(function (i) {
    return "a" + i;
  }).join(",") + "," + indices.map(function (i) {
    return "c" + i;
  }).join(",") + ",b)}"); //view.step():

  code.push("proto.step=function " + className + "_step(" + args.join(",") + "){var " + indices.map(function (i) {
    return "a" + i + "=this.shape[" + i + "]";
  }).join(",") + "," + indices.map(function (i) {
    return "b" + i + "=this.stride[" + i + "]";
  }).join(",") + ",c=this.offset,d=0,ceil=Math.ceil");

  for (var i = 0; i < dimension; ++i) {
    code.push("if(typeof i" + i + "==='number'){\
d=i" + i + "|0;\
if(d<0){\
c+=b" + i + "*(a" + i + "-1);\
a" + i + "=ceil(-a" + i + "/d)\
}else{\
a" + i + "=ceil(a" + i + "/d)\
}\
b" + i + "*=d\
}");
  }

  code.push("return new " + className + "(this.data," + indices.map(function (i) {
    return "a" + i;
  }).join(",") + "," + indices.map(function (i) {
    return "b" + i;
  }).join(",") + ",c)}"); //view.transpose():

  var tShape = new Array(dimension);
  var tStride = new Array(dimension);

  for (var i = 0; i < dimension; ++i) {
    tShape[i] = "a[i" + i + "]";
    tStride[i] = "b[i" + i + "]";
  }

  code.push("proto.transpose=function " + className + "_transpose(" + args + "){" + args.map(function (n, idx) {
    return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)";
  }).join(";"), "var a=this.shape,b=this.stride;return new " + className + "(this.data," + tShape.join(",") + "," + tStride.join(",") + ",this.offset)}"); //view.pick():

  code.push("proto.pick=function " + className + "_pick(" + args + "){var a=[],b=[],c=this.offset");

  for (var i = 0; i < dimension; ++i) {
    code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){c=(c+this.stride[" + i + "]*i" + i + ")|0}else{a.push(this.shape[" + i + "]);b.push(this.stride[" + i + "])}");
  }

  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}"); //Add return statement

  code.push("return function construct_" + className + "(data,shape,stride,offset){return new " + className + "(data," + indices.map(function (i) {
    return "shape[" + i + "]";
  }).join(",") + "," + indices.map(function (i) {
    return "stride[" + i + "]";
  }).join(",") + ",offset)}"); //Compile procedure

  var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"));
  return procedure(CACHED_CONSTRUCTORS[dtype], order);
}

function arrayDType(data) {
  if (isBuffer(data)) {
    return "buffer";
  }

  if (hasTypedArrays) {
    switch (Object.prototype.toString.call(data)) {
      case "[object Float64Array]":
        return "float64";

      case "[object Float32Array]":
        return "float32";

      case "[object Int8Array]":
        return "int8";

      case "[object Int16Array]":
        return "int16";

      case "[object Int32Array]":
        return "int32";

      case "[object Uint8Array]":
        return "uint8";

      case "[object Uint16Array]":
        return "uint16";

      case "[object Uint32Array]":
        return "uint32";

      case "[object Uint8ClampedArray]":
        return "uint8_clamped";

      case "[object BigInt64Array]":
        return "bigint64";

      case "[object BigUint64Array]":
        return "biguint64";
    }
  }

  if (Array.isArray(data)) {
    return "array";
  }

  return "generic";
}

var CACHED_CONSTRUCTORS = {
  "float32": [],
  "float64": [],
  "int8": [],
  "int16": [],
  "int32": [],
  "uint8": [],
  "uint16": [],
  "uint32": [],
  "array": [],
  "uint8_clamped": [],
  "bigint64": [],
  "biguint64": [],
  "buffer": [],
  "generic": []
};

(function () {
  for (var id in CACHED_CONSTRUCTORS) {
    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1));
  }
});

function wrappedNDArrayCtor(data, shape, stride, offset) {
  if (data === undefined) {
    var ctor = CACHED_CONSTRUCTORS.array[0];
    return ctor([]);
  } else if (typeof data === "number") {
    data = [data];
  }

  if (shape === undefined) {
    shape = [data.length];
  }

  var d = shape.length;

  if (stride === undefined) {
    stride = new Array(d);

    for (var i = d - 1, sz = 1; i >= 0; --i) {
      stride[i] = sz;
      sz *= shape[i];
    }
  }

  if (offset === undefined) {
    offset = 0;

    for (var i = 0; i < d; ++i) {
      if (stride[i] < 0) {
        offset -= (shape[i] - 1) * stride[i];
      }
    }
  }

  var dtype = arrayDType(data);
  var ctor_list = CACHED_CONSTRUCTORS[dtype];

  while (ctor_list.length <= d + 1) {
    ctor_list.push(compileConstructor(dtype, ctor_list.length - 1));
  }

  var ctor = ctor_list[d + 1];
  return ctor(data, shape, stride, offset);
}

module.exports = wrappedNDArrayCtor;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter;
module.exports.once = once; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = _getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) copy[i] = arr[i];

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function eventListener() {
      if (errorListener !== undefined) {
        emitter.removeListener('error', errorListener);
      }

      resolve([].slice.call(arguments));
    }

    ;
    var errorListener; // Adding an error listener is not optional because
    // if an error is thrown on an event emitter we cannot
    // guarantee that the actual event we are waiting will
    // be fired. The result could be a silent way to create
    // memory or file descriptor leaks, which is something
    // we should avoid.

    if (name !== 'error') {
      errorListener = function errorListener(err) {
        emitter.removeListener(name, eventListener);
        reject(err);
      };

      emitter.once('error', errorListener);
    }

    emitter.once(name, eventListener);
  });
}

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(57);
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(33);
exports.Duplex = __webpack_require__(15);
exports.Transform = __webpack_require__(61);
exports.PassThrough = __webpack_require__(182);

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(21);

var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}

if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
} // Copy static methods from Buffer


copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }

  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  var buf = Buffer(size);

  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }

  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return buffer.SlowBuffer(size);
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

/*<replacement>*/

var pna = __webpack_require__(24);
/*</replacement>*/


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/

var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var util = Object.create(__webpack_require__(22));
util.inherits = __webpack_require__(18);
/*</replacement>*/

/*<replacement>*/

var internalUtil = {
  deprecate: __webpack_require__(180)
};
/*</replacement>*/

/*<replacement>*/

var Stream = __webpack_require__(58);
/*</replacement>*/

/*<replacement>*/


var Buffer = __webpack_require__(32).Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/


var destroyImpl = __webpack_require__(59);

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(15);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(15); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  pna.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }

  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;
  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      stream.emit('error', err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(14), __webpack_require__(178).setImmediate, __webpack_require__(13)))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(35);

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),
/* 35 */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = 0.000001;

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = create;
/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new Float32Array(2);
  out[0] = 0;
  out[1] = 0;
  return out;
}

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = subtract;
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = multiply;
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = divide;
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = distance;
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.sqrt(x * x + y * y);
}

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = squaredDistance;
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}

/***/ }),
/* 43 */
/***/ (function(module, exports) {

module.exports = length;
/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1];
  return Math.sqrt(x * x + y * y);
}

/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = squaredLength;
/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = 0.000001;

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = create;
/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new Float32Array(3);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = fromValues;
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new Float32Array(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = normalize;
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }

  return out;
}

/***/ }),
/* 49 */
/***/ (function(module, exports) {

module.exports = dot;
/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/***/ }),
/* 50 */
/***/ (function(module, exports) {

module.exports = subtract;
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/***/ }),
/* 51 */
/***/ (function(module, exports) {

module.exports = multiply;
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/***/ }),
/* 52 */
/***/ (function(module, exports) {

module.exports = divide;
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/***/ }),
/* 53 */
/***/ (function(module, exports) {

module.exports = distance;
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1],
      z = b[2] - a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/***/ }),
/* 54 */
/***/ (function(module, exports) {

module.exports = squaredDistance;
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1],
      z = b[2] - a[2];
  return x * x + y * y + z * z;
}

/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = length;
/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/***/ }),
/* 56 */
/***/ (function(module, exports) {

module.exports = squaredLength;
/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  return x * x + y * y + z * z;
}

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/

var pna = __webpack_require__(24);
/*</replacement>*/


module.exports = Readable;
/*<replacement>*/

var isArray = __webpack_require__(174);
/*</replacement>*/

/*<replacement>*/


var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = __webpack_require__(30).EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = __webpack_require__(58);
/*</replacement>*/

/*<replacement>*/


var Buffer = __webpack_require__(32).Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

/*<replacement>*/


var util = Object.create(__webpack_require__(22));
util.inherits = __webpack_require__(18);
/*</replacement>*/

/*<replacement>*/

var debugUtil = __webpack_require__(175);

var debug = void 0;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/


var BufferList = __webpack_require__(176);

var destroyImpl = __webpack_require__(59);

var StringDecoder;
util.inherits(Readable, Stream);
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(15);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(60).StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(15);
  if (!(this instanceof Readable)) return new Readable(options);
  this._readableState = new ReadableState(options, this); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  return er;
} // if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.


function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(60).StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
}; // Don't raise the hwm > 8MB


var MAX_HWM = 0x800000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true; // emit 'readable' now to make sure it gets picked up.

  emitReadable(stream);
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;

  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;else len = state.length;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  } // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.


  var increasedAwaitDrain = false;
  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);

    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;

    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;

      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }

  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {}
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList; // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }
  return ret;
} // Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function fromListPartial(n, list, hasStrings) {
  var ret;

  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }

  return ret;
} // Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;

  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;

    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }

      break;
    }

    ++c;
  }

  list.length -= c;
  return ret;
} // Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;

  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;

    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }

      break;
    }

    ++c;
  }

  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState; // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.

  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(13), __webpack_require__(14)))

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(30).EventEmitter;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*<replacement>*/

var pna = __webpack_require__(24);
/*</replacement>*/
// undocumented cb() API, needed for core, not for public API


function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);

      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/

var Buffer = __webpack_require__(181).Buffer;
/*</replacement>*/


var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;

  switch (encoding && encoding.toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;

  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';

      case 'latin1':
      case 'binary':
        return 'latin1';

      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;

      default:
        if (retried) return; // undefined

        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
}

; // Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings

function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);

  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
} // StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.


exports.StringDecoder = StringDecoder;

function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;

  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;

    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;

    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;

    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }

  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;

  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }

  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer

StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer

StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
}; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.


function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
} // Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.


function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }

    return nb;
  }

  return 0;
} // Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.


function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }

  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }

    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
} // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.


function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;

  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
} // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.


function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
} // For UTF-8, a replacement character is added when ending on a partial
// character.


function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
} // UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.


function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);

    if (r) {
      var c = r.charCodeAt(r.length - 1);

      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }

    return r;
  }

  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
} // For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.


function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';

  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }

  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;

  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }

  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
} // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)


function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.


module.exports = Transform;

var Duplex = __webpack_require__(15);
/*<replacement>*/


var util = Object.create(__webpack_require__(22));
util.inherits = __webpack_require__(18);
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);

    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');
  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');
  return stream.push(null);
}

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var CVUtils = __webpack_require__(8);

var Ndarray = __webpack_require__(29);

var Interp2D = __webpack_require__(188).d2;

var FrameGrabber = {};

FrameGrabber.create = function (inputStream) {
  var _that = {};

  var _videoSize = CVUtils.imageRef(inputStream.getRealWidth(), inputStream.getRealHeight());

  var _canvasSize = inputStream.getCanvasSize();

  var _size = CVUtils.imageRef(inputStream.getWidth(), inputStream.getHeight());

  var _topRight = inputStream.getTopRight();

  var _data = new Uint8Array(_size.x * _size.y);

  var _grayData = new Uint8Array(_videoSize.x * _videoSize.y);

  var _canvasData = new Uint8Array(_canvasSize.x * _canvasSize.y);
  /* eslint-disable new-cap */


  var _grayImageArray = Ndarray(_grayData, [_videoSize.y, _videoSize.x]).transpose(1, 0);

  var _canvasImageArray = Ndarray(_canvasData, [_canvasSize.y, _canvasSize.x]).transpose(1, 0);

  var _targetImageArray = _canvasImageArray.hi(_topRight.x + _size.x, _topRight.y + _size.y).lo(_topRight.x, _topRight.y);

  var _stepSizeX = _videoSize.x / _canvasSize.x;

  var _stepSizeY = _videoSize.y / _canvasSize.y;

  if (true) {
    console.log('FrameGrabber', JSON.stringify({
      videoSize: _grayImageArray.shape,
      canvasSize: _canvasImageArray.shape,
      stepSize: [_stepSizeX, _stepSizeY],
      size: _targetImageArray.shape,
      topRight: _topRight
    }));
  }
  /**
   * Uses the given array as frame-buffer
   */


  _that.attachData = function (data) {
    _data = data;
  };
  /**
   * Returns the used frame-buffer
   */


  _that.getData = function () {
    return _data;
  };
  /**
   * Fetches a frame from the input-stream and puts into the frame-buffer.
   * The image-data is converted to gray-scale and then half-sampled if configured.
   */


  _that.grab = function () {
    var frame = inputStream.getFrame();

    if (frame) {
      this.scaleAndCrop(frame);
      return true;
    }

    return false;
  }; // eslint-disable-next-line


  _that.scaleAndCrop = function (frame) {
    // 1. compute full-sized gray image
    CVUtils.computeGray(frame.data, _grayData); // 2. interpolate

    for (var y = 0; y < _canvasSize.y; y++) {
      for (var x = 0; x < _canvasSize.x; x++) {
        // eslint-disable-next-line no-bitwise
        _canvasImageArray.set(x, y, Interp2D(_grayImageArray, x * _stepSizeX, y * _stepSizeY) | 0);
      }
    } // targetImageArray must be equal to targetSize


    if (_targetImageArray.shape[0] !== _size.x || _targetImageArray.shape[1] !== _size.y) {
      throw new Error('Shapes do not match!');
    } // 3. crop


    for (var _y = 0; _y < _size.y; _y++) {
      for (var _x = 0; _x < _size.x; _x++) {
        _data[_y * _size.x + _x] = _targetImageArray.get(_x, _y);
      }
    }
  };

  _that.getSize = function () {
    return _size;
  };

  return _that;
};

module.exports = FrameGrabber;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  EPSILON: __webpack_require__(45),
  create: __webpack_require__(46),
  clone: __webpack_require__(107),
  angle: __webpack_require__(108),
  fromValues: __webpack_require__(47),
  copy: __webpack_require__(109),
  set: __webpack_require__(110),
  equals: __webpack_require__(111),
  exactEquals: __webpack_require__(112),
  add: __webpack_require__(113),
  subtract: __webpack_require__(50),
  sub: __webpack_require__(114),
  multiply: __webpack_require__(51),
  mul: __webpack_require__(115),
  divide: __webpack_require__(52),
  div: __webpack_require__(116),
  min: __webpack_require__(117),
  max: __webpack_require__(118),
  floor: __webpack_require__(119),
  ceil: __webpack_require__(120),
  round: __webpack_require__(121),
  scale: __webpack_require__(122),
  scaleAndAdd: __webpack_require__(123),
  distance: __webpack_require__(53),
  dist: __webpack_require__(124),
  squaredDistance: __webpack_require__(54),
  sqrDist: __webpack_require__(125),
  length: __webpack_require__(55),
  len: __webpack_require__(126),
  squaredLength: __webpack_require__(56),
  sqrLen: __webpack_require__(127),
  negate: __webpack_require__(128),
  inverse: __webpack_require__(129),
  normalize: __webpack_require__(48),
  dot: __webpack_require__(49),
  cross: __webpack_require__(130),
  lerp: __webpack_require__(131),
  random: __webpack_require__(132),
  transformMat4: __webpack_require__(133),
  transformMat3: __webpack_require__(134),
  transformQuat: __webpack_require__(135),
  rotateX: __webpack_require__(136),
  rotateY: __webpack_require__(137),
  rotateZ: __webpack_require__(138),
  forEach: __webpack_require__(139)
};

/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);

/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */

var Rasterizer = {
  createContour2D: function createContour2D() {
    return {
      dir: null,
      index: null,
      firstVertex: null,
      insideContours: null,
      nextpeer: null,
      prevpeer: null
    };
  },
  CONTOUR_DIR: {
    CW_DIR: 0,
    CCW_DIR: 1,
    UNKNOWN_DIR: 2
  },
  DIR: {
    OUTSIDE_EDGE: -32767,
    INSIDE_EDGE: -32766
  },
  create: function create(imageWrapper, labelWrapper) {
    var imageData = imageWrapper.data;
    var labelData = labelWrapper.data;
    var width = imageWrapper.size.x;
    var height = imageWrapper.size.y;
    var tracer = _tracer__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].create(imageWrapper, labelWrapper);
    return {
      rasterize: function rasterize(depthlabel) {
        var color;
        var bc;
        var lc;
        var labelindex;
        var cx;
        var cy;
        var colorMap = [];
        var vertex;
        var p;
        var cc;
        var sc;
        var pos;
        var connectedCount = 0;
        var i;

        for (i = 0; i < 400; i++) {
          colorMap[i] = 0;
        }

        colorMap[0] = imageData[0];
        cc = null;

        for (cy = 1; cy < height - 1; cy++) {
          labelindex = 0;
          bc = colorMap[0];

          for (cx = 1; cx < width - 1; cx++) {
            pos = cy * width + cx;

            if (labelData[pos] === 0) {
              color = imageData[pos];

              if (color !== bc) {
                if (labelindex === 0) {
                  lc = connectedCount + 1;
                  colorMap[lc] = color;
                  bc = color;
                  vertex = tracer.contourTracing(cy, cx, lc, color, Rasterizer.DIR.OUTSIDE_EDGE);

                  if (vertex !== null) {
                    connectedCount++;
                    labelindex = lc;
                    p = Rasterizer.createContour2D();
                    p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                    p.index = labelindex;
                    p.firstVertex = vertex;
                    p.nextpeer = cc;
                    p.insideContours = null;

                    if (cc !== null) {
                      cc.prevpeer = p;
                    }

                    cc = p;
                  }
                } else {
                  vertex = tracer.contourTracing(cy, cx, Rasterizer.DIR.INSIDE_EDGE, color, labelindex);

                  if (vertex !== null) {
                    p = Rasterizer.createContour2D();
                    p.firstVertex = vertex;
                    p.insideContours = null;

                    if (depthlabel === 0) {
                      p.dir = Rasterizer.CONTOUR_DIR.CCW_DIR;
                    } else {
                      p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                    }

                    p.index = depthlabel;
                    sc = cc;

                    while (sc !== null && sc.index !== labelindex) {
                      sc = sc.nextpeer;
                    }

                    if (sc !== null) {
                      p.nextpeer = sc.insideContours;

                      if (sc.insideContours !== null) {
                        sc.insideContours.prevpeer = p;
                      }

                      sc.insideContours = p;
                    }
                  }
                }
              } else {
                labelData[pos] = labelindex;
              }
            } else if (labelData[pos] === Rasterizer.DIR.OUTSIDE_EDGE || labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
              labelindex = 0;

              if (labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
                bc = imageData[pos];
              } else {
                bc = colorMap[0];
              }
            } else {
              labelindex = labelData[pos];
              bc = colorMap[labelindex];
            }
          }
        }

        sc = cc;

        while (sc !== null) {
          sc.index = depthlabel;
          sc = sc.nextpeer;
        }

        return {
          cc: cc,
          count: connectedCount
        };
      },
      debug: {
        drawContour: function drawContour(canvas, firstContour) {
          var ctx = canvas.getContext('2d');
          var pq = firstContour;
          var iq;
          var q;
          var p;
          ctx.strokeStyle = 'red';
          ctx.fillStyle = 'red';
          ctx.lineWidth = 1;

          if (pq !== null) {
            iq = pq.insideContours;
          } else {
            iq = null;
          }

          while (pq !== null) {
            if (iq !== null) {
              q = iq;
              iq = iq.nextpeer;
            } else {
              q = pq;
              pq = pq.nextpeer;

              if (pq !== null) {
                iq = pq.insideContours;
              } else {
                iq = null;
              }
            }

            switch (q.dir) {
              case Rasterizer.CONTOUR_DIR.CW_DIR:
                ctx.strokeStyle = 'red';
                break;

              case Rasterizer.CONTOUR_DIR.CCW_DIR:
                ctx.strokeStyle = 'blue';
                break;

              case Rasterizer.CONTOUR_DIR.UNKNOWN_DIR:
                ctx.strokeStyle = 'green';
                break;
            }

            p = q.firstVertex;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);

            do {
              p = p.next;
              ctx.lineTo(p.x, p.y);
            } while (p !== q.firstVertex);

            ctx.stroke();
          }
        }
      }
    };
  }
};
/* harmony default export */ __webpack_exports__["a"] = (Rasterizer);

/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* eslint-disable no-param-reassign */

/* eslint-disable no-bitwise */

/* eslint-disable eqeqeq */

/* @preserve ASM BEGIN */
function Skeletonizer(stdlib, foreign, buffer) {
  'use asm';

  var images = new stdlib.Uint8Array(buffer);
  var size = foreign.size | 0;
  var imul = stdlib.Math.imul;

  function erode(inImagePtr, outImagePtr) {
    inImagePtr |= 0;
    outImagePtr |= 0;
    var v = 0;
    var u = 0;
    var sum = 0;
    var yStart1 = 0;
    var yStart2 = 0;
    var xStart1 = 0;
    var xStart2 = 0;
    var offset = 0;

    for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
      offset = offset + size | 0;

      for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
        yStart1 = offset - size | 0;
        yStart2 = offset + size | 0;
        xStart1 = u - 1 | 0;
        xStart2 = u + 1 | 0;
        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;

        if ((sum | 0) == (5 | 0)) {
          images[outImagePtr + offset + u | 0] = 1;
        } else {
          images[outImagePtr + offset + u | 0] = 0;
        }
      }
    }
  }

  function subtract(aImagePtr, bImagePtr, outImagePtr) {
    aImagePtr |= 0;
    bImagePtr |= 0;
    outImagePtr |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[outImagePtr + length | 0] = (images[aImagePtr + length | 0] | 0) - (images[bImagePtr + length | 0] | 0) | 0;
    }
  }

  function bitwiseOr(aImagePtr, bImagePtr, outImagePtr) {
    aImagePtr |= 0;
    bImagePtr |= 0;
    outImagePtr |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[outImagePtr + length | 0] = images[aImagePtr + length | 0] | 0 | (images[bImagePtr + length | 0] | 0) | 0;
    }
  }

  function countNonZero(imagePtr) {
    imagePtr |= 0;
    var sum = 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      sum = (sum | 0) + (images[imagePtr + length | 0] | 0) | 0;
    }

    return sum | 0;
  }

  function init(imagePtr, value) {
    imagePtr |= 0;
    value |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[imagePtr + length | 0] = value;
    }
  }

  function dilate(inImagePtr, outImagePtr) {
    inImagePtr |= 0;
    outImagePtr |= 0;
    var v = 0;
    var u = 0;
    var sum = 0;
    var yStart1 = 0;
    var yStart2 = 0;
    var xStart1 = 0;
    var xStart2 = 0;
    var offset = 0;

    for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
      offset = offset + size | 0;

      for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
        yStart1 = offset - size | 0;
        yStart2 = offset + size | 0;
        xStart1 = u - 1 | 0;
        xStart2 = u + 1 | 0;
        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;

        if ((sum | 0) > (0 | 0)) {
          images[outImagePtr + offset + u | 0] = 1;
        } else {
          images[outImagePtr + offset + u | 0] = 0;
        }
      }
    }
  }

  function memcpy(srcImagePtr, dstImagePtr) {
    srcImagePtr |= 0;
    dstImagePtr |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[dstImagePtr + length | 0] = images[srcImagePtr + length | 0] | 0;
    }
  }

  function zeroBorder(imagePtr) {
    imagePtr |= 0;
    var x = 0;
    var y = 0;

    for (x = 0; (x | 0) < (size - 1 | 0); x = x + 1 | 0) {
      images[imagePtr + x | 0] = 0;
      images[imagePtr + y | 0] = 0;
      y = y + size - 1 | 0;
      images[imagePtr + y | 0] = 0;
      y = y + 1 | 0;
    }

    for (x = 0; (x | 0) < (size | 0); x = x + 1 | 0) {
      images[imagePtr + y | 0] = 0;
      y = y + 1 | 0;
    }
  }

  function skeletonize() {
    var subImagePtr = 0;
    var erodedImagePtr = 0;
    var tempImagePtr = 0;
    var skelImagePtr = 0;
    var sum = 0;
    var done = 0;
    erodedImagePtr = imul(size, size) | 0;
    tempImagePtr = erodedImagePtr + erodedImagePtr | 0;
    skelImagePtr = tempImagePtr + erodedImagePtr | 0; // init skel-image

    init(skelImagePtr, 0);
    zeroBorder(subImagePtr);

    do {
      erode(subImagePtr, erodedImagePtr);
      dilate(erodedImagePtr, tempImagePtr);
      subtract(subImagePtr, tempImagePtr, tempImagePtr);
      bitwiseOr(skelImagePtr, tempImagePtr, skelImagePtr);
      memcpy(erodedImagePtr, subImagePtr);
      sum = countNonZero(subImagePtr) | 0;
      done = (sum | 0) == 0 | 0;
    } while (!done);
  }

  return {
    skeletonize: skeletonize
  };
}
/* @preserve ASM END */


/* harmony default export */ __webpack_exports__["a"] = (Skeletonizer);
/* eslint-enable eqeqeq */

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, Buffer) {

var path = __webpack_require__(162);

var ndarray = __webpack_require__(29);

var GifReader = __webpack_require__(165).GifReader;

var pack = __webpack_require__(166);

var through = __webpack_require__(172);

var parseDataURI = __webpack_require__(187);

function defaultImage(url, cb) {
  var img = new Image();
  img.crossOrigin = "Anonymous";

  img.onload = function () {
    var canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    var context = canvas.getContext('2d');
    context.drawImage(img, 0, 0);
    var pixels = context.getImageData(0, 0, img.width, img.height);
    cb(null, ndarray(new Uint8Array(pixels.data), [img.width, img.height, 4], [4, 4 * img.width, 1], 0));
  };

  img.onerror = function (err) {
    cb(err);
  };

  img.src = url;
} //Animated gif loading


function handleGif(data, cb) {
  var reader;

  try {
    reader = new GifReader(data);
  } catch (err) {
    cb(err);
    return;
  }

  if (reader.numFrames() > 0) {
    var nshape = [reader.numFrames(), reader.height, reader.width, 4];
    var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2] * nshape[3]);
    var result = ndarray(ndata, nshape);

    try {
      for (var i = 0; i < reader.numFrames(); ++i) {
        reader.decodeAndBlitFrameRGBA(i, ndata.subarray(result.index(i, 0, 0, 0), result.index(i + 1, 0, 0, 0)));
      }
    } catch (err) {
      cb(err);
      return;
    }

    cb(null, result.transpose(0, 2, 1));
  } else {
    var nshape = [reader.height, reader.width, 4];
    var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2]);
    var result = ndarray(ndata, nshape);

    try {
      reader.decodeAndBlitFrameRGBA(0, ndata);
    } catch (err) {
      cb(err);
      return;
    }

    cb(null, result.transpose(1, 0));
  }
}

function httpGif(url, cb) {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', url, true);
  xhr.responseType = 'arraybuffer';

  if (xhr.overrideMimeType) {
    xhr.overrideMimeType('application/binary');
  }

  xhr.onerror = function (err) {
    cb(err);
  };

  xhr.onload = function () {
    if (xhr.readyState !== 4) {
      return;
    }

    var data = new Uint8Array(xhr.response);
    handleGif(data, cb);
    return;
  };

  xhr.send();
}

function copyBuffer(buffer) {
  if (buffer[0] === undefined) {
    var n = buffer.length;
    var result = new Uint8Array(n);

    for (var i = 0; i < n; ++i) {
      result[i] = buffer.get(i);
    }

    return result;
  } else {
    return new Uint8Array(buffer);
  }
}

function dataGif(url, cb) {
  process.nextTick(function () {
    try {
      var buffer = parseDataURI(url);

      if (buffer) {
        handleGif(copyBuffer(buffer), cb);
      } else {
        cb(new Error('Error parsing data URI'));
      }
    } catch (err) {
      cb(err);
    }
  });
}

module.exports = function getPixels(url, type, cb) {
  if (!cb) {
    cb = type;
    type = '';
  }

  var ext = path.extname(url);

  switch (type || ext.toUpperCase()) {
    case '.GIF':
      httpGif(url, cb);
      break;

    default:
      if (Buffer.isBuffer(url)) {
        url = 'data:' + type + ';base64,' + url.toString('base64');
      }

      if (url.indexOf('data:image/gif;') === 0) {
        dataGif(url, cb);
      } else {
        defaultImage(url, cb);
      }

  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(14), __webpack_require__(21).Buffer))

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(189);


/***/ }),
/* 68 */
/***/ (function(module, exports) {

/*
 * typedefs.js
 * Normalizes browser-specific prefixes and provide some basic polyfills
 */
if (typeof window !== 'undefined') {
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function () {
      return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (
      /* function FrameRequestCallback */
      callback) {
        window.setTimeout(callback, 1000 / 60);
      };
    }();
  }
}

if (typeof Math.imul !== 'function') {
  /* eslint-disable no-bitwise */
  Math.imul = function (a, b) {
    var ah = a >>> 16 & 0xffff;
    var al = a & 0xffff;
    var bh = b >>> 16 & 0xffff;
    var bl = b & 0xffff; // the shift by 0 fixes the sign on the high part
    // the final |0 converts the unsigned value into a signed value

    return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
  };
  /* eslint-enable no-bitwise */

}

if (typeof Object.assign !== 'function') {
  Object.assign = function (target) {
    // .length of function is 2
    'use strict';

    if (target === null) {
      // TypeError if undefined or null
      throw new TypeError('Cannot convert undefined or null to object');
    }

    var to = Object(target);

    for (var index = 1; index < arguments.length; index++) {
      // eslint-disable-next-line prefer-rest-params
      var nextSource = arguments[index];

      if (nextSource !== null) {
        // Skip over if undefined or null
        // eslint-disable-next-line no-restricted-syntax
        for (var nextKey in nextSource) {
          // Avoid bugs when hasOwnProperty is shadowed
          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }

    return to;
  };
}

/***/ }),
/* 69 */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),
/* 70 */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),
/* 71 */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),
/* 72 */
/***/ (function(module, exports) {

module.exports = clone;
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new Float32Array(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/***/ }),
/* 73 */
/***/ (function(module, exports) {

module.exports = fromValues;
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new Float32Array(2);
  out[0] = x;
  out[1] = y;
  return out;
}

/***/ }),
/* 74 */
/***/ (function(module, exports) {

module.exports = copy;
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/***/ }),
/* 75 */
/***/ (function(module, exports) {

module.exports = set;
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = equals;

var EPSILON = __webpack_require__(36);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0];
  var a1 = a[1];
  var b0 = b[0];
  var b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}

/***/ }),
/* 77 */
/***/ (function(module, exports) {

module.exports = exactEquals;
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/***/ }),
/* 78 */
/***/ (function(module, exports) {

module.exports = add;
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(38);

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(39);

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(40);

/***/ }),
/* 82 */
/***/ (function(module, exports) {

module.exports = inverse;
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}

/***/ }),
/* 83 */
/***/ (function(module, exports) {

module.exports = min;
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}

/***/ }),
/* 84 */
/***/ (function(module, exports) {

module.exports = max;
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}

/***/ }),
/* 85 */
/***/ (function(module, exports) {

module.exports = rotate;
/**
 * Rotates a vec2 by an angle
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to rotate
 * @param {Number} angle the angle of rotation (in radians)
 * @returns {vec2} out
 */

function rotate(out, a, angle) {
  var c = Math.cos(angle),
      s = Math.sin(angle);
  var x = a[0],
      y = a[1];
  out[0] = x * c - y * s;
  out[1] = x * s + y * c;
  return out;
}

/***/ }),
/* 86 */
/***/ (function(module, exports) {

module.exports = floor;
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}

/***/ }),
/* 87 */
/***/ (function(module, exports) {

module.exports = ceil;
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}

/***/ }),
/* 88 */
/***/ (function(module, exports) {

module.exports = round;
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}

/***/ }),
/* 89 */
/***/ (function(module, exports) {

module.exports = scale;
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}

/***/ }),
/* 90 */
/***/ (function(module, exports) {

module.exports = scaleAndAdd;
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(41);

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(42);

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(43);

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(44);

/***/ }),
/* 95 */
/***/ (function(module, exports) {

module.exports = negate;
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}

/***/ }),
/* 96 */
/***/ (function(module, exports) {

module.exports = normalize;
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
  }

  return out;
}

/***/ }),
/* 97 */
/***/ (function(module, exports) {

module.exports = dot;
/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

/***/ }),
/* 98 */
/***/ (function(module, exports) {

module.exports = cross;
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}

/***/ }),
/* 99 */
/***/ (function(module, exports) {

module.exports = lerp;
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}

/***/ }),
/* 100 */
/***/ (function(module, exports) {

module.exports = random;
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = Math.random() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}

/***/ }),
/* 101 */
/***/ (function(module, exports) {

module.exports = transformMat2;
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}

/***/ }),
/* 102 */
/***/ (function(module, exports) {

module.exports = transformMat2d;
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}

/***/ }),
/* 103 */
/***/ (function(module, exports) {

module.exports = transformMat3;
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}

/***/ }),
/* 104 */
/***/ (function(module, exports) {

module.exports = transformMat4;
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = forEach;

var vec = __webpack_require__(37)();
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */


function forEach(a, stride, offset, count, fn, arg) {
  var i, l;

  if (!stride) {
    stride = 2;
  }

  if (!offset) {
    offset = 0;
  }

  if (count) {
    l = Math.min(count * stride + offset, a.length);
  } else {
    l = a.length;
  }

  for (i = offset; i < l; i += stride) {
    vec[0] = a[i];
    vec[1] = a[i + 1];
    fn(vec, vec, arg);
    a[i] = vec[0];
    a[i + 1] = vec[1];
  }

  return a;
}

/***/ }),
/* 106 */
/***/ (function(module, exports) {

module.exports = limit;
/**
 * Limit the magnitude of this vector to the value used for the `max`
 * parameter.
 *
 * @param  {vec2} the vector to limit
 * @param  {Number} max the maximum magnitude for the vector
 * @returns {vec2} out
 */

function limit(out, a, max) {
  var mSq = a[0] * a[0] + a[1] * a[1];

  if (mSq > max * max) {
    var n = Math.sqrt(mSq);
    out[0] = a[0] / n * max;
    out[1] = a[1] / n * max;
  } else {
    out[0] = a[0];
    out[1] = a[1];
  }

  return out;
}

/***/ }),
/* 107 */
/***/ (function(module, exports) {

module.exports = clone;
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new Float32Array(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = angle;

var fromValues = __webpack_require__(47);

var normalize = __webpack_require__(48);

var dot = __webpack_require__(49);
/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var tempA = fromValues(a[0], a[1], a[2]);
  var tempB = fromValues(b[0], b[1], b[2]);
  normalize(tempA, tempA);
  normalize(tempB, tempB);
  var cosine = dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else {
    return Math.acos(cosine);
  }
}

/***/ }),
/* 109 */
/***/ (function(module, exports) {

module.exports = copy;
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/***/ }),
/* 110 */
/***/ (function(module, exports) {

module.exports = set;
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = equals;

var EPSILON = __webpack_require__(45);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0];
  var a1 = a[1];
  var a2 = a[2];
  var b0 = b[0];
  var b1 = b[1];
  var b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}

/***/ }),
/* 112 */
/***/ (function(module, exports) {

module.exports = exactEquals;
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/***/ }),
/* 113 */
/***/ (function(module, exports) {

module.exports = add;
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(50);

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(51);

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(52);

/***/ }),
/* 117 */
/***/ (function(module, exports) {

module.exports = min;
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/***/ }),
/* 118 */
/***/ (function(module, exports) {

module.exports = max;
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/***/ }),
/* 119 */
/***/ (function(module, exports) {

module.exports = floor;
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/***/ }),
/* 120 */
/***/ (function(module, exports) {

module.exports = ceil;
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/***/ }),
/* 121 */
/***/ (function(module, exports) {

module.exports = round;
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}

/***/ }),
/* 122 */
/***/ (function(module, exports) {

module.exports = scale;
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/***/ }),
/* 123 */
/***/ (function(module, exports) {

module.exports = scaleAndAdd;
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(53);

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(54);

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(55);

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(56);

/***/ }),
/* 128 */
/***/ (function(module, exports) {

module.exports = negate;
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/***/ }),
/* 129 */
/***/ (function(module, exports) {

module.exports = inverse;
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/***/ }),
/* 130 */
/***/ (function(module, exports) {

module.exports = cross;
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/***/ }),
/* 131 */
/***/ (function(module, exports) {

module.exports = lerp;
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/***/ }),
/* 132 */
/***/ (function(module, exports) {

module.exports = random;
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = Math.random() * 2.0 * Math.PI;
  var z = Math.random() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/***/ }),
/* 133 */
/***/ (function(module, exports) {

module.exports = transformMat4;
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/***/ }),
/* 134 */
/***/ (function(module, exports) {

module.exports = transformMat3;
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/***/ }),
/* 135 */
/***/ (function(module, exports) {

module.exports = transformQuat;
/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations
  var x = a[0],
      y = a[1],
      z = a[2],
      qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      // calculate quat * vec
  ix = qw * x + qy * z - qz * y,
      iy = qw * y + qz * x - qx * z,
      iz = qw * z + qx * y - qy * x,
      iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return out;
}

/***/ }),
/* 136 */
/***/ (function(module, exports) {

module.exports = rotateX;
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateX(out, a, b, c) {
  var by = b[1];
  var bz = b[2]; // Translate point to the origin

  var py = a[1] - by;
  var pz = a[2] - bz;
  var sc = Math.sin(c);
  var cc = Math.cos(c); // perform rotation and translate to correct position

  out[0] = a[0];
  out[1] = by + py * cc - pz * sc;
  out[2] = bz + py * sc + pz * cc;
  return out;
}

/***/ }),
/* 137 */
/***/ (function(module, exports) {

module.exports = rotateY;
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateY(out, a, b, c) {
  var bx = b[0];
  var bz = b[2]; // translate point to the origin

  var px = a[0] - bx;
  var pz = a[2] - bz;
  var sc = Math.sin(c);
  var cc = Math.cos(c); // perform rotation and translate to correct position

  out[0] = bx + pz * sc + px * cc;
  out[1] = a[1];
  out[2] = bz + pz * cc - px * sc;
  return out;
}

/***/ }),
/* 138 */
/***/ (function(module, exports) {

module.exports = rotateZ;
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateZ(out, a, b, c) {
  var bx = b[0];
  var by = b[1]; //Translate point to the origin

  var px = a[0] - bx;
  var py = a[1] - by;
  var sc = Math.sin(c);
  var cc = Math.cos(c); // perform rotation and translate to correct position

  out[0] = bx + px * cc - py * sc;
  out[1] = by + px * sc + py * cc;
  out[2] = a[2];
  return out;
}

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = forEach;

var vec = __webpack_require__(46)();
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */


function forEach(a, stride, offset, count, fn, arg) {
  var i, l;

  if (!stride) {
    stride = 3;
  }

  if (!offset) {
    offset = 0;
  }

  if (count) {
    l = Math.min(count * stride + offset, a.length);
  } else {
    l = a.length;
  }

  for (i = offset; i < l; i += stride) {
    vec[0] = a[i];
    vec[1] = a[i + 1];
    vec[2] = a[i + 2];
    fn(vec, vec, arg);
    a[i] = vec[0];
    a[i + 1] = vec[1];
    a[i + 2] = vec[2];
  }

  return a;
}

/***/ }),
/* 140 */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),
/* 141 */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function () {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function () {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(35);

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;

/***/ }),
/* 143 */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),
/* 144 */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(2);

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

module.exports = _superPropBase;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var runtime = function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  exports.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;

      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  exports.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  exports.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function () {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function (record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  }; // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.

  return exports;
}( // If this script is executing as a CommonJS module, use module.exports
// as the regeneratorRuntime namespace. Otherwise create a new empty
// object. Either way, the resulting object will be used to initialize
// the regeneratorRuntime variable at the top of this file.
 true ? module.exports : undefined);

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

/***/ }),
/* 147 */
/***/ (function(module, exports) {

module.exports = determinant;
/**
 * Calculates the determinant of a mat2
 *
 * @alias mat2.determinant
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}

/***/ }),
/* 148 */
/***/ (function(module, exports) {

module.exports = transpose;
/**
 * Transpose the values of a mat2
 *
 * @alias mat2.transpose
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}

/***/ }),
/* 149 */
/***/ (function(module, exports) {

module.exports = multiply;
/**
 * Multiplies two mat2's
 *
 * @alias mat2.multiply
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}

/***/ }),
/* 150 */
/***/ (function(module, exports) {

module.exports = identity;
/**
 * Set a mat2 to the identity matrix
 *
 * @alias mat2.identity
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/***/ }),
/* 151 */
/***/ (function(module, exports) {

module.exports = adjoint;
/**
 * Calculates the adjugate of a mat2
 *
 * @alias mat2.adjoint
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}

/***/ }),
/* 152 */
/***/ (function(module, exports) {

module.exports = rotate;
/**
 * Rotates a mat2 by the given angle
 *
 * @alias mat2.rotate
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}

/***/ }),
/* 153 */
/***/ (function(module, exports) {

module.exports = invert;
/**
 * Inverts a mat2
 *
 * @alias mat2.invert
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function invert(out, a) {
  var a0 = a[0];
  var a1 = a[1];
  var a2 = a[2];
  var a3 = a[3];
  var det = a0 * a3 - a2 * a1;
  if (!det) return null;
  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}

/***/ }),
/* 154 */
/***/ (function(module, exports) {

module.exports = create;
/**
 * Creates a new identity mat2
 *
 * @alias mat2.create
 * @returns {mat2} a new 2x2 matrix
 */

function create() {
  var out = new Float32Array(4);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/***/ }),
/* 155 */
/***/ (function(module, exports) {

module.exports = scale;
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @alias mat2.scale
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}

/***/ }),
/* 156 */
/***/ (function(module, exports) {

module.exports = copy;
/**
 * Copy the values from one mat2 to another
 *
 * @alias mat2.copy
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/***/ }),
/* 157 */
/***/ (function(module, exports) {

module.exports = frob;
/**
 * Returns Frobenius norm of a mat2
 *
 * @alias mat2.frob
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
}

/***/ }),
/* 158 */
/***/ (function(module, exports) {

module.exports = ldu;
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 *
 * @alias mat2.ldu
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */

function ldu(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;

  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),
/* 160 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),
/* 161 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;

  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];

    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  } // if the path is allowed to go above the root, restore leading ..s


  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
} // path.resolve([from ...], to)
// posix version


exports.resolve = function () {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = i >= 0 ? arguments[i] : process.cwd(); // Skip empty and invalid entries

    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  } // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)
  // Normalize the path


  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
    return !!p;
  }), !resolvedAbsolute).join('/');
  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
}; // path.normalize(path)
// posix version


exports.normalize = function (path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/'; // Normalize the path

  path = normalizeArray(filter(path.split('/'), function (p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }

  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
}; // posix version


exports.isAbsolute = function (path) {
  return path.charAt(0) === '/';
}; // posix version


exports.join = function () {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function (p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }

    return p;
  }).join('/'));
}; // path.relative(from, to)
// posix version


exports.relative = function (from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;

    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;

    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;

  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];

  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47
  /*/*/
  ;
  var end = -1;
  var matchedSlash = true;

  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);

    if (code === 47
    /*/*/
    ) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';

  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }

  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';
  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47
    /*/*/
    ) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
} // Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here


exports.basename = function (path, ext) {
  var f = basename(path);

  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }

  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true; // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find

  var preDotState = 0;

  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);

    if (code === 47
    /*/*/
    ) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }

        continue;
      }

    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }

    if (code === 46
    /*.*/
    ) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
      } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }

  return path.slice(startDot, end);
};

function filter(xs, f) {
  if (xs.filter) return xs.filter(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    if (f(xs[i], i, xs)) res.push(xs[i]);
  }

  return res;
} // String.prototype.substr - negative index don't work in IE8


var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
  return str.substr(start, len);
} : function (str, start, len) {
  if (start < 0) start = str.length + start;
  return str.substr(start, len);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(14)))

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function iota(n) {
  var result = new Array(n);

  for (var i = 0; i < n; ++i) {
    result[i] = i;
  }

  return result;
}

module.exports = iota;

/***/ }),
/* 164 */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};

function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
} // For Node v0.10 support. Remove this eventually.


function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// (c) Dean McNamee <dean@gmail.com>, 2013.
//
// https://github.com/deanm/omggif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
//
// omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
// including animation and compression.  It does not rely on any specific
// underlying system, so should run in the browser, Node, or Plask.


function GifWriter(buf, width, height, gopts) {
  var p = 0;
  var gopts = gopts === undefined ? {} : gopts;
  var loop_count = gopts.loop === undefined ? null : gopts.loop;
  var global_palette = gopts.palette === undefined ? null : gopts.palette;
  if (width <= 0 || height <= 0 || width > 65535 || height > 65535) throw new Error("Width/Height invalid.");

  function check_palette_and_num_colors(palette) {
    var num_colors = palette.length;

    if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) {
      throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");
    }

    return num_colors;
  } // - Header.


  buf[p++] = 0x47;
  buf[p++] = 0x49;
  buf[p++] = 0x46; // GIF

  buf[p++] = 0x38;
  buf[p++] = 0x39;
  buf[p++] = 0x61; // 89a
  // Handling of Global Color Table (palette) and background index.

  var gp_num_colors_pow2 = 0;
  var background = 0;

  if (global_palette !== null) {
    var gp_num_colors = check_palette_and_num_colors(global_palette);

    while (gp_num_colors >>= 1) ++gp_num_colors_pow2;

    gp_num_colors = 1 << gp_num_colors_pow2;
    --gp_num_colors_pow2;

    if (gopts.background !== undefined) {
      background = gopts.background;
      if (background >= gp_num_colors) throw new Error("Background index out of range."); // The GIF spec states that a background index of 0 should be ignored, so
      // this is probably a mistake and you really want to set it to another
      // slot in the palette.  But actually in the end most browsers, etc end
      // up ignoring this almost completely (including for dispose background).

      if (background === 0) throw new Error("Background index explicitly passed as 0.");
    }
  } // - Logical Screen Descriptor.
  // NOTE(deanm): w/h apparently ignored by implementations, but set anyway.


  buf[p++] = width & 0xff;
  buf[p++] = width >> 8 & 0xff;
  buf[p++] = height & 0xff;
  buf[p++] = height >> 8 & 0xff; // NOTE: Indicates 0-bpp original color resolution (unused?).

  buf[p++] = (global_palette !== null ? 0x80 : 0) | // Global Color Table Flag.
  gp_num_colors_pow2; // NOTE: No sort flag (unused?).

  buf[p++] = background; // Background Color Index.

  buf[p++] = 0; // Pixel aspect ratio (unused?).
  // - Global Color Table

  if (global_palette !== null) {
    for (var i = 0, il = global_palette.length; i < il; ++i) {
      var rgb = global_palette[i];
      buf[p++] = rgb >> 16 & 0xff;
      buf[p++] = rgb >> 8 & 0xff;
      buf[p++] = rgb & 0xff;
    }
  }

  if (loop_count !== null) {
    // Netscape block for looping.
    if (loop_count < 0 || loop_count > 65535) throw new Error("Loop count invalid."); // Extension code, label, and length.

    buf[p++] = 0x21;
    buf[p++] = 0xff;
    buf[p++] = 0x0b; // NETSCAPE2.0

    buf[p++] = 0x4e;
    buf[p++] = 0x45;
    buf[p++] = 0x54;
    buf[p++] = 0x53;
    buf[p++] = 0x43;
    buf[p++] = 0x41;
    buf[p++] = 0x50;
    buf[p++] = 0x45;
    buf[p++] = 0x32;
    buf[p++] = 0x2e;
    buf[p++] = 0x30; // Sub-block

    buf[p++] = 0x03;
    buf[p++] = 0x01;
    buf[p++] = loop_count & 0xff;
    buf[p++] = loop_count >> 8 & 0xff;
    buf[p++] = 0x00; // Terminator.
  }

  var ended = false;

  this.addFrame = function (x, y, w, h, indexed_pixels, opts) {
    if (ended === true) {
      --p;
      ended = false;
    } // Un-end.


    opts = opts === undefined ? {} : opts; // TODO(deanm): Bounds check x, y.  Do they need to be within the virtual
    // canvas width/height, I imagine?

    if (x < 0 || y < 0 || x > 65535 || y > 65535) throw new Error("x/y invalid.");
    if (w <= 0 || h <= 0 || w > 65535 || h > 65535) throw new Error("Width/Height invalid.");
    if (indexed_pixels.length < w * h) throw new Error("Not enough pixels for the frame size.");
    var using_local_palette = true;
    var palette = opts.palette;

    if (palette === undefined || palette === null) {
      using_local_palette = false;
      palette = global_palette;
    }

    if (palette === undefined || palette === null) throw new Error("Must supply either a local or global palette.");
    var num_colors = check_palette_and_num_colors(palette); // Compute the min_code_size (power of 2), destroying num_colors.

    var min_code_size = 0;

    while (num_colors >>= 1) ++min_code_size;

    num_colors = 1 << min_code_size; // Now we can easily get it back.

    var delay = opts.delay === undefined ? 0 : opts.delay; // From the spec:
    //     0 -   No disposal specified. The decoder is
    //           not required to take any action.
    //     1 -   Do not dispose. The graphic is to be left
    //           in place.
    //     2 -   Restore to background color. The area used by the
    //           graphic must be restored to the background color.
    //     3 -   Restore to previous. The decoder is required to
    //           restore the area overwritten by the graphic with
    //           what was there prior to rendering the graphic.
    //  4-7 -    To be defined.
    // NOTE(deanm): Dispose background doesn't really work, apparently most
    // browsers ignore the background palette index and clear to transparency.

    var disposal = opts.disposal === undefined ? 0 : opts.disposal;
    if (disposal < 0 || disposal > 3) // 4-7 is reserved.
      throw new Error("Disposal out of range.");
    var use_transparency = false;
    var transparent_index = 0;

    if (opts.transparent !== undefined && opts.transparent !== null) {
      use_transparency = true;
      transparent_index = opts.transparent;
      if (transparent_index < 0 || transparent_index >= num_colors) throw new Error("Transparent color index.");
    }

    if (disposal !== 0 || use_transparency || delay !== 0) {
      // - Graphics Control Extension
      buf[p++] = 0x21;
      buf[p++] = 0xf9; // Extension / Label.

      buf[p++] = 4; // Byte size.

      buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
      buf[p++] = delay & 0xff;
      buf[p++] = delay >> 8 & 0xff;
      buf[p++] = transparent_index; // Transparent color index.

      buf[p++] = 0; // Block Terminator.
    } // - Image Descriptor


    buf[p++] = 0x2c; // Image Seperator.

    buf[p++] = x & 0xff;
    buf[p++] = x >> 8 & 0xff; // Left.

    buf[p++] = y & 0xff;
    buf[p++] = y >> 8 & 0xff; // Top.

    buf[p++] = w & 0xff;
    buf[p++] = w >> 8 & 0xff;
    buf[p++] = h & 0xff;
    buf[p++] = h >> 8 & 0xff; // NOTE: No sort flag (unused?).
    // TODO(deanm): Support interlace.

    buf[p++] = using_local_palette === true ? 0x80 | min_code_size - 1 : 0; // - Local Color Table

    if (using_local_palette === true) {
      for (var i = 0, il = palette.length; i < il; ++i) {
        var rgb = palette[i];
        buf[p++] = rgb >> 16 & 0xff;
        buf[p++] = rgb >> 8 & 0xff;
        buf[p++] = rgb & 0xff;
      }
    }

    p = GifWriterOutputLZWCodeStream(buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);
    return p;
  };

  this.end = function () {
    if (ended === false) {
      buf[p++] = 0x3b; // Trailer.

      ended = true;
    }

    return p;
  };

  this.getOutputBuffer = function () {
    return buf;
  };

  this.setOutputBuffer = function (v) {
    buf = v;
  };

  this.getOutputBufferPosition = function () {
    return p;
  };

  this.setOutputBufferPosition = function (v) {
    p = v;
  };
} // Main compression routine, palette indexes -> LZW code stream.
// |index_stream| must have at least one entry.


function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
  buf[p++] = min_code_size;
  var cur_subblock = p++; // Pointing at the length field.

  var clear_code = 1 << min_code_size;
  var code_mask = clear_code - 1;
  var eoi_code = clear_code + 1;
  var next_code = eoi_code + 1;
  var cur_code_size = min_code_size + 1; // Number of bits per code.

  var cur_shift = 0; // We have at most 12-bit codes, so we should have to hold a max of 19
  // bits here (and then we would write out).

  var cur = 0;

  function emit_bytes_to_buffer(bit_block_size) {
    while (cur_shift >= bit_block_size) {
      buf[p++] = cur & 0xff;
      cur >>= 8;
      cur_shift -= 8;

      if (p === cur_subblock + 256) {
        // Finished a subblock.
        buf[cur_subblock] = 255;
        cur_subblock = p++;
      }
    }
  }

  function emit_code(c) {
    cur |= c << cur_shift;
    cur_shift += cur_code_size;
    emit_bytes_to_buffer(8);
  } // I am not an expert on the topic, and I don't want to write a thesis.
  // However, it is good to outline here the basic algorithm and the few data
  // structures and optimizations here that make this implementation fast.
  // The basic idea behind LZW is to build a table of previously seen runs
  // addressed by a short id (herein called output code).  All data is
  // referenced by a code, which represents one or more values from the
  // original input stream.  All input bytes can be referenced as the same
  // value as an output code.  So if you didn't want any compression, you
  // could more or less just output the original bytes as codes (there are
  // some details to this, but it is the idea).  In order to achieve
  // compression, values greater then the input range (codes can be up to
  // 12-bit while input only 8-bit) represent a sequence of previously seen
  // inputs.  The decompressor is able to build the same mapping while
  // decoding, so there is always a shared common knowledge between the
  // encoding and decoder, which is also important for "timing" aspects like
  // how to handle variable bit width code encoding.
  //
  // One obvious but very important consequence of the table system is there
  // is always a unique id (at most 12-bits) to map the runs.  'A' might be
  // 4, then 'AA' might be 10, 'AAA' 11, 'AAAA' 12, etc.  This relationship
  // can be used for an effecient lookup strategy for the code mapping.  We
  // need to know if a run has been seen before, and be able to map that run
  // to the output code.  Since we start with known unique ids (input bytes),
  // and then from those build more unique ids (table entries), we can
  // continue this chain (almost like a linked list) to always have small
  // integer values that represent the current byte chains in the encoder.
  // This means instead of tracking the input bytes (AAAABCD) to know our
  // current state, we can track the table entry for AAAABC (it is guaranteed
  // to exist by the nature of the algorithm) and the next character D.
  // Therefor the tuple of (table_entry, byte) is guaranteed to also be
  // unique.  This allows us to create a simple lookup key for mapping input
  // sequences to codes (table indices) without having to store or search
  // any of the code sequences.  So if 'AAAA' has a table entry of 12, the
  // tuple of ('AAAA', K) for any input byte K will be unique, and can be our
  // key.  This leads to a integer value at most 20-bits, which can always
  // fit in an SMI value and be used as a fast sparse array / object key.
  // Output code for the current contents of the index buffer.


  var ib_code = index_stream[0] & code_mask; // Load first input index.

  var code_table = {}; // Key'd on our 20-bit "tuple".

  emit_code(clear_code); // Spec says first code should be a clear code.
  // First index already loaded, process the rest of the stream.

  for (var i = 1, il = index_stream.length; i < il; ++i) {
    var k = index_stream[i] & code_mask;
    var cur_key = ib_code << 8 | k; // (prev, k) unique tuple.

    var cur_code = code_table[cur_key]; // buffer + k.
    // Check if we have to create a new code table entry.

    if (cur_code === undefined) {
      // We don't have buffer + k.
      // Emit index buffer (without k).
      // This is an inline version of emit_code, because this is the core
      // writing routine of the compressor (and V8 cannot inline emit_code
      // because it is a closure here in a different context).  Additionally
      // we can call emit_byte_to_buffer less often, because we can have
      // 30-bits (from our 31-bit signed SMI), and we know our codes will only
      // be 12-bits, so can safely have 18-bits there without overflow.
      // emit_code(ib_code);
      cur |= ib_code << cur_shift;
      cur_shift += cur_code_size;

      while (cur_shift >= 8) {
        buf[p++] = cur & 0xff;
        cur >>= 8;
        cur_shift -= 8;

        if (p === cur_subblock + 256) {
          // Finished a subblock.
          buf[cur_subblock] = 255;
          cur_subblock = p++;
        }
      }

      if (next_code === 4096) {
        // Table full, need a clear.
        emit_code(clear_code);
        next_code = eoi_code + 1;
        cur_code_size = min_code_size + 1;
        code_table = {};
      } else {
        // Table not full, insert a new entry.
        // Increase our variable bit code sizes if necessary.  This is a bit
        // tricky as it is based on "timing" between the encoding and
        // decoder.  From the encoders perspective this should happen after
        // we've already emitted the index buffer and are about to create the
        // first table entry that would overflow our current code bit size.
        if (next_code >= 1 << cur_code_size) ++cur_code_size;
        code_table[cur_key] = next_code++; // Insert into code table.
      }

      ib_code = k; // Index buffer to single input k.
    } else {
      ib_code = cur_code; // Index buffer to sequence in code table.
    }
  }

  emit_code(ib_code); // There will still be something in the index buffer.

  emit_code(eoi_code); // End Of Information.
  // Flush / finalize the sub-blocks stream to the buffer.

  emit_bytes_to_buffer(1); // Finish the sub-blocks, writing out any unfinished lengths and
  // terminating with a sub-block of length 0.  If we have already started
  // but not yet used a sub-block it can just become the terminator.

  if (cur_subblock + 1 === p) {
    // Started but unused.
    buf[cur_subblock] = 0;
  } else {
    // Started and used, write length and additional terminator block.
    buf[cur_subblock] = p - cur_subblock - 1;
    buf[p++] = 0;
  }

  return p;
}

function GifReader(buf) {
  var p = 0; // - Header (GIF87a or GIF89a).

  if (buf[p++] !== 0x47 || buf[p++] !== 0x49 || buf[p++] !== 0x46 || buf[p++] !== 0x38 || (buf[p++] + 1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {
    throw new Error("Invalid GIF 87a/89a header.");
  } // - Logical Screen Descriptor.


  var width = buf[p++] | buf[p++] << 8;
  var height = buf[p++] | buf[p++] << 8;
  var pf0 = buf[p++]; // <Packed Fields>.

  var global_palette_flag = pf0 >> 7;
  var num_global_colors_pow2 = pf0 & 0x7;
  var num_global_colors = 1 << num_global_colors_pow2 + 1;
  var background = buf[p++];
  buf[p++]; // Pixel aspect ratio (unused?).

  var global_palette_offset = null;
  var global_palette_size = null;

  if (global_palette_flag) {
    global_palette_offset = p;
    global_palette_size = num_global_colors;
    p += num_global_colors * 3; // Seek past palette.
  }

  var no_eof = true;
  var frames = [];
  var delay = 0;
  var transparent_index = null;
  var disposal = 0; // 0 - No disposal specified.

  var loop_count = null;
  this.width = width;
  this.height = height;

  while (no_eof && p < buf.length) {
    switch (buf[p++]) {
      case 0x21:
        // Graphics Control Extension Block
        switch (buf[p++]) {
          case 0xff:
            // Application specific block
            // Try if it's a Netscape block (with animation loop counter).
            if (buf[p] !== 0x0b || // 21 FF already read, check block size.
            // NETSCAPE2.0
            buf[p + 1] == 0x4e && buf[p + 2] == 0x45 && buf[p + 3] == 0x54 && buf[p + 4] == 0x53 && buf[p + 5] == 0x43 && buf[p + 6] == 0x41 && buf[p + 7] == 0x50 && buf[p + 8] == 0x45 && buf[p + 9] == 0x32 && buf[p + 10] == 0x2e && buf[p + 11] == 0x30 && // Sub-block
            buf[p + 12] == 0x03 && buf[p + 13] == 0x01 && buf[p + 16] == 0) {
              p += 14;
              loop_count = buf[p++] | buf[p++] << 8;
              p++; // Skip terminator.
            } else {
              // We don't know what it is, just try to get past it.
              p += 12;

              while (true) {
                // Seek through subblocks.
                var block_size = buf[p++]; // Bad block size (ex: undefined from an out of bounds read).

                if (!(block_size >= 0)) throw Error("Invalid block size");
                if (block_size === 0) break; // 0 size is terminator

                p += block_size;
              }
            }

            break;

          case 0xf9:
            // Graphics Control Extension
            if (buf[p++] !== 0x4 || buf[p + 4] !== 0) throw new Error("Invalid graphics extension block.");
            var pf1 = buf[p++];
            delay = buf[p++] | buf[p++] << 8;
            transparent_index = buf[p++];
            if ((pf1 & 1) === 0) transparent_index = null;
            disposal = pf1 >> 2 & 0x7;
            p++; // Skip terminator.

            break;

          case 0xfe:
            // Comment Extension.
            while (true) {
              // Seek through subblocks.
              var block_size = buf[p++]; // Bad block size (ex: undefined from an out of bounds read).

              if (!(block_size >= 0)) throw Error("Invalid block size");
              if (block_size === 0) break; // 0 size is terminator
              // console.log(buf.slice(p, p+block_size).toString('ascii'));

              p += block_size;
            }

            break;

          default:
            throw new Error("Unknown graphic control label: 0x" + buf[p - 1].toString(16));
        }

        break;

      case 0x2c:
        // Image Descriptor.
        var x = buf[p++] | buf[p++] << 8;
        var y = buf[p++] | buf[p++] << 8;
        var w = buf[p++] | buf[p++] << 8;
        var h = buf[p++] | buf[p++] << 8;
        var pf2 = buf[p++];
        var local_palette_flag = pf2 >> 7;
        var interlace_flag = pf2 >> 6 & 1;
        var num_local_colors_pow2 = pf2 & 0x7;
        var num_local_colors = 1 << num_local_colors_pow2 + 1;
        var palette_offset = global_palette_offset;
        var palette_size = global_palette_size;
        var has_local_palette = false;

        if (local_palette_flag) {
          var has_local_palette = true;
          palette_offset = p; // Override with local palette.

          palette_size = num_local_colors;
          p += num_local_colors * 3; // Seek past palette.
        }

        var data_offset = p;
        p++; // codesize

        while (true) {
          var block_size = buf[p++]; // Bad block size (ex: undefined from an out of bounds read).

          if (!(block_size >= 0)) throw Error("Invalid block size");
          if (block_size === 0) break; // 0 size is terminator

          p += block_size;
        }

        frames.push({
          x: x,
          y: y,
          width: w,
          height: h,
          has_local_palette: has_local_palette,
          palette_offset: palette_offset,
          palette_size: palette_size,
          data_offset: data_offset,
          data_length: p - data_offset,
          transparent_index: transparent_index,
          interlaced: !!interlace_flag,
          delay: delay,
          disposal: disposal
        });
        break;

      case 0x3b:
        // Trailer Marker (end of file).
        no_eof = false;
        break;

      default:
        throw new Error("Unknown gif block: 0x" + buf[p - 1].toString(16));
        break;
    }
  }

  this.numFrames = function () {
    return frames.length;
  };

  this.loopCount = function () {
    return loop_count;
  };

  this.frameInfo = function (frame_num) {
    if (frame_num < 0 || frame_num >= frames.length) throw new Error("Frame index out of range.");
    return frames[frame_num];
  };

  this.decodeAndBlitFrameBGRA = function (frame_num, pixels) {
    var frame = this.frameInfo(frame_num);
    var num_pixels = frame.width * frame.height;
    var index_stream = new Uint8Array(num_pixels); // At most 8-bit indices.

    GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
    var palette_offset = frame.palette_offset; // NOTE(deanm): It seems to be much faster to compare index to 256 than
    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
    // the profile, not sure if it's related to using a Uint8Array.

    var trans = frame.transparent_index;
    if (trans === null) trans = 256; // We are possibly just blitting to a portion of the entire frame.
    // That is a subrect within the framerect, so the additional pixels
    // must be skipped over after we finished a scanline.

    var framewidth = frame.width;
    var framestride = width - framewidth;
    var xleft = framewidth; // Number of subrect pixels left in scanline.
    // Output indicies of the top left and bottom right corners of the subrect.

    var opbeg = (frame.y * width + frame.x) * 4;
    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
    var op = opbeg;
    var scanstride = framestride * 4; // Use scanstride to skip past the rows when interlacing.  This is skipping
    // 7 rows for the first two passes, then 3 then 1.

    if (frame.interlaced === true) {
      scanstride += width * 4 * 7; // Pass 1.
    }

    var interlaceskip = 8; // Tracking the row interval in the current pass.

    for (var i = 0, il = index_stream.length; i < il; ++i) {
      var index = index_stream[i];

      if (xleft === 0) {
        // Beginning of new scan line
        op += scanstride;
        xleft = framewidth;

        if (op >= opend) {
          // Catch the wrap to switch passes when interlacing.
          scanstride = framestride * 4 + width * 4 * (interlaceskip - 1); // interlaceskip / 2 * 4 is interlaceskip << 1.

          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
          interlaceskip >>= 1;
        }
      }

      if (index === trans) {
        op += 4;
      } else {
        var r = buf[palette_offset + index * 3];
        var g = buf[palette_offset + index * 3 + 1];
        var b = buf[palette_offset + index * 3 + 2];
        pixels[op++] = b;
        pixels[op++] = g;
        pixels[op++] = r;
        pixels[op++] = 255;
      }

      --xleft;
    }
  }; // I will go to copy and paste hell one day...


  this.decodeAndBlitFrameRGBA = function (frame_num, pixels) {
    var frame = this.frameInfo(frame_num);
    var num_pixels = frame.width * frame.height;
    var index_stream = new Uint8Array(num_pixels); // At most 8-bit indices.

    GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
    var palette_offset = frame.palette_offset; // NOTE(deanm): It seems to be much faster to compare index to 256 than
    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
    // the profile, not sure if it's related to using a Uint8Array.

    var trans = frame.transparent_index;
    if (trans === null) trans = 256; // We are possibly just blitting to a portion of the entire frame.
    // That is a subrect within the framerect, so the additional pixels
    // must be skipped over after we finished a scanline.

    var framewidth = frame.width;
    var framestride = width - framewidth;
    var xleft = framewidth; // Number of subrect pixels left in scanline.
    // Output indicies of the top left and bottom right corners of the subrect.

    var opbeg = (frame.y * width + frame.x) * 4;
    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
    var op = opbeg;
    var scanstride = framestride * 4; // Use scanstride to skip past the rows when interlacing.  This is skipping
    // 7 rows for the first two passes, then 3 then 1.

    if (frame.interlaced === true) {
      scanstride += width * 4 * 7; // Pass 1.
    }

    var interlaceskip = 8; // Tracking the row interval in the current pass.

    for (var i = 0, il = index_stream.length; i < il; ++i) {
      var index = index_stream[i];

      if (xleft === 0) {
        // Beginning of new scan line
        op += scanstride;
        xleft = framewidth;

        if (op >= opend) {
          // Catch the wrap to switch passes when interlacing.
          scanstride = framestride * 4 + width * 4 * (interlaceskip - 1); // interlaceskip / 2 * 4 is interlaceskip << 1.

          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
          interlaceskip >>= 1;
        }
      }

      if (index === trans) {
        op += 4;
      } else {
        var r = buf[palette_offset + index * 3];
        var g = buf[palette_offset + index * 3 + 1];
        var b = buf[palette_offset + index * 3 + 2];
        pixels[op++] = r;
        pixels[op++] = g;
        pixels[op++] = b;
        pixels[op++] = 255;
      }

      --xleft;
    }
  };
}

function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
  var min_code_size = code_stream[p++];
  var clear_code = 1 << min_code_size;
  var eoi_code = clear_code + 1;
  var next_code = eoi_code + 1;
  var cur_code_size = min_code_size + 1; // Number of bits per code.
  // NOTE: This shares the same name as the encoder, but has a different
  // meaning here.  Here this masks each code coming from the code stream.

  var code_mask = (1 << cur_code_size) - 1;
  var cur_shift = 0;
  var cur = 0;
  var op = 0; // Output pointer.

  var subblock_size = code_stream[p++]; // TODO(deanm): Would using a TypedArray be any faster?  At least it would
  // solve the fast mode / backing store uncertainty.
  // var code_table = Array(4096);

  var code_table = new Int32Array(4096); // Can be signed, we only use 20 bits.

  var prev_code = null; // Track code-1.

  while (true) {
    // Read up to two bytes, making sure we always 12-bits for max sized code.
    while (cur_shift < 16) {
      if (subblock_size === 0) break; // No more data to be read.

      cur |= code_stream[p++] << cur_shift;
      cur_shift += 8;

      if (subblock_size === 1) {
        // Never let it get to 0 to hold logic above.
        subblock_size = code_stream[p++]; // Next subblock.
      } else {
        --subblock_size;
      }
    } // TODO(deanm): We should never really get here, we should have received
    // and EOI.


    if (cur_shift < cur_code_size) break;
    var code = cur & code_mask;
    cur >>= cur_code_size;
    cur_shift -= cur_code_size; // TODO(deanm): Maybe should check that the first code was a clear code,
    // at least this is what you're supposed to do.  But actually our encoder
    // now doesn't emit a clear code first anyway.

    if (code === clear_code) {
      // We don't actually have to clear the table.  This could be a good idea
      // for greater error checking, but we don't really do any anyway.  We
      // will just track it with next_code and overwrite old entries.
      next_code = eoi_code + 1;
      cur_code_size = min_code_size + 1;
      code_mask = (1 << cur_code_size) - 1; // Don't update prev_code ?

      prev_code = null;
      continue;
    } else if (code === eoi_code) {
      break;
    } // We have a similar situation as the decoder, where we want to store
    // variable length entries (code table entries), but we want to do in a
    // faster manner than an array of arrays.  The code below stores sort of a
    // linked list within the code table, and then "chases" through it to
    // construct the dictionary entries.  When a new entry is created, just the
    // last byte is stored, and the rest (prefix) of the entry is only
    // referenced by its table entry.  Then the code chases through the
    // prefixes until it reaches a single byte code.  We have to chase twice,
    // first to compute the length, and then to actually copy the data to the
    // output (backwards, since we know the length).  The alternative would be
    // storing something in an intermediate stack, but that doesn't make any
    // more sense.  I implemented an approach where it also stored the length
    // in the code table, although it's a bit tricky because you run out of
    // bits (12 + 12 + 8), but I didn't measure much improvements (the table
    // entries are generally not the long).  Even when I created benchmarks for
    // very long table entries the complexity did not seem worth it.
    // The code table stores the prefix entry in 12 bits and then the suffix
    // byte in 8 bits, so each entry is 20 bits.


    var chase_code = code < next_code ? code : prev_code; // Chase what we will output, either {CODE} or {CODE-1}.

    var chase_length = 0;
    var chase = chase_code;

    while (chase > clear_code) {
      chase = code_table[chase] >> 8;
      ++chase_length;
    }

    var k = chase;
    var op_end = op + chase_length + (chase_code !== code ? 1 : 0);

    if (op_end > output_length) {
      console.log("Warning, gif stream longer than expected.");
      return;
    } // Already have the first byte from the chase, might as well write it fast.


    output[op++] = k;
    op += chase_length;
    var b = op; // Track pointer, writing backwards.

    if (chase_code !== code) // The case of emitting {CODE-1} + k.
      output[op++] = k;
    chase = chase_code;

    while (chase_length--) {
      chase = code_table[chase];
      output[--b] = chase & 0xff; // Write backwards.

      chase >>= 8; // Pull down to the prefix code.
    }

    if (prev_code !== null && next_code < 4096) {
      code_table[next_code++] = prev_code << 8 | k; // TODO(deanm): Figure out this clearing vs code growth logic better.  I
      // have an feeling that it should just happen somewhere else, for now it
      // is awkward between when we grow past the max and then hit a clear code.
      // For now just check if we hit the max 12-bits (then a clear code should
      // follow, also of course encoded in 12-bits).

      if (next_code >= code_mask + 1 && cur_code_size < 12) {
        ++cur_code_size;
        code_mask = code_mask << 1 | 1;
      }
    }

    prev_code = code;
  }

  if (op !== output_length) {
    console.log("Warning, gif stream shorter than expected.");
  }

  return output;
} // CommonJS.


try {
  exports.GifWriter = GifWriter;
  exports.GifReader = GifReader;
} catch (e) {}

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ndarray = __webpack_require__(29);

var do_convert = __webpack_require__(167);

module.exports = function convert(arr, result) {
  var shape = [],
      c = arr,
      sz = 1;

  while (Array.isArray(c)) {
    shape.push(c.length);
    sz *= c.length;
    c = c[0];
  }

  if (shape.length === 0) {
    return ndarray();
  }

  if (!result) {
    result = ndarray(new Float64Array(sz), shape);
  }

  do_convert(result, arr);
  return result;
};

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(168)({
  "args": ["array", "scalar", "index"],
  "pre": {
    "body": "{}",
    "args": [],
    "thisVars": [],
    "localVars": []
  },
  "body": {
    "body": "{\nvar _inline_1_v=_inline_1_arg1_,_inline_1_i\nfor(_inline_1_i=0;_inline_1_i<_inline_1_arg2_.length-1;++_inline_1_i) {\n_inline_1_v=_inline_1_v[_inline_1_arg2_[_inline_1_i]]\n}\n_inline_1_arg0_=_inline_1_v[_inline_1_arg2_[_inline_1_arg2_.length-1]]\n}",
    "args": [{
      "name": "_inline_1_arg0_",
      "lvalue": true,
      "rvalue": false,
      "count": 1
    }, {
      "name": "_inline_1_arg1_",
      "lvalue": false,
      "rvalue": true,
      "count": 1
    }, {
      "name": "_inline_1_arg2_",
      "lvalue": false,
      "rvalue": true,
      "count": 4
    }],
    "thisVars": [],
    "localVars": ["_inline_1_i", "_inline_1_v"]
  },
  "post": {
    "body": "{}",
    "args": [],
    "thisVars": [],
    "localVars": []
  },
  "funcName": "convert",
  "blockSize": 64
});

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createThunk = __webpack_require__(169);

function Procedure() {
  this.argTypes = [];
  this.shimArgs = [];
  this.arrayArgs = [];
  this.arrayBlockIndices = [];
  this.scalarArgs = [];
  this.offsetArgs = [];
  this.offsetArgIndex = [];
  this.indexArgs = [];
  this.shapeArgs = [];
  this.funcName = "";
  this.pre = null;
  this.body = null;
  this.post = null;
  this.debug = false;
}

function compileCwise(user_args) {
  //Create procedure
  var proc = new Procedure(); //Parse blocks

  proc.pre = user_args.pre;
  proc.body = user_args.body;
  proc.post = user_args.post; //Parse arguments

  var proc_args = user_args.args.slice(0);
  proc.argTypes = proc_args;

  for (var i = 0; i < proc_args.length; ++i) {
    var arg_type = proc_args[i];

    if (arg_type === "array" || typeof arg_type === "object" && arg_type.blockIndices) {
      proc.argTypes[i] = "array";
      proc.arrayArgs.push(i);
      proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0);
      proc.shimArgs.push("array" + i);

      if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
        throw new Error("cwise: pre() block may not reference array args");
      }

      if (i < proc.post.args.length && proc.post.args[i].count > 0) {
        throw new Error("cwise: post() block may not reference array args");
      }
    } else if (arg_type === "scalar") {
      proc.scalarArgs.push(i);
      proc.shimArgs.push("scalar" + i);
    } else if (arg_type === "index") {
      proc.indexArgs.push(i);

      if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
        throw new Error("cwise: pre() block may not reference array index");
      }

      if (i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array index");
      }

      if (i < proc.post.args.length && proc.post.args[i].count > 0) {
        throw new Error("cwise: post() block may not reference array index");
      }
    } else if (arg_type === "shape") {
      proc.shapeArgs.push(i);

      if (i < proc.pre.args.length && proc.pre.args[i].lvalue) {
        throw new Error("cwise: pre() block may not write to array shape");
      }

      if (i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array shape");
      }

      if (i < proc.post.args.length && proc.post.args[i].lvalue) {
        throw new Error("cwise: post() block may not write to array shape");
      }
    } else if (typeof arg_type === "object" && arg_type.offset) {
      proc.argTypes[i] = "offset";
      proc.offsetArgs.push({
        array: arg_type.array,
        offset: arg_type.offset
      });
      proc.offsetArgIndex.push(i);
    } else {
      throw new Error("cwise: Unknown argument type " + proc_args[i]);
    }
  } //Make sure at least one array argument was specified


  if (proc.arrayArgs.length <= 0) {
    throw new Error("cwise: No array arguments specified");
  } //Make sure arguments are correct


  if (proc.pre.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in pre() block");
  }

  if (proc.body.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in body() block");
  }

  if (proc.post.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in post() block");
  } //Check debug flag


  proc.debug = !!user_args.printCode || !!user_args.debug; //Retrieve name

  proc.funcName = user_args.funcName || "cwise"; //Read in block size

  proc.blockSize = user_args.blockSize || 64;
  return createThunk(proc);
}

module.exports = compileCwise;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // The function below is called when constructing a cwise function object, and does the following:
// A function object is constructed which accepts as argument a compilation function and returns another function.
// It is this other function that is eventually returned by createThunk, and this function is the one that actually
// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.
// The compilation passed to the first function object is used for compiling new functions.
// Once this function object is created, it is called with compile as argument, where the first argument of compile
// is bound to "proc" (essentially containing a preprocessed version of the user arguments to cwise).
// So createThunk roughly works like this:
// function createThunk(proc) {
//   var thunk = function(compileBound) {
//     var CACHED = {}
//     return function(arrays and scalars) {
//       if (dtype and order of arrays in CACHED) {
//         var func = CACHED[dtype and order of arrays]
//       } else {
//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)
//       }
//       return func(arrays and scalars)
//     }
//   }
//   return thunk(compile.bind1(proc))
// }

var compile = __webpack_require__(170);

function createThunk(proc) {
  var code = ["'use strict'", "var CACHED={}"];
  var vars = [];
  var thunkName = proc.funcName + "_cwise_thunk"; //Build thunk

  code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""));
  var typesig = [];
  var string_typesig = [];
  var proc_args = [["array", proc.arrayArgs[0], ".shape.slice(", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).
  Math.max(0, proc.arrayBlockIndices[0]), proc.arrayBlockIndices[0] < 0 ? "," + proc.arrayBlockIndices[0] + ")" : ")"].join("")];
  var shapeLengthConditions = [],
      shapeConditions = []; // Process array arguments

  for (var i = 0; i < proc.arrayArgs.length; ++i) {
    var j = proc.arrayArgs[i];
    vars.push(["t", j, "=array", j, ".dtype,", "r", j, "=array", j, ".order"].join(""));
    typesig.push("t" + j);
    typesig.push("r" + j);
    string_typesig.push("t" + j);
    string_typesig.push("r" + j + ".join()");
    proc_args.push("array" + j + ".data");
    proc_args.push("array" + j + ".stride");
    proc_args.push("array" + j + ".offset|0");

    if (i > 0) {
      // Gather conditions to check for shape equality (ignoring block indices)
      shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0]) - Math.abs(proc.arrayBlockIndices[i])));
      shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[i]) + "]");
    }
  } // Check for shape equality


  if (proc.arrayArgs.length > 1) {
    code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')");
    code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {");
    code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')");
    code.push("}");
  } // Process scalar arguments


  for (var i = 0; i < proc.scalarArgs.length; ++i) {
    proc_args.push("scalar" + proc.scalarArgs[i]);
  } // Check for cached function (and if not present, generate it)


  vars.push(["type=[", string_typesig.join(","), "].join()"].join(""));
  vars.push("proc=CACHED[type]");
  code.push("var " + vars.join(","));
  code.push(["if(!proc){", "CACHED[type]=proc=compile([", typesig.join(","), "])}", "return proc(", proc_args.join(","), ")}"].join(""));

  if (proc.debug) {
    console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------");
  } //Compile thunk


  var thunk = new Function("compile", code.join("\n"));
  return thunk(compile.bind(undefined, proc));
}

module.exports = createThunk;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var uniq = __webpack_require__(171); // This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)
// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of "pointers" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.


function innerFill(order, proc, body) {
  var dimension = order.length,
      nargs = proc.arrayArgs.length,
      has_index = proc.indexArgs.length > 0,
      code = [],
      vars = [],
      idx = 0,
      pidx = 0,
      i,
      j;

  for (i = 0; i < dimension; ++i) {
    // Iteration variables
    vars.push(["i", i, "=0"].join(""));
  } //Compute scan deltas


  for (j = 0; j < nargs; ++j) {
    for (i = 0; i < dimension; ++i) {
      pidx = idx;
      idx = order[i];

      if (i === 0) {
        // The innermost/fastest dimension's delta is simply its stride
        vars.push(["d", j, "s", i, "=t", j, "p", idx].join(""));
      } else {
        // For other dimensions the delta is basically the stride minus something which essentially "rewinds" the previous (more inner) dimension
        vars.push(["d", j, "s", i, "=(t", j, "p", idx, "-s", pidx, "*t", j, "p", pidx, ")"].join(""));
      }
    }
  }

  if (vars.length > 0) {
    code.push("var " + vars.join(","));
  } //Scan loop


  for (i = dimension - 1; i >= 0; --i) {
    // Start at largest stride and work your way inwards
    idx = order[i];
    code.push(["for(i", i, "=0;i", i, "<s", idx, ";++i", i, "){"].join(""));
  } //Push body of inner loop


  code.push(body); //Advance scan pointers

  for (i = 0; i < dimension; ++i) {
    pidx = idx;
    idx = order[i];

    for (j = 0; j < nargs; ++j) {
      code.push(["p", j, "+=d", j, "s", i].join(""));
    }

    if (has_index) {
      if (i > 0) {
        code.push(["index[", pidx, "]-=s", pidx].join(""));
      }

      code.push(["++index[", idx, "]"].join(""));
    }

    code.push("}");
  }

  return code.join("\n");
} // Generate "outer" loops that loop over blocks of data, applying "inner" loops to the blocks by manipulating the local variables in such a way that the inner loop only "sees" the current block.
// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.
//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and "shape" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.


function outerFill(matched, order, proc, body) {
  var dimension = order.length,
      nargs = proc.arrayArgs.length,
      blockSize = proc.blockSize,
      has_index = proc.indexArgs.length > 0,
      code = [];

  for (var i = 0; i < nargs; ++i) {
    code.push(["var offset", i, "=p", i].join(""));
  } //Generate loops for unmatched dimensions
  // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)
  // TODO: It would be nice if the order in which these loops are placed would also be somehow "optimal" (at the very least we should check that it really doesn't hurt us if they're not).


  for (var i = matched; i < dimension; ++i) {
    code.push(["for(var j" + i + "=SS[", order[i], "]|0;j", i, ">0;){"].join("")); // Iterate back to front

    code.push(["if(j", i, "<", blockSize, "){"].join("")); // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).

    code.push(["s", order[i], "=j", i].join(""));
    code.push(["j", i, "=0"].join(""));
    code.push(["}else{s", order[i], "=", blockSize].join(""));
    code.push(["j", i, "-=", blockSize, "}"].join(""));

    if (has_index) {
      code.push(["index[", order[i], "]=j", i].join(""));
    }
  }

  for (var i = 0; i < nargs; ++i) {
    var indexStr = ["offset" + i];

    for (var j = matched; j < dimension; ++j) {
      indexStr.push(["j", j, "*t", i, "p", order[j]].join(""));
    }

    code.push(["p", i, "=(", indexStr.join("+"), ")"].join(""));
  }

  code.push(innerFill(order, proc, body));

  for (var i = matched; i < dimension; ++i) {
    code.push("}");
  }

  return code.join("\n");
} //Count the number of compatible inner orders
// This is the length of the longest common prefix of the arrays in orders.
// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.
// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.


function countMatches(orders) {
  var matched = 0,
      dimension = orders[0].length;

  while (matched < dimension) {
    for (var j = 1; j < orders.length; ++j) {
      if (orders[j][matched] !== orders[0][matched]) {
        return matched;
      }
    }

    ++matched;
  }

  return matched;
} //Processes a block according to the given data types
// Replaces variable names by different ones, either "local" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.


function processBlock(block, proc, dtypes) {
  var code = block.body;
  var pre = [];
  var post = [];

  for (var i = 0; i < block.args.length; ++i) {
    var carg = block.args[i];

    if (carg.count <= 0) {
      continue;
    }

    var re = new RegExp(carg.name, "g");
    var ptrStr = "";
    var arrNum = proc.arrayArgs.indexOf(i);

    switch (proc.argTypes[i]) {
      case "offset":
        var offArgIndex = proc.offsetArgIndex.indexOf(i);
        var offArg = proc.offsetArgs[offArgIndex];
        arrNum = offArg.array;
        ptrStr = "+q" + offArgIndex;
      // Adds offset to the "pointer" in the array

      case "array":
        ptrStr = "p" + arrNum + ptrStr;
        var localStr = "l" + i;
        var arrStr = "a" + arrNum;

        if (proc.arrayBlockIndices[arrNum] === 0) {
          // Argument to body is just a single value from this array
          if (carg.count === 1) {
            // Argument/array used only once(?)
            if (dtypes[arrNum] === "generic") {
              if (carg.lvalue) {
                pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")); // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)

                code = code.replace(re, localStr);
                post.push([arrStr, ".set(", ptrStr, ",", localStr, ")"].join(""));
              } else {
                code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""));
              }
            } else {
              code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""));
            }
          } else if (dtypes[arrNum] === "generic") {
            pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")); // TODO: Could we optimize by checking for carg.rvalue?

            code = code.replace(re, localStr);

            if (carg.lvalue) {
              post.push([arrStr, ".set(", ptrStr, ",", localStr, ")"].join(""));
            }
          } else {
            pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join("")); // TODO: Could we optimize by checking for carg.rvalue?

            code = code.replace(re, localStr);

            if (carg.lvalue) {
              post.push([arrStr, "[", ptrStr, "]=", localStr].join(""));
            }
          }
        } else {
          // Argument to body is a "block"
          var reStrArr = [carg.name],
              ptrStrArr = [ptrStr];

          for (var j = 0; j < Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
            reStrArr.push("\\s*\\[([^\\]]+)\\]");
            ptrStrArr.push("$" + (j + 1) + "*t" + arrNum + "b" + j); // Matched index times stride
          }

          re = new RegExp(reStrArr.join(""), "g");
          ptrStr = ptrStrArr.join("+");

          if (dtypes[arrNum] === "generic") {
            /*if(carg.lvalue) {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
              code = code.replace(re, localStr)
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            } else {
              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
            }*/
            throw new Error("cwise: Generic arrays not supported in combination with blocks!");
          } else {
            // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.
            code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""));
          }
        }

        break;

      case "scalar":
        code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i));
        break;

      case "index":
        code = code.replace(re, "index");
        break;

      case "shape":
        code = code.replace(re, "shape");
        break;
    }
  }

  return [pre.join("\n"), code, post.join("\n")].join("\n").trim();
}

function typeSummary(dtypes) {
  var summary = new Array(dtypes.length);
  var allEqual = true;

  for (var i = 0; i < dtypes.length; ++i) {
    var t = dtypes[i];
    var digits = t.match(/\d+/);

    if (!digits) {
      digits = "";
    } else {
      digits = digits[0];
    }

    if (t.charAt(0) === 0) {
      summary[i] = "u" + t.charAt(1) + digits;
    } else {
      summary[i] = t.charAt(0) + digits;
    }

    if (i > 0) {
      allEqual = allEqual && summary[i] === summary[i - 1];
    }
  }

  if (allEqual) {
    return summary[0];
  }

  return summary.join("");
} //Generates a cwise operator


function generateCWiseOp(proc, typesig) {
  //Compute dimension
  // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.
  var dimension = typesig[1].length - Math.abs(proc.arrayBlockIndices[0]) | 0;
  var orders = new Array(proc.arrayArgs.length);
  var dtypes = new Array(proc.arrayArgs.length);

  for (var i = 0; i < proc.arrayArgs.length; ++i) {
    dtypes[i] = typesig[2 * i];
    orders[i] = typesig[2 * i + 1];
  } //Determine where block and loop indices start and end


  var blockBegin = [],
      blockEnd = []; // These indices are exposed as blocks

  var loopBegin = [],
      loopEnd = []; // These indices are iterated over

  var loopOrders = []; // orders restricted to the loop indices

  for (var i = 0; i < proc.arrayArgs.length; ++i) {
    if (proc.arrayBlockIndices[i] < 0) {
      loopBegin.push(0);
      loopEnd.push(dimension);
      blockBegin.push(dimension);
      blockEnd.push(dimension + proc.arrayBlockIndices[i]);
    } else {
      loopBegin.push(proc.arrayBlockIndices[i]); // Non-negative

      loopEnd.push(proc.arrayBlockIndices[i] + dimension);
      blockBegin.push(0);
      blockEnd.push(proc.arrayBlockIndices[i]);
    }

    var newOrder = [];

    for (var j = 0; j < orders[i].length; j++) {
      if (loopBegin[i] <= orders[i][j] && orders[i][j] < loopEnd[i]) {
        newOrder.push(orders[i][j] - loopBegin[i]); // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.
      }
    }

    loopOrders.push(newOrder);
  } //First create arguments for procedure


  var arglist = ["SS"]; // SS is the overall shape over which we iterate

  var code = ["'use strict'"];
  var vars = [];

  for (var j = 0; j < dimension; ++j) {
    vars.push(["s", j, "=SS[", j, "]"].join("")); // The limits for each dimension.
  }

  for (var i = 0; i < proc.arrayArgs.length; ++i) {
    arglist.push("a" + i); // Actual data array

    arglist.push("t" + i); // Strides

    arglist.push("p" + i); // Offset in the array at which the data starts (also used for iterating over the data)

    for (var j = 0; j < dimension; ++j) {
      // Unpack the strides into vars for looping
      vars.push(["t", i, "p", j, "=t", i, "[", loopBegin[i] + j, "]"].join(""));
    }

    for (var j = 0; j < Math.abs(proc.arrayBlockIndices[i]); ++j) {
      // Unpack the strides into vars for block iteration
      vars.push(["t", i, "b", j, "=t", i, "[", blockBegin[i] + j, "]"].join(""));
    }
  }

  for (var i = 0; i < proc.scalarArgs.length; ++i) {
    arglist.push("Y" + i);
  }

  if (proc.shapeArgs.length > 0) {
    vars.push("shape=SS.slice(0)"); // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)
  }

  if (proc.indexArgs.length > 0) {
    // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.
    var zeros = new Array(dimension);

    for (var i = 0; i < dimension; ++i) {
      zeros[i] = "0";
    }

    vars.push(["index=[", zeros.join(","), "]"].join(""));
  }

  for (var i = 0; i < proc.offsetArgs.length; ++i) {
    // Offset arguments used for stencil operations
    var off_arg = proc.offsetArgs[i];
    var init_string = [];

    for (var j = 0; j < off_arg.offset.length; ++j) {
      if (off_arg.offset[j] === 0) {
        continue;
      } else if (off_arg.offset[j] === 1) {
        init_string.push(["t", off_arg.array, "p", j].join(""));
      } else {
        init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""));
      }
    }

    if (init_string.length === 0) {
      vars.push("q" + i + "=0");
    } else {
      vars.push(["q", i, "=", init_string.join("+")].join(""));
    }
  } //Prepare this variables


  var thisVars = uniq([].concat(proc.pre.thisVars).concat(proc.body.thisVars).concat(proc.post.thisVars));
  vars = vars.concat(thisVars);

  if (vars.length > 0) {
    code.push("var " + vars.join(","));
  }

  for (var i = 0; i < proc.arrayArgs.length; ++i) {
    code.push("p" + i + "|=0");
  } //Inline prelude


  if (proc.pre.body.length > 3) {
    code.push(processBlock(proc.pre, proc, dtypes));
  } //Process body


  var body = processBlock(proc.body, proc, dtypes);
  var matched = countMatches(loopOrders);

  if (matched < dimension) {
    code.push(outerFill(matched, loopOrders[0], proc, body)); // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.
  } else {
    code.push(innerFill(loopOrders[0], proc, body));
  } //Inline epilog


  if (proc.post.body.length > 3) {
    code.push(processBlock(proc.post, proc, dtypes));
  }

  if (proc.debug) {
    console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------");
  }

  var loopName = [proc.funcName || "unnamed", "_cwise_loop_", orders[0].join("s"), "m", matched, typeSummary(dtypes)].join("");
  var f = new Function(["function ", loopName, "(", arglist.join(","), "){", code.join("\n"), "} return ", loopName].join(""));
  return f();
}

module.exports = generateCWiseOp;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function unique_pred(list, compare) {
  var ptr = 1,
      len = list.length,
      a = list[0],
      b = list[0];

  for (var i = 1; i < len; ++i) {
    b = a;
    a = list[i];

    if (compare(a, b)) {
      if (i === ptr) {
        ptr++;
        continue;
      }

      list[ptr++] = a;
    }
  }

  list.length = ptr;
  return list;
}

function unique_eq(list) {
  var ptr = 1,
      len = list.length,
      a = list[0],
      b = list[0];

  for (var i = 1; i < len; ++i, b = a) {
    b = a;
    a = list[i];

    if (a !== b) {
      if (i === ptr) {
        ptr++;
        continue;
      }

      list[ptr++] = a;
    }
  }

  list.length = ptr;
  return list;
}

function unique(list, compare, sorted) {
  if (list.length === 0) {
    return list;
  }

  if (compare) {
    if (!sorted) {
      list.sort(compare);
    }

    return unique_pred(list, compare);
  }

  if (!sorted) {
    list.sort();
  }

  return unique_eq(list);
}

module.exports = unique;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var Stream = __webpack_require__(173); // through
//
// a stream that does nothing but re-emit the input.
// useful for aggregating a series of changing but not ending streams into one stream)


exports = module.exports = through;
through.through = through; //create a readable writable stream.

function through(write, end, opts) {
  write = write || function (data) {
    this.queue(data);
  };

  end = end || function () {
    this.queue(null);
  };

  var ended = false,
      destroyed = false,
      buffer = [],
      _ended = false;
  var stream = new Stream();
  stream.readable = stream.writable = true;
  stream.paused = false; //  stream.autoPause   = !(opts && opts.autoPause   === false)

  stream.autoDestroy = !(opts && opts.autoDestroy === false);

  stream.write = function (data) {
    write.call(this, data);
    return !stream.paused;
  };

  function drain() {
    while (buffer.length && !stream.paused) {
      var data = buffer.shift();
      if (null === data) return stream.emit('end');else stream.emit('data', data);
    }
  }

  stream.queue = stream.push = function (data) {
    //    console.error(ended)
    if (_ended) return stream;
    if (data === null) _ended = true;
    buffer.push(data);
    drain();
    return stream;
  }; //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'


  stream.on('end', function () {
    stream.readable = false;
    if (!stream.writable && stream.autoDestroy) process.nextTick(function () {
      stream.destroy();
    });
  });

  function _end() {
    stream.writable = false;
    end.call(stream);
    if (!stream.readable && stream.autoDestroy) stream.destroy();
  }

  stream.end = function (data) {
    if (ended) return;
    ended = true;
    if (arguments.length) stream.write(data);

    _end(); // will emit or queue


    return stream;
  };

  stream.destroy = function () {
    if (destroyed) return;
    destroyed = true;
    ended = true;
    buffer.length = 0;
    stream.writable = stream.readable = false;
    stream.emit('close');
    return stream;
  };

  stream.pause = function () {
    if (stream.paused) return;
    stream.paused = true;
    return stream;
  };

  stream.resume = function () {
    if (stream.paused) {
      stream.paused = false;
      stream.emit('resume');
    }

    drain(); //may have become paused again,
    //as drain emits 'data'.

    if (!stream.paused) stream.emit('drain');
    return stream;
  };

  return stream;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(14)))

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Stream;

var EE = __webpack_require__(30).EventEmitter;

var inherits = __webpack_require__(18);

inherits(Stream, EE);
Stream.Readable = __webpack_require__(31);
Stream.Writable = __webpack_require__(183);
Stream.Duplex = __webpack_require__(184);
Stream.Transform = __webpack_require__(185);
Stream.PassThrough = __webpack_require__(186); // Backwards-compat with node 0.4.x

Stream.Stream = Stream; // old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function (dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain); // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.

  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;

  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  }

  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === 'function') dest.destroy();
  } // don't leave dangling pipes when there are errors.


  function onerror(er) {
    cleanup();

    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror); // remove all the event listeners that were added.

  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);
    source.removeListener('end', onend);
    source.removeListener('close', onclose);
    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);
    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);
    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);
  dest.on('close', cleanup);
  dest.emit('pipe', source); // Allow for unix-like usage: A.pipe(B).pipe(C)

  return dest;
};

/***/ }),
/* 174 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 175 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Buffer = __webpack_require__(32).Buffer;

var util = __webpack_require__(177);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = {
      data: v,
      next: null
    };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = {
      data: v,
      next: this.head
    };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;

    while (p = p.next) {
      ret += s + p.data;
    }

    return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;

    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }

    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({
      length: this.length
    });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),
/* 177 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(179); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(13)))

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
  "use strict";

  if (global.setImmediate) {
    return;
  }

  var nextHandle = 1; // Spec says greater than zero

  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;

  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    } // Copy function arguments


    var args = new Array(arguments.length - 1);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    } // Store and register the task


    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;

    switch (args.length) {
      case 0:
        callback();
        break;

      case 1:
        callback(args[0]);
        break;

      case 2:
        callback(args[0], args[1]);
        break;

      case 3:
        callback(args[0], args[1], args[2]);
        break;

      default:
        callback.apply(undefined, args);
        break;
    }
  }

  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];

      if (task) {
        currentlyRunningATask = true;

        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function installNextTickImplementation() {
    registerImmediate = function (handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }

  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;

      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };

      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }

  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
    var messagePrefix = "setImmediate$" + Math.random() + "$";

    var onGlobalMessage = function (event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };

    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }

    registerImmediate = function (handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function (handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function (handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function (handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 6–8
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(13), __webpack_require__(14)))

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Module exports.
 */
module.exports = deprecate;
/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate(fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */


function config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }

  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(13)))

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(21);

var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}

if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
}

SafeBuffer.prototype = Object.create(Buffer.prototype); // Copy static methods from Buffer

copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }

  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  var buf = Buffer(size);

  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }

  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return buffer.SlowBuffer(size);
};

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.


module.exports = PassThrough;

var Transform = __webpack_require__(61);
/*<replacement>*/


var util = Object.create(__webpack_require__(22));
util.inherits = __webpack_require__(18);
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(33);

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(15);

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(31).Transform;

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(31).PassThrough;

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/**
 * Module exports.
 */
module.exports = dataUriToBuffer;
/**
 * Returns a `Buffer` instance from the given data URI `uri`.
 *
 * @param {String} uri Data URI to turn into a Buffer instance
 * @return {Buffer} Buffer instance from Data URI
 * @api public
 */

function dataUriToBuffer(uri) {
  if (!/^data\:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  } // strip newlines


  uri = uri.replace(/\r?\n/g, ''); // split the URI up into the "metadata" and the "data" portions

  var firstComma = uri.indexOf(',');
  if (-1 === firstComma || firstComma <= 4) throw new TypeError('malformed data: URI'); // remove the "data:" scheme and parse the metadata

  var meta = uri.substring(5, firstComma).split(';');
  var base64 = false;
  var charset = 'US-ASCII';

  for (var i = 0; i < meta.length; i++) {
    if ('base64' == meta[i]) {
      base64 = true;
    } else if (0 == meta[i].indexOf('charset=')) {
      charset = meta[i].substring(8);
    }
  } // get the encoded data portion and decode URI-encoded chars


  var data = unescape(uri.substring(firstComma + 1));
  var encoding = base64 ? 'base64' : 'ascii';
  var buffer = new Buffer(data, encoding); // set `.type` property to MIME type

  buffer.type = meta[0] || 'text/plain'; // set the `.charset` property

  buffer.charset = charset;
  return buffer;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(21).Buffer))

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function interp1d(arr, x) {
  var ix = Math.floor(x),
      fx = x - ix,
      s0 = 0 <= ix && ix < arr.shape[0],
      s1 = 0 <= ix + 1 && ix + 1 < arr.shape[0],
      w0 = s0 ? +arr.get(ix) : 0.0,
      w1 = s1 ? +arr.get(ix + 1) : 0.0;
  return (1.0 - fx) * w0 + fx * w1;
}

function interp2d(arr, x, y) {
  var ix = Math.floor(x),
      fx = x - ix,
      s0 = 0 <= ix && ix < arr.shape[0],
      s1 = 0 <= ix + 1 && ix + 1 < arr.shape[0],
      iy = Math.floor(y),
      fy = y - iy,
      t0 = 0 <= iy && iy < arr.shape[1],
      t1 = 0 <= iy + 1 && iy + 1 < arr.shape[1],
      w00 = s0 && t0 ? arr.get(ix, iy) : 0.0,
      w01 = s0 && t1 ? arr.get(ix, iy + 1) : 0.0,
      w10 = s1 && t0 ? arr.get(ix + 1, iy) : 0.0,
      w11 = s1 && t1 ? arr.get(ix + 1, iy + 1) : 0.0;
  return (1.0 - fy) * ((1.0 - fx) * w00 + fx * w10) + fy * ((1.0 - fx) * w01 + fx * w11);
}

function interp3d(arr, x, y, z) {
  var ix = Math.floor(x),
      fx = x - ix,
      s0 = 0 <= ix && ix < arr.shape[0],
      s1 = 0 <= ix + 1 && ix + 1 < arr.shape[0],
      iy = Math.floor(y),
      fy = y - iy,
      t0 = 0 <= iy && iy < arr.shape[1],
      t1 = 0 <= iy + 1 && iy + 1 < arr.shape[1],
      iz = Math.floor(z),
      fz = z - iz,
      u0 = 0 <= iz && iz < arr.shape[2],
      u1 = 0 <= iz + 1 && iz + 1 < arr.shape[2],
      w000 = s0 && t0 && u0 ? arr.get(ix, iy, iz) : 0.0,
      w010 = s0 && t1 && u0 ? arr.get(ix, iy + 1, iz) : 0.0,
      w100 = s1 && t0 && u0 ? arr.get(ix + 1, iy, iz) : 0.0,
      w110 = s1 && t1 && u0 ? arr.get(ix + 1, iy + 1, iz) : 0.0,
      w001 = s0 && t0 && u1 ? arr.get(ix, iy, iz + 1) : 0.0,
      w011 = s0 && t1 && u1 ? arr.get(ix, iy + 1, iz + 1) : 0.0,
      w101 = s1 && t0 && u1 ? arr.get(ix + 1, iy, iz + 1) : 0.0,
      w111 = s1 && t1 && u1 ? arr.get(ix + 1, iy + 1, iz + 1) : 0.0;
  return (1.0 - fz) * ((1.0 - fy) * ((1.0 - fx) * w000 + fx * w100) + fy * ((1.0 - fx) * w010 + fx * w110)) + fz * ((1.0 - fy) * ((1.0 - fx) * w001 + fx * w101) + fy * ((1.0 - fx) * w011 + fx * w111));
}

function interpNd(arr) {
  var d = arr.shape.length | 0,
      ix = new Array(d),
      fx = new Array(d),
      s0 = new Array(d),
      s1 = new Array(d),
      i,
      t;

  for (i = 0; i < d; ++i) {
    t = +arguments[i + 1];
    ix[i] = Math.floor(t);
    fx[i] = t - ix[i];
    s0[i] = 0 <= ix[i] && ix[i] < arr.shape[i];
    s1[i] = 0 <= ix[i] + 1 && ix[i] + 1 < arr.shape[i];
  }

  var r = 0.0,
      j,
      w,
      idx;

  i_loop: for (i = 0; i < 1 << d; ++i) {
    w = 1.0;
    idx = arr.offset;

    for (j = 0; j < d; ++j) {
      if (i & 1 << j) {
        if (!s1[j]) {
          continue i_loop;
        }

        w *= fx[j];
        idx += arr.stride[j] * (ix[j] + 1);
      } else {
        if (!s0[j]) {
          continue i_loop;
        }

        w *= 1.0 - fx[j];
        idx += arr.stride[j] * ix[j];
      }
    }

    r += w * arr.data[idx];
  }

  return r;
}

function interpolate(arr, x, y, z) {
  switch (arr.shape.length) {
    case 0:
      return 0.0;

    case 1:
      return interp1d(arr, x);

    case 2:
      return interp2d(arr, x, y);

    case 3:
      return interp3d(arr, x, y, z);

    default:
      return interpNd.apply(undefined, arguments);
  }
}

module.exports = interpolate;
module.exports.d1 = interp1d;
module.exports.d2 = interp2d;
module.exports.d3 = interp3d;

/***/ }),
/* 189 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "BarcodeDecoder", function() { return /* reexport */ barcode_decoder; });
__webpack_require__.d(__webpack_exports__, "BarcodeReader", function() { return /* reexport */ barcode_reader; });
__webpack_require__.d(__webpack_exports__, "CameraAccess", function() { return /* reexport */ camera_access; });
__webpack_require__.d(__webpack_exports__, "ImageDebug", function() { return /* reexport */ image_debug["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "ImageWrapper", function() { return /* reexport */ image_wrapper["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "ResultCollector", function() { return /* reexport */ result_collector; });

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__(19);
var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

// EXTERNAL MODULE: ./src/common/typedefs.js
var typedefs = __webpack_require__(68);

// EXTERNAL MODULE: ./src/common/image_wrapper.ts
var image_wrapper = __webpack_require__(11);

// CONCATENATED MODULE: ./src/decoder/bresenham.js
var Bresenham = {};
var Slope = {
  DIR: {
    UP: 1,
    DOWN: -1
  }
};
/**
 * Scans a line of the given image from point p1 to p2 and returns a result object containing
 * gray-scale values (0-255) of the underlying pixels in addition to the min
 * and max values.
 * @param {Object} imageWrapper
 * @param {Object} p1 The start point {x,y}
 * @param {Object} p2 The end point {x,y}
 * @returns {line, min, max}
 */

Bresenham.getBarcodeLine = function (imageWrapper, p1, p2) {
  /* eslint-disable no-bitwise */
  var x0 = p1.x | 0;
  var y0 = p1.y | 0;
  var x1 = p2.x | 0;
  var y1 = p2.y | 0;
  /* eslint-disable no-bitwise */

  var steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);
  var error;
  var y;
  var tmp;
  var x;
  var line = [];
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var val;
  var min = 255;
  var max = 0;

  function read(a, b) {
    val = imageData[b * width + a];
    min = val < min ? val : min;
    max = val > max ? val : max;
    line.push(val);
  }

  if (steep) {
    tmp = x0;
    x0 = y0;
    y0 = tmp;
    tmp = x1;
    x1 = y1;
    y1 = tmp;
  }

  if (x0 > x1) {
    tmp = x0;
    x0 = x1;
    x1 = tmp;
    tmp = y0;
    y0 = y1;
    y1 = tmp;
  }

  var deltaX = x1 - x0;
  var deltaY = Math.abs(y1 - y0);
  error = deltaX / 2 | 0;
  y = y0;
  var yStep = y0 < y1 ? 1 : -1;

  for (x = x0; x < x1; x++) {
    if (steep) {
      read(y, x);
    } else {
      read(x, y);
    }

    error -= deltaY;

    if (error < 0) {
      y += yStep;
      error += deltaX;
    }
  }

  return {
    line: line,
    min: min,
    max: max
  };
};
/**
 * Converts the result from getBarcodeLine into a binary representation
 * also considering the frequency and slope of the signal for more robust results
 * @param {Object} result {line, min, max}
 */


Bresenham.toBinaryLine = function (result) {
  var min = result.min;
  var max = result.max;
  var line = result.line;
  var slope;
  var slope2;
  var center = min + (max - min) / 2;
  var extrema = [];
  var currentDir;
  var dir;
  var threshold = (max - min) / 12;
  var rThreshold = -threshold;
  var i;
  var j; // 1. find extrema

  currentDir = line[0] > center ? Slope.DIR.UP : Slope.DIR.DOWN;
  extrema.push({
    pos: 0,
    val: line[0]
  });

  for (i = 0; i < line.length - 2; i++) {
    slope = line[i + 1] - line[i];
    slope2 = line[i + 2] - line[i + 1];

    if (slope + slope2 < rThreshold && line[i + 1] < center * 1.5) {
      dir = Slope.DIR.DOWN;
    } else if (slope + slope2 > threshold && line[i + 1] > center * 0.5) {
      dir = Slope.DIR.UP;
    } else {
      dir = currentDir;
    }

    if (currentDir !== dir) {
      extrema.push({
        pos: i,
        val: line[i]
      });
      currentDir = dir;
    }
  }

  extrema.push({
    pos: line.length,
    val: line[line.length - 1]
  });

  for (j = extrema[0].pos; j < extrema[1].pos; j++) {
    line[j] = line[j] > center ? 0 : 1;
  } // iterate over extrema and convert to binary based on avg between minmax


  for (i = 1; i < extrema.length - 1; i++) {
    if (extrema[i + 1].val > extrema[i].val) {
      threshold = extrema[i].val + (extrema[i + 1].val - extrema[i].val) / 3 * 2 | 0;
    } else {
      threshold = extrema[i + 1].val + (extrema[i].val - extrema[i + 1].val) / 3 | 0;
    }

    for (j = extrema[i].pos; j < extrema[i + 1].pos; j++) {
      line[j] = line[j] > threshold ? 0 : 1;
    }
  }

  return {
    line: line,
    threshold: threshold
  };
};
/**
 * Used for development only
 */


Bresenham.debug = {
  printFrequency: function printFrequency(line, canvas) {
    var i;
    var ctx = canvas.getContext('2d'); // eslint-disable-next-line no-param-reassign

    canvas.width = line.length; // eslint-disable-next-line no-param-reassign

    canvas.height = 256;
    ctx.beginPath();
    ctx.strokeStyle = 'blue';

    for (i = 0; i < line.length; i++) {
      ctx.moveTo(i, 255);
      ctx.lineTo(i, 255 - line[i]);
    }

    ctx.stroke();
    ctx.closePath();
  },
  printPattern: function printPattern(line, canvas) {
    var ctx = canvas.getContext('2d');
    var i; // eslint-disable-next-line no-param-reassign

    canvas.width = line.length;
    ctx.fillColor = 'black';

    for (i = 0; i < line.length; i++) {
      if (line[i] === 1) {
        ctx.fillRect(i, 0, 1, 100);
      }
    }
  }
};
/* harmony default export */ var bresenham = (Bresenham);
// EXTERNAL MODULE: ./src/common/image_debug.ts
var image_debug = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(3);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(4);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/assertThisInitialized.js
var assertThisInitialized = __webpack_require__(1);
var assertThisInitialized_default = /*#__PURE__*/__webpack_require__.n(assertThisInitialized);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inherits.js
var inherits = __webpack_require__(6);
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__(5);
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(2);
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__(0);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);

// EXTERNAL MODULE: ./src/common/array_helper.ts
var array_helper = __webpack_require__(10);

// CONCATENATED MODULE: ./src/reader/barcode_reader.ts




var BarcodeDirection;

(function (BarcodeDirection) {
  BarcodeDirection[BarcodeDirection["Forward"] = 1] = "Forward";
  BarcodeDirection[BarcodeDirection["Reverse"] = -1] = "Reverse";
})(BarcodeDirection || (BarcodeDirection = {}));

;
;
;
;
;
;
var barcode_reader_BarcodeReader = /*#__PURE__*/function () {
  createClass_default()(BarcodeReader, null, [{
    key: "Exception",
    get: function get() {
      return {
        StartNotFoundException: 'Start-Info was not found!',
        CodeNotFoundException: 'Code could not be found!',
        PatternNotFoundException: 'Pattern could not be found!'
      };
    }
  }]);

  function BarcodeReader(config, supplements) {
    classCallCheck_default()(this, BarcodeReader);

    defineProperty_default()(this, "_row", []);

    defineProperty_default()(this, "config", {});

    defineProperty_default()(this, "supplements", []);

    defineProperty_default()(this, "SINGLE_CODE_ERROR", 0);

    defineProperty_default()(this, "FORMAT", 'unknown');

    defineProperty_default()(this, "CONFIG_KEYS", {});

    this._row = [];
    this.config = config || {};

    if (supplements) {
      this.supplements = supplements;
    }

    return this;
  }

  createClass_default()(BarcodeReader, [{
    key: "_nextUnset",
    value: function _nextUnset(line) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = start; i < line.length; i++) {
        if (!line[i]) return i;
      }

      return line.length;
    }
  }, {
    key: "_matchPattern",
    value: function _matchPattern(counter, code, maxSingleError) {
      var error = 0;
      var singleError = 0;
      var sum = 0;
      var modulo = 0;
      var barWidth = 0;
      var count = 0;
      var scaled = 0;
      maxSingleError = maxSingleError || this.SINGLE_CODE_ERROR || 1;

      for (var i = 0; i < counter.length; i++) {
        sum += counter[i];
        modulo += code[i];
      }

      if (sum < modulo) {
        return Number.MAX_VALUE;
      }

      barWidth = sum / modulo;
      maxSingleError *= barWidth;

      for (var _i = 0; _i < counter.length; _i++) {
        count = counter[_i];
        scaled = code[_i] * barWidth;
        singleError = Math.abs(count - scaled) / scaled;

        if (singleError > maxSingleError) {
          return Number.MAX_VALUE;
        }

        error += singleError;
      }

      return error / modulo;
    }
  }, {
    key: "_nextSet",
    value: function _nextSet(line) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = offset; i < line.length; i++) {
        if (line[i]) return i;
      }

      return line.length;
    }
  }, {
    key: "_correctBars",
    value: function _correctBars(counter, correction, indices) {
      var length = indices.length;
      var tmp = 0;

      while (length--) {
        tmp = counter[indices[length]] * (1 - (1 - correction) / 2);

        if (tmp > 1) {
          counter[indices[length]] = tmp;
        }
      }
    }
  }, {
    key: "decodePattern",
    value: function decodePattern(pattern) {
      // console.warn('* decodePattern', pattern);
      this._row = pattern; // console.warn('* decodePattern calling decode', typeof this, this.constructor, this.FORMAT, JSON.stringify(this));

      var result = this._decode(); // console.warn('* first result=', result);


      if (result === null) {
        this._row.reverse();

        result = this._decode(); // console.warn('* reversed result=', result);

        if (result) {
          result.direction = BarcodeDirection.Reverse;
          result.start = this._row.length - result.start;
          result.end = this._row.length - result.end;
        }
      } else {
        result.direction = BarcodeDirection.Forward;
      }

      if (result) {
        result.format = this.FORMAT;
      } // console.warn('* returning', result);


      return result;
    }
  }, {
    key: "_matchRange",
    value: function _matchRange(start, end, value) {
      var i;
      start = start < 0 ? 0 : start;

      for (i = start; i < end; i++) {
        if (this._row[i] !== value) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "_fillCounters",
    value: function _fillCounters() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._nextUnset(this._row);
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._row.length;
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var counters = [];
      var counterPos = 0;
      counters[counterPos] = 0;

      for (var i = offset; i < end; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counters[counterPos]++;
        } else {
          counterPos++;
          counters[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return counters;
    }
  }, {
    key: "_toCounters",
    value: function _toCounters(start, counters) {
      var numCounters = counters.length;
      var end = this._row.length;
      var isWhite = !this._row[start];
      var counterPos = 0;
      array_helper["a" /* default */].init(counters, 0);

      for (var i = start; i < end; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counters[counterPos]++;
        } else {
          counterPos++;

          if (counterPos === numCounters) {
            break;
          } else {
            counters[counterPos] = 1;
            isWhite = !isWhite;
          }
        }
      }

      return counters;
    }
  }]);

  return BarcodeReader;
}();
/* harmony default export */ var barcode_reader = (barcode_reader_BarcodeReader);
// CONCATENATED MODULE: ./src/reader/code_128_reader.ts








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var code_128_reader_Code128Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(Code128Reader, _BarcodeReader);

  var _super = _createSuper(Code128Reader);

  function Code128Reader() {
    var _this;

    classCallCheck_default()(this, Code128Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_SHIFT", 98);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_C", 99);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_B", 100);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_A", 101);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_A", 103);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_B", 104);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_C", 105);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_CODE", 106);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_PATTERN", [[2, 1, 2, 2, 2, 2], [2, 2, 2, 1, 2, 2], [2, 2, 2, 2, 2, 1], [1, 2, 1, 2, 2, 3], [1, 2, 1, 3, 2, 2], [1, 3, 1, 2, 2, 2], [1, 2, 2, 2, 1, 3], [1, 2, 2, 3, 1, 2], [1, 3, 2, 2, 1, 2], [2, 2, 1, 2, 1, 3], [2, 2, 1, 3, 1, 2], [2, 3, 1, 2, 1, 2], [1, 1, 2, 2, 3, 2], [1, 2, 2, 1, 3, 2], [1, 2, 2, 2, 3, 1], [1, 1, 3, 2, 2, 2], [1, 2, 3, 1, 2, 2], [1, 2, 3, 2, 2, 1], [2, 2, 3, 2, 1, 1], [2, 2, 1, 1, 3, 2], [2, 2, 1, 2, 3, 1], [2, 1, 3, 2, 1, 2], [2, 2, 3, 1, 1, 2], [3, 1, 2, 1, 3, 1], [3, 1, 1, 2, 2, 2], [3, 2, 1, 1, 2, 2], [3, 2, 1, 2, 2, 1], [3, 1, 2, 2, 1, 2], [3, 2, 2, 1, 1, 2], [3, 2, 2, 2, 1, 1], [2, 1, 2, 1, 2, 3], [2, 1, 2, 3, 2, 1], [2, 3, 2, 1, 2, 1], [1, 1, 1, 3, 2, 3], [1, 3, 1, 1, 2, 3], [1, 3, 1, 3, 2, 1], [1, 1, 2, 3, 1, 3], [1, 3, 2, 1, 1, 3], [1, 3, 2, 3, 1, 1], [2, 1, 1, 3, 1, 3], [2, 3, 1, 1, 1, 3], [2, 3, 1, 3, 1, 1], [1, 1, 2, 1, 3, 3], [1, 1, 2, 3, 3, 1], [1, 3, 2, 1, 3, 1], [1, 1, 3, 1, 2, 3], [1, 1, 3, 3, 2, 1], [1, 3, 3, 1, 2, 1], [3, 1, 3, 1, 2, 1], [2, 1, 1, 3, 3, 1], [2, 3, 1, 1, 3, 1], [2, 1, 3, 1, 1, 3], [2, 1, 3, 3, 1, 1], [2, 1, 3, 1, 3, 1], [3, 1, 1, 1, 2, 3], [3, 1, 1, 3, 2, 1], [3, 3, 1, 1, 2, 1], [3, 1, 2, 1, 1, 3], [3, 1, 2, 3, 1, 1], [3, 3, 2, 1, 1, 1], [3, 1, 4, 1, 1, 1], [2, 2, 1, 4, 1, 1], [4, 3, 1, 1, 1, 1], [1, 1, 1, 2, 2, 4], [1, 1, 1, 4, 2, 2], [1, 2, 1, 1, 2, 4], [1, 2, 1, 4, 2, 1], [1, 4, 1, 1, 2, 2], [1, 4, 1, 2, 2, 1], [1, 1, 2, 2, 1, 4], [1, 1, 2, 4, 1, 2], [1, 2, 2, 1, 1, 4], [1, 2, 2, 4, 1, 1], [1, 4, 2, 1, 1, 2], [1, 4, 2, 2, 1, 1], [2, 4, 1, 2, 1, 1], [2, 2, 1, 1, 1, 4], [4, 1, 3, 1, 1, 1], [2, 4, 1, 1, 1, 2], [1, 3, 4, 1, 1, 1], [1, 1, 1, 2, 4, 2], [1, 2, 1, 1, 4, 2], [1, 2, 1, 2, 4, 1], [1, 1, 4, 2, 1, 2], [1, 2, 4, 1, 1, 2], [1, 2, 4, 2, 1, 1], [4, 1, 1, 2, 1, 2], [4, 2, 1, 1, 1, 2], [4, 2, 1, 2, 1, 1], [2, 1, 2, 1, 4, 1], [2, 1, 4, 1, 2, 1], [4, 1, 2, 1, 2, 1], [1, 1, 1, 1, 4, 3], [1, 1, 1, 3, 4, 1], [1, 3, 1, 1, 4, 1], [1, 1, 4, 1, 1, 3], [1, 1, 4, 3, 1, 1], [4, 1, 1, 1, 1, 3], [4, 1, 1, 3, 1, 1], [1, 1, 3, 1, 4, 1], [1, 1, 4, 1, 3, 1], [3, 1, 1, 1, 4, 1], [4, 1, 1, 1, 3, 1], [2, 1, 1, 4, 1, 2], [2, 1, 1, 2, 1, 4], [2, 1, 1, 2, 3, 2], [2, 3, 3, 1, 1, 1, 2]]);

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.64);

    defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.30);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_128');

    defineProperty_default()(assertThisInitialized_default()(_this), "MODULE_INDICES", {
      bar: [0, 2, 4],
      space: [1, 3, 5]
    });

    return _this;
  }

  createClass_default()(Code128Reader, [{
    key: "_decodeCode",
    value: function _decodeCode(start, correction) {
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start,
        correction: {
          bar: 1,
          space: 1
        }
      };
      var counter = [0, 0, 0, 0, 0, 0];
      var offset = start;
      var isWhite = !this._row[offset];
      var counterPos = 0;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            if (correction) {
              this._correct(counter, correction);
            }

            for (var code = 0; code < this.CODE_PATTERN.length; code++) {
              var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }

            bestMatch.end = i;

            if (bestMatch.code === -1 || bestMatch.error > this.AVG_CODE_ERROR) {
              return null;
            }

            if (this.CODE_PATTERN[bestMatch.code]) {
              bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
              bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
            }

            return bestMatch;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_correct",
    value: function _correct(counter, correction) {
      this._correctBars(counter, correction.bar, this.MODULE_INDICES.bar);

      this._correctBars(counter, correction.space, this.MODULE_INDICES.space);
    }
  }, {
    key: "_findStart",
    // TODO: _findStart and decodeCode share similar code, can we re-use some?
    value: function _findStart() {
      var counter = [0, 0, 0, 0, 0, 0];

      var offset = this._nextSet(this._row);

      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0,
        correction: {
          bar: 1,
          space: 1
        }
      };
      var isWhite = false;
      var counterPos = 0;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            var sum = counter.reduce(function (prev, next) {
              return prev + next;
            }, 0);

            for (var code = this.START_CODE_A; code <= this.START_CODE_C; code++) {
              var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }

            if (bestMatch.error < this.AVG_CODE_ERROR) {
              bestMatch.start = i - sum;
              bestMatch.end = i;
              bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
              bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
              return bestMatch;
            }

            for (var j = 0; j < 4; j++) {
              counter[j] = counter[j + 2];
            }

            counter[4] = 0;
            counter[5] = 0;
            counterPos--;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var _this2 = this;

      var startInfo = this._findStart();

      if (startInfo === null) {
        return null;
      } // var self = this,
      //     done = false,
      //     result = [],
      //     multiplier = 0,
      //     checksum = 0,
      //     codeset,
      //     rawResult = [],
      //     decodedCodes = [],
      //     shiftNext = false,
      //     unshift,
      //     removeLastCharacter = true;


      var code = {
        code: startInfo.code,
        start: startInfo.start,
        end: startInfo.end,
        correction: {
          bar: startInfo.correction.bar,
          space: startInfo.correction.space
        }
      };
      var decodedCodes = [];
      decodedCodes.push(code);
      var checksum = code.code;

      var codeset = function (c) {
        switch (c) {
          case _this2.START_CODE_A:
            return _this2.CODE_A;

          case _this2.START_CODE_B:
            return _this2.CODE_B;

          case _this2.START_CODE_C:
            return _this2.CODE_C;

          default:
            return null;
        }
      }(code.code);

      var done = false;
      var shiftNext = false;
      var unshift = shiftNext;
      var removeLastCharacter = true;
      var multiplier = 0;
      var rawResult = [];
      var result = []; // TODO: i think this should be string only, but it creates problems if it is

      while (!done) {
        unshift = shiftNext;
        shiftNext = false;
        code = this._decodeCode(code.end, code.correction);

        if (code !== null) {
          if (code.code !== this.STOP_CODE) {
            removeLastCharacter = true;
          }

          if (code.code !== this.STOP_CODE) {
            rawResult.push(code.code);
            multiplier++;
            checksum += multiplier * code.code;
          }

          decodedCodes.push(code);

          switch (codeset) {
            case this.CODE_A:
              if (code.code < 64) {
                result.push(String.fromCharCode(32 + code.code));
              } else if (code.code < 96) {
                result.push(String.fromCharCode(code.code - 64));
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }

                switch (code.code) {
                  case this.CODE_SHIFT:
                    shiftNext = true;
                    codeset = this.CODE_B;
                    break;

                  case this.CODE_B:
                    codeset = this.CODE_B;
                    break;

                  case this.CODE_C:
                    codeset = this.CODE_C;
                    break;

                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }

              break;

            case this.CODE_B:
              if (code.code < 96) {
                result.push(String.fromCharCode(32 + code.code));
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }

                switch (code.code) {
                  case this.CODE_SHIFT:
                    shiftNext = true;
                    codeset = this.CODE_A;
                    break;

                  case this.CODE_A:
                    codeset = this.CODE_A;
                    break;

                  case this.CODE_C:
                    codeset = this.CODE_C;
                    break;

                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }

              break;

            case this.CODE_C:
              if (code.code < 100) {
                result.push(code.code < 10 ? '0' + code.code : code.code);
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }

                switch (code.code) {
                  case this.CODE_A:
                    codeset = this.CODE_A;
                    break;

                  case this.CODE_B:
                    codeset = this.CODE_B;
                    break;

                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }

              break;
          }
        } else {
          done = true;
        }

        if (unshift) {
          codeset = codeset === this.CODE_A ? this.CODE_B : this.CODE_A;
        }
      }

      if (code === null) {
        return null;
      }

      code.end = this._nextUnset(this._row, code.end);

      if (!this._verifyTrailingWhitespace(code)) {
        return null;
      }

      checksum -= multiplier * rawResult[rawResult.length - 1];

      if (checksum % 103 !== rawResult[rawResult.length - 1]) {
        return null;
      }

      if (!result.length) {
        return null;
      } // remove last code from result (checksum)


      if (removeLastCharacter) {
        result.splice(result.length - 1, 1);
      }

      return {
        code: result.join(''),
        start: startInfo.start,
        end: code.end,
        codeset: codeset,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        endInfo: code,
        format: this.FORMAT
      };
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var self = this,
          trailingWhitespaceEnd;
      trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }, {
    key: "calculateCorrection",
    value: function calculateCorrection(expected, normalized, indices) {
      var length = indices.length,
          sumNormalized = 0,
          sumExpected = 0;

      while (length--) {
        sumExpected += expected[indices[length]];
        sumNormalized += normalized[indices[length]];
      }

      return sumExpected / sumNormalized;
    }
  }]);

  return Code128Reader;
}(barcode_reader);

/* harmony default export */ var code_128_reader = (code_128_reader_Code128Reader);
// EXTERNAL MODULE: ./node_modules/lodash/lodash.js
var lodash = __webpack_require__(12);

// CONCATENATED MODULE: ./src/reader/ean_reader.ts








function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ean_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


 // const CODE_L_START = 0;

var CODE_G_START = 10;

var START_PATTERN = [1, 1, 1];
var MIDDLE_PATTERN = [1, 1, 1, 1, 1];

var EXTENSION_START_PATTERN = [1, 1, 2];
var CODE_PATTERN = [[3, 2, 1, 1], [2, 2, 2, 1], [2, 1, 2, 2], [1, 4, 1, 1], [1, 1, 3, 2], [1, 2, 3, 1], [1, 1, 1, 4], [1, 3, 1, 2], [1, 2, 1, 3], [3, 1, 1, 2], [1, 1, 2, 3], [1, 2, 2, 2], [2, 2, 1, 2], [1, 1, 4, 1], [2, 3, 1, 1], [1, 3, 2, 1], [4, 1, 1, 1], [2, 1, 3, 1], [3, 1, 2, 1], [2, 1, 1, 3]];
var CODE_FREQUENCY = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26]; // const SINGLE_CODE_ERROR = 0.70;

var AVG_CODE_ERROR = 0.48;

var ean_reader_EANReader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(EANReader, _BarcodeReader);

  var _super = ean_reader_createSuper(EANReader);

  // TODO: does this need to be in the class?
  function EANReader(config, supplements) {
    var _this;

    classCallCheck_default()(this, EANReader);

    _this = _super.call(this, Object(lodash["merge"])({
      supplements: []
    }, config), supplements);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_13');

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.70);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [1, 1, 1]);

    return _this;
  }

  createClass_default()(EANReader, [{
    key: "_findPattern",
    value: function _findPattern(pattern, offset, isWhite, tryHarder) {
      var counter = new Array(pattern.length).fill(0);
      var bestMatch = {
        error: Number.MAX_VALUE,
        start: 0,
        end: 0
      };
      var epsilon = AVG_CODE_ERROR; // console.warn('* findPattern', pattern, offset, isWhite, tryHarder, epsilon);

      var counterPos = 0;

      if (!offset) {
        offset = this._nextSet(this._row);
      }

      var found = false;

      for (var i = offset; i < this._row.length; i++) {
        // console.warn(`* loop i=${offset} len=${this._row.length} isWhite=${isWhite} counterPos=${counterPos}`);
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos] += 1;
        } else {
          if (counterPos === counter.length - 1) {
            var error = this._matchPattern(counter, pattern); // console.warn('* matchPattern', error, counter, pattern);


            if (error < epsilon && bestMatch.error && error < bestMatch.error) {
              found = true;
              bestMatch.error = error;
              bestMatch.start = i - counter.reduce(function (sum, value) {
                return sum + value;
              }, 0);
              bestMatch.end = i; // console.warn('* return bestMatch', JSON.stringify(bestMatch));

              return bestMatch;
            }

            if (tryHarder) {
              for (var j = 0; j < counter.length - 2; j++) {
                counter[j] = counter[j + 2];
              }

              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            }
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      if (found) {// console.warn('* return bestMatch', JSON.stringify(bestMatch));
      } else {// console.warn('* return null');
        }

      return found ? bestMatch : null;
    } // TODO: findPattern and decodeCode appear to share quite similar code, can it be reduced?

  }, {
    key: "_decodeCode",
    value: function _decodeCode(start, coderange) {
      // console.warn('* decodeCode', start, coderange);
      var counter = [0, 0, 0, 0];
      var offset = start;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start
      };
      var epsilon = AVG_CODE_ERROR;
      var isWhite = !this._row[offset];
      var counterPos = 0;

      if (!coderange) {
        // console.warn('* decodeCode before length');
        coderange = CODE_PATTERN.length; // console.warn('* decodeCode after length');
      }

      var found = false;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            for (var code = 0; code < coderange; code++) {
              var error = this._matchPattern(counter, CODE_PATTERN[code]);

              bestMatch.end = i;

              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }

            if (bestMatch.error > epsilon) {
              // console.warn('* return null');
              return null;
            } // console.warn('* return bestMatch', JSON.stringify(bestMatch));


            return bestMatch;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return found ? bestMatch : null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      // console.warn('* findStart');
      var offset = this._nextSet(this._row);

      var startInfo = null;

      while (!startInfo) {
        startInfo = this._findPattern(START_PATTERN, offset, false, true); // console.warn('* startInfo=', JSON.stringify(startInfo));

        if (!startInfo) {
          return null;
        }

        var leadingWhitespaceStart = startInfo.start - (startInfo.end - startInfo.start);

        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            // console.warn('* returning startInfo');
            return startInfo;
          }
        }

        offset = startInfo.end;
        startInfo = null;
      } // console.warn('* returning null');


      return null;
    }
  }, {
    key: "_calculateFirstDigit",
    value: function _calculateFirstDigit(codeFrequency) {
      // console.warn('* calculateFirstDigit', codeFrequency);
      for (var i = 0; i < CODE_FREQUENCY.length; i++) {
        if (codeFrequency === CODE_FREQUENCY[i]) {
          // console.warn('* returning', i);
          return i;
        }
      } // console.warn('* return null');


      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      // console.warn('* decodePayload', inCode, result, decodedCodes);
      var outCode = _objectSpread({}, inCode);

      var codeFrequency = 0x0;

      for (var i = 0; i < 6; i++) {
        outCode = this._decodeCode(outCode.end); // console.warn('* decodeCode=', outCode);

        if (!outCode) {
          // console.warn('* return null');
          return null;
        }

        if (outCode.code >= CODE_G_START) {
          outCode.code -= CODE_G_START;
          codeFrequency |= 1 << 5 - i;
        } else {
          codeFrequency |= 0 << 5 - i;
        }

        result.push(outCode.code);
        decodedCodes.push(outCode);
      }

      var firstDigit = this._calculateFirstDigit(codeFrequency); // console.warn('* firstDigit=', firstDigit);


      if (firstDigit === null) {
        // console.warn('* return null');
        return null;
      }

      result.unshift(firstDigit);

      var middlePattern = this._findPattern(MIDDLE_PATTERN, outCode.end, true, false); // console.warn('* findPattern=', JSON.stringify(middlePattern));


      if (middlePattern === null || !middlePattern.end) {
        // console.warn('* return null');
        return null;
      }

      decodedCodes.push(middlePattern);

      for (var _i = 0; _i < 6; _i++) {
        middlePattern = this._decodeCode(middlePattern.end, CODE_G_START); // console.warn('* decodeCode=', JSON.stringify(middlePattern));

        if (!middlePattern) {
          // console.warn('* return null');
          return null;
        }

        decodedCodes.push(middlePattern);
        result.push(middlePattern.code);
      } // console.warn('* end code=', JSON.stringify(middlePattern));
      // console.warn('* end result=', JSON.stringify(result));
      // console.warn('* end decodedCodes=', decodedCodes);


      return middlePattern;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      // console.warn('* verifyTrailingWhitespace', JSON.stringify(endInfo));
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start);

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          // console.warn('* returning', JSON.stringify(endInfo));
          return endInfo;
        }
      } // console.warn('* return null');


      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd(offset, isWhite) {
      // console.warn('* findEnd', offset, isWhite);
      var endInfo = this._findPattern(this.STOP_PATTERN, offset, isWhite, false);

      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_checksum",
    value: function _checksum(result) {
      // console.warn('* _checksum', result);
      var sum = 0;

      for (var i = result.length - 2; i >= 0; i -= 2) {
        sum += result[i];
      }

      sum *= 3;

      for (var _i2 = result.length - 1; _i2 >= 0; _i2 -= 2) {
        sum += result[_i2];
      } // console.warn('* end checksum', sum % 10 === 0);


      return sum % 10 === 0;
    }
  }, {
    key: "_decodeExtensions",
    value: function _decodeExtensions(offset) {
      var start = this._nextSet(this._row, offset);

      var startInfo = this._findPattern(EXTENSION_START_PATTERN, start, false, false);

      if (startInfo === null) {
        return null;
      } // console.warn('* decodeExtensions', this.supplements);
      // console.warn('* there are ', this.supplements.length, ' supplements');


      for (var i = 0; i < this.supplements.length; i++) {
        // console.warn('* extensions loop', i, this.supplements[i], this.supplements[i]._decode);
        try {
          var result = this.supplements[i]._decode(this._row, startInfo.end); // console.warn('* decode result=', result);


          if (result !== null) {
            return {
              code: result.code,
              start: start,
              startInfo: startInfo,
              end: result.end,
              decodedCodes: result.decodedCodes,
              format: this.supplements[i].FORMAT
            };
          }
        } catch (err) {
          console.error('* decodeExtensions error in ', this.supplements[i], ': ', err);
        }
      } // console.warn('* end decodeExtensions');


      return null;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      // console.warn('* decode', row);
      // console.warn('* decode', start);
      var result = new Array();
      var decodedCodes = new Array();
      var resultInfo = {};

      var startInfo = this._findStart();

      if (!startInfo) {
        return null;
      }

      var code = {
        start: startInfo.start,
        end: startInfo.end
      };
      decodedCodes.push(code);
      code = this._decodePayload(code, result, decodedCodes);

      if (!code) {
        return null;
      }

      code = this._findEnd(code.end, false);

      if (!code) {
        return null;
      }

      decodedCodes.push(code); // Checksum

      if (!this._checksum(result)) {
        return null;
      } // console.warn('* this.supplements=', this.supplements);


      if (this.supplements.length > 0) {
        var supplement = this._decodeExtensions(code.end); // console.warn('* decodeExtensions returns', supplement);


        if (!supplement) {
          return null;
        }

        if (!supplement.decodedCodes) {
          return null;
        }

        var lastCode = supplement.decodedCodes[supplement.decodedCodes.length - 1];
        var endInfo = {
          start: lastCode.start + ((lastCode.end - lastCode.start) / 2 | 0),
          end: lastCode.end
        };

        if (!this._verifyTrailingWhitespace(endInfo)) {
          return null;
        }

        resultInfo = {
          supplement: supplement,
          code: result.join('') + supplement.code
        };
      }

      return _objectSpread(_objectSpread({
        code: result.join(''),
        start: startInfo.start,
        end: code.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes
      }, resultInfo), {}, {
        format: this.FORMAT
      });
    }
  }]);

  return EANReader;
}(barcode_reader);

/* harmony default export */ var ean_reader = (ean_reader_EANReader);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__(26);
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// CONCATENATED MODULE: ./src/reader/code_39_reader.ts









function code_39_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_39_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_39_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. *$/+%';
var ALPHABET = new Uint16Array(toConsumableArray_default()(ALPHABETH_STRING).map(function (_char) {
  return _char.charCodeAt(0);
}));
var CHARACTER_ENCODINGS = new Uint16Array([0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064, 0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C, 0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016, 0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x094, 0x0A8, 0x0A2, 0x08A, 0x02A]);
var ASTERISK = 0x094;

var code_39_reader_Code39Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(Code39Reader, _BarcodeReader);

  var _super = code_39_reader_createSuper(Code39Reader);

  function Code39Reader() {
    var _this;

    classCallCheck_default()(this, Code39Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_39');

    return _this;
  }

  createClass_default()(Code39Reader, [{
    key: "_findStart",
    value: function _findStart() {
      var offset = this._nextSet(this._row);

      var patternStart = offset;
      var counter = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      var counterPos = 0;
      var isWhite = false;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            // find start pattern
            if (this._toPattern(counter) === ASTERISK) {
              var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));

              if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                return {
                  start: patternStart,
                  end: i
                };
              }
            }

            patternStart += counter[0] + counter[1];

            for (var j = 0; j < 7; j++) {
              counter[j] = counter[j + 2];
            }

            counter[7] = 0;
            counter[8] = 0;
            counterPos--;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(counters) {
      var numCounters = counters.length;
      var maxNarrowWidth = 0;
      var numWideBars = numCounters;
      var wideBarWidth = 0;

      while (numWideBars > 3) {
        maxNarrowWidth = this._findNextWidth(counters, maxNarrowWidth);
        numWideBars = 0;
        var pattern = 0;

        for (var i = 0; i < numCounters; i++) {
          if (counters[i] > maxNarrowWidth) {
            pattern |= 1 << numCounters - 1 - i;
            numWideBars++;
            wideBarWidth += counters[i];
          }
        }

        if (numWideBars === 3) {
          for (var _i = 0; _i < numCounters && numWideBars > 0; _i++) {
            if (counters[_i] > maxNarrowWidth) {
              numWideBars--;

              if (counters[_i] * 2 >= wideBarWidth) {
                return -1;
              }
            }
          }

          return pattern;
        }
      }

      return -1;
    }
  }, {
    key: "_findNextWidth",
    value: function _findNextWidth(counters, current) {
      var minWidth = Number.MAX_VALUE;

      for (var i = 0; i < counters.length; i++) {
        if (counters[i] < minWidth && counters[i] > current) {
          minWidth = counters[i];
        }
      }

      return minWidth;
    }
  }, {
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < CHARACTER_ENCODINGS.length; i++) {
        if (CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(ALPHABET[i]);
        }
      }

      return null;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(lastStart, nextStart, counters) {
      var patternSize = array_helper["a" /* default */].sum(counters);
      var trailingWhitespaceEnd = nextStart - lastStart - patternSize;

      if (trailingWhitespaceEnd * 3 >= patternSize) {
        return true;
      }

      return false;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var counters = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      var result = [];
      start = this._findStart();

      if (!start) {
        return null;
      }

      var nextStart = this._nextSet(this._row, start.end);

      var decodedChar;
      var lastStart;

      do {
        counters = this._toCounters(nextStart, counters);

        var pattern = this._toPattern(counters);

        if (pattern < 0) {
          return null;
        }

        decodedChar = this._patternToChar(pattern);

        if (decodedChar === null) {
          return null;
        }

        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += array_helper["a" /* default */].sum(counters);
        nextStart = this._nextSet(this._row, nextStart);
      } while (decodedChar !== '*');

      result.pop();

      if (!result.length) {
        return null;
      }

      if (!this._verifyTrailingWhitespace(lastStart, nextStart, counters)) {
        return null;
      }

      return {
        code: result.join(''),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT
      };
    }
  }]);

  return Code39Reader;
}(barcode_reader);

/* harmony default export */ var code_39_reader = (code_39_reader_Code39Reader);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/get.js
var get = __webpack_require__(16);
var get_default = /*#__PURE__*/__webpack_require__.n(get);

// CONCATENATED MODULE: ./src/reader/code_39_vin_reader.ts









function code_39_vin_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_39_vin_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_39_vin_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var patterns = {
  IOQ: /[IOQ]/g,
  AZ09: /[A-Z0-9]{17}/
};

var code_39_vin_reader_Code39VINReader = /*#__PURE__*/function (_Code39Reader) {
  inherits_default()(Code39VINReader, _Code39Reader);

  var _super = code_39_vin_reader_createSuper(Code39VINReader);

  function Code39VINReader() {
    var _this;

    classCallCheck_default()(this, Code39VINReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_39_vin');

    return _this;
  }

  createClass_default()(Code39VINReader, [{
    key: "_checkChecksum",
    // TODO (this was todo in original repo, no text was there. sorry.)
    value: function _checkChecksum(code) {
      return !!code;
    } // Cribbed from:
    // https://github.com/zxing/zxing/blob/master/core/src/main/java/com/google/zxing/client/result/VINResultParser.java

  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var result = get_default()(getPrototypeOf_default()(Code39VINReader.prototype), "_decode", this).call(this, row, start);

      if (!result) {
        return null;
      }

      var code = result.code;

      if (!code) {
        return null;
      }

      code = code.replace(patterns.IOQ, '');

      if (!code.match(patterns.AZ09)) {
        if (true) {
          console.log('Failed AZ09 pattern code:', code);
        }

        return null;
      }

      if (!this._checkChecksum(code)) {
        return null;
      }

      result.code = code;
      return result;
    }
  }]);

  return Code39VINReader;
}(code_39_reader);

/* harmony default export */ var code_39_vin_reader = (code_39_vin_reader_Code39VINReader);
// CONCATENATED MODULE: ./src/reader/codabar_reader.ts








function codabar_reader_createSuper(Derived) { var hasNativeReflectConstruct = codabar_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function codabar_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

 // const ALPHABETH_STRING = '0123456789-$:/.+ABCD';

var codabar_reader_ALPHABET = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 36, 58, 47, 46, 43, 65, 66, 67, 68];
var codabar_reader_CHARACTER_ENCODINGS = [0x003, 0x006, 0x009, 0x060, 0x012, 0x042, 0x021, 0x024, 0x030, 0x048, 0x00c, 0x018, 0x045, 0x051, 0x054, 0x015, 0x01A, 0x029, 0x00B, 0x00E];
var START_END = [0x01A, 0x029, 0x00B, 0x00E];
var MIN_ENCODED_CHARS = 4;
var MAX_ACCEPTABLE = 2.0;
var PADDING = 1.5;
;
;

var codabar_reader_NewCodabarReader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(NewCodabarReader, _BarcodeReader);

  var _super = codabar_reader_createSuper(NewCodabarReader);

  function NewCodabarReader() {
    var _this;

    classCallCheck_default()(this, NewCodabarReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "_counters", []);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'codabar');

    return _this;
  }

  createClass_default()(NewCodabarReader, [{
    key: "_computeAlternatingThreshold",
    value: function _computeAlternatingThreshold(offset, end) {
      var min = Number.MAX_VALUE;
      var max = 0;
      var counter = 0;

      for (var i = offset; i < end; i += 2) {
        counter = this._counters[i];

        if (counter > max) {
          max = counter;
        }

        if (counter < min) {
          min = counter;
        }
      }

      return (min + max) / 2.0 | 0;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(offset) {
      var numCounters = 7;
      var end = offset + numCounters;

      if (end > this._counters.length) {
        return -1;
      }

      var barThreshold = this._computeAlternatingThreshold(offset, end);

      var spaceThreshold = this._computeAlternatingThreshold(offset + 1, end);

      var bitmask = 1 << numCounters - 1;
      var threshold = 0;
      var pattern = 0;

      for (var i = 0; i < numCounters; i++) {
        threshold = (i & 1) === 0 ? barThreshold : spaceThreshold;

        if (this._counters[offset + i] > threshold) {
          pattern |= bitmask;
        }

        bitmask >>= 1;
      }

      return pattern;
    }
  }, {
    key: "_isStartEnd",
    value: function _isStartEnd(pattern) {
      for (var i = 0; i < START_END.length; i++) {
        if (START_END[i] === pattern) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "_sumCounters",
    value: function _sumCounters(start, end) {
      var sum = 0;

      for (var i = start; i < end; i++) {
        sum += this._counters[i];
      }

      return sum;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var start = this._nextUnset(this._row);

      var end = start;

      for (var i = 1; i < this._counters.length; i++) {
        var pattern = this._toPattern(i);

        if (pattern !== -1 && this._isStartEnd(pattern)) {
          // TODO: Look for whitespace ahead
          start += this._sumCounters(0, i);
          end = start + this._sumCounters(i, i + 8);
          return {
            start: start,
            end: end,
            startCounter: i,
            endCounter: i + 8
          };
        }
      }

      return null;
    }
  }, {
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < codabar_reader_CHARACTER_ENCODINGS.length; i++) {
        if (codabar_reader_CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(codabar_reader_ALPHABET[i]);
        }
      }

      return null;
    }
  }, {
    key: "_calculatePatternLength",
    value: function _calculatePatternLength(offset) {
      var sum = 0;

      for (var i = offset; i < offset + 7; i++) {
        sum += this._counters[i];
      }

      return sum;
    }
  }, {
    key: "_verifyWhitespace",
    value: function _verifyWhitespace(startCounter, endCounter) {
      if (startCounter - 1 <= 0 || this._counters[startCounter - 1] >= this._calculatePatternLength(startCounter) / 2.0) {
        if (endCounter + 8 >= this._counters.length || this._counters[endCounter + 7] >= this._calculatePatternLength(endCounter) / 2.0) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "_charToPattern",
    value: function _charToPattern(_char) {
      var charCode = _char.charCodeAt(0);

      for (var i = 0; i < codabar_reader_ALPHABET.length; i++) {
        if (codabar_reader_ALPHABET[i] === charCode) {
          return codabar_reader_CHARACTER_ENCODINGS[i];
        }
      }

      return 0x0;
    }
  }, {
    key: "_thresholdResultPattern",
    value: function _thresholdResultPattern(result, startCounter) {
      var categorization = {
        space: {
          narrow: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          },
          wide: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          }
        },
        bar: {
          narrow: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          },
          wide: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          }
        }
      };
      var pos = startCounter;
      var pattern;

      for (var i = 0; i < result.length; i++) {
        pattern = this._charToPattern(result[i]);

        for (var j = 6; j >= 0; j--) {
          var kind = (j & 1) === 2 ? categorization.bar : categorization.space;
          var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
          cat.size += this._counters[pos + j];
          cat.counts++;
          pattern >>= 1;
        }

        pos += 8;
      }

      ['space', 'bar'].forEach(function (key) {
        var newkind = categorization[key];
        newkind.wide.min = Math.floor((newkind.narrow.size / newkind.narrow.counts + newkind.wide.size / newkind.wide.counts) / 2);
        newkind.narrow.max = Math.ceil(newkind.wide.min);
        newkind.wide.max = Math.ceil((newkind.wide.size * MAX_ACCEPTABLE + PADDING) / newkind.wide.counts);
      });
      return categorization;
    }
  }, {
    key: "_validateResult",
    value: function _validateResult(result, startCounter) {
      var thresholds = this._thresholdResultPattern(result, startCounter);

      var pos = startCounter;
      var pattern;

      for (var i = 0; i < result.length; i++) {
        pattern = this._charToPattern(result[i]);

        for (var j = 6; j >= 0; j--) {
          var kind = (j & 1) === 0 ? thresholds.bar : thresholds.space;
          var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
          var size = this._counters[pos + j];

          if (size < cat.min || size > cat.max) {
            return false;
          }

          pattern >>= 1;
        }

        pos += 8;
      }

      return true;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      this._counters = this._fillCounters();
      start = this._findStart();

      if (!start) {
        return null;
      }

      var nextStart = start.startCounter;
      var result = [];
      var pattern;

      do {
        pattern = this._toPattern(nextStart);

        if (pattern < 0) {
          return null;
        }

        var decodedChar = this._patternToChar(pattern);

        if (decodedChar === null) {
          return null;
        }

        result.push(decodedChar);
        nextStart += 8;

        if (result.length > 1 && this._isStartEnd(pattern)) {
          break;
        }
      } while (nextStart < this._counters.length); // verify end


      if (result.length - 2 < MIN_ENCODED_CHARS || !this._isStartEnd(pattern)) {
        return null;
      } // verify end white space


      if (!this._verifyWhitespace(start.startCounter, nextStart - 8)) {
        return null;
      }

      if (!this._validateResult(result, start.startCounter)) {
        return null;
      }

      nextStart = nextStart > this._counters.length ? this._counters.length : nextStart;

      var end = start.start + this._sumCounters(start.startCounter, nextStart - 8);

      return {
        code: result.join(''),
        start: start.start,
        end: end,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT // TODO: i think it should not be required to return format from this, as barcode_reader force sets the format anyway

      };
    }
  }]);

  return NewCodabarReader;
}(barcode_reader);

/* harmony default export */ var codabar_reader = (codabar_reader_NewCodabarReader);
// CONCATENATED MODULE: ./src/reader/upc_reader.ts








function upc_reader_createSuper(Derived) { var hasNativeReflectConstruct = upc_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function upc_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var upc_reader_UPCReader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(UPCReader, _EANReader);

  var _super = upc_reader_createSuper(UPCReader);

  function UPCReader() {
    var _this;

    classCallCheck_default()(this, UPCReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'upc_a');

    return _this;
  }

  createClass_default()(UPCReader, [{
    key: "_decode",
    value: function _decode(row, start) {
      var result = ean_reader.prototype._decode.call(this);

      if (result && result.code && result.code.length === 13 && result.code.charAt(0) === '0') {
        result.code = result.code.substring(1);
        return result;
      }

      return null;
    }
  }]);

  return UPCReader;
}(ean_reader);

/* harmony default export */ var upc_reader = (upc_reader_UPCReader);
// CONCATENATED MODULE: ./src/reader/ean_8_reader.ts








function ean_8_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_8_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_8_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var ean_8_reader_EAN8Reader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(EAN8Reader, _EANReader);

  var _super = ean_8_reader_createSuper(EAN8Reader);

  function EAN8Reader() {
    var _this;

    classCallCheck_default()(this, EAN8Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_8');

    return _this;
  }

  createClass_default()(EAN8Reader, [{
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      var code = inCode;

      for (var i = 0; i < 4; i++) {
        code = this._decodeCode(code.end, CODE_G_START);

        if (!code) {
          return null;
        }

        result.push(code.code);
        decodedCodes.push(code);
      }

      code = this._findPattern(MIDDLE_PATTERN, code.end, true, false);

      if (code === null) {
        return null;
      }

      decodedCodes.push(code);

      for (var _i = 0; _i < 4; _i++) {
        code = this._decodeCode(code.end, CODE_G_START);

        if (!code) {
          return null;
        }

        decodedCodes.push(code);
        result.push(code.code);
      }

      return code;
    }
  }]);

  return EAN8Reader;
}(ean_reader);

/* harmony default export */ var ean_8_reader = (ean_8_reader_EAN8Reader);
// CONCATENATED MODULE: ./src/reader/ean_2_reader.ts








function ean_2_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_2_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_2_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var ean_2_reader_EAN2Reader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(EAN2Reader, _EANReader);

  var _super = ean_2_reader_createSuper(EAN2Reader);

  function EAN2Reader() {
    var _this;

    classCallCheck_default()(this, EAN2Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_2');

    return _this;
  }

  createClass_default()(EAN2Reader, [{
    key: "_decode",
    value: function _decode(row, start) {
      if (row) {
        this._row = row;
      }

      var codeFrequency = 0;
      var offset = start;
      var end = this._row.length;
      var result = [];
      var decodedCodes = [];
      var code = null;

      if (offset === undefined) {
        return null;
      }

      for (var i = 0; i < 2 && offset < end; i++) {
        code = this._decodeCode(offset);

        if (!code) {
          return null;
        }

        decodedCodes.push(code);
        result.push(code.code % 10);

        if (code.code >= CODE_G_START) {
          codeFrequency |= 1 << 1 - i;
        }

        if (i !== 1) {
          offset = this._nextSet(this._row, code.end);
          offset = this._nextUnset(this._row, offset);
        }
      }

      if (result.length !== 2 || parseInt(result.join('')) % 4 !== codeFrequency) {
        return null;
      }

      var startInfo = this._findStart();

      return {
        code: result.join(''),
        decodedCodes: decodedCodes,
        end: code.end,
        format: this.FORMAT,
        startInfo: startInfo,
        start: startInfo.start
      };
    }
  }]);

  return EAN2Reader;
}(ean_reader);

;
/* harmony default export */ var ean_2_reader = (ean_2_reader_EAN2Reader);
// CONCATENATED MODULE: ./src/reader/ean_5_reader.ts








function ean_5_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];

function determineCheckDigit(codeFrequency) {
  for (var i = 0; i < 10; i++) {
    if (codeFrequency === CHECK_DIGIT_ENCODINGS[i]) {
      return i;
    }
  }

  return null;
}

function extensionChecksum(result) {
  var length = result.length;
  var sum = 0;

  for (var i = length - 2; i >= 0; i -= 2) {
    sum += result[i];
  }

  sum *= 3;

  for (var _i = length - 1; _i >= 0; _i -= 2) {
    sum += result[_i];
  }

  sum *= 3;
  return sum % 10;
}

var ean_5_reader_EAN5Reader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(EAN5Reader, _EANReader);

  var _super = ean_5_reader_createSuper(EAN5Reader);

  function EAN5Reader() {
    var _this;

    classCallCheck_default()(this, EAN5Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_5');

    return _this;
  }

  createClass_default()(EAN5Reader, [{
    key: "_decode",
    value: function _decode(row, start) {
      if (start === undefined) {
        return null;
      }

      if (row) {
        this._row = row;
      }

      var codeFrequency = 0;
      var offset = start;
      var end = this._row.length;
      var code = null;
      var result = [];
      var decodedCodes = [];

      for (var i = 0; i < 5 && offset < end; i++) {
        code = this._decodeCode(offset);

        if (!code) {
          return null;
        }

        decodedCodes.push(code);
        result.push(code.code % 10);

        if (code.code >= CODE_G_START) {
          codeFrequency |= 1 << 4 - i;
        }

        if (i !== 4) {
          offset = this._nextSet(this._row, code.end);
          offset = this._nextUnset(this._row, offset);
        }
      }

      if (result.length !== 5) {
        return null;
      }

      if (extensionChecksum(result) !== determineCheckDigit(codeFrequency)) {
        return null;
      }

      var startInfo = this._findStart();

      return {
        code: result.join(''),
        decodedCodes: decodedCodes,
        end: code.end,
        format: this.FORMAT,
        startInfo: startInfo,
        start: startInfo.start
      };
    }
  }]);

  return EAN5Reader;
}(ean_reader);

;
/* harmony default export */ var ean_5_reader = (ean_5_reader_EAN5Reader);
// CONCATENATED MODULE: ./src/reader/upc_e_reader.ts









function upc_e_reader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function upc_e_reader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { upc_e_reader_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { upc_e_reader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function upc_e_reader_createSuper(Derived) { var hasNativeReflectConstruct = upc_e_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function upc_e_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var upc_e_reader_UPCEReader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(UPCEReader, _EANReader);

  var _super = upc_e_reader_createSuper(UPCEReader);

  function UPCEReader() {
    var _this;

    classCallCheck_default()(this, UPCEReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_FREQUENCY", [[56, 52, 50, 49, 44, 38, 35, 42, 41, 37], [7, 11, 13, 14, 19, 25, 28, 21, 22, 26]]);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7]);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'upc_e');

    return _this;
  }

  createClass_default()(UPCEReader, [{
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      var outCode = upc_e_reader_objectSpread({}, inCode);

      var codeFrequency = 0x0;

      for (var i = 0; i < 6; i++) {
        outCode = this._decodeCode(outCode.end);

        if (!outCode) {
          return null;
        }

        if (outCode.code >= CODE_G_START) {
          outCode.code = outCode.code - CODE_G_START;
          codeFrequency |= 1 << 5 - i;
        }

        result.push(outCode.code);
        decodedCodes.push(outCode);
      }

      if (!this._determineParity(codeFrequency, result)) {
        return null;
      }

      return outCode;
    }
  }, {
    key: "_determineParity",
    value: function _determineParity(codeFrequency, result) {
      for (var nrSystem = 0; nrSystem < this.CODE_FREQUENCY.length; nrSystem++) {
        for (var i = 0; i < this.CODE_FREQUENCY[nrSystem].length; i++) {
          if (codeFrequency === this.CODE_FREQUENCY[nrSystem][i]) {
            result.unshift(nrSystem);
            result.push(i);
            return true;
          }
        }
      }

      return false;
    }
  }, {
    key: "_convertToUPCA",
    value: function _convertToUPCA(result) {
      var upca = [result[0]];
      var lastDigit = result[result.length - 2];

      if (lastDigit <= 2) {
        upca = upca.concat(result.slice(1, 3)).concat([lastDigit, 0, 0, 0, 0]).concat(result.slice(3, 6));
      } else if (lastDigit === 3) {
        upca = upca.concat(result.slice(1, 4)).concat([0, 0, 0, 0, 0]).concat(result.slice(4, 6));
      } else if (lastDigit === 4) {
        upca = upca.concat(result.slice(1, 5)).concat([0, 0, 0, 0, 0, result[5]]);
      } else {
        upca = upca.concat(result.slice(1, 6)).concat([0, 0, 0, 0, lastDigit]);
      }

      upca.push(result[result.length - 1]);
      return upca;
    }
  }, {
    key: "_checksum",
    value: function _checksum(result) {
      return get_default()(getPrototypeOf_default()(UPCEReader.prototype), "_checksum", this).call(this, this._convertToUPCA(result));
    }
  }, {
    key: "_findEnd",
    value: function _findEnd(offset, isWhite) {
      return get_default()(getPrototypeOf_default()(UPCEReader.prototype), "_findEnd", this).call(this, offset, true);
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }]);

  return UPCEReader;
}(ean_reader);

/* harmony default export */ var upc_e_reader = (upc_e_reader_UPCEReader);
// CONCATENATED MODULE: ./src/reader/i2of5_reader.ts








function i2of5_reader_createSuper(Derived) { var hasNativeReflectConstruct = i2of5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function i2of5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

// TODO: i2of5_reader and 2of5_reader share very similar code, make use of that


var N = 1;
var W = 3;

var i2of5_reader_I2of5Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(I2of5Reader, _BarcodeReader);

  var _super = i2of5_reader_createSuper(I2of5Reader);

  function I2of5Reader(opts) {
    var _this;

    classCallCheck_default()(this, I2of5Reader);

    _this = _super.call(this, Object(lodash["merge"])({
      normalizeBarSpaceWidth: false
    }, opts));

    defineProperty_default()(assertThisInitialized_default()(_this), "barSpaceRatio", [1, 1]);

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.78);

    defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.38);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_PATTERN", [N, N, N, N]);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [N, N, W]);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_PATTERN", [[N, N, W, W, N], [W, N, N, N, W], [N, W, N, N, W], [W, W, N, N, N], [N, N, W, N, W], [W, N, W, N, N], [N, W, W, N, N], [N, N, N, W, W], [W, N, N, W, N], [N, W, N, W, N]]);

    defineProperty_default()(assertThisInitialized_default()(_this), "MAX_CORRECTION_FACTOR", 5);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'i2of5');

    if (opts.normalizeBarSpaceWidth) {
      _this.SINGLE_CODE_ERROR = 0.38;
      _this.AVG_CODE_ERROR = 0.09;
    }

    _this.config = opts;
    return possibleConstructorReturn_default()(_this, assertThisInitialized_default()(_this));
  }

  createClass_default()(I2of5Reader, [{
    key: "_matchPattern",
    value: function _matchPattern(counter, code) {
      if (this.config.normalizeBarSpaceWidth) {
        var counterSum = [0, 0];
        var codeSum = [0, 0];
        var correction = [0, 0];
        var correctionRatio = this.MAX_CORRECTION_FACTOR;
        var correctionRatioInverse = 1 / correctionRatio;

        for (var i = 0; i < counter.length; i++) {
          counterSum[i % 2] += counter[i];
          codeSum[i % 2] += code[i];
        }

        correction[0] = codeSum[0] / counterSum[0];
        correction[1] = codeSum[1] / counterSum[1];
        correction[0] = Math.max(Math.min(correction[0], correctionRatio), correctionRatioInverse);
        correction[1] = Math.max(Math.min(correction[1], correctionRatio), correctionRatioInverse);
        this.barSpaceRatio = correction;

        for (var _i = 0; _i < counter.length; _i++) {
          counter[_i] *= this.barSpaceRatio[_i % 2];
        }
      }

      return barcode_reader.prototype._matchPattern.call(this, counter, code);
    }
  }, {
    key: "_findPattern",
    value: function _findPattern(pattern, offset) {
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var counter = new Array(pattern.length).fill(0);
      var counterPos = 0;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };
      var epsilon = this.AVG_CODE_ERROR;
      isWhite = isWhite || false;
      tryHarder = tryHarder || false;

      if (!offset) {
        offset = this._nextSet(this._row);
      }

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            var sum = counter.reduce(function (prev, next) {
              return prev + next;
            }, 0);

            var error = this._matchPattern(counter, pattern);

            if (error < epsilon) {
              bestMatch.error = error;
              bestMatch.start = i - sum;
              bestMatch.end = i;
              return bestMatch;
            }

            if (tryHarder) {
              for (var j = 0; j < counter.length - 2; j++) {
                counter[j] = counter[j + 2];
              }

              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            } else {
              return null;
            }
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var leadingWhitespaceStart = 0;

      var offset = this._nextSet(this._row);

      var startInfo = null;
      var narrowBarWidth = 1;

      while (!startInfo) {
        startInfo = this._findPattern(this.START_PATTERN, offset, false, true);

        if (!startInfo) {
          return null;
        }

        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / 4);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 10;

        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            return startInfo;
          }
        }

        offset = startInfo.end;
        startInfo = null;
      }

      return null;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd() {
      this._row.reverse();

      var endInfo = this._findPattern(this.STOP_PATTERN);

      this._row.reverse();

      if (endInfo === null) {
        return null;
      } // reverse numbers


      var tmp = endInfo.start;
      endInfo.start = this._row.length - endInfo.end;
      endInfo.end = this._row.length - tmp;
      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_decodePair",
    value: function _decodePair(counterPair) {
      var codes = [];

      for (var i = 0; i < counterPair.length; i++) {
        var code = this._decodeCode(counterPair[i]);

        if (!code) {
          return null;
        }

        codes.push(code);
      }

      return codes;
    }
  }, {
    key: "_decodeCode",
    value: function _decodeCode(counter) {
      var epsilon = this.AVG_CODE_ERROR;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };

      for (var code = 0; code < this.CODE_PATTERN.length; code++) {
        var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

        if (error < bestMatch.error) {
          bestMatch.code = code;
          bestMatch.error = error;
        }
      }

      if (bestMatch.error < epsilon) {
        return bestMatch;
      }

      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(counters, result, decodedCodes) {
      var pos = 0;
      var counterLength = counters.length;
      var counterPair = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]];
      var codes = null;

      while (pos < counterLength) {
        for (var i = 0; i < 5; i++) {
          counterPair[0][i] = counters[pos] * this.barSpaceRatio[0];
          counterPair[1][i] = counters[pos + 1] * this.barSpaceRatio[1];
          pos += 2;
        }

        codes = this._decodePair(counterPair);

        if (!codes) {
          return null;
        }

        for (var _i2 = 0; _i2 < codes.length; _i2++) {
          result.push(codes[_i2].code + '');
          decodedCodes.push(codes[_i2]);
        }
      }

      return codes;
    }
  }, {
    key: "_verifyCounterLength",
    value: function _verifyCounterLength(counters) {
      return counters.length % 10 === 0;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var result = new Array();
      var decodedCodes = new Array();

      var startInfo = this._findStart();

      if (!startInfo) {
        return null;
      }

      decodedCodes.push(startInfo);

      var endInfo = this._findEnd();

      if (!endInfo) {
        return null;
      }

      var counters = this._fillCounters(startInfo.end, endInfo.start, false);

      if (!this._verifyCounterLength(counters)) {
        return null;
      }

      var code = this._decodePayload(counters, result, decodedCodes);

      if (!code) {
        return null;
      }

      if (result.length % 2 !== 0 || result.length < 6) {
        return null;
      }

      decodedCodes.push(endInfo);
      return {
        code: result.join(''),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        format: this.FORMAT
      };
    }
  }]);

  return I2of5Reader;
}(barcode_reader);

/* harmony default export */ var i2of5_reader = (i2of5_reader_I2of5Reader);
// CONCATENATED MODULE: ./src/reader/2of5_reader.ts








function _2of5_reader_createSuper(Derived) { var hasNativeReflectConstruct = _2of5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _2of5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var _2of5_reader_N = 1;
var _2of5_reader_W = 3;
var _2of5_reader_START_PATTERN = [_2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N];
var STOP_PATTERN = [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W];
var _2of5_reader_CODE_PATTERN = [[_2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_W, _2of5_reader_N], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N]];
var START_PATTERN_LENGTH = _2of5_reader_START_PATTERN.reduce(function (sum, val) {
  return sum + val;
}, 0);

var _2of5_reader_TwoOfFiveReader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(TwoOfFiveReader, _BarcodeReader);

  var _super = _2of5_reader_createSuper(TwoOfFiveReader);

  function TwoOfFiveReader() {
    var _this;

    classCallCheck_default()(this, TwoOfFiveReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "barSpaceRatio", [1, 1]);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", '2of5');

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.78);

    defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.30);

    return _this;
  }

  createClass_default()(TwoOfFiveReader, [{
    key: "_findPattern",
    value: function _findPattern(pattern, offset) {
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var counter = [];
      var counterPos = 0;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };
      var sum = 0;
      var error = 0;
      var epsilon = this.AVG_CODE_ERROR;

      if (!offset) {
        offset = this._nextSet(this._row);
      }

      for (var i = 0; i < pattern.length; i++) {
        counter[i] = 0;
      }

      for (var _i = offset; _i < this._row.length; _i++) {
        if (this._row[_i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            sum = 0;

            for (var j = 0; j < counter.length; j++) {
              sum += counter[j];
            }

            error = this._matchPattern(counter, pattern);

            if (error < epsilon) {
              bestMatch.error = error;
              bestMatch.start = _i - sum;
              bestMatch.end = _i;
              return bestMatch;
            }

            if (tryHarder) {
              for (var _j = 0; _j < counter.length - 2; _j++) {
                counter[_j] = counter[_j + 2];
              }

              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            } else {
              return null;
            }
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var startInfo = null;

      var offset = this._nextSet(this._row);

      var narrowBarWidth = 1;
      var leadingWhitespaceStart = 0;

      while (!startInfo) {
        startInfo = this._findPattern(_2of5_reader_START_PATTERN, offset, false, true);

        if (!startInfo) {
          return null;
        }

        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / START_PATTERN_LENGTH);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 5;

        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            return startInfo;
          }
        }

        offset = startInfo.end;
        startInfo = null;
      }

      return startInfo;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd() {
      // TODO: reverse, followed by some calcs, followed by another reverse? really?
      this._row.reverse();

      var offset = this._nextSet(this._row);

      var endInfo = this._findPattern(STOP_PATTERN, offset, false, true);

      this._row.reverse();

      if (endInfo === null) {
        return null;
      } // reverse numbers


      var tmp = endInfo.start;
      endInfo.start = this._row.length - endInfo.end;
      endInfo.end = this._row.length - tmp;
      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_verifyCounterLength",
    value: function _verifyCounterLength(counters) {
      return counters.length % 10 === 0;
    }
  }, {
    key: "_decodeCode",
    value: function _decodeCode(counter) {
      var epsilon = this.AVG_CODE_ERROR;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };

      for (var code = 0; code < _2of5_reader_CODE_PATTERN.length; code++) {
        var error = this._matchPattern(counter, _2of5_reader_CODE_PATTERN[code]);

        if (error < bestMatch.error) {
          bestMatch.code = code;
          bestMatch.error = error;
        }
      }

      if (bestMatch.error < epsilon) {
        return bestMatch;
      }

      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(counters, result, decodedCodes) {
      var pos = 0;
      var counterLength = counters.length;
      var counter = [0, 0, 0, 0, 0];
      var code = null;

      while (pos < counterLength) {
        for (var i = 0; i < 5; i++) {
          counter[i] = counters[pos] * this.barSpaceRatio[0];
          pos += 2;
        }

        code = this._decodeCode(counter);

        if (!code) {
          return null;
        }

        result.push("".concat(code.code));
        decodedCodes.push(code);
      }

      return code;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var startInfo = this._findStart();

      if (!startInfo) {
        return null;
      }

      var endInfo = this._findEnd();

      if (!endInfo) {
        return null;
      }

      var counters = this._fillCounters(startInfo.end, endInfo.start, false);

      if (!this._verifyCounterLength(counters)) {
        return null;
      }

      var decodedCodes = [];
      decodedCodes.push(startInfo);
      var result = [];

      var code = this._decodePayload(counters, result, decodedCodes);

      if (!code) {
        return null;
      }

      if (result.length < 5) {
        return null;
      }

      decodedCodes.push(endInfo);
      return {
        code: result.join(''),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        format: this.FORMAT
      };
    }
  }]);

  return TwoOfFiveReader;
}(barcode_reader);

/* harmony default export */ var _2of5_reader = (_2of5_reader_TwoOfFiveReader);
// CONCATENATED MODULE: ./src/reader/code_93_reader.ts









function code_93_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_93_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_93_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var code_93_reader_ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%abcd*';
var code_93_reader_ALPHABET = new Uint16Array(toConsumableArray_default()(code_93_reader_ALPHABETH_STRING).map(function (_char) {
  return _char.charCodeAt(0);
}));
var code_93_reader_CHARACTER_ENCODINGS = new Uint16Array([0x114, 0x148, 0x144, 0x142, 0x128, 0x124, 0x122, 0x150, 0x112, 0x10A, 0x1A8, 0x1A4, 0x1A2, 0x194, 0x192, 0x18A, 0x168, 0x164, 0x162, 0x134, 0x11A, 0x158, 0x14C, 0x146, 0x12C, 0x116, 0x1B4, 0x1B2, 0x1AC, 0x1A6, 0x196, 0x19A, 0x16C, 0x166, 0x136, 0x13A, 0x12E, 0x1D4, 0x1D2, 0x1CA, 0x16E, 0x176, 0x1AE, 0x126, 0x1DA, 0x1D6, 0x132, 0x15E]);
var code_93_reader_ASTERISK = 0x15E;

var code_93_reader_Code93Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(Code93Reader, _BarcodeReader);

  var _super = code_93_reader_createSuper(Code93Reader);

  function Code93Reader() {
    var _this;

    classCallCheck_default()(this, Code93Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_93');

    return _this;
  }

  createClass_default()(Code93Reader, [{
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < code_93_reader_CHARACTER_ENCODINGS.length; i++) {
        if (code_93_reader_CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(code_93_reader_ALPHABET[i]);
        }
      }

      return null;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(counters) {
      var numCounters = counters.length;
      var sum = counters.reduce(function (prev, next) {
        return prev + next;
      }, 0);
      var pattern = 0;

      for (var i = 0; i < numCounters; i++) {
        var normalized = Math.round(counters[i] * 9 / sum);

        if (normalized < 1 || normalized > 4) {
          return -1;
        }

        if ((i & 1) === 0) {
          for (var j = 0; j < normalized; j++) {
            pattern = pattern << 1 | 1;
          }
        } else {
          pattern <<= normalized;
        }
      }

      return pattern;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var offset = this._nextSet(this._row);

      var patternStart = offset;
      var counter = new Uint16Array([0, 0, 0, 0, 0, 0]);
      var counterPos = 0;
      var isWhite = false;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            // find start pattern
            if (this._toPattern(counter) === code_93_reader_ASTERISK) {
              var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));

              if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                return {
                  start: patternStart,
                  end: i
                };
              }
            }

            patternStart += counter[0] + counter[1];

            for (var j = 0; j < 4; j++) {
              counter[j] = counter[j + 2];
            }

            counter[4] = 0;
            counter[5] = 0;
            counterPos--;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_verifyEnd",
    value: function _verifyEnd(lastStart, nextStart) {
      if (lastStart === nextStart || !this._row[nextStart]) {
        return false;
      }

      return true;
    }
  }, {
    key: "_decodeExtended",
    value: function _decodeExtended(charArray) {
      var length = charArray.length;
      var result = [];

      for (var i = 0; i < length; i++) {
        var _char2 = charArray[i];

        if (_char2 >= 'a' && _char2 <= 'd') {
          if (i > length - 2) {
            return null;
          }

          var nextChar = charArray[++i];
          var nextCharCode = nextChar.charCodeAt(0);
          var decodedChar = void 0;

          switch (_char2) {
            case 'a':
              if (nextChar >= 'A' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(nextCharCode - 64);
              } else {
                return null;
              }

              break;

            case 'b':
              if (nextChar >= 'A' && nextChar <= 'E') {
                decodedChar = String.fromCharCode(nextCharCode - 38);
              } else if (nextChar >= 'F' && nextChar <= 'J') {
                decodedChar = String.fromCharCode(nextCharCode - 11);
              } else if (nextChar >= 'K' && nextChar <= 'O') {
                decodedChar = String.fromCharCode(nextCharCode + 16);
              } else if (nextChar >= 'P' && nextChar <= 'S') {
                decodedChar = String.fromCharCode(nextCharCode + 43);
              } else if (nextChar >= 'T' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(127);
              } else {
                return null;
              }

              break;

            case 'c':
              if (nextChar >= 'A' && nextChar <= 'O') {
                decodedChar = String.fromCharCode(nextCharCode - 32);
              } else if (nextChar === 'Z') {
                decodedChar = ':';
              } else {
                return null;
              }

              break;

            case 'd':
              if (nextChar >= 'A' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(nextCharCode + 32);
              } else {
                return null;
              }

              break;

            default:
              console.warn('* code_93_reader _decodeExtended hit default case, this may be an error', decodedChar);
              return null;
          }

          result.push(decodedChar);
        } else {
          result.push(_char2);
        }
      }

      return result;
    }
  }, {
    key: "_matchCheckChar",
    value: function _matchCheckChar(charArray, index, maxWeight) {
      var arrayToCheck = charArray.slice(0, index);
      var length = arrayToCheck.length;
      var weightedSums = arrayToCheck.reduce(function (sum, _char3, i) {
        var weight = (i * -1 + (length - 1)) % maxWeight + 1;
        var value = code_93_reader_ALPHABET.indexOf(_char3.charCodeAt(0));
        return sum + weight * value;
      }, 0);
      var checkChar = code_93_reader_ALPHABET[weightedSums % 47];
      return checkChar === charArray[index].charCodeAt(0);
    }
  }, {
    key: "_verifyChecksums",
    value: function _verifyChecksums(charArray) {
      return this._matchCheckChar(charArray, charArray.length - 2, 20) && this._matchCheckChar(charArray, charArray.length - 1, 15);
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      start = this._findStart();

      if (!start) {
        return null;
      }

      var counters = new Uint16Array([0, 0, 0, 0, 0, 0]);
      var result = [];

      var nextStart = this._nextSet(this._row, start.end);

      var lastStart;
      var decodedChar;

      do {
        counters = this._toCounters(nextStart, counters);

        var pattern = this._toPattern(counters);

        if (pattern < 0) {
          return null;
        }

        decodedChar = this._patternToChar(pattern);

        if (decodedChar === null) {
          return null;
        }

        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += array_helper["a" /* default */].sum(counters);
        nextStart = this._nextSet(this._row, nextStart);
      } while (decodedChar !== '*');

      result.pop();

      if (!result.length) {
        return null;
      }

      if (!this._verifyEnd(lastStart, nextStart)) {
        return null;
      }

      if (!this._verifyChecksums(result)) {
        return null;
      }

      result = result.slice(0, result.length - 2); // yes, this is an assign inside an if.

      if ((result = this._decodeExtended(result)) === null) {
        return null;
      }

      return {
        code: result.join(''),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT
      };
    }
  }]);

  return Code93Reader;
}(barcode_reader);

/* harmony default export */ var code_93_reader = (code_93_reader_Code93Reader);
// CONCATENATED MODULE: ./src/reader/code_32_reader.ts









function code_32_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_32_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_32_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var code_32_reader_patterns = {
  AEIO: /[AEIO]/g,
  AZ09: /[A-Z0-9]/
};
var code32set = '0123456789BCDFGHJKLMNPQRSTUVWXYZ';

var code_32_reader_Code32Reader = /*#__PURE__*/function (_Code39Reader) {
  inherits_default()(Code32Reader, _Code39Reader);

  var _super = code_32_reader_createSuper(Code32Reader);

  function Code32Reader() {
    var _this;

    classCallCheck_default()(this, Code32Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_32_reader');

    return _this;
  }

  createClass_default()(Code32Reader, [{
    key: "_decodeCode32",
    value: function _decodeCode32(code) {
      if (/[^0-9BCDFGHJKLMNPQRSTUVWXYZ]/.test(code)) {
        return null;
      }

      var res = 0;

      for (var i = 0; i < code.length; i++) {
        res = res * 32 + code32set.indexOf(code[i]);
      }

      var code32 = '' + res;

      if (code32.length < 9) {
        code32 = ('000000000' + code32).slice(-9);
      }

      return 'A' + code32;
    } // TODO (this was todo in original repo, no text was there. sorry.)

  }, {
    key: "_checkChecksum",
    value: function _checkChecksum(code) {
      return !!code;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var result = get_default()(getPrototypeOf_default()(Code32Reader.prototype), "_decode", this).call(this, row, start);

      if (!result) {
        return null;
      }

      var code = result.code;

      if (!code) {
        return null;
      }

      code = code.replace(code_32_reader_patterns.AEIO, '');

      if (!this._checkChecksum(code)) {
        return null;
      }

      var code32 = this._decodeCode32(code);

      if (!code32) {
        return null;
      }

      result.code = code32;
      return result;
    }
  }]);

  return Code32Reader;
}(code_39_reader);

/* harmony default export */ var code_32_reader = (code_32_reader_Code32Reader);
// CONCATENATED MODULE: ./src/decoder/barcode_decoder.js

















var READERS = {
  code_128_reader: code_128_reader,
  ean_reader: ean_reader,
  ean_5_reader: ean_5_reader,
  ean_2_reader: ean_2_reader,
  ean_8_reader: ean_8_reader,
  code_39_reader: code_39_reader,
  code_39_vin_reader: code_39_vin_reader,
  codabar_reader: codabar_reader,
  upc_reader: upc_reader,
  upc_e_reader: upc_e_reader,
  i2of5_reader: i2of5_reader,
  '2of5_reader': _2of5_reader,
  code_93_reader: code_93_reader,
  code_32_reader: code_32_reader
};
/* harmony default export */ var barcode_decoder = ({
  registerReader: function registerReader(name, reader) {
    READERS[name] = reader;
  },
  create: function create(config, inputImageWrapper) {
    var _canvas = {
      ctx: {
        frequency: null,
        pattern: null,
        overlay: null
      },
      dom: {
        frequency: null,
        pattern: null,
        overlay: null
      }
    };
    var _barcodeReaders = [];
    initCanvas();
    initReaders();
    initConfig();

    function initCanvas() {
      if ( true && typeof document !== 'undefined') {
        var $debug = document.querySelector('#debug.detection');
        _canvas.dom.frequency = document.querySelector('canvas.frequency');

        if (!_canvas.dom.frequency) {
          _canvas.dom.frequency = document.createElement('canvas');
          _canvas.dom.frequency.className = 'frequency';

          if ($debug) {
            $debug.appendChild(_canvas.dom.frequency);
          }
        }

        _canvas.ctx.frequency = _canvas.dom.frequency.getContext('2d');
        _canvas.dom.pattern = document.querySelector('canvas.patternBuffer');

        if (!_canvas.dom.pattern) {
          _canvas.dom.pattern = document.createElement('canvas');
          _canvas.dom.pattern.className = 'patternBuffer';

          if ($debug) {
            $debug.appendChild(_canvas.dom.pattern);
          }
        }

        _canvas.ctx.pattern = _canvas.dom.pattern.getContext('2d');
        _canvas.dom.overlay = document.querySelector('canvas.drawingBuffer');

        if (_canvas.dom.overlay) {
          _canvas.ctx.overlay = _canvas.dom.overlay.getContext('2d');
        }
      }
    }

    function initReaders() {
      config.readers.forEach(function (readerConfig) {
        var reader;
        var configuration = {};
        var supplements = [];

        if (typeof_default()(readerConfig) === 'object') {
          reader = readerConfig.format;
          configuration = readerConfig.config;
        } else if (typeof readerConfig === 'string') {
          reader = readerConfig;
        }

        if (true) {
          console.log('Before registering reader: ', reader);
        }

        if (configuration.supplements) {
          supplements = configuration.supplements.map(function (supplement) {
            return new READERS[supplement]();
          });
        }

        try {
          var readerObj = new READERS[reader](configuration, supplements);

          _barcodeReaders.push(readerObj);
        } catch (err) {
          console.error('* Error constructing reader ', reader, err);
          throw err;
        }
      });

      if (true) {
        console.log("Registered Readers: ".concat(_barcodeReaders.map(function (reader) {
          return JSON.stringify({
            format: reader.FORMAT,
            config: reader.config
          });
        }).join(', ')));
      }
    }

    function initConfig() {
      if ( true && typeof document !== 'undefined') {
        var i;
        var vis = [{
          node: _canvas.dom.frequency,
          prop: config.debug.showFrequency
        }, {
          node: _canvas.dom.pattern,
          prop: config.debug.showPattern
        }];

        for (i = 0; i < vis.length; i++) {
          if (vis[i].prop === true) {
            vis[i].node.style.display = 'block';
          } else {
            vis[i].node.style.display = 'none';
          }
        }
      }
    }
    /**
     * extend the line on both ends
     * @param {Array} line
     * @param {Number} angle
     */


    function getExtendedLine(line, angle, ext) {
      function extendLine(amount) {
        var extension = {
          y: amount * Math.sin(angle),
          x: amount * Math.cos(angle)
        };
        /* eslint-disable no-param-reassign */

        line[0].y -= extension.y;
        line[0].x -= extension.x;
        line[1].y += extension.y;
        line[1].x += extension.x;
        /* eslint-enable no-param-reassign */
      } // check if inside image


      extendLine(ext);

      while (ext > 1 && (!inputImageWrapper.inImageWithBorder(line[0]) || !inputImageWrapper.inImageWithBorder(line[1]))) {
        // eslint-disable-next-line no-param-reassign
        ext -= Math.ceil(ext / 2);
        extendLine(-ext);
      }

      return line;
    }

    function getLine(box) {
      return [{
        x: (box[1][0] - box[0][0]) / 2 + box[0][0],
        y: (box[1][1] - box[0][1]) / 2 + box[0][1]
      }, {
        x: (box[3][0] - box[2][0]) / 2 + box[2][0],
        y: (box[3][1] - box[2][1]) / 2 + box[2][1]
      }];
    }

    function tryDecode(line) {
      var result = null;
      var i;
      var barcodeLine = bresenham.getBarcodeLine(inputImageWrapper, line[0], line[1]);

      if ( true && config.debug.showFrequency) {
        image_debug["a" /* default */].drawPath(line, {
          x: 'x',
          y: 'y'
        }, _canvas.ctx.overlay, {
          color: 'red',
          lineWidth: 3
        });
        bresenham.debug.printFrequency(barcodeLine.line, _canvas.dom.frequency);
      }

      bresenham.toBinaryLine(barcodeLine);

      if ( true && config.debug.showPattern) {
        bresenham.debug.printPattern(barcodeLine.line, _canvas.dom.pattern);
      }

      for (i = 0; i < _barcodeReaders.length && result === null; i++) {
        result = _barcodeReaders[i].decodePattern(barcodeLine.line);
      }

      if (result === null) {
        return null;
      }

      return {
        codeResult: result,
        barcodeLine: barcodeLine
      };
    }
    /**
     * This method slices the given area apart and tries to detect a barcode-pattern
     * for each slice. It returns the decoded barcode, or null if nothing was found
     * @param {Array} box
     * @param {Array} line
     * @param {Number} lineAngle
     */


    function tryDecodeBruteForce(box, line, lineAngle) {
      var sideLength = Math.sqrt(Math.pow(box[1][0] - box[0][0], 2) + Math.pow(box[1][1] - box[0][1], 2));
      var i;
      var slices = 16;
      var result = null;
      var dir;
      var extension;
      var xdir = Math.sin(lineAngle);
      var ydir = Math.cos(lineAngle);

      for (i = 1; i < slices && result === null; i++) {
        // move line perpendicular to angle
        // eslint-disable-next-line no-mixed-operators
        dir = sideLength / slices * i * (i % 2 === 0 ? -1 : 1);
        extension = {
          y: dir * xdir,
          x: dir * ydir
        };
        /* eslint-disable no-param-reassign */

        line[0].y += extension.x;
        line[0].x -= extension.y;
        line[1].y += extension.x;
        line[1].x -= extension.y;
        /* eslint-enable no-param-reassign */

        result = tryDecode(line);
      }

      return result;
    }

    function getLineLength(line) {
      return Math.sqrt(Math.pow(Math.abs(line[1].y - line[0].y), 2) + Math.pow(Math.abs(line[1].x - line[0].x), 2));
    }

    function _decodeFromImage(imageWrapper) {
      var result = null;

      for (var i = 0; i < _barcodeReaders.length && result === null; i++) {
        result = _barcodeReaders[i].decodeImage ? _barcodeReaders[i].decodeImage(imageWrapper) : null;
      }

      return result;
    }
    /**
     * With the help of the configured readers (Code128 or EAN) this function tries to detect a
     * valid barcode pattern within the given area.
     * @param {Object} box The area to search in
     * @returns {Object} the result {codeResult, line, angle, pattern, threshold}
     */


    function _decodeFromBoundingBox(box) {
      var line;
      var ctx = _canvas.ctx.overlay;
      var result;

      if (true) {
        if (config.debug.drawBoundingBox && ctx) {
          image_debug["a" /* default */].drawPath(box, {
            x: 0,
            y: 1
          }, ctx, {
            color: 'blue',
            lineWidth: 2
          });
        }
      }

      line = getLine(box);
      var lineLength = getLineLength(line);
      var lineAngle = Math.atan2(line[1].y - line[0].y, line[1].x - line[0].x);
      line = getExtendedLine(line, lineAngle, Math.floor(lineLength * 0.1));

      if (line === null) {
        return null;
      }

      result = tryDecode(line);

      if (result === null) {
        result = tryDecodeBruteForce(box, line, lineAngle);
      }

      if (result === null) {
        return null;
      }

      if ( true && result && config.debug.drawScanline && ctx) {
        image_debug["a" /* default */].drawPath(line, {
          x: 'x',
          y: 'y'
        }, ctx, {
          color: 'red',
          lineWidth: 3
        });
      }

      return {
        codeResult: result.codeResult,
        line: line,
        angle: lineAngle,
        pattern: result.barcodeLine.line,
        threshold: result.barcodeLine.threshold
      };
    }

    return {
      decodeFromBoundingBox: function decodeFromBoundingBox(box) {
        return _decodeFromBoundingBox(box);
      },
      decodeFromBoundingBoxes: function decodeFromBoundingBoxes(boxes) {
        var i;
        var result;
        var barcodes = [];
        var multiple = config.multiple;

        for (i = 0; i < boxes.length; i++) {
          var box = boxes[i];
          result = _decodeFromBoundingBox(box) || {};
          result.box = box;

          if (multiple) {
            barcodes.push(result);
          } else if (result.codeResult) {
            return result;
          }
        }

        if (multiple) {
          return {
            barcodes: barcodes
          };
        }
      },
      decodeFromImage: function decodeFromImage(inputImageWrapper) {
        var result = _decodeFromImage(inputImageWrapper);

        return result;
      },
      registerReader: function registerReader(name, reader) {
        if (READERS[name]) {
          throw new Error('cannot register existing reader', name);
        }

        READERS[name] = reader;
      },
      setReaders: function setReaders(readers) {
        // eslint-disable-next-line no-param-reassign
        config.readers = readers;
        _barcodeReaders.length = 0;
        initReaders();
      }
    };
  }
});
// CONCATENATED MODULE: ./src/common/events.ts
/* harmony default export */ var events = ((function EventInterface() {
  var events = {};

  function getEvent(eventName) {
    if (!events[eventName]) {
      events[eventName] = {
        subscribers: []
      };
    }

    return events[eventName];
  }

  function clearEvents() {
    events = {};
  }

  function publishSubscription(subscription, data) {
    if (subscription.async) {
      setTimeout(function () {
        subscription.callback(data);
      }, 4);
    } else {
      subscription.callback(data);
    }
  }

  function _subscribe(event, callback, async) {
    var subscription;

    if (typeof callback === 'function') {
      subscription = {
        callback: callback,
        async: async
      };
    } else {
      subscription = callback;

      if (!subscription.callback) {
        throw new Error('Callback was not specified on options');
      }
    }

    getEvent(event).subscribers.push(subscription);
  }

  return {
    subscribe: function subscribe(event, callback, async) {
      return _subscribe(event, callback, async);
    },
    publish: function publish(eventName, data) {
      var event = getEvent(eventName);
      var subscribers = event.subscribers; // Publish one-time subscriptions

      subscribers.filter(function (subscriber) {
        return !!subscriber.once;
      }).forEach(function (subscriber) {
        publishSubscription(subscriber, data);
      }); // remove them from the subscriber

      event.subscribers = subscribers.filter(function (subscriber) {
        return !subscriber.once;
      }); // publish the rest

      event.subscribers.forEach(function (subscriber) {
        publishSubscription(subscriber, data);
      });
    },
    once: function once(event, callback) {
      var async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      _subscribe(event, {
        callback: callback,
        async: async,
        once: true
      });
    },
    unsubscribe: function unsubscribe(eventName, callback) {
      if (eventName) {
        var _event = getEvent(eventName);

        if (_event && callback) {
          _event.subscribers = _event.subscribers.filter(function (subscriber) {
            return subscriber.callback !== callback;
          });
        } else {
          _event.subscribers = [];
        }
      } else {
        clearEvents();
      }
    }
  };
})());
// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __webpack_require__(17);
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js
var asyncToGenerator = __webpack_require__(27);
var asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator);

// CONCATENATED MODULE: ./src/common/mediaDevices.ts
function enumerateDevices() {
  try {
    return navigator.mediaDevices.enumerateDevices();
  } catch (err) {
    return Promise.reject(new Error('enumerateDevices is not defined'));
  }
}
function getUserMedia(constraints) {
  try {
    return navigator.mediaDevices.getUserMedia(constraints);
  } catch (err) {
    return Promise.reject(new Error('getUserMedia is not defined'));
  }
}
// CONCATENATED MODULE: ./src/input/camera_access.ts




var streamRef;

function waitForVideo(video) {
  return new Promise(function (resolve, reject) {
    var attempts = 10;

    function checkVideo() {
      if (attempts > 0) {
        if (video.videoWidth > 10 && video.videoHeight > 10) {
          if (true) {
            console.log("* dev: checkVideo found ".concat(video.videoWidth, "px x ").concat(video.videoHeight, "px"));
          }

          resolve();
        } else {
          window.setTimeout(checkVideo, 500);
        }
      } else {
        reject(new Error('Unable to play video stream. Is webcam working?'));
      }

      attempts--;
    }

    checkVideo();
  });
}
/**
 * Tries to attach the camera-stream to a given video-element
 * and calls the callback function when the content is ready
 * @param {Object} constraints
 * @param {Object} video
 */


function initCamera(_x, _x2) {
  return _initCamera.apply(this, arguments);
}

function _initCamera() {
  _initCamera = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee2(video, constraints) {
    var stream;
    return regenerator_default.a.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return getUserMedia(constraints);

          case 2:
            stream = _context2.sent;
            streamRef = stream;
            video.setAttribute('autoplay', 'true');
            video.setAttribute('muted', 'true');
            video.setAttribute('playsinline', 'true'); // not listed on MDN...
            // eslint-disable-next-line no-param-reassign

            video.srcObject = stream;
            video.addEventListener('loadedmetadata', function () {
              video.play();
            });
            return _context2.abrupt("return", waitForVideo(video));

          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _initCamera.apply(this, arguments);
}

function deprecatedConstraints(videoConstraints) {
  var normalized = Object(lodash["pick"])(videoConstraints, ['width', 'height', 'facingMode', 'aspectRatio', 'deviceId']);

  if (typeof videoConstraints.minAspectRatio !== 'undefined' && videoConstraints.minAspectRatio > 0) {
    normalized.aspectRatio = videoConstraints.minAspectRatio;
    console.log('WARNING: Constraint \'minAspectRatio\' is deprecated; Use \'aspectRatio\' instead');
  }

  if (typeof videoConstraints.facing !== 'undefined') {
    normalized.facingMode = videoConstraints.facing;
    console.log('WARNING: Constraint \'facing\' is deprecated. Use \'facingMode\' instead\'');
  }

  return normalized;
} // TODO: #192 I don't think there's any good reason pickConstraints should return a Promise,
// I think it was just that way so it could be chained to other functions that did return a Promise.
// That's not necessary with async functions being a thing, so that should be fixed.


function pickConstraints() {
  var videoConstraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var video = deprecatedConstraints(videoConstraints);

  if (video && video.deviceId && video.facingMode) {
    delete video.facingMode;
  }

  return Promise.resolve({
    audio: false,
    video: video
  });
}

function enumerateVideoDevices() {
  return _enumerateVideoDevices.apply(this, arguments);
}

function _enumerateVideoDevices() {
  _enumerateVideoDevices = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee3() {
    var devices;
    return regenerator_default.a.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return enumerateDevices();

          case 2:
            devices = _context3.sent;
            return _context3.abrupt("return", devices.filter(function (device) {
              return device.kind === 'videoinput';
            }));

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _enumerateVideoDevices.apply(this, arguments);
}

function getActiveTrack() {
  if (!streamRef) {
    return null;
  }

  var tracks = streamRef.getVideoTracks();
  return tracks && (tracks === null || tracks === void 0 ? void 0 : tracks.length) ? tracks[0] : null;
}
/**
 * Used for accessing information about the active stream track and available video devices.
 */


var QuaggaJSCameraAccess = {
  request: function request(video, videoConstraints) {
    return asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee() {
      var newConstraints;
      return regenerator_default.a.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return pickConstraints(videoConstraints);

            case 2:
              newConstraints = _context.sent;
              return _context.abrupt("return", initCamera(video, newConstraints));

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
  },
  release: function release() {
    // TODO: i wonder if telling the Video element to pause() before calling MediaStreamTrack.stop() would alleviate some of the issues with the camera appearing to stay open on Android even after stopping.
    var tracks = streamRef && streamRef.getVideoTracks();

    if (tracks && tracks.length) {
      tracks[0].stop();
    }

    streamRef = null;
  },
  enumerateVideoDevices: enumerateVideoDevices,
  getActiveStreamLabel: function getActiveStreamLabel() {
    var track = getActiveTrack();
    return track ? track.label : '';
  },
  getActiveTrack: getActiveTrack
};
/* harmony default export */ var camera_access = (QuaggaJSCameraAccess);
// CONCATENATED MODULE: ./src/analytics/result_collector.ts


function contains(codeResult, list) {
  return list && list.some(function (item) {
    var keys = Object.keys(item);
    return keys.every(function (key) {
      return item[key] === codeResult[key];
    });
  });
}

function passesFilter(codeResult, filter) {
  return typeof filter === 'function' ? filter(codeResult) : true;
}

/* harmony default export */ var result_collector = ({
  create: function create(config) {
    var _config$capacity;

    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    var results = [];
    var capacity = (_config$capacity = config.capacity) !== null && _config$capacity !== void 0 ? _config$capacity : 20;
    var capture = config.capture === true;

    function matchesConstraints(codeResult) {
      return !!capacity && codeResult && !contains(codeResult, config.blacklist) && passesFilter(codeResult, config.filter);
    }

    return {
      addResult: function addResult(data, imageSize, codeResult) {
        var result = {}; // this is 'any' to avoid having to construct a whole QuaggaJSCodeResult :|

        if (matchesConstraints(codeResult)) {
          capacity--;
          result.codeResult = codeResult;

          if (capture) {
            canvas.width = imageSize.x;
            canvas.height = imageSize.y;
            image_debug["a" /* default */].drawImage(data, imageSize, ctx);
            result.frame = canvas.toDataURL();
          }

          results.push(result);
        }
      },
      getResults: function getResults() {
        return results;
      }
    };
  }
});
// CONCATENATED MODULE: ./src/config/config.dev.ts
var DevConfig = {
  inputStream: {
    name: 'Live',
    type: 'LiveStream',
    constraints: {
      width: 640,
      height: 480,
      // aspectRatio: 640/480, // optional
      facingMode: 'environment' // or user
      // deviceId: "38745983457387598375983759834"

    },
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read

  },
  locate: true,
  numOfWorkers: 0,
  decoder: {
    readers: ['code_128_reader'],
    debug: {
      drawBoundingBox: false,
      showFrequency: false,
      drawScanline: false,
      showPattern: false
    }
  },
  locator: {
    halfSample: true,
    patchSize: 'medium',
    // x-small, small, medium, large, x-large
    debug: {
      showCanvas: false,
      showPatches: false,
      showFoundPatches: false,
      showSkeleton: false,
      showLabels: false,
      showPatchLabels: false,
      showRemainingPatchLabels: false,
      boxFromPatches: {
        showTransformed: false,
        showTransformedBox: false,
        showBB: false
      }
    }
  }
};
/* harmony default export */ var config_dev = (DevConfig);
// CONCATENATED MODULE: ./src/config/config.node.ts
var NodeConfig = {
  inputStream: {
    type: 'ImageStream',
    sequence: false,
    size: 800,
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read

  },
  locate: true,
  numOfWorkers: 0,
  decoder: {
    readers: ['code_128_reader']
  },
  locator: {
    halfSample: true,
    patchSize: 'medium' // x-small, small, medium, large, x-large

  }
};
/* harmony default export */ var config_node = (NodeConfig);
// CONCATENATED MODULE: ./src/config/config.prod.ts
var ProdConfig = {
  inputStream: {
    name: 'Live',
    type: 'LiveStream',
    constraints: {
      width: 640,
      height: 480,
      // aspectRatio: 640/480, // optional
      facingMode: 'environment' // or user
      // deviceId: "38745983457387598375983759834"

    },
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read

  },
  locate: true,
  numOfWorkers: 4,
  decoder: {
    readers: ['code_128_reader']
  },
  locator: {
    halfSample: true,
    patchSize: 'medium' // x-small, small, medium, large, x-large

  }
};
/* harmony default export */ var config_prod = (ProdConfig);
// CONCATENATED MODULE: ./src/config/config.ts


 // @ts-ignore // TODO: this produces a bizarre typescript error
// eslint-disable-next-line no-nested-ternary

var QuaggaConfig =  true ? config_dev : undefined;
/* harmony default export */ var config_config = (QuaggaConfig);
// EXTERNAL MODULE: ./node_modules/gl-vec2/index.js
var gl_vec2 = __webpack_require__(7);

// CONCATENATED MODULE: ./src/QuaggaContext.ts


var QuaggaContext_QuaggaContext = function QuaggaContext() {
  classCallCheck_default()(this, QuaggaContext);

  defineProperty_default()(this, "config", void 0);

  defineProperty_default()(this, "inputStream", void 0);

  defineProperty_default()(this, "framegrabber", void 0);

  defineProperty_default()(this, "inputImageWrapper", void 0);

  defineProperty_default()(this, "stopped", false);

  defineProperty_default()(this, "boxSize", void 0);

  defineProperty_default()(this, "resultCollector", void 0);

  defineProperty_default()(this, "decoder", void 0);

  defineProperty_default()(this, "workerPool", []);

  defineProperty_default()(this, "onUIThread", true);

  defineProperty_default()(this, "canvasContainer", new QuaggaContext_CanvasContainer());
};
var QuaggaContext_CanvasInfo = function CanvasInfo() {
  classCallCheck_default()(this, CanvasInfo);

  defineProperty_default()(this, "image", void 0);

  defineProperty_default()(this, "overlay", void 0);
};
var QuaggaContext_CanvasContainer = function CanvasContainer() {
  classCallCheck_default()(this, CanvasContainer);

  defineProperty_default()(this, "ctx", void 0);

  defineProperty_default()(this, "dom", void 0);

  this.ctx = new QuaggaContext_CanvasInfo();
  this.dom = new QuaggaContext_CanvasInfo();
};
// EXTERNAL MODULE: ./src/locator/barcode_locator.js
var barcode_locator = __webpack_require__(23);

// CONCATENATED MODULE: ./src/quagga/initBuffers.ts



// TODO: need typescript def for BarcodeLocator
function initBuffers_initBuffers(inputStream, imageWrapper, locator) {
  var inputImageWrapper = imageWrapper || new image_wrapper["a" /* default */]({
    x: inputStream.getWidth(),
    y: inputStream.getHeight(),
    type: 'XYSize'
  });

  if (true) {
    console.log("image wrapper size ".concat(inputImageWrapper.size));
  }

  var boxSize = [Object(gl_vec2["clone"])([0, 0]), Object(gl_vec2["clone"])([0, inputImageWrapper.size.y]), Object(gl_vec2["clone"])([inputImageWrapper.size.x, inputImageWrapper.size.y]), Object(gl_vec2["clone"])([inputImageWrapper.size.x, 0])];
  barcode_locator["a" /* default */].init(inputImageWrapper, locator);
  return {
    inputImageWrapper: inputImageWrapper,
    boxSize: boxSize
  };
}
// CONCATENATED MODULE: ./src/quagga/getViewPort.ts
function getViewPort_getViewPort(target) {
  if (typeof document === 'undefined') {
    return null;
  } // Check if target is already a DOM element


  if (target instanceof HTMLElement && target.nodeName && target.nodeType === 1) {
    return target;
  } // Use '#interactive.viewport' as a fallback selector (backwards compatibility)


  var selector = typeof target === 'string' ? target : '#interactive.viewport';
  return document.querySelector(selector);
}
// CONCATENATED MODULE: ./src/quagga/initCanvas.ts


function findOrCreateCanvas(selector, className) {
  var canvas = document.querySelector(selector);

  if (!canvas) {
    canvas = document.createElement('canvas');
    canvas.className = className;
  }

  return canvas;
}

function getCanvasAndContext(selector, className) {
  var canvas = findOrCreateCanvas(selector, className);
  var context = canvas.getContext('2d');
  return {
    canvas: canvas,
    context: context
  };
}

function initCanvases(canvasSize) {
  if (typeof document !== 'undefined') {
    var image = getCanvasAndContext('canvas.imgBuffer', 'imgBuffer');
    var overlay = getCanvasAndContext('canvas.drawingBuffer', 'drawingBuffer');
    image.canvas.width = overlay.canvas.width = canvasSize.x;
    image.canvas.height = overlay.canvas.height = canvasSize.y;
    return {
      dom: {
        image: image.canvas,
        overlay: overlay.canvas
      },
      ctx: {
        image: image.context,
        overlay: overlay.context
      }
    };
  }

  return null;
}

function initCanvas_initCanvas(context) {
  var _context$config, _context$config$input, _context$config2, _context$config2$inpu;

  var viewport = getViewPort_getViewPort(context === null || context === void 0 ? void 0 : (_context$config = context.config) === null || _context$config === void 0 ? void 0 : (_context$config$input = _context$config.inputStream) === null || _context$config$input === void 0 ? void 0 : _context$config$input.target);
  var type = context === null || context === void 0 ? void 0 : (_context$config2 = context.config) === null || _context$config2 === void 0 ? void 0 : (_context$config2$inpu = _context$config2.inputStream) === null || _context$config2$inpu === void 0 ? void 0 : _context$config2$inpu.type;
  if (!type) return null;
  var container = initCanvases(context.inputStream.getCanvasSize());
  if (!container) return {
    dom: {
      image: null,
      overlay: null
    },
    ctx: {
      image: null,
      overlay: null
    }
  };
  var dom = container.dom;

  if (typeof document !== 'undefined') {
    if (viewport) {
      if (type === 'ImageStream' && !viewport.contains(dom.image)) {
        viewport.appendChild(dom.image);
      }

      if (!viewport.contains(dom.overlay)) {
        viewport.appendChild(dom.overlay);
      }
    }
  }

  return container;
}
// CONCATENATED MODULE: ./src/input/exif_helper.js
// NOTE: (SOME OF) THIS IS BROWSER ONLY CODE.  Node does not have 'atob' built in, nor XMLHttpRequest.
// How exactly is this set of functions used in Quagga? Do we need the browser specific code? Do we
// need to port any part of this that doesn't work in Node to node?
// Tags scraped from https://github.com/exif-js/exif-js
var ExifTags = {
  0x0112: 'orientation'
};
var AvailableTags = Object.keys(ExifTags).map(function (key) {
  return ExifTags[key];
});
function findTagsInObjectURL(src) {
  var tags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AvailableTags;

  if (/^blob:/i.test(src)) {
    return objectURLToBlob(src).then(readToBuffer).then(function (buffer) {
      return findTagsInBuffer(buffer, tags);
    });
  }

  return Promise.resolve(null);
}
function base64ToArrayBuffer(dataUrl) {
  var base64 = dataUrl.replace(/^data:([^;]+);base64,/gmi, '');
  var binary = atob(base64);
  var len = binary.length;
  var buffer = new ArrayBuffer(len);
  var view = new Uint8Array(buffer);

  for (var i = 0; i < len; i++) {
    view[i] = binary.charCodeAt(i);
  }

  return buffer;
}

function readToBuffer(blob) {
  return new Promise(function (resolve) {
    var fileReader = new FileReader();

    fileReader.onload = function (e) {
      return resolve(e.target.result);
    };

    fileReader.readAsArrayBuffer(blob);
  });
}

function objectURLToBlob(url) {
  return new Promise(function (resolve, reject) {
    var http = new XMLHttpRequest();
    http.open('GET', url, true);
    http.responseType = 'blob';

    http.onreadystatechange = function () {
      if (http.readyState === XMLHttpRequest.DONE && (http.status === 200 || http.status === 0)) {
        resolve(this.response);
      }
    };

    http.onerror = reject;
    http.send();
  });
}

function findTagsInBuffer(file) {
  var selectedTags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AvailableTags;
  var dataView = new DataView(file);
  var length = file.byteLength;
  var exifTags = selectedTags.reduce(function (result, selectedTag) {
    var exifTag = Object.keys(ExifTags).filter(function (tag) {
      return ExifTags[tag] === selectedTag;
    })[0];

    if (exifTag) {
      result[exifTag] = selectedTag;
    }

    return result;
  }, {});
  var offset = 2;
  var marker;

  if (dataView.getUint8(0) !== 0xFF || dataView.getUint8(1) !== 0xD8) {
    return false;
  }

  while (offset < length) {
    if (dataView.getUint8(offset) !== 0xFF) {
      return false;
    }

    marker = dataView.getUint8(offset + 1);

    if (marker === 0xE1) {
      return readEXIFData(dataView, offset + 4, exifTags);
    }

    offset += 2 + dataView.getUint16(offset + 2);
  }

  return false;
}

function readEXIFData(file, start, exifTags) {
  if (getStringFromBuffer(file, start, 4) !== 'Exif') {
    return false;
  }

  var tiffOffset = start + 6;
  var bigEnd;

  if (file.getUint16(tiffOffset) === 0x4949) {
    bigEnd = false;
  } else if (file.getUint16(tiffOffset) === 0x4D4D) {
    bigEnd = true;
  } else {
    return false;
  }

  if (file.getUint16(tiffOffset + 2, !bigEnd) !== 0x002A) {
    return false;
  }

  var firstIFDOffset = file.getUint32(tiffOffset + 4, !bigEnd);

  if (firstIFDOffset < 0x00000008) {
    return false;
  }

  var tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, exifTags, bigEnd);
  return tags;
}

function readTags(file, tiffStart, dirStart, strings, bigEnd) {
  var entries = file.getUint16(dirStart, !bigEnd);
  var tags = {};

  for (var i = 0; i < entries; i++) {
    var entryOffset = dirStart + i * 12 + 2;
    var tag = strings[file.getUint16(entryOffset, !bigEnd)];

    if (tag) {
      tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);
    }
  }

  return tags;
}

function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {
  var type = file.getUint16(entryOffset + 2, !bigEnd);
  var numValues = file.getUint32(entryOffset + 4, !bigEnd);

  switch (type) {
    case 3:
      if (numValues === 1) {
        return file.getUint16(entryOffset + 8, !bigEnd);
      }

  }

  return null;
}

function getStringFromBuffer(buffer, start, length) {
  var outstr = '';

  for (var n = start; n < start + length; n++) {
    outstr += String.fromCharCode(buffer.getUint8(n));
  }

  return outstr;
}
// CONCATENATED MODULE: ./src/input/image_loader.js

var ImageLoader = {};

ImageLoader.load = function (directory, callback, offset, size, sequence) {
  var htmlImagesSrcArray = new Array(size);
  var htmlImagesArray = new Array(htmlImagesSrcArray.length);
  var i;
  var img;
  var num;

  if (sequence === false) {
    htmlImagesSrcArray[0] = directory;
  } else {
    for (i = 0; i < htmlImagesSrcArray.length; i++) {
      num = offset + i;
      htmlImagesSrcArray[i] = "".concat(directory, "image-").concat("00".concat(num).slice(-3), ".jpg");
    }
  }

  htmlImagesArray.notLoaded = [];

  htmlImagesArray.addImage = function (image) {
    htmlImagesArray.notLoaded.push(image);
  };

  htmlImagesArray.loaded = function (loadedImg) {
    var notloadedImgs = htmlImagesArray.notLoaded;

    for (var x = 0; x < notloadedImgs.length; x++) {
      if (notloadedImgs[x] === loadedImg) {
        notloadedImgs.splice(x, 1);

        for (var y = 0; y < htmlImagesSrcArray.length; y++) {
          var imgName = htmlImagesSrcArray[y].substr(htmlImagesSrcArray[y].lastIndexOf('/'));

          if (loadedImg.src.lastIndexOf(imgName) !== -1) {
            htmlImagesArray[y] = {
              img: loadedImg
            };
            break;
          }
        }

        break;
      }
    }

    if (notloadedImgs.length === 0) {
      if (true) {
        console.log('Images loaded');
      }

      if (sequence === false) {
        findTagsInObjectURL(directory, ['orientation']).then(function (tags) {
          htmlImagesArray[0].tags = tags;
          callback(htmlImagesArray);
        })["catch"](function (e) {
          console.log(e);
          callback(htmlImagesArray);
        });
      } else {
        callback(htmlImagesArray);
      }
    }
  };

  for (i = 0; i < htmlImagesSrcArray.length; i++) {
    img = new Image();
    htmlImagesArray.addImage(img);
    addOnloadHandler(img, htmlImagesArray);
    img.src = htmlImagesSrcArray[i];
  }
};

function addOnloadHandler(img, htmlImagesArray) {
  img.onload = function () {
    htmlImagesArray.loaded(this);
  };
}

/* harmony default export */ var image_loader = (ImageLoader);
// CONCATENATED MODULE: ./src/input/input_stream/input_stream_browser.ts
/* eslint-disable @typescript-eslint/no-explicit-any */

var inputStreamFactory = {
  createVideoStream: function createVideoStream(video) {
    var _config = null;
    var _eventNames = ['canrecord', 'ended'];
    var _eventHandlers = {};

    var _calculatedWidth;

    var _calculatedHeight;

    var _topRight = {
      x: 0,
      y: 0,
      type: 'Point'
    };
    var _canvasSize = {
      x: 0,
      y: 0,
      type: 'XYSize'
    };

    function initSize() {
      var _config2, _config3;

      var width = video.videoWidth;
      var height = video.videoHeight; // eslint-disable-next-line no-nested-ternary

      _calculatedWidth = ((_config2 = _config) === null || _config2 === void 0 ? void 0 : _config2.size) ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width; // eslint-disable-next-line no-nested-ternary

      _calculatedHeight = ((_config3 = _config) === null || _config3 === void 0 ? void 0 : _config3.size) ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
      _canvasSize.x = _calculatedWidth;
      _canvasSize.y = _calculatedHeight;
    }

    var inputStream = {
      getRealWidth: function getRealWidth() {
        return video.videoWidth;
      },
      getRealHeight: function getRealHeight() {
        return video.videoHeight;
      },
      getWidth: function getWidth() {
        return _calculatedWidth;
      },
      getHeight: function getHeight() {
        return _calculatedHeight;
      },
      setWidth: function setWidth(width) {
        _calculatedWidth = width;
      },
      setHeight: function setHeight(height) {
        _calculatedHeight = height;
      },
      setInputStream: function setInputStream(config) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        _config = config; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

        this.setAttribute('src', typeof config.src !== 'undefined' ? config.src : '');
      },
      ended: function ended() {
        return video.ended;
      },
      getConfig: function getConfig() {
        return _config;
      },
      setAttribute: function setAttribute(name, value) {
        if (video) {
          video.setAttribute(name, value);
        }
      },
      pause: function pause() {
        video.pause();
      },
      play: function play() {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        video.play();
      },
      setCurrentTime: function setCurrentTime(time) {
        var _config4;

        if (((_config4 = _config) === null || _config4 === void 0 ? void 0 : _config4.type) !== 'LiveStream') {
          this.setAttribute('currentTime', time.toString());
        }
      },
      addEventListener: function addEventListener(event, f, bool) {
        if (_eventNames.indexOf(event) !== -1) {
          if (!_eventHandlers[event]) {
            _eventHandlers[event] = [];
          }

          _eventHandlers[event].push(f);
        } else {
          video.addEventListener(event, f, bool);
        }
      },
      clearEventHandlers: function clearEventHandlers() {
        _eventNames.forEach(function (eventName) {
          var handlers = _eventHandlers[eventName];

          if (handlers && handlers.length > 0) {
            handlers.forEach(function (handler) {
              video.removeEventListener(eventName, handler);
            });
          }
        });
      },
      trigger: function trigger(eventName, args) {
        var j; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

        var handlers = _eventHandlers[eventName];

        if (eventName === 'canrecord') {
          initSize();
        }

        if (handlers && handlers.length > 0) {
          for (j = 0; j < handlers.length; j++) {
            handlers[j].apply(inputStream, args);
          }
        }
      },
      setTopRight: function setTopRight(topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
      },
      getTopRight: function getTopRight() {
        return _topRight;
      },
      setCanvasSize: function setCanvasSize(size) {
        _canvasSize.x = size.x;
        _canvasSize.y = size.y;
      },
      getCanvasSize: function getCanvasSize() {
        return _canvasSize;
      },
      getFrame: function getFrame() {
        return video;
      }
    };
    return inputStream;
  },
  createLiveStream: function createLiveStream(video) {
    if (video) {
      video.setAttribute('autoplay', 'true');
    }

    var that = inputStreamFactory.createVideoStream(video);

    that.ended = function ended() {
      return false;
    };

    return that;
  },
  createImageStream: function createImageStream() {
    var _config = null;
    var width = 0;
    var height = 0;
    var frameIdx = 0;
    var paused = true;
    var loaded = false;
    var imgArray = null;
    var size = 0;
    var offset = 1;
    var baseUrl = null;
    var _ended = false;
    var calculatedWidth;
    var calculatedHeight;
    var _eventNames = ['canrecord', 'ended'];
    var _eventHandlers = {};
    var _topRight = {
      x: 0,
      y: 0,
      type: 'Point'
    };
    var _canvasSize = {
      x: 0,
      y: 0,
      type: 'XYSize'
    };

    function loadImages() {
      var _config7;

      loaded = false;
      image_loader.load(baseUrl, function (imgs) {
        var _config5, _config6;

        imgArray = imgs; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

        if (imgs[0].tags && imgs[0].tags.orientation) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          switch (imgs[0].tags.orientation) {
            case 6:
            case 8:
              width = imgs[0].img.height;
              height = imgs[0].img.width;
              break;

            default:
              width = imgs[0].img.width;
              height = imgs[0].img.height;
          }
        } else {
          width = imgs[0].img.width;
          height = imgs[0].img.height;
        } // eslint-disable-next-line no-nested-ternary


        calculatedWidth = ((_config5 = _config) === null || _config5 === void 0 ? void 0 : _config5.size) ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width; // eslint-disable-next-line no-nested-ternary

        calculatedHeight = ((_config6 = _config) === null || _config6 === void 0 ? void 0 : _config6.size) ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
        _canvasSize.x = calculatedWidth;
        _canvasSize.y = calculatedHeight;
        loaded = true;
        frameIdx = 0;
        setTimeout(function () {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          publishEvent('canrecord', []);
        }, 0);
      }, offset, size, (_config7 = _config) === null || _config7 === void 0 ? void 0 : _config7.sequence);
    }

    function publishEvent(eventName, args) {
      var j;
      var handlers = _eventHandlers[eventName];

      if (handlers && handlers.length > 0) {
        for (j = 0; j < handlers.length; j++) {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          handlers[j].apply(inputStream, args); // TODO: typescript complains that any[] is not valid for a second arg for apply?!
        }
      }
    } // TODO: any code shared with the first InputStream above should be shared not copied
    // TODO: publishEvent needs access to inputStream, but inputStream needs access to publishEvent
    // TODO: This is why it's a 'var', so it hoists back.  This is ugly, and should be changed.
    // eslint-disable-next-line no-var,vars-on-top


    var inputStream = {
      trigger: publishEvent,
      getWidth: function getWidth() {
        return calculatedWidth;
      },
      getHeight: function getHeight() {
        return calculatedHeight;
      },
      setWidth: function setWidth(newWidth) {
        calculatedWidth = newWidth;
      },
      setHeight: function setHeight(newHeight) {
        calculatedHeight = newHeight;
      },
      getRealWidth: function getRealWidth() {
        return width;
      },
      getRealHeight: function getRealHeight() {
        return height;
      },
      setInputStream: function setInputStream(stream) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        _config = stream; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

        if (stream.sequence === false) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
          baseUrl = stream.src;
          size = 1;
        } else {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
          baseUrl = stream.src; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access

          size = stream.length;
        }

        loadImages();
      },
      ended: function ended() {
        return _ended;
      },
      setAttribute: function setAttribute() {},
      getConfig: function getConfig() {
        return _config;
      },
      pause: function pause() {
        paused = true;
      },
      play: function play() {
        paused = false;
      },
      setCurrentTime: function setCurrentTime(time) {
        frameIdx = time;
      },
      addEventListener: function addEventListener(event, f) {
        if (_eventNames.indexOf(event) !== -1) {
          if (!_eventHandlers[event]) {
            _eventHandlers[event] = [];
          }

          _eventHandlers[event].push(f);
        }
      },
      clearEventHandlers: function clearEventHandlers() {
        Object.keys(_eventHandlers).forEach(function (ind) {
          return delete _eventHandlers[ind];
        });
      },
      setTopRight: function setTopRight(topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
      },
      getTopRight: function getTopRight() {
        return _topRight;
      },
      setCanvasSize: function setCanvasSize(canvasSize) {
        _canvasSize.x = canvasSize.x;
        _canvasSize.y = canvasSize.y;
      },
      getCanvasSize: function getCanvasSize() {
        return _canvasSize;
      },
      getFrame: function getFrame() {
        var frame;

        if (!loaded) {
          return null;
        }

        if (!paused) {
          var _imgArray;

          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          frame = (_imgArray = imgArray) === null || _imgArray === void 0 ? void 0 : _imgArray[frameIdx];

          if (frameIdx < size - 1) {
            frameIdx++;
          } else {
            setTimeout(function () {
              _ended = true;
              publishEvent('ended', []);
            }, 0);
          }
        } // eslint-disable-next-line @typescript-eslint/no-unsafe-return


        return frame;
      }
    };
    return inputStream;
  }
};
/* harmony default export */ var input_stream_browser = (inputStreamFactory);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/slicedToArray.js
var slicedToArray = __webpack_require__(25);
var slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);

// EXTERNAL MODULE: ./node_modules/get-pixels/dom-pixels.js
var dom_pixels = __webpack_require__(66);
var dom_pixels_default = /*#__PURE__*/__webpack_require__.n(dom_pixels);

// CONCATENATED MODULE: ./src/input/input_stream/input_stream_node.ts

// TODO: It's pretty likely that this shares code with the browser version, investigate that

var input_stream_node_inputStreamFactory = {
  createVideoStream: function createVideoStream() {
    throw new Error('createVideoStream not available');
  },
  createLiveStream: function createLiveStream() {
    throw new Error('createLiveStream not available');
  },
  createImageStream: function createImageStream() {
    var _config = null;
    var width = 0;
    var height = 0;
    var loaded = false; // TODO: frame should be a type NdArray, but NdArray doesn't have ts definitions
    // TODO: there is a ts-ndarray that might work, though

    var frame = null;
    var baseUrl;
    var _ended = false;
    var calculatedWidth;
    var calculatedHeight;
    var _eventNames = ['canrecord', 'ended'];
    var _eventHandlers = {};
    var _topRight = {
      x: 0,
      y: 0,
      type: 'Point'
    };
    var _canvasSize = {
      x: 0,
      y: 0,
      type: 'XYSize'
    };
    /* eslint-disable no-unused-vars */
    // false eslint errors? weird.
    // @ts-ignore

    var size = 0; // @ts-ignore

    var frameIdx = 0; // @ts-ignore

    var paused = false;
    /* eslint-enable no-unused-vars */

    function loadImages() {
      var _config2;

      loaded = false;
      /* eslint-disable new-cap */

      dom_pixels_default()(baseUrl, (_config2 = _config) === null || _config2 === void 0 ? void 0 : _config2.mime, function (err, pixels) {
        var _config3, _config4;

        if (err) {
          console.error('**** quagga loadImages error:', err);
          throw new Error('error decoding pixels in loadImages');
        }

        loaded = true;

        if (true) {
          console.log('* InputStreamNode pixels.shape', pixels.shape);
        } // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment


        frame = pixels; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access

        var _pixels$shape = slicedToArray_default()(pixels.shape, 2);

        width = _pixels$shape[0];
        height = _pixels$shape[1];
        // eslint-disable-next-line no-nested-ternary
        calculatedWidth = ((_config3 = _config) === null || _config3 === void 0 ? void 0 : _config3.size) ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width; // eslint-disable-next-line no-nested-ternary

        calculatedHeight = ((_config4 = _config) === null || _config4 === void 0 ? void 0 : _config4.size) ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
        _canvasSize.x = calculatedWidth;
        _canvasSize.y = calculatedHeight;
        setTimeout(function () {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          publishEvent('canrecord', []);
        }, 0);
      });
    }

    function publishEvent(eventName, args) {
      var handlers = _eventHandlers[eventName];

      if (handlers && handlers.length > 0) {
        for (var j = 0; j < handlers.length; j++) {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          handlers[j].apply(inputStream, args);
        }
      }
    } // eslint-disable-next-line no-var,vars-on-top


    var inputStream = {
      trigger: publishEvent,
      getWidth: function getWidth() {
        return calculatedWidth;
      },
      getHeight: function getHeight() {
        return calculatedHeight;
      },
      setWidth: function setWidth(w) {
        calculatedWidth = w;
      },
      setHeight: function setHeight(h) {
        calculatedHeight = h;
      },
      getRealWidth: function getRealWidth() {
        return width;
      },
      getRealHeight: function getRealHeight() {
        return height;
      },
      setInputStream: function setInputStream(stream) {
        var _config5;

        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        _config = stream; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access

        baseUrl = (_config5 = _config) === null || _config5 === void 0 ? void 0 : _config5.src;
        size = 1;
        loadImages();
      },
      ended: function ended() {
        return _ended;
      },
      setAttribute: function setAttribute() {},
      getConfig: function getConfig() {
        return _config;
      },
      pause: function pause() {
        paused = true;
      },
      play: function play() {
        paused = false;
      },
      setCurrentTime: function setCurrentTime(time) {
        frameIdx = time;
      },
      addEventListener: function addEventListener(event, f) {
        if (_eventNames.indexOf(event) !== -1) {
          if (!_eventHandlers[event]) {
            _eventHandlers[event] = [];
          }

          _eventHandlers[event].push(f);
        }
      },
      clearEventHandlers: function clearEventHandlers() {
        Object.keys(_eventHandlers).forEach(function (ind) {
          return delete _eventHandlers[ind];
        });
      },
      setTopRight: function setTopRight(topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
      },
      getTopRight: function getTopRight() {
        return _topRight;
      },
      setCanvasSize: function setCanvasSize(sz) {
        _canvasSize.x = sz.x;
        _canvasSize.y = sz.y;
      },
      getCanvasSize: function getCanvasSize() {
        return _canvasSize;
      },
      getFrame: function getFrame() {
        if (!loaded) {
          return null;
        } // eslint-disable-next-line @typescript-eslint/no-unsafe-return


        return frame;
      }
    };
    return inputStream;
  }
};
/* harmony default export */ var input_stream_node = (input_stream_node_inputStreamFactory);
// CONCATENATED MODULE: ./src/input/input_stream_factory.ts


/* harmony default export */ var input_stream_factory = (input_stream_browser);

// EXTERNAL MODULE: ./src/input/frame_grabber_node.js
var frame_grabber_node = __webpack_require__(62);
var frame_grabber_node_default = /*#__PURE__*/__webpack_require__.n(frame_grabber_node);

// EXTERNAL MODULE: ./src/common/cv_utils.js + 1 modules
var cv_utils = __webpack_require__(8);

// CONCATENATED MODULE: ./src/input/frame_grabber.js


var TO_RADIANS = Math.PI / 180;

function adjustCanvasSize(canvas, targetSize) {
  if (canvas.width !== targetSize.x) {
    if (true) {
      console.log('WARNING: canvas-size needs to be adjusted');
    }

    canvas.width = targetSize.x;
  }

  if (canvas.height !== targetSize.y) {
    if (true) {
      console.log('WARNING: canvas-size needs to be adjusted');
    }

    canvas.height = targetSize.y;
  }
}

var FrameGrabber = {};

FrameGrabber.create = function (inputStream, canvas) {
  var _that = {};

  var _streamConfig = inputStream.getConfig();

  var _videoSize = Object(cv_utils["imageRef"])(inputStream.getRealWidth(), inputStream.getRealHeight());

  var _canvasSize = inputStream.getCanvasSize();

  var _size = Object(cv_utils["imageRef"])(inputStream.getWidth(), inputStream.getHeight());

  var topRight = inputStream.getTopRight();
  var _sx = topRight.x;
  var _sy = topRight.y;

  var _canvas;

  var _ctx = null;
  var _data = null;
  _canvas = canvas || document.createElement('canvas');
  _canvas.width = _canvasSize.x;
  _canvas.height = _canvasSize.y;
  _ctx = _canvas.getContext('2d');
  _data = new Uint8Array(_size.x * _size.y);

  if (true) {
    console.log('FrameGrabber', JSON.stringify({
      size: _size,
      topRight: topRight,
      videoSize: _videoSize,
      canvasSize: _canvasSize
    }));
  }
  /**
   * Uses the given array as frame-buffer
   */


  _that.attachData = function (data) {
    _data = data;
  };
  /**
   * Returns the used frame-buffer
   */


  _that.getData = function () {
    return _data;
  };
  /**
   * Fetches a frame from the input-stream and puts into the frame-buffer.
   * The image-data is converted to gray-scale and then half-sampled if configured.
   */


  _that.grab = function () {
    var doHalfSample = _streamConfig.halfSample;
    var frame = inputStream.getFrame();
    var drawable = frame;
    var drawAngle = 0;
    var ctxData;

    if (drawable) {
      adjustCanvasSize(_canvas, _canvasSize);

      if (_streamConfig.type === 'ImageStream') {
        drawable = frame.img;

        if (frame.tags && frame.tags.orientation) {
          switch (frame.tags.orientation) {
            case 6:
              drawAngle = 90 * TO_RADIANS;
              break;

            case 8:
              drawAngle = -90 * TO_RADIANS;
              break;
          }
        }
      }

      if (drawAngle !== 0) {
        _ctx.translate(_canvasSize.x / 2, _canvasSize.y / 2);

        _ctx.rotate(drawAngle);

        _ctx.drawImage(drawable, -_canvasSize.y / 2, -_canvasSize.x / 2, _canvasSize.y, _canvasSize.x);

        _ctx.rotate(-drawAngle);

        _ctx.translate(-_canvasSize.x / 2, -_canvasSize.y / 2);
      } else {
        _ctx.drawImage(drawable, 0, 0, _canvasSize.x, _canvasSize.y);
      }

      ctxData = _ctx.getImageData(_sx, _sy, _size.x, _size.y).data;

      if (doHalfSample) {
        Object(cv_utils["grayAndHalfSampleFromCanvasData"])(ctxData, _size, _data);
      } else {
        Object(cv_utils["computeGray"])(ctxData, _data, _streamConfig);
      }

      return true;
    }

    return false;
  };

  _that.getSize = function () {
    return _size;
  };

  return _that;
};

/* harmony default export */ var frame_grabber = (FrameGrabber);

// CONCATENATED MODULE: ./src/quagga/qworker.ts


function qworker_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function qworker_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { qworker_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { qworker_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/* Worker functions. These are straight from the original quagga.js file.
 * Not presently used, as worker support is non-functional.  Keeping them around temporarily
 * to refer to until it is re-implemented. We may be able to fix/use some of this.
 */
// TODO: need a typescript interface for FrameGrabber
var workerPool = [];
function updateWorkers(frameGrabber) {
  var availableWorker;

  if (workerPool.length) {
    availableWorker = workerPool.filter(function (workerThread) {
      return !workerThread.busy;
    })[0];

    if (availableWorker) {
      frameGrabber.attachData(availableWorker.imageData);

      if (frameGrabber.grab()) {
        availableWorker.busy = true;
        availableWorker.worker.postMessage({
          cmd: 'process',
          imageData: availableWorker.imageData
        }, [availableWorker.imageData.buffer]);
      }

      return true;
    } else {
      return false;
    }
  }

  return null;
}

function configForWorker(config) {
  return qworker_objectSpread(qworker_objectSpread({}, config), {}, {
    inputStream: qworker_objectSpread(qworker_objectSpread({}, config.inputStream), {}, {
      target: null
    })
  });
} // @ts-ignore


function workerInterface(factory) {
  if (factory) {
    var Quagga = factory()["default"];

    if (!Quagga) {
      // @ts-ignore
      self.postMessage({
        'event': 'error',
        message: 'Quagga could not be created'
      });
      return;
    }
  } // @ts-ignore


  var imageWrapper; // @ts-ignore

  function onProcessed(result) {
    self.postMessage({
      'event': 'processed',
      // @ts-ignore
      imageData: imageWrapper.data,
      result: result // @ts-ignore

    }, [imageWrapper.data.buffer]);
  }

  function workerInterfaceReady() {
    self.postMessage({
      'event': 'initialized',
      // @ts-ignore
      imageData: imageWrapper.data // @ts-ignore

    }, [imageWrapper.data.buffer]);
  } // @ts-ignore


  self.onmessage = function (e) {
    if (e.data.cmd === 'init') {
      var config = e.data.config;
      config.numOfWorkers = 0;
      imageWrapper = new Quagga.ImageWrapper({
        x: e.data.size.x,
        y: e.data.size.y
      }, new Uint8Array(e.data.imageData));
      Quagga.init(config, workerInterfaceReady, imageWrapper);
      Quagga.onProcessed(onProcessed);
    } else if (e.data.cmd === 'process') {
      // @ts-ignore
      imageWrapper.data = new Uint8Array(e.data.imageData);
      Quagga.start();
    } else if (e.data.cmd === 'setReaders') {
      Quagga.setReaders(e.data.readers);
    } else if (e.data.cmd === 'registerReader') {
      Quagga.registerReader(e.data.name, e.data.reader);
    }
  };
}

function generateWorkerBlob() {
  var blob, factorySource;
  /* jshint ignore:start */
  // @ts-ignore

  if (typeof __factorySource__ !== 'undefined') {
    // @ts-ignore
    factorySource = __factorySource__; // eslint-disable-line no-undef
  }
  /* jshint ignore:end */


  blob = new Blob(['(' + workerInterface.toString() + ')(' + factorySource + ');'], {
    type: 'text/javascript'
  });
  return window.URL.createObjectURL(blob);
}

function initWorker(config, inputStream, cb) {
  var blobURL = generateWorkerBlob();
  var worker = new Worker(blobURL);
  var workerThread = {
    worker: worker,
    imageData: new Uint8Array(inputStream.getWidth() * inputStream.getHeight()),
    busy: true
  };

  workerThread.worker.onmessage = function (e) {
    if (e.data.event === 'initialized') {
      URL.revokeObjectURL(blobURL);
      workerThread.busy = false;
      workerThread.imageData = new Uint8Array(e.data.imageData);

      if (true) {
        console.log('Worker initialized');
      }

      cb(workerThread);
    } else if (e.data.event === 'processed') {
      workerThread.imageData = new Uint8Array(e.data.imageData);
      workerThread.busy = false; // TODO: how to thread publishResult into here?
      // publishResult(e.data.result, workerThread.imageData);
    } else if (e.data.event === 'error') {
      if (true) {
        console.log('Worker error: ' + e.data.message);
      }
    }
  };

  workerThread.worker.postMessage({
    cmd: 'init',
    size: {
      x: inputStream.getWidth(),
      y: inputStream.getHeight()
    },
    imageData: workerThread.imageData,
    config: configForWorker(config)
  }, [workerThread.imageData.buffer]);
}
function adjustWorkerPool(capacity, config, inputStream, cb) {
  var increaseBy = capacity - workerPool.length;

  if (increaseBy === 0 && cb) {
    cb();
  } else if (increaseBy < 0) {
    var workersToTerminate = workerPool.slice(increaseBy);
    workersToTerminate.forEach(function (workerThread) {
      workerThread.worker.terminate();

      if (true) {
        console.log('Worker terminated!');
      }
    });
    workerPool = workerPool.slice(0, increaseBy);

    if (cb) {
      cb();
    }
  } else {
    var workerInitialized = function workerInitialized(workerThread) {
      workerPool.push(workerThread);

      if (workerPool.length >= capacity && cb) {
        cb();
      }
    };

    if (config) {
      for (var i = 0; i < increaseBy; i++) {
        initWorker(config, inputStream, workerInitialized);
      }
    }
  }
}
function qworker_setReaders(readers) {
  workerPool.forEach(function (workerThread) {
    return workerThread.worker.postMessage({
      cmd: 'setReaders',
      readers: readers
    });
  });
}
function qworker_registerReader(name, reader) {
  workerPool.forEach(function (workerThread) {
    return workerThread.worker.postMessage({
      cmd: 'registerReader',
      name: name,
      reader: reader
    });
  });
}
// CONCATENATED MODULE: ./src/quagga/setupInputStream.ts
// TODO: need to create an InputStream typescript interface, so we don't have an "any" in the next line
function setupInputStream() {
  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'LiveStream';
  var viewport = arguments.length > 1 ? arguments[1] : undefined;
  var InputStream = arguments.length > 2 ? arguments[2] : undefined;

  switch (type) {
    case 'VideoStream':
      {
        var video = document.createElement('video');
        return {
          video: video,
          inputStream: InputStream.createVideoStream(video)
        };
      }

    case 'ImageStream':
      return {
        inputStream: InputStream.createImageStream()
      };

    case 'LiveStream':
      {
        var _video = null;

        if (viewport) {
          _video = viewport.querySelector('video');

          if (!_video) {
            _video = document.createElement('video');
            viewport.appendChild(_video);
          }
        }

        return {
          video: _video,
          inputStream: InputStream.createLiveStream(_video)
        };
      }

    default:
      console.error("* setupInputStream invalid type ".concat(type));
      return {
        video: null,
        inputStream: null
      };
  }
}
// CONCATENATED MODULE: ./src/quagga/transform.ts
/* eslint-disable no-param-reassign */
function moveBox(box, xOffset, yOffset) {
  var corner = box.length;

  while (corner--) {
    box[corner][0] += xOffset;
    box[corner][1] += yOffset;
  }
}
function moveLine(line, xOffset, yOffset) {
  line[0].x += xOffset;
  line[0].y += yOffset;
  line[1].x += xOffset;
  line[1].y += yOffset;
}
// CONCATENATED MODULE: ./src/quagga/quagga.ts

















var InputStream = typeof window === 'undefined' ? input_stream_node : input_stream_factory;
var quagga_FrameGrabber = typeof window === 'undefined' ? frame_grabber_node_default.a : frame_grabber;

var quagga_Quagga = /*#__PURE__*/function () {
  function Quagga() {
    var _this = this;

    classCallCheck_default()(this, Quagga);

    defineProperty_default()(this, "context", new QuaggaContext_QuaggaContext());

    defineProperty_default()(this, "canRecord", function (callback) {
      var _this$context$config;

      if (!_this.context.config) {
        return;
      }

      barcode_locator["a" /* default */].checkImageConstraints(_this.context.inputStream, (_this$context$config = _this.context.config) === null || _this$context$config === void 0 ? void 0 : _this$context$config.locator);

      _this.initCanvas();

      _this.context.framegrabber = quagga_FrameGrabber.create(_this.context.inputStream, _this.context.canvasContainer.dom.image);

      if (_this.context.config.numOfWorkers === undefined) {
        _this.context.config.numOfWorkers = 0;
      }

      adjustWorkerPool(_this.context.config.numOfWorkers, _this.context.config, _this.context.inputStream, function () {
        var _this$context$config2;

        if (((_this$context$config2 = _this.context.config) === null || _this$context$config2 === void 0 ? void 0 : _this$context$config2.numOfWorkers) === 0) {
          _this.initializeData();
        }

        _this.ready(callback);
      });
    });

    defineProperty_default()(this, "update", function () {
      if (_this.context.onUIThread) {
        var workersUpdated = updateWorkers(_this.context.framegrabber);

        if (!workersUpdated) {
          var _this$context$inputIm;

          _this.context.framegrabber.attachData((_this$context$inputIm = _this.context.inputImageWrapper) === null || _this$context$inputIm === void 0 ? void 0 : _this$context$inputIm.data);

          if (_this.context.framegrabber.grab()) {
            if (!workersUpdated) {
              _this.locateAndDecode();
            }
          }
        }
      } else {
        var _this$context$inputIm2;

        _this.context.framegrabber.attachData((_this$context$inputIm2 = _this.context.inputImageWrapper) === null || _this$context$inputIm2 === void 0 ? void 0 : _this$context$inputIm2.data);

        _this.context.framegrabber.grab();

        _this.locateAndDecode();
      }
    });
  }

  createClass_default()(Quagga, [{
    key: "initBuffers",
    value: function initBuffers(imageWrapper) {
      if (!this.context.config) {
        return;
      }

      var _initBuffers2 = initBuffers_initBuffers(this.context.inputStream, imageWrapper, this.context.config.locator),
          inputImageWrapper = _initBuffers2.inputImageWrapper,
          boxSize = _initBuffers2.boxSize;

      this.context.inputImageWrapper = inputImageWrapper;
      this.context.boxSize = boxSize;
    }
  }, {
    key: "initializeData",
    value: function initializeData(imageWrapper) {
      if (!this.context.config) {
        return;
      }

      this.initBuffers(imageWrapper);
      this.context.decoder = barcode_decoder.create(this.context.config.decoder, this.context.inputImageWrapper);
    }
  }, {
    key: "getViewPort",
    value: function getViewPort() {
      if (!this.context.config || !this.context.config.inputStream) {
        return null;
      }

      var target = this.context.config.inputStream.target;
      return getViewPort_getViewPort(target);
    }
  }, {
    key: "ready",
    value: function ready(callback) {
      this.context.inputStream.play();
      callback();
    }
  }, {
    key: "initCanvas",
    value: function initCanvas() {
      var container = initCanvas_initCanvas(this.context);

      if (!container) {
        return;
      }

      var ctx = container.ctx,
          dom = container.dom;
      this.context.canvasContainer.dom.image = dom.image;
      this.context.canvasContainer.dom.overlay = dom.overlay;
      this.context.canvasContainer.ctx.image = ctx.image;
      this.context.canvasContainer.ctx.overlay = ctx.overlay;
    }
  }, {
    key: "initInputStream",
    value: function initInputStream(callback) {
      if (!this.context.config || !this.context.config.inputStream) {
        return;
      }

      var _this$context$config$ = this.context.config.inputStream,
          inputType = _this$context$config$.type,
          constraints = _this$context$config$.constraints;

      var _setupInputStream = setupInputStream(inputType, this.getViewPort(), InputStream),
          video = _setupInputStream.video,
          inputStream = _setupInputStream.inputStream;

      if (inputType === 'LiveStream' && video) {
        camera_access.request(video, constraints).then(function () {
          return inputStream.trigger('canrecord');
        })["catch"](function (err) {
          return callback(err);
        });
      }

      inputStream.setAttribute('preload', 'auto');
      inputStream.setInputStream(this.context.config.inputStream);
      inputStream.addEventListener('canrecord', this.canRecord.bind(undefined, callback));
      this.context.inputStream = inputStream;
    }
  }, {
    key: "getBoundingBoxes",
    value: function getBoundingBoxes() {
      var _this$context$config3;

      return ((_this$context$config3 = this.context.config) === null || _this$context$config3 === void 0 ? void 0 : _this$context$config3.locate) ? barcode_locator["a" /* default */].locate() : [[Object(gl_vec2["clone"])(this.context.boxSize[0]), Object(gl_vec2["clone"])(this.context.boxSize[1]), Object(gl_vec2["clone"])(this.context.boxSize[2]), Object(gl_vec2["clone"])(this.context.boxSize[3])]];
    } // TODO: need a typescript type for result here.
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

  }, {
    key: "transformResult",
    value: function transformResult(result) {
      var _this2 = this;

      var topRight = this.context.inputStream.getTopRight();
      var xOffset = topRight.x;
      var yOffset = topRight.y;

      if (xOffset === 0 && yOffset === 0) {
        return;
      }

      if (result.barcodes) {
        // TODO: BarcodeInfo may not be the right type here.
        result.barcodes.forEach(function (barcode) {
          return _this2.transformResult(barcode);
        });
      }

      if (result.line && result.line.length === 2) {
        moveLine(result.line, xOffset, yOffset);
      }

      if (result.box) {
        moveBox(result.box, xOffset, yOffset);
      }

      if (result.boxes && result.boxes.length > 0) {
        for (var i = 0; i < result.boxes.length; i++) {
          moveBox(result.boxes[i], xOffset, yOffset);
        }
      }
    }
  }, {
    key: "addResult",
    value: function addResult(result, imageData) {
      var _this3 = this;

      if (!imageData || !this.context.resultCollector) {
        return;
      } // TODO: Figure out what data structure holds a "barcodes" result, if any...


      if (result.barcodes) {
        result.barcodes.filter(function (barcode) {
          return barcode.codeResult;
        }).forEach(function (barcode) {
          return _this3.addResult(barcode, imageData);
        });
      } else if (result.codeResult) {
        this.context.resultCollector.addResult(imageData, this.context.inputStream.getCanvasSize(), result.codeResult);
      }
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "hasCodeResult",
    value: function hasCodeResult(result) {
      return !!(result && (result.barcodes ? result.barcodes.some(function (barcode) {
        return barcode.codeResult;
      }) : result.codeResult));
    } // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

  }, {
    key: "publishResult",
    value: function publishResult() {
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var imageData = arguments.length > 1 ? arguments[1] : undefined;
      var resultToPublish = result;

      if (result && this.context.onUIThread) {
        this.transformResult(result);
        this.addResult(result, imageData);
        resultToPublish = result.barcodes || result;
      }

      events.publish('processed', resultToPublish);

      if (this.hasCodeResult(result)) {
        events.publish('detected', resultToPublish);
      }
    }
  }, {
    key: "locateAndDecode",
    value: function locateAndDecode() {
      var boxes = this.getBoundingBoxes();

      if (boxes) {
        var _this$context$inputIm3;

        var decodeResult = this.context.decoder.decodeFromBoundingBoxes(boxes) || {};
        decodeResult.boxes = boxes;
        this.publishResult(decodeResult, (_this$context$inputIm3 = this.context.inputImageWrapper) === null || _this$context$inputIm3 === void 0 ? void 0 : _this$context$inputIm3.data);
      } else {
        var imageResult = this.context.decoder.decodeFromImage(this.context.inputImageWrapper);

        if (imageResult) {
          var _this$context$inputIm4;

          this.publishResult(imageResult, (_this$context$inputIm4 = this.context.inputImageWrapper) === null || _this$context$inputIm4 === void 0 ? void 0 : _this$context$inputIm4.data);
        } else {
          this.publishResult();
        }
      }
    }
  }, {
    key: "startContinuousUpdate",
    value: function startContinuousUpdate() {
      var _this$context$config4,
          _this4 = this;

      var next = null;
      var delay = 1000 / (((_this$context$config4 = this.context.config) === null || _this$context$config4 === void 0 ? void 0 : _this$context$config4.frequency) || 60);
      this.context.stopped = false;
      var context = this.context;

      var newFrame = function newFrame(timestamp) {
        next = next || timestamp;

        if (!context.stopped) {
          if (timestamp >= next) {
            next += delay;

            _this4.update();
          }

          window.requestAnimationFrame(newFrame);
        }
      };

      newFrame(performance.now());
    }
  }, {
    key: "start",
    value: function start() {
      var _this$context$config5, _this$context$config6;

      if (this.context.onUIThread && ((_this$context$config5 = this.context.config) === null || _this$context$config5 === void 0 ? void 0 : (_this$context$config6 = _this$context$config5.inputStream) === null || _this$context$config6 === void 0 ? void 0 : _this$context$config6.type) === 'LiveStream') {
        this.startContinuousUpdate();
      } else {
        this.update();
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      var _this$context$config7;

      this.context.stopped = true;
      adjustWorkerPool(0);

      if (((_this$context$config7 = this.context.config) === null || _this$context$config7 === void 0 ? void 0 : _this$context$config7.inputStream) && this.context.config.inputStream.type === 'LiveStream') {
        camera_access.release();
        this.context.inputStream.clearEventHandlers();
      }
    }
  }, {
    key: "setReaders",
    value: function setReaders(readers) {
      if (this.context.decoder) {
        this.context.decoder.setReaders(readers);
      }

      qworker_setReaders(readers);
    }
  }, {
    key: "registerReader",
    value: function registerReader(name, reader) {
      barcode_decoder.registerReader(name, reader);

      if (this.context.decoder) {
        this.context.decoder.registerReader(name, reader);
      }

      qworker_registerReader(name, reader);
    }
  }]);

  return Quagga;
}();


// CONCATENATED MODULE: ./src/quagga.js

 // eslint-disable-line no-unused-vars











var instance = new quagga_Quagga();
var _context = instance.context;
var QuaggaJSStaticInterface = {
  init: function init(config, cb, imageWrapper) {
    var quaggaInstance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : instance;
    var promise;

    if (!cb) {
      promise = new Promise(function (resolve, reject) {
        cb = function cb(err) {
          err ? reject(err) : resolve();
        };
      });
    }

    quaggaInstance.context.config = Object(lodash["merge"])({}, config_config, config); // TODO #179: pending restructure in Issue #179, we are temp disabling workers

    if (quaggaInstance.context.config.numOfWorkers > 0) {
      quaggaInstance.context.config.numOfWorkers = 0;
    }

    if (imageWrapper) {
      quaggaInstance.context.onUIThread = false;
      quaggaInstance.initializeData(imageWrapper);

      if (cb) {
        cb();
      }
    } else {
      quaggaInstance.initInputStream(cb);
    }

    return promise;
  },
  start: function start() {
    instance.start();
  },
  stop: function stop() {
    instance.stop();
  },
  pause: function pause() {
    _context.stopped = true;
  },
  onDetected: function onDetected(callback) {
    if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {
      console.trace('* warning: Quagga.onDetected called with invalid callback, ignoring');
      return;
    }

    events.subscribe('detected', callback);
  },
  offDetected: function offDetected(callback) {
    events.unsubscribe('detected', callback);
  },
  onProcessed: function onProcessed(callback) {
    if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {
      console.trace('* warning: Quagga.onProcessed called with invalid callback, ignoring');
      return;
    }

    events.subscribe('processed', callback);
  },
  offProcessed: function offProcessed(callback) {
    events.unsubscribe('processed', callback);
  },
  setReaders: function setReaders(readers) {
    if (!readers) {
      console.trace('* warning: Quagga.setReaders called with no readers, ignoring');
      return;
    }

    instance.setReaders(readers);
  },
  registerReader: function registerReader(name, reader) {
    if (!name) {
      console.trace('* warning: Quagga.registerReader called with no name, ignoring');
      return;
    }

    if (!reader) {
      console.trace('* warning: Quagga.registerReader called with no reader, ignoring');
      return;
    }

    instance.registerReader(name, reader);
  },
  registerResultCollector: function registerResultCollector(resultCollector) {
    if (resultCollector && typeof resultCollector.addResult === 'function') {
      _context.resultCollector = resultCollector;
    }
  },

  get canvas() {
    return _context.canvasContainer;
  },

  decodeSingle: function decodeSingle(config, resultCallback) {
    var _this = this;

    var quaggaInstance = new quagga_Quagga();
    config = Object(lodash["merge"])({
      inputStream: {
        type: 'ImageStream',
        sequence: false,
        size: 800,
        src: config.src
      },
      numOfWorkers:  true && config.debug ? 0 : 1,
      locator: {
        halfSample: false
      }
    }, config); // TODO #175: restructure worker support so that it will work with typescript using worker-loader
    // https://webpack.js.org/loaders/worker-loader/

    if (config.numOfWorkers > 0) {
      config.numOfWorkers = 0;
    } // workers require Worker and Blob support presently, so if no Blob or Worker then set
    // workers to 0.


    if (config.numOfWorkers > 0 && (typeof Blob === 'undefined' || typeof Worker === 'undefined')) {
      console.warn('* no Worker and/or Blob support - forcing numOfWorkers to 0');
      config.numOfWorkers = 0;
    }

    return new Promise(function (resolve, reject) {
      try {
        _this.init(config, function () {
          events.once('processed', function (result) {
            quaggaInstance.stop();

            if (resultCallback) {
              resultCallback.call(null, result);
            }

            resolve(result);
          }, true);
          quaggaInstance.start();
        }, null, quaggaInstance);
      } catch (err) {
        reject(err);
      }
    });
  },

  // add the usually expected "default" for use with require, build step won't allow us to
  // write to module.exports so do it here.
  get default() {
    return QuaggaJSStaticInterface;
  },

  BarcodeReader: barcode_reader,
  CameraAccess: camera_access,
  ImageDebug: image_debug["a" /* default */],
  ImageWrapper: image_wrapper["a" /* default */],
  ResultCollector: result_collector
};
/* harmony default export */ var quagga = __webpack_exports__["default"] = (QuaggaJSStaticInterface); // export BarcodeReader and other utilities for external plugins



/***/ })
/******/ ])["default"];
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9RdWFnZ2Evd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL1F1YWdnYS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29tbW9uL2NsdXN0ZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi9jdl91dGlscy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29tbW9uL2ltYWdlX2RlYnVnLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vYXJyYXlfaGVscGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vaW1hZ2Vfd3JhcHBlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2xvZGFzaC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2xvY2F0b3IvdHJhY2VyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL25kYXJyYXkvbmRhcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Vwc2lsb24uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvY3JlYXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3N1YnRyYWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL211bHRpcGx5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2RpdmlkZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9kaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zcXVhcmVkRGlzdGFuY2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbGVuZ3RoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NxdWFyZWRMZW5ndGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZXBzaWxvbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZnJvbVZhbHVlcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9ub3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZG90LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3N1YnRyYWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL211bHRpcGx5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2RpdmlkZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9kaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9zcXVhcmVkRGlzdGFuY2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbGVuZ3RoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NxdWFyZWRMZW5ndGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvaW5wdXQvZnJhbWVfZ3JhYmJlcl9ub2RlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9sb2NhdG9yL3Jhc3Rlcml6ZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2xvY2F0b3Ivc2tlbGV0b25pemVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nZXQtcGl4ZWxzL2RvbS1waXhlbHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi90eXBlZGVmcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVJlc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvY2xvbmUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZnJvbVZhbHVlcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9jb3B5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9lcXVhbHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZXhhY3RFcXVhbHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvYWRkLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3N1Yi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9tdWwuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZGl2LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2ludmVyc2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbWluLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL21heC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9yb3RhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZmxvb3IuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvY2VpbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9yb3VuZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zY2FsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zY2FsZUFuZEFkZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9kaXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NxckRpc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbGVuLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3Nxckxlbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9uZWdhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbm9ybWFsaXplLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2RvdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9jcm9zcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9sZXJwLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3JhbmRvbS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi90cmFuc2Zvcm1NYXQyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3RyYW5zZm9ybU1hdDJkLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3RyYW5zZm9ybU1hdDMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvdHJhbnNmb3JtTWF0NC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9mb3JFYWNoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2xpbWl0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Nsb25lLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2FuZ2xlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2NvcHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2VxdWFscy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9leGFjdEVxdWFscy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9hZGQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3ViLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL211bC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9kaXYuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbWluLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL21heC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9mbG9vci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9jZWlsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3JvdW5kLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NjYWxlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NjYWxlQW5kQWRkLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Rpc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3FyRGlzdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9sZW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3FyTGVuLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL25lZ2F0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9pbnZlcnNlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Nyb3NzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2xlcnAuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvcmFuZG9tLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3RyYW5zZm9ybU1hdDQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvdHJhbnNmb3JtTWF0My5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy90cmFuc2Zvcm1RdWF0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3JvdGF0ZVguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvcm90YXRlWS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9yb3RhdGVaLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2ZvckVhY2guanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc3VwZXJQcm9wQmFzZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL2RldGVybWluYW50LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL3RyYW5zcG9zZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9tdWx0aXBseS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9hZGpvaW50LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL3JvdGF0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9pbnZlcnQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvY3JlYXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL3NjYWxlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL2NvcHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvZnJvYi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9sZHUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvaW90YS1hcnJheS9pb3RhLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL29tZ2dpZi9vbWdnaWYuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL25kYXJyYXktcGFjay9jb252ZXJ0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9uZGFycmF5LXBhY2svZG9Db252ZXJ0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9jb21waWxlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbGliL3RodW5rLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9saWIvY29tcGlsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvdW5pcS91bmlxLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy90aHJvdWdoL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS91dGlsIChpZ25vcmVkKSIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhL3V0aWwgKGlnbm9yZWQpPzhkNTciLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS1icm93c2VyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZGF0YS11cmktdG8tYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9uZGFycmF5LWxpbmVhci1pbnRlcnBvbGF0ZS9pbnRlcnAuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2RlY29kZXIvYnJlc2VuaGFtLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvYmFyY29kZV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RlXzEyOF9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9lYW5fcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kZV8zOV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RlXzM5X3Zpbl9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RhYmFyX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL3VwY19yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9lYW5fOF9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9lYW5fMl9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9lYW5fNV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci91cGNfZV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9pMm9mNV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci8yb2Y1X3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2NvZGVfOTNfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kZV8zMl9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2RlY29kZXIvYmFyY29kZV9kZWNvZGVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vZXZlbnRzLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vbWVkaWFEZXZpY2VzLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9jYW1lcmFfYWNjZXNzLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9hbmFseXRpY3MvcmVzdWx0X2NvbGxlY3Rvci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29uZmlnL2NvbmZpZy5kZXYudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbmZpZy9jb25maWcubm9kZS50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29uZmlnL2NvbmZpZy5wcm9kLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb25maWcvY29uZmlnLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9RdWFnZ2FDb250ZXh0LnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvaW5pdEJ1ZmZlcnMudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9nZXRWaWV3UG9ydC50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL2luaXRDYW52YXMudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2lucHV0L2V4aWZfaGVscGVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9pbWFnZV9sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2lucHV0L2lucHV0X3N0cmVhbS9pbnB1dF9zdHJlYW1fYnJvd3Nlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvaW5wdXQvaW5wdXRfc3RyZWFtL2lucHV0X3N0cmVhbV9ub2RlLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9pbnB1dF9zdHJlYW1fZmFjdG9yeS50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvaW5wdXQvZnJhbWVfZ3JhYmJlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL3F3b3JrZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9zZXR1cElucHV0U3RyZWFtLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvdHJhbnNmb3JtLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvcXVhZ2dhLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EuanMiXSwibmFtZXMiOlsiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwic2VsZiIsIlJlZmVyZW5jZUVycm9yIiwiX2dldFByb3RvdHlwZU9mIiwibyIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwicHJvdG90eXBlIiwiX3R5cGVvZiIsInJlcXVpcmUiLCJhc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsImNhbGwiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsIkVQU0lMT04iLCJjbG9uZSIsImZyb21WYWx1ZXMiLCJjb3B5Iiwic2V0IiwiZXF1YWxzIiwiZXhhY3RFcXVhbHMiLCJhZGQiLCJzdWJ0cmFjdCIsInN1YiIsIm11bHRpcGx5IiwibXVsIiwiZGl2aWRlIiwiZGl2IiwiaW52ZXJzZSIsIm1pbiIsIm1heCIsInJvdGF0ZSIsImZsb29yIiwiY2VpbCIsInJvdW5kIiwic2NhbGUiLCJzY2FsZUFuZEFkZCIsImRpc3RhbmNlIiwiZGlzdCIsInNxdWFyZWREaXN0YW5jZSIsInNxckRpc3QiLCJsZW4iLCJzcXVhcmVkTGVuZ3RoIiwic3FyTGVuIiwibmVnYXRlIiwibm9ybWFsaXplIiwiZG90IiwiY3Jvc3MiLCJsZXJwIiwicmFuZG9tIiwidHJhbnNmb3JtTWF0MiIsInRyYW5zZm9ybU1hdDJkIiwidHJhbnNmb3JtTWF0MyIsInRyYW5zZm9ybU1hdDQiLCJmb3JFYWNoIiwibGltaXQiLCJ2ZWMyIiwicG9pbnQiLCJ0aHJlc2hvbGQiLCJwb2ludHMiLCJjZW50ZXIiLCJyYWQiLCJ2ZWMiLCJwb2ludE1hcCIsInBvaW50VG9BZGQiLCJpZCIsInB1c2giLCJ1cGRhdGVDZW50ZXIiLCJzdW0iLCJNYXRoIiwiY29zIiwic2luIiwiaW5pdCIsImZpdHMiLCJvdGhlclBvaW50Iiwic2ltaWxhcml0eSIsImFicyIsImdldFBvaW50cyIsImdldENlbnRlciIsImNyZWF0ZVBvaW50IiwibmV3UG9pbnQiLCJwcm9wZXJ0eSIsInYyY2xvbmUiLCJ2ZWMzIiwidjNjbG9uZSIsImltYWdlUmVmIiwieCIsInkiLCJ0aGF0IiwidG9WZWMyIiwidG9WZWMzIiwiY29tcHV0ZUludGVncmFsSW1hZ2UyIiwiaW1hZ2VXcmFwcGVyIiwiaW50ZWdyYWxXcmFwcGVyIiwiaW1hZ2VEYXRhIiwiZGF0YSIsIndpZHRoIiwic2l6ZSIsImhlaWdodCIsImludGVncmFsSW1hZ2VEYXRhIiwicG9zQSIsInBvc0IiLCJwb3NDIiwicG9zRCIsImNvbXB1dGVJbnRlZ3JhbEltYWdlIiwidiIsInUiLCJ0aHJlc2hvbGRJbWFnZSIsInRhcmdldFdyYXBwZXIiLCJ0YXJnZXREYXRhIiwiY29tcHV0ZUhpc3RvZ3JhbSIsImJpdHNQZXJQaXhlbCIsImJpdFNoaWZ0IiwiYnVja2V0Q250IiwiaGlzdCIsIkludDMyQXJyYXkiLCJzaGFycGVuTGluZSIsImxpbmUiLCJsZWZ0IiwicmlnaHQiLCJkZXRlcm1pbmVPdHN1VGhyZXNob2xkIiwicHgiLCJlbmQiLCJteCIsImRldGVybWluZVRocmVzaG9sZCIsInZldCIsInAxIiwicDIiLCJwMTIiLCJtMSIsIm0yIiwibTEyIiwiayIsIkFycmF5SGVscGVyIiwibWF4SW5kZXgiLCJvdHN1VGhyZXNob2xkIiwiY29tcHV0ZUJpbmFyeUltYWdlIiwia2VybmVsIiwiQSIsIkIiLCJDIiwiRCIsImF2ZyIsImNsdXN0ZXIiLCJ0aGlzQ2x1c3RlciIsImNsdXN0ZXJzIiwiYWRkVG9DbHVzdGVyIiwiZm91bmQiLCJDbHVzdGVyMiIsIlRyYWNlciIsInRyYWNlIiwiaXRlcmF0aW9uIiwibWF4SXRlcmF0aW9ucyIsInRvcCIsInJlc3VsdCIsImNlbnRlclBvcyIsImN1cnJlbnRQb3MiLCJpZHgiLCJmb3J3YXJkIiwidG8iLCJ0b0lkeCIsInByZWRpY3RlZFBvcyIsInRocmVzaG9sZFgiLCJ0aHJlc2hvbGRZIiwibWF0Y2giLCJwb3MiLCJwcmVkaWN0ZWQiLCJmcm9tIiwiRElMQVRFIiwiRVJPREUiLCJkaWxhdGUiLCJpbkltYWdlV3JhcHBlciIsIm91dEltYWdlV3JhcHBlciIsImluSW1hZ2VEYXRhIiwib3V0SW1hZ2VEYXRhIiwieVN0YXJ0MSIsInlTdGFydDIiLCJ4U3RhcnQxIiwieFN0YXJ0MiIsImVyb2RlIiwiYUltYWdlV3JhcHBlciIsImJJbWFnZVdyYXBwZXIiLCJyZXN1bHRJbWFnZVdyYXBwZXIiLCJhSW1hZ2VEYXRhIiwiYkltYWdlRGF0YSIsImNJbWFnZURhdGEiLCJiaXR3aXNlT3IiLCJjb3VudE5vblplcm8iLCJ0b3BHZW5lcmljIiwibGlzdCIsInNjb3JlRnVuYyIsIm1pbklkeCIsInF1ZXVlIiwic2NvcmUiLCJoaXQiLCJpdGVtIiwiYXBwbHkiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJncmF5QXJyYXlGcm9tSW1hZ2UiLCJodG1sSW1hZ2UiLCJvZmZzZXRYIiwiY3R4IiwiYXJyYXkiLCJkcmF3SW1hZ2UiLCJjdHhEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwiY29tcHV0ZUdyYXkiLCJncmF5QXJyYXlGcm9tQ29udGV4dCIsIm9mZnNldCIsImdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGEiLCJjYW52YXNEYXRhIiwib3V0QXJyYXkiLCJ0b3BSb3dJZHgiLCJib3R0b21Sb3dJZHgiLCJlbmRJZHgiLCJvdXRXaWR0aCIsIm91dEltZ0lkeCIsImluV2lkdGgiLCJjb25maWciLCJsIiwic2luZ2xlQ2hhbm5lbCIsImxvYWRJbWFnZUFycmF5Iiwic3JjIiwiY2FsbGJhY2siLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbWciLCJJbWFnZSIsIm9ubG9hZCIsImdldENvbnRleHQiLCJVaW50OEFycmF5IiwiaGFsZlNhbXBsZSIsImluSW1nV3JhcHBlciIsIm91dEltZ1dyYXBwZXIiLCJpbkltZyIsIm91dEltZyIsImhzdjJyZ2IiLCJoc3YiLCJyZ2IiLCJoIiwicyIsImMiLCJtIiwiciIsImciLCJiIiwiX2NvbXB1dGVEaXZpc29ycyIsIm4iLCJsYXJnZURpdmlzb3JzIiwiZGl2aXNvcnMiLCJzcXJ0IiwidW5zaGlmdCIsImNvbmNhdCIsIl9jb21wdXRlSW50ZXJzZWN0aW9uIiwiYXJyMSIsImFycjIiLCJqIiwiY2FsY3VsYXRlUGF0Y2hTaXplIiwicGF0Y2hTaXplIiwiaW1nU2l6ZSIsImRpdmlzb3JzWCIsImRpdmlzb3JzWSIsIndpZGVTaWRlIiwiY29tbW9uIiwibnJPZlBhdGNoZXNMaXN0IiwibnJPZlBhdGNoZXNNYXAiLCJzbWFsbCIsIm1lZGl1bSIsImxhcmdlIiwibnJPZlBhdGNoZXNJZHgiLCJuck9mUGF0Y2hlcyIsImRlc2lyZWRQYXRjaFNpemUiLCJvcHRpbWFsUGF0Y2hTaXplIiwiZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzIiwiX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzIiwiZGltZW5zaW9uIiwicGFyc2VGbG9hdCIsInVuaXQiLCJpbmRleE9mIiwiX2RpbWVuc2lvbnNDb252ZXJ0ZXJzIiwiY29udGV4dCIsImJvdHRvbSIsImNvbXB1dGVJbWFnZUFyZWEiLCJpbnB1dFdpZHRoIiwiaW5wdXRIZWlnaHQiLCJhcmVhIiwicGFyc2VkQXJlYSIsImtleXMiLCJyZWR1Y2UiLCJwYXJzZWQiLCJjYWxjdWxhdGVkIiwic3giLCJzeSIsInN3Iiwic2giLCJkcmF3UmVjdCIsInN0eWxlIiwic3Ryb2tlU3R5bGUiLCJjb2xvciIsImZpbGxTdHlsZSIsImxpbmVXaWR0aCIsImJlZ2luUGF0aCIsInN0cm9rZVJlY3QiLCJkcmF3UGF0aCIsInBhdGgiLCJkZWYiLCJtb3ZlVG8iLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJzdHJva2UiLCJjYW52YXNEYXRhUG9zIiwiaW1hZ2VEYXRhUG9zIiwicHV0SW1hZ2VEYXRhIiwiYXJyIiwidmFsIiwic2h1ZmZsZSIsInRvUG9pbnRMaXN0Iiwicm93cyIsInAiLCJyb3ciLCJqb2luIiwicHJldiIsIm5leHQiLCJhc3NlcnROdW1iZXJQb3NpdGl2ZSIsIkVycm9yIiwiSW1hZ2VXcmFwcGVyIiwiQXJyYXlUeXBlIiwiaW5pdGlhbGl6ZSIsImltZ1JlZiIsImJvcmRlciIsInNpemVYIiwic2l6ZVkiLCJpbmRleE1hcHBpbmciLCJsYWJlbENvdW50IiwieXNxIiwibGFiZWxTdW0iLCJsYWJlbCIsIm11MTEiLCJtdTAyIiwibXUyMCIsInhfIiwieV8iLCJ0bXAiLCJQSSIsIlBJXzQiLCJtMDAiLCJtMDEiLCJtMTAiLCJtMTEiLCJtMDIiLCJtMjAiLCJ0aGV0YSIsImlzTmFOIiwiYXRhbiIsInJldCIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwicGl4ZWwiLCJjdXJyZW50IiwiZ2V0IiwiZnJhbWUiLCJnZXRBc1JHQkEiLCJuZXdGcmFtZSIsIkltYWdlRGF0YSIsImluU2NhbGUiLCJhZGp1c3RlZFNjYWxlIiwid2hpdGVSZ2IiLCJibGFja1JnYiIsInVuZGVmaW5lZCIsIlZFUlNJT04iLCJMQVJHRV9BUlJBWV9TSVpFIiwiQ09SRV9FUlJPUl9URVhUIiwiRlVOQ19FUlJPUl9URVhUIiwiSEFTSF9VTkRFRklORUQiLCJNQVhfTUVNT0laRV9TSVpFIiwiUExBQ0VIT0xERVIiLCJDTE9ORV9ERUVQX0ZMQUciLCJDTE9ORV9GTEFUX0ZMQUciLCJDTE9ORV9TWU1CT0xTX0ZMQUciLCJDT01QQVJFX1BBUlRJQUxfRkxBRyIsIkNPTVBBUkVfVU5PUkRFUkVEX0ZMQUciLCJXUkFQX0JJTkRfRkxBRyIsIldSQVBfQklORF9LRVlfRkxBRyIsIldSQVBfQ1VSUllfQk9VTkRfRkxBRyIsIldSQVBfQ1VSUllfRkxBRyIsIldSQVBfQ1VSUllfUklHSFRfRkxBRyIsIldSQVBfUEFSVElBTF9GTEFHIiwiV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUciLCJXUkFQX0FSWV9GTEFHIiwiV1JBUF9SRUFSR19GTEFHIiwiV1JBUF9GTElQX0ZMQUciLCJERUZBVUxUX1RSVU5DX0xFTkdUSCIsIkRFRkFVTFRfVFJVTkNfT01JU1NJT04iLCJIT1RfQ09VTlQiLCJIT1RfU1BBTiIsIkxBWllfRklMVEVSX0ZMQUciLCJMQVpZX01BUF9GTEFHIiwiTEFaWV9XSElMRV9GTEFHIiwiSU5GSU5JVFkiLCJNQVhfU0FGRV9JTlRFR0VSIiwiTUFYX0lOVEVHRVIiLCJOQU4iLCJNQVhfQVJSQVlfTEVOR1RIIiwiTUFYX0FSUkFZX0lOREVYIiwiSEFMRl9NQVhfQVJSQVlfTEVOR1RIIiwid3JhcEZsYWdzIiwiYXJnc1RhZyIsImFycmF5VGFnIiwiYXN5bmNUYWciLCJib29sVGFnIiwiZGF0ZVRhZyIsImRvbUV4Y1RhZyIsImVycm9yVGFnIiwiZnVuY1RhZyIsImdlblRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsIm51bGxUYWciLCJvYmplY3RUYWciLCJwcm9taXNlVGFnIiwicHJveHlUYWciLCJyZWdleHBUYWciLCJzZXRUYWciLCJzdHJpbmdUYWciLCJzeW1ib2xUYWciLCJ1bmRlZmluZWRUYWciLCJ3ZWFrTWFwVGFnIiwid2Vha1NldFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJyZUVtcHR5U3RyaW5nTGVhZGluZyIsInJlRW1wdHlTdHJpbmdNaWRkbGUiLCJyZUVtcHR5U3RyaW5nVHJhaWxpbmciLCJyZUVzY2FwZWRIdG1sIiwicmVVbmVzY2FwZWRIdG1sIiwicmVIYXNFc2NhcGVkSHRtbCIsIlJlZ0V4cCIsInNvdXJjZSIsInJlSGFzVW5lc2NhcGVkSHRtbCIsInJlRXNjYXBlIiwicmVFdmFsdWF0ZSIsInJlSW50ZXJwb2xhdGUiLCJyZUlzRGVlcFByb3AiLCJyZUlzUGxhaW5Qcm9wIiwicmVQcm9wTmFtZSIsInJlUmVnRXhwQ2hhciIsInJlSGFzUmVnRXhwQ2hhciIsInJlVHJpbSIsInJlVHJpbVN0YXJ0IiwicmVUcmltRW5kIiwicmVXcmFwQ29tbWVudCIsInJlV3JhcERldGFpbHMiLCJyZVNwbGl0RGV0YWlscyIsInJlQXNjaWlXb3JkIiwicmVFc2NhcGVDaGFyIiwicmVFc1RlbXBsYXRlIiwicmVGbGFncyIsInJlSXNCYWRIZXgiLCJyZUlzQmluYXJ5IiwicmVJc0hvc3RDdG9yIiwicmVJc09jdGFsIiwicmVJc1VpbnQiLCJyZUxhdGluIiwicmVOb01hdGNoIiwicmVVbmVzY2FwZWRTdHJpbmciLCJyc0FzdHJhbFJhbmdlIiwicnNDb21ib01hcmtzUmFuZ2UiLCJyZUNvbWJvSGFsZk1hcmtzUmFuZ2UiLCJyc0NvbWJvU3ltYm9sc1JhbmdlIiwicnNDb21ib1JhbmdlIiwicnNEaW5nYmF0UmFuZ2UiLCJyc0xvd2VyUmFuZ2UiLCJyc01hdGhPcFJhbmdlIiwicnNOb25DaGFyUmFuZ2UiLCJyc1B1bmN0dWF0aW9uUmFuZ2UiLCJyc1NwYWNlUmFuZ2UiLCJyc1VwcGVyUmFuZ2UiLCJyc1ZhclJhbmdlIiwicnNCcmVha1JhbmdlIiwicnNBcG9zIiwicnNBc3RyYWwiLCJyc0JyZWFrIiwicnNDb21ibyIsInJzRGlnaXRzIiwicnNEaW5nYmF0IiwicnNMb3dlciIsInJzTWlzYyIsInJzRml0eiIsInJzTW9kaWZpZXIiLCJyc05vbkFzdHJhbCIsInJzUmVnaW9uYWwiLCJyc1N1cnJQYWlyIiwicnNVcHBlciIsInJzWldKIiwicnNNaXNjTG93ZXIiLCJyc01pc2NVcHBlciIsInJzT3B0Q29udHJMb3dlciIsInJzT3B0Q29udHJVcHBlciIsInJlT3B0TW9kIiwicnNPcHRWYXIiLCJyc09wdEpvaW4iLCJyc09yZExvd2VyIiwicnNPcmRVcHBlciIsInJzU2VxIiwicnNFbW9qaSIsInJzU3ltYm9sIiwicmVBcG9zIiwicmVDb21ib01hcmsiLCJyZVVuaWNvZGUiLCJyZVVuaWNvZGVXb3JkIiwicmVIYXNVbmljb2RlIiwicmVIYXNVbmljb2RlV29yZCIsImNvbnRleHRQcm9wcyIsInRlbXBsYXRlQ291bnRlciIsInR5cGVkQXJyYXlUYWdzIiwiY2xvbmVhYmxlVGFncyIsImRlYnVycmVkTGV0dGVycyIsImh0bWxFc2NhcGVzIiwiaHRtbFVuZXNjYXBlcyIsInN0cmluZ0VzY2FwZXMiLCJmcmVlUGFyc2VGbG9hdCIsImZyZWVQYXJzZUludCIsInBhcnNlSW50IiwiZnJlZUdsb2JhbCIsImdsb2JhbCIsImZyZWVTZWxmIiwicm9vdCIsIkZ1bmN0aW9uIiwiZnJlZUV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJtb2R1bGVFeHBvcnRzIiwiZnJlZVByb2Nlc3MiLCJwcm9jZXNzIiwibm9kZVV0aWwiLCJ0eXBlcyIsImJpbmRpbmciLCJlIiwibm9kZUlzQXJyYXlCdWZmZXIiLCJpc0FycmF5QnVmZmVyIiwibm9kZUlzRGF0ZSIsImlzRGF0ZSIsIm5vZGVJc01hcCIsImlzTWFwIiwibm9kZUlzUmVnRXhwIiwiaXNSZWdFeHAiLCJub2RlSXNTZXQiLCJpc1NldCIsIm5vZGVJc1R5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXkiLCJmdW5jIiwidGhpc0FyZyIsImFyZ3MiLCJhcnJheUFnZ3JlZ2F0b3IiLCJzZXR0ZXIiLCJpdGVyYXRlZSIsImFjY3VtdWxhdG9yIiwiaW5kZXgiLCJhcnJheUVhY2giLCJhcnJheUVhY2hSaWdodCIsImFycmF5RXZlcnkiLCJwcmVkaWNhdGUiLCJhcnJheUZpbHRlciIsInJlc0luZGV4IiwiYXJyYXlJbmNsdWRlcyIsImJhc2VJbmRleE9mIiwiYXJyYXlJbmNsdWRlc1dpdGgiLCJjb21wYXJhdG9yIiwiYXJyYXlNYXAiLCJBcnJheSIsImFycmF5UHVzaCIsInZhbHVlcyIsImFycmF5UmVkdWNlIiwiaW5pdEFjY3VtIiwiYXJyYXlSZWR1Y2VSaWdodCIsImFycmF5U29tZSIsImFzY2lpU2l6ZSIsImJhc2VQcm9wZXJ0eSIsImFzY2lpVG9BcnJheSIsInN0cmluZyIsInNwbGl0IiwiYXNjaWlXb3JkcyIsImJhc2VGaW5kS2V5IiwiY29sbGVjdGlvbiIsImVhY2hGdW5jIiwiYmFzZUZpbmRJbmRleCIsImZyb21JbmRleCIsImZyb21SaWdodCIsInN0cmljdEluZGV4T2YiLCJiYXNlSXNOYU4iLCJiYXNlSW5kZXhPZldpdGgiLCJiYXNlTWVhbiIsImJhc2VTdW0iLCJvYmplY3QiLCJiYXNlUHJvcGVydHlPZiIsImJhc2VSZWR1Y2UiLCJiYXNlU29ydEJ5IiwiY29tcGFyZXIiLCJzb3J0IiwiYmFzZVRpbWVzIiwiYmFzZVRvUGFpcnMiLCJiYXNlVW5hcnkiLCJiYXNlVmFsdWVzIiwiY2FjaGVIYXMiLCJjYWNoZSIsImhhcyIsImNoYXJzU3RhcnRJbmRleCIsInN0clN5bWJvbHMiLCJjaHJTeW1ib2xzIiwiY2hhcnNFbmRJbmRleCIsImNvdW50SG9sZGVycyIsInBsYWNlaG9sZGVyIiwiZGVidXJyTGV0dGVyIiwiZXNjYXBlSHRtbENoYXIiLCJlc2NhcGVTdHJpbmdDaGFyIiwiY2hyIiwiZ2V0VmFsdWUiLCJoYXNVbmljb2RlIiwidGVzdCIsImhhc1VuaWNvZGVXb3JkIiwiaXRlcmF0b3JUb0FycmF5IiwiaXRlcmF0b3IiLCJkb25lIiwibWFwVG9BcnJheSIsIm1hcCIsIm92ZXJBcmciLCJ0cmFuc2Zvcm0iLCJhcmciLCJyZXBsYWNlSG9sZGVycyIsInNldFRvQXJyYXkiLCJzZXRUb1BhaXJzIiwic3RyaWN0TGFzdEluZGV4T2YiLCJzdHJpbmdTaXplIiwidW5pY29kZVNpemUiLCJzdHJpbmdUb0FycmF5IiwidW5pY29kZVRvQXJyYXkiLCJ1bmVzY2FwZUh0bWxDaGFyIiwibGFzdEluZGV4IiwidW5pY29kZVdvcmRzIiwicnVuSW5Db250ZXh0IiwiXyIsImRlZmF1bHRzIiwicGljayIsIkRhdGUiLCJTdHJpbmciLCJhcnJheVByb3RvIiwiZnVuY1Byb3RvIiwib2JqZWN0UHJvdG8iLCJjb3JlSnNEYXRhIiwiZnVuY1RvU3RyaW5nIiwidG9TdHJpbmciLCJoYXNPd25Qcm9wZXJ0eSIsImlkQ291bnRlciIsIm1hc2tTcmNLZXkiLCJ1aWQiLCJleGVjIiwiSUVfUFJPVE8iLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsIm9iamVjdEN0b3JTdHJpbmciLCJvbGREYXNoIiwicmVJc05hdGl2ZSIsInJlcGxhY2UiLCJCdWZmZXIiLCJTeW1ib2wiLCJhbGxvY1Vuc2FmZSIsImdldFByb3RvdHlwZSIsIm9iamVjdENyZWF0ZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwic3BsaWNlIiwic3ByZWFkYWJsZVN5bWJvbCIsImlzQ29uY2F0U3ByZWFkYWJsZSIsInN5bUl0ZXJhdG9yIiwic3ltVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsImdldE5hdGl2ZSIsImN0eENsZWFyVGltZW91dCIsImNsZWFyVGltZW91dCIsImN0eE5vdyIsIm5vdyIsImN0eFNldFRpbWVvdXQiLCJzZXRUaW1lb3V0IiwibmF0aXZlQ2VpbCIsIm5hdGl2ZUZsb29yIiwibmF0aXZlR2V0U3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIm5hdGl2ZUlzQnVmZmVyIiwiaXNCdWZmZXIiLCJuYXRpdmVJc0Zpbml0ZSIsImlzRmluaXRlIiwibmF0aXZlSm9pbiIsIm5hdGl2ZUtleXMiLCJuYXRpdmVNYXgiLCJuYXRpdmVNaW4iLCJuYXRpdmVOb3ciLCJuYXRpdmVQYXJzZUludCIsIm5hdGl2ZVJhbmRvbSIsIm5hdGl2ZVJldmVyc2UiLCJyZXZlcnNlIiwiRGF0YVZpZXciLCJNYXAiLCJQcm9taXNlIiwiU2V0IiwiV2Vha01hcCIsIm5hdGl2ZUNyZWF0ZSIsIm1ldGFNYXAiLCJyZWFsTmFtZXMiLCJkYXRhVmlld0N0b3JTdHJpbmciLCJ0b1NvdXJjZSIsIm1hcEN0b3JTdHJpbmciLCJwcm9taXNlQ3RvclN0cmluZyIsInNldEN0b3JTdHJpbmciLCJ3ZWFrTWFwQ3RvclN0cmluZyIsInN5bWJvbFByb3RvIiwic3ltYm9sVmFsdWVPZiIsInZhbHVlT2YiLCJzeW1ib2xUb1N0cmluZyIsImxvZGFzaCIsImlzT2JqZWN0TGlrZSIsImlzQXJyYXkiLCJMYXp5V3JhcHBlciIsIkxvZGFzaFdyYXBwZXIiLCJ3cmFwcGVyQ2xvbmUiLCJiYXNlQ3JlYXRlIiwicHJvdG8iLCJpc09iamVjdCIsImJhc2VMb2Rhc2giLCJjaGFpbkFsbCIsIl9fd3JhcHBlZF9fIiwiX19hY3Rpb25zX18iLCJfX2NoYWluX18iLCJfX2luZGV4X18iLCJfX3ZhbHVlc19fIiwidGVtcGxhdGVTZXR0aW5ncyIsIl9fZGlyX18iLCJfX2ZpbHRlcmVkX18iLCJfX2l0ZXJhdGVlc19fIiwiX190YWtlQ291bnRfXyIsIl9fdmlld3NfXyIsImxhenlDbG9uZSIsImNvcHlBcnJheSIsImxhenlSZXZlcnNlIiwibGF6eVZhbHVlIiwiZGlyIiwiaXNBcnIiLCJpc1JpZ2h0IiwiYXJyTGVuZ3RoIiwidmlldyIsImdldFZpZXciLCJzdGFydCIsIml0ZXJhdGVlcyIsIml0ZXJMZW5ndGgiLCJ0YWtlQ291bnQiLCJiYXNlV3JhcHBlclZhbHVlIiwib3V0ZXIiLCJpdGVySW5kZXgiLCJ0eXBlIiwiY29tcHV0ZWQiLCJIYXNoIiwiZW50cmllcyIsImNsZWFyIiwiZW50cnkiLCJoYXNoQ2xlYXIiLCJfX2RhdGFfXyIsImhhc2hEZWxldGUiLCJoYXNoR2V0IiwiaGFzaEhhcyIsImhhc2hTZXQiLCJMaXN0Q2FjaGUiLCJsaXN0Q2FjaGVDbGVhciIsImxpc3RDYWNoZURlbGV0ZSIsImFzc29jSW5kZXhPZiIsInBvcCIsImxpc3RDYWNoZUdldCIsImxpc3RDYWNoZUhhcyIsImxpc3RDYWNoZVNldCIsIk1hcENhY2hlIiwibWFwQ2FjaGVDbGVhciIsIm1hcENhY2hlRGVsZXRlIiwiZ2V0TWFwRGF0YSIsIm1hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsIlNldENhY2hlIiwic2V0Q2FjaGVBZGQiLCJzZXRDYWNoZUhhcyIsIlN0YWNrIiwic3RhY2tDbGVhciIsInN0YWNrRGVsZXRlIiwic3RhY2tHZXQiLCJzdGFja0hhcyIsInN0YWNrU2V0IiwicGFpcnMiLCJhcnJheUxpa2VLZXlzIiwiaW5oZXJpdGVkIiwiaXNBcmciLCJpc0FyZ3VtZW50cyIsImlzQnVmZiIsImlzVHlwZSIsInNraXBJbmRleGVzIiwiaXNJbmRleCIsImFycmF5U2FtcGxlIiwiYmFzZVJhbmRvbSIsImFycmF5U2FtcGxlU2l6ZSIsInNodWZmbGVTZWxmIiwiYmFzZUNsYW1wIiwiYXJyYXlTaHVmZmxlIiwiYXNzaWduTWVyZ2VWYWx1ZSIsImVxIiwiYmFzZUFzc2lnblZhbHVlIiwiYXNzaWduVmFsdWUiLCJvYmpWYWx1ZSIsImJhc2VBZ2dyZWdhdG9yIiwiYmFzZUVhY2giLCJiYXNlQXNzaWduIiwiY29weU9iamVjdCIsImJhc2VBc3NpZ25JbiIsImtleXNJbiIsImJhc2VBdCIsInBhdGhzIiwic2tpcCIsIm51bWJlciIsImxvd2VyIiwidXBwZXIiLCJiYXNlQ2xvbmUiLCJiaXRtYXNrIiwiY3VzdG9taXplciIsInN0YWNrIiwiaXNEZWVwIiwiaXNGbGF0IiwiaXNGdWxsIiwiaW5pdENsb25lQXJyYXkiLCJ0YWciLCJnZXRUYWciLCJpc0Z1bmMiLCJjbG9uZUJ1ZmZlciIsImluaXRDbG9uZU9iamVjdCIsImNvcHlTeW1ib2xzSW4iLCJjb3B5U3ltYm9scyIsImluaXRDbG9uZUJ5VGFnIiwic3RhY2tlZCIsInN1YlZhbHVlIiwia2V5c0Z1bmMiLCJnZXRBbGxLZXlzSW4iLCJnZXRBbGxLZXlzIiwiYmFzZUNvbmZvcm1zIiwiYmFzZUNvbmZvcm1zVG8iLCJiYXNlRGVsYXkiLCJ3YWl0IiwiYmFzZURpZmZlcmVuY2UiLCJpbmNsdWRlcyIsImlzQ29tbW9uIiwidmFsdWVzTGVuZ3RoIiwidmFsdWVzSW5kZXgiLCJjcmVhdGVCYXNlRWFjaCIsImJhc2VGb3JPd24iLCJiYXNlRWFjaFJpZ2h0IiwiYmFzZUZvck93blJpZ2h0IiwiYmFzZUV2ZXJ5IiwiYmFzZUV4dHJlbXVtIiwiaXNTeW1ib2wiLCJiYXNlRmlsbCIsInRvSW50ZWdlciIsInRvTGVuZ3RoIiwiYmFzZUZpbHRlciIsImJhc2VGbGF0dGVuIiwiZGVwdGgiLCJpc1N0cmljdCIsImlzRmxhdHRlbmFibGUiLCJiYXNlRm9yIiwiY3JlYXRlQmFzZUZvciIsImJhc2VGb3JSaWdodCIsImJhc2VGdW5jdGlvbnMiLCJpc0Z1bmN0aW9uIiwiYmFzZUdldCIsImNhc3RQYXRoIiwidG9LZXkiLCJiYXNlR2V0QWxsS2V5cyIsInN5bWJvbHNGdW5jIiwiYmFzZUdldFRhZyIsImdldFJhd1RhZyIsIm9iamVjdFRvU3RyaW5nIiwiYmFzZUd0Iiwib3RoZXIiLCJiYXNlSGFzIiwiYmFzZUhhc0luIiwiYmFzZUluUmFuZ2UiLCJiYXNlSW50ZXJzZWN0aW9uIiwiYXJyYXlzIiwib3RoTGVuZ3RoIiwib3RoSW5kZXgiLCJjYWNoZXMiLCJtYXhMZW5ndGgiLCJJbmZpbml0eSIsInNlZW4iLCJiYXNlSW52ZXJ0ZXIiLCJiYXNlSW52b2tlIiwicGFyZW50IiwibGFzdCIsImJhc2VJc0FyZ3VtZW50cyIsImJhc2VJc0FycmF5QnVmZmVyIiwiYmFzZUlzRGF0ZSIsImJhc2VJc0VxdWFsIiwiYmFzZUlzRXF1YWxEZWVwIiwiZXF1YWxGdW5jIiwib2JqSXNBcnIiLCJvdGhJc0FyciIsIm9ialRhZyIsIm90aFRhZyIsIm9iaklzT2JqIiwib3RoSXNPYmoiLCJpc1NhbWVUYWciLCJlcXVhbEFycmF5cyIsImVxdWFsQnlUYWciLCJvYmpJc1dyYXBwZWQiLCJvdGhJc1dyYXBwZWQiLCJvYmpVbndyYXBwZWQiLCJvdGhVbndyYXBwZWQiLCJlcXVhbE9iamVjdHMiLCJiYXNlSXNNYXAiLCJiYXNlSXNNYXRjaCIsIm1hdGNoRGF0YSIsIm5vQ3VzdG9taXplciIsInNyY1ZhbHVlIiwiYmFzZUlzTmF0aXZlIiwiaXNNYXNrZWQiLCJwYXR0ZXJuIiwiYmFzZUlzUmVnRXhwIiwiYmFzZUlzU2V0IiwiYmFzZUlzVHlwZWRBcnJheSIsImlzTGVuZ3RoIiwiYmFzZUl0ZXJhdGVlIiwiaWRlbnRpdHkiLCJiYXNlTWF0Y2hlc1Byb3BlcnR5IiwiYmFzZU1hdGNoZXMiLCJiYXNlS2V5cyIsImlzUHJvdG90eXBlIiwiYmFzZUtleXNJbiIsIm5hdGl2ZUtleXNJbiIsImlzUHJvdG8iLCJiYXNlTHQiLCJiYXNlTWFwIiwiaXNBcnJheUxpa2UiLCJnZXRNYXRjaERhdGEiLCJtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSIsImlzS2V5IiwiaXNTdHJpY3RDb21wYXJhYmxlIiwiaGFzSW4iLCJiYXNlTWVyZ2UiLCJzcmNJbmRleCIsImJhc2VNZXJnZURlZXAiLCJuZXdWYWx1ZSIsInNhZmVHZXQiLCJtZXJnZUZ1bmMiLCJpc1R5cGVkIiwiaXNBcnJheUxpa2VPYmplY3QiLCJjbG9uZVR5cGVkQXJyYXkiLCJpc1BsYWluT2JqZWN0IiwidG9QbGFpbk9iamVjdCIsImJhc2VOdGgiLCJiYXNlT3JkZXJCeSIsIm9yZGVycyIsImdldEl0ZXJhdGVlIiwiY3JpdGVyaWEiLCJjb21wYXJlTXVsdGlwbGUiLCJiYXNlUGljayIsImJhc2VQaWNrQnkiLCJiYXNlU2V0IiwiYmFzZVByb3BlcnR5RGVlcCIsImJhc2VQdWxsQWxsIiwiYmFzZVB1bGxBdCIsImluZGV4ZXMiLCJwcmV2aW91cyIsImJhc2VVbnNldCIsImJhc2VSYW5nZSIsInN0ZXAiLCJiYXNlUmVwZWF0IiwiYmFzZVJlc3QiLCJzZXRUb1N0cmluZyIsIm92ZXJSZXN0IiwiYmFzZVNhbXBsZSIsImJhc2VTYW1wbGVTaXplIiwibmVzdGVkIiwiYmFzZVNldERhdGEiLCJiYXNlU2V0VG9TdHJpbmciLCJjb25zdGFudCIsImJhc2VTaHVmZmxlIiwiYmFzZVNsaWNlIiwiYmFzZVNvbWUiLCJiYXNlU29ydGVkSW5kZXgiLCJyZXRIaWdoZXN0IiwibG93IiwiaGlnaCIsIm1pZCIsImJhc2VTb3J0ZWRJbmRleEJ5IiwidmFsSXNOYU4iLCJ2YWxJc051bGwiLCJ2YWxJc1N5bWJvbCIsInZhbElzVW5kZWZpbmVkIiwib3RoSXNEZWZpbmVkIiwib3RoSXNOdWxsIiwib3RoSXNSZWZsZXhpdmUiLCJvdGhJc1N5bWJvbCIsInNldExvdyIsImJhc2VTb3J0ZWRVbmlxIiwiYmFzZVRvTnVtYmVyIiwiYmFzZVRvU3RyaW5nIiwiYmFzZVVuaXEiLCJjcmVhdGVTZXQiLCJzZWVuSW5kZXgiLCJiYXNlVXBkYXRlIiwidXBkYXRlciIsImJhc2VXaGlsZSIsImlzRHJvcCIsImFjdGlvbnMiLCJhY3Rpb24iLCJiYXNlWG9yIiwiYmFzZVppcE9iamVjdCIsImFzc2lnbkZ1bmMiLCJ2YWxzTGVuZ3RoIiwiY2FzdEFycmF5TGlrZU9iamVjdCIsImNhc3RGdW5jdGlvbiIsInN0cmluZ1RvUGF0aCIsImNhc3RSZXN0IiwiY2FzdFNsaWNlIiwiYnVmZmVyIiwic2xpY2UiLCJjbG9uZUFycmF5QnVmZmVyIiwiYXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwiY2xvbmVEYXRhVmlldyIsImRhdGFWaWV3IiwiYnl0ZU9mZnNldCIsImNsb25lUmVnRXhwIiwicmVnZXhwIiwiY2xvbmVTeW1ib2wiLCJzeW1ib2wiLCJ0eXBlZEFycmF5IiwiY29tcGFyZUFzY2VuZGluZyIsInZhbElzRGVmaW5lZCIsInZhbElzUmVmbGV4aXZlIiwib2JqQ3JpdGVyaWEiLCJvdGhDcml0ZXJpYSIsIm9yZGVyc0xlbmd0aCIsIm9yZGVyIiwiY29tcG9zZUFyZ3MiLCJwYXJ0aWFscyIsImhvbGRlcnMiLCJpc0N1cnJpZWQiLCJhcmdzSW5kZXgiLCJhcmdzTGVuZ3RoIiwiaG9sZGVyc0xlbmd0aCIsImxlZnRJbmRleCIsImxlZnRMZW5ndGgiLCJyYW5nZUxlbmd0aCIsImlzVW5jdXJyaWVkIiwiY29tcG9zZUFyZ3NSaWdodCIsImhvbGRlcnNJbmRleCIsInJpZ2h0SW5kZXgiLCJyaWdodExlbmd0aCIsImlzTmV3IiwiZ2V0U3ltYm9scyIsImdldFN5bWJvbHNJbiIsImNyZWF0ZUFnZ3JlZ2F0b3IiLCJpbml0aWFsaXplciIsImNyZWF0ZUFzc2lnbmVyIiwiYXNzaWduZXIiLCJzb3VyY2VzIiwiZ3VhcmQiLCJpc0l0ZXJhdGVlQ2FsbCIsIml0ZXJhYmxlIiwiY3JlYXRlQmluZCIsImlzQmluZCIsIkN0b3IiLCJjcmVhdGVDdG9yIiwid3JhcHBlciIsImZuIiwiYXJndW1lbnRzIiwiY3JlYXRlQ2FzZUZpcnN0IiwibWV0aG9kTmFtZSIsImNoYXJBdCIsInRyYWlsaW5nIiwiY3JlYXRlQ29tcG91bmRlciIsIndvcmRzIiwiZGVidXJyIiwidGhpc0JpbmRpbmciLCJjcmVhdGVDdXJyeSIsImFyaXR5IiwiZ2V0SG9sZGVyIiwiY3JlYXRlUmVjdXJyeSIsImNyZWF0ZUh5YnJpZCIsImNyZWF0ZUZpbmQiLCJmaW5kSW5kZXhGdW5jIiwiY3JlYXRlRmxvdyIsImZsYXRSZXN0IiwiZnVuY3MiLCJwcmVyZXEiLCJ0aHJ1IiwiZ2V0RnVuY05hbWUiLCJmdW5jTmFtZSIsImdldERhdGEiLCJpc0xhemlhYmxlIiwicGxhbnQiLCJwYXJ0aWFsc1JpZ2h0IiwiaG9sZGVyc1JpZ2h0IiwiYXJnUG9zIiwiYXJ5IiwiaXNBcnkiLCJpc0JpbmRLZXkiLCJpc0ZsaXAiLCJob2xkZXJzQ291bnQiLCJuZXdIb2xkZXJzIiwicmVvcmRlciIsImNyZWF0ZUludmVydGVyIiwidG9JdGVyYXRlZSIsImNyZWF0ZU1hdGhPcGVyYXRpb24iLCJvcGVyYXRvciIsImRlZmF1bHRWYWx1ZSIsImNyZWF0ZU92ZXIiLCJhcnJheUZ1bmMiLCJjcmVhdGVQYWRkaW5nIiwiY2hhcnMiLCJjaGFyc0xlbmd0aCIsImNyZWF0ZVBhcnRpYWwiLCJjcmVhdGVSYW5nZSIsInRvRmluaXRlIiwiY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbiIsInRvTnVtYmVyIiwid3JhcEZ1bmMiLCJpc0N1cnJ5IiwibmV3SG9sZGVyc1JpZ2h0IiwibmV3UGFydGlhbHMiLCJuZXdQYXJ0aWFsc1JpZ2h0IiwibmV3RGF0YSIsInNldERhdGEiLCJzZXRXcmFwVG9TdHJpbmciLCJjcmVhdGVSb3VuZCIsInByZWNpc2lvbiIsInBhaXIiLCJub29wIiwiY3JlYXRlVG9QYWlycyIsImNyZWF0ZVdyYXAiLCJtZXJnZURhdGEiLCJjdXN0b21EZWZhdWx0c0Fzc2lnbkluIiwiY3VzdG9tRGVmYXVsdHNNZXJnZSIsImN1c3RvbU9taXRDbG9uZSIsImlzUGFydGlhbCIsImFyclN0YWNrZWQiLCJvdGhTdGFja2VkIiwiYXJyVmFsdWUiLCJvdGhWYWx1ZSIsImNvbXBhcmVkIiwibmFtZSIsIm1lc3NhZ2UiLCJjb252ZXJ0Iiwib2JqUHJvcHMiLCJvYmpMZW5ndGgiLCJvdGhQcm9wcyIsIm9ialN0YWNrZWQiLCJza2lwQ3RvciIsIm9iakN0b3IiLCJvdGhDdG9yIiwiZmxhdHRlbiIsIm90aGVyRnVuYyIsImlzS2V5YWJsZSIsImlzT3duIiwidW5tYXNrZWQiLCJzdHViQXJyYXkiLCJBcnJheUJ1ZmZlciIsInJlc29sdmUiLCJjdG9yU3RyaW5nIiwidHJhbnNmb3JtcyIsImdldFdyYXBEZXRhaWxzIiwiaGFzUGF0aCIsImhhc0Z1bmMiLCJpbnB1dCIsImluc2VydFdyYXBEZXRhaWxzIiwiZGV0YWlscyIsImlzTWFza2FibGUiLCJzdHViRmFsc2UiLCJtZW1vaXplQ2FwcGVkIiwibWVtb2l6ZSIsInNyY0JpdG1hc2siLCJuZXdCaXRtYXNrIiwiaXNDb21ibyIsIm90aGVyQXJncyIsIm9sZEFycmF5Iiwic2hvcnRPdXQiLCJyZWZlcmVuY2UiLCJ1cGRhdGVXcmFwRGV0YWlscyIsImNvdW50IiwibGFzdENhbGxlZCIsInN0YW1wIiwicmVtYWluaW5nIiwicmFuZCIsImNoYXJDb2RlQXQiLCJxdW90ZSIsInN1YlN0cmluZyIsImNodW5rIiwiY29tcGFjdCIsImRpZmZlcmVuY2UiLCJkaWZmZXJlbmNlQnkiLCJkaWZmZXJlbmNlV2l0aCIsImRyb3AiLCJkcm9wUmlnaHQiLCJkcm9wUmlnaHRXaGlsZSIsImRyb3BXaGlsZSIsImZpbGwiLCJmaW5kSW5kZXgiLCJmaW5kTGFzdEluZGV4IiwiZmxhdHRlbkRlZXAiLCJmbGF0dGVuRGVwdGgiLCJmcm9tUGFpcnMiLCJoZWFkIiwiaW5pdGlhbCIsImludGVyc2VjdGlvbiIsIm1hcHBlZCIsImludGVyc2VjdGlvbkJ5IiwiaW50ZXJzZWN0aW9uV2l0aCIsInNlcGFyYXRvciIsImxhc3RJbmRleE9mIiwibnRoIiwicHVsbCIsInB1bGxBbGwiLCJwdWxsQWxsQnkiLCJwdWxsQWxsV2l0aCIsInB1bGxBdCIsInJlbW92ZSIsInNvcnRlZEluZGV4Iiwic29ydGVkSW5kZXhCeSIsInNvcnRlZEluZGV4T2YiLCJzb3J0ZWRMYXN0SW5kZXgiLCJzb3J0ZWRMYXN0SW5kZXhCeSIsInNvcnRlZExhc3RJbmRleE9mIiwic29ydGVkVW5pcSIsInNvcnRlZFVuaXFCeSIsInRhaWwiLCJ0YWtlIiwidGFrZVJpZ2h0IiwidGFrZVJpZ2h0V2hpbGUiLCJ0YWtlV2hpbGUiLCJ1bmlvbiIsInVuaW9uQnkiLCJ1bmlvbldpdGgiLCJ1bmlxIiwidW5pcUJ5IiwidW5pcVdpdGgiLCJ1bnppcCIsImdyb3VwIiwidW56aXBXaXRoIiwid2l0aG91dCIsInhvciIsInhvckJ5IiwieG9yV2l0aCIsInppcCIsInppcE9iamVjdCIsInppcE9iamVjdERlZXAiLCJ6aXBXaXRoIiwiY2hhaW4iLCJ0YXAiLCJpbnRlcmNlcHRvciIsIndyYXBwZXJBdCIsIndyYXBwZXJDaGFpbiIsIndyYXBwZXJDb21taXQiLCJ3cmFwcGVyTmV4dCIsInRvQXJyYXkiLCJ3cmFwcGVyVG9JdGVyYXRvciIsIndyYXBwZXJQbGFudCIsIndyYXBwZXJSZXZlcnNlIiwid3JhcHBlZCIsIndyYXBwZXJWYWx1ZSIsImNvdW50QnkiLCJldmVyeSIsImZpbHRlciIsImZpbmQiLCJmaW5kTGFzdCIsImZsYXRNYXAiLCJmbGF0TWFwRGVlcCIsImZsYXRNYXBEZXB0aCIsImZvckVhY2hSaWdodCIsImdyb3VwQnkiLCJpc1N0cmluZyIsImludm9rZU1hcCIsImtleUJ5Iiwib3JkZXJCeSIsInBhcnRpdGlvbiIsInJlZHVjZVJpZ2h0IiwicmVqZWN0Iiwic2FtcGxlIiwic2FtcGxlU2l6ZSIsInNvbWUiLCJzb3J0QnkiLCJhZnRlciIsImJlZm9yZSIsImJpbmQiLCJiaW5kS2V5IiwiY3VycnkiLCJjdXJyeVJpZ2h0IiwiZGVib3VuY2UiLCJvcHRpb25zIiwibGFzdEFyZ3MiLCJsYXN0VGhpcyIsIm1heFdhaXQiLCJ0aW1lcklkIiwibGFzdENhbGxUaW1lIiwibGFzdEludm9rZVRpbWUiLCJsZWFkaW5nIiwibWF4aW5nIiwiaW52b2tlRnVuYyIsInRpbWUiLCJsZWFkaW5nRWRnZSIsInRpbWVyRXhwaXJlZCIsInJlbWFpbmluZ1dhaXQiLCJ0aW1lU2luY2VMYXN0Q2FsbCIsInRpbWVTaW5jZUxhc3RJbnZva2UiLCJ0aW1lV2FpdGluZyIsInNob3VsZEludm9rZSIsInRyYWlsaW5nRWRnZSIsImNhbmNlbCIsImZsdXNoIiwiZGVib3VuY2VkIiwiaXNJbnZva2luZyIsImRlZmVyIiwiZGVsYXkiLCJmbGlwIiwicmVzb2x2ZXIiLCJtZW1vaXplZCIsIkNhY2hlIiwib25jZSIsIm92ZXJBcmdzIiwiZnVuY3NMZW5ndGgiLCJwYXJ0aWFsIiwicGFydGlhbFJpZ2h0IiwicmVhcmciLCJyZXN0Iiwic3ByZWFkIiwidGhyb3R0bGUiLCJ1bmFyeSIsIndyYXAiLCJjYXN0QXJyYXkiLCJjbG9uZVdpdGgiLCJjbG9uZURlZXAiLCJjbG9uZURlZXBXaXRoIiwiY29uZm9ybXNUbyIsImd0IiwiZ3RlIiwiaXNCb29sZWFuIiwiaXNFbGVtZW50IiwiaXNFbXB0eSIsImlzRXF1YWwiLCJpc0VxdWFsV2l0aCIsImlzRXJyb3IiLCJpc0ludGVnZXIiLCJpc01hdGNoIiwiaXNNYXRjaFdpdGgiLCJpc051bWJlciIsImlzTmF0aXZlIiwiaXNOdWxsIiwiaXNOaWwiLCJpc1NhZmVJbnRlZ2VyIiwiaXNVbmRlZmluZWQiLCJpc1dlYWtNYXAiLCJpc1dlYWtTZXQiLCJsdCIsImx0ZSIsInNpZ24iLCJyZW1haW5kZXIiLCJpc0JpbmFyeSIsInRvU2FmZUludGVnZXIiLCJhc3NpZ24iLCJhc3NpZ25JbiIsImFzc2lnbkluV2l0aCIsImFzc2lnbldpdGgiLCJhdCIsInByb3BlcnRpZXMiLCJwcm9wc0luZGV4IiwicHJvcHNMZW5ndGgiLCJkZWZhdWx0c0RlZXAiLCJtZXJnZVdpdGgiLCJmaW5kS2V5IiwiZmluZExhc3RLZXkiLCJmb3JJbiIsImZvckluUmlnaHQiLCJmb3JPd24iLCJmb3JPd25SaWdodCIsImZ1bmN0aW9ucyIsImZ1bmN0aW9uc0luIiwiaW52ZXJ0IiwiaW52ZXJ0QnkiLCJpbnZva2UiLCJtYXBLZXlzIiwibWFwVmFsdWVzIiwibWVyZ2UiLCJvbWl0Iiwib21pdEJ5IiwicGlja0J5IiwicHJvcCIsInNldFdpdGgiLCJ0b1BhaXJzIiwidG9QYWlyc0luIiwiaXNBcnJMaWtlIiwidW5zZXQiLCJ1cGRhdGUiLCJ1cGRhdGVXaXRoIiwidmFsdWVzSW4iLCJjbGFtcCIsImluUmFuZ2UiLCJmbG9hdGluZyIsInRlbXAiLCJjYW1lbENhc2UiLCJ3b3JkIiwidG9Mb3dlckNhc2UiLCJjYXBpdGFsaXplIiwidXBwZXJGaXJzdCIsImVuZHNXaXRoIiwicG9zaXRpb24iLCJlc2NhcGUiLCJlc2NhcGVSZWdFeHAiLCJrZWJhYkNhc2UiLCJsb3dlckNhc2UiLCJsb3dlckZpcnN0IiwicGFkIiwic3RyTGVuZ3RoIiwicGFkRW5kIiwicGFkU3RhcnQiLCJyYWRpeCIsInJlcGVhdCIsInNuYWtlQ2FzZSIsInN0YXJ0Q2FzZSIsInN0YXJ0c1dpdGgiLCJ0ZW1wbGF0ZSIsInNldHRpbmdzIiwiaW1wb3J0cyIsImltcG9ydHNLZXlzIiwiaW1wb3J0c1ZhbHVlcyIsImlzRXNjYXBpbmciLCJpc0V2YWx1YXRpbmciLCJpbnRlcnBvbGF0ZSIsInJlRGVsaW1pdGVycyIsImV2YWx1YXRlIiwic291cmNlVVJMIiwiZXNjYXBlVmFsdWUiLCJpbnRlcnBvbGF0ZVZhbHVlIiwiZXNUZW1wbGF0ZVZhbHVlIiwiZXZhbHVhdGVWYWx1ZSIsInZhcmlhYmxlIiwiYXR0ZW1wdCIsInRvTG93ZXIiLCJ0b1VwcGVyIiwidG9VcHBlckNhc2UiLCJ0cmltIiwidHJpbUVuZCIsInRyaW1TdGFydCIsInRydW5jYXRlIiwib21pc3Npb24iLCJzZWFyY2giLCJzdWJzdHJpbmciLCJuZXdFbmQiLCJ1bmVzY2FwZSIsInVwcGVyQ2FzZSIsImJpbmRBbGwiLCJtZXRob2ROYW1lcyIsImNvbmQiLCJjb25mb3JtcyIsImRlZmF1bHRUbyIsImZsb3ciLCJmbG93UmlnaHQiLCJtYXRjaGVzIiwibWF0Y2hlc1Byb3BlcnR5IiwibWV0aG9kIiwibWV0aG9kT2YiLCJtaXhpbiIsIm5vQ29uZmxpY3QiLCJudGhBcmciLCJvdmVyIiwib3ZlckV2ZXJ5Iiwib3ZlclNvbWUiLCJwcm9wZXJ0eU9mIiwicmFuZ2UiLCJyYW5nZVJpZ2h0Iiwic3R1Yk9iamVjdCIsInN0dWJTdHJpbmciLCJzdHViVHJ1ZSIsInRpbWVzIiwidG9QYXRoIiwidW5pcXVlSWQiLCJwcmVmaXgiLCJhdWdlbmQiLCJhZGRlbmQiLCJkaXZpZGVuZCIsImRpdmlzb3IiLCJtYXhCeSIsIm1lYW4iLCJtZWFuQnkiLCJtaW5CeSIsIm11bHRpcGxpZXIiLCJtdWx0aXBsaWNhbmQiLCJtaW51ZW5kIiwic3VidHJhaGVuZCIsInN1bUJ5IiwiZW50cmllc0luIiwiZXh0ZW5kIiwiZXh0ZW5kV2l0aCIsImVhY2giLCJlYWNoUmlnaHQiLCJmaXJzdCIsImlzRmlsdGVyIiwidGFrZU5hbWUiLCJkcm9wTmFtZSIsImNoZWNrSXRlcmF0ZWUiLCJpc1Rha2VyIiwibG9kYXNoRnVuYyIsInJldFVud3JhcHBlZCIsImlzTGF6eSIsInVzZUxhenkiLCJpc0h5YnJpZCIsImlzVW53cmFwcGVkIiwib25seUxhenkiLCJjaGFpbk5hbWUiLCJjb21taXQiLCJ0b0pTT04iLCJkZWZpbmUiLCJ3aW5kb3ciLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiZHJhaW5RdWV1ZSIsInRpbWVvdXQiLCJydW4iLCJuZXh0VGljayIsIkl0ZW0iLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwib24iLCJhZGRMaXN0ZW5lciIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJjd2QiLCJjaGRpciIsInVtYXNrIiwicG5hIiwib2JqZWN0S2V5cyIsIkR1cGxleCIsInV0aWwiLCJpbmhlcml0cyIsIlJlYWRhYmxlIiwiV3JpdGFibGUiLCJyZWFkYWJsZSIsImFsbG93SGFsZk9wZW4iLCJvbmVuZCIsIl93cml0YWJsZVN0YXRlIiwiaGlnaFdhdGVyTWFyayIsImVuZGVkIiwib25FbmROVCIsIl9yZWFkYWJsZVN0YXRlIiwiZGVzdHJveWVkIiwiX2Rlc3Ryb3kiLCJlcnIiLCJjYiIsInN1cGVyUHJvcEJhc2UiLCJfZ2V0IiwicmVjZWl2ZXIiLCJSZWZsZWN0IiwiYmFzZSIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJjdG9yIiwic3VwZXJDdG9yIiwic3VwZXJfIiwiVGVtcEN0b3IiLCJzZWFyY2hEaXJlY3Rpb25zIiwibGFiZWxXcmFwcGVyIiwibGFiZWxEYXRhIiwiZWRnZWxhYmVsIiwiY3kiLCJjeCIsInZlcnRleDJEIiwiY29udG91clRyYWNpbmciLCJGdiIsIkN2IiwiUCIsImxkaXIiLCJiYXNlNjQiLCJpZWVlNzU0IiwiU2xvd0J1ZmZlciIsIklOU1BFQ1RfTUFYX0JZVEVTIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsInR5cGVkQXJyYXlTdXBwb3J0Iiwia01heExlbmd0aCIsImZvbyIsInN1YmFycmF5IiwiY3JlYXRlQnVmZmVyIiwiUmFuZ2VFcnJvciIsImVuY29kaW5nT3JPZmZzZXQiLCJwb29sU2l6ZSIsIl9hdWdtZW50IiwiZnJvbUFycmF5QnVmZmVyIiwiZnJvbVN0cmluZyIsImZyb21PYmplY3QiLCJzcGVjaWVzIiwiYXNzZXJ0U2l6ZSIsImFsbG9jIiwiZW5jb2RpbmciLCJjaGVja2VkIiwiYWxsb2NVbnNhZmVTbG93IiwiaXNFbmNvZGluZyIsImFjdHVhbCIsIndyaXRlIiwiZnJvbUFycmF5TGlrZSIsImlzbmFuIiwiX2lzQnVmZmVyIiwiY29tcGFyZSIsImEiLCJidWYiLCJpc1ZpZXciLCJsb3dlcmVkQ2FzZSIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwiaW5zcGVjdCIsInN0ciIsInRoaXNTdGFydCIsInRoaXNFbmQiLCJ0aGlzQ29weSIsInRhcmdldENvcHkiLCJiaWRpcmVjdGlvbmFsSW5kZXhPZiIsImFycmF5SW5kZXhPZiIsImluZGV4U2l6ZSIsInZhbExlbmd0aCIsInJlYWQiLCJyZWFkVUludDE2QkUiLCJmb3VuZEluZGV4IiwiaGV4V3JpdGUiLCJzdHJMZW4iLCJzdWJzdHIiLCJ1dGY4V3JpdGUiLCJibGl0QnVmZmVyIiwiYXNjaWlXcml0ZSIsImFzY2lpVG9CeXRlcyIsImxhdGluMVdyaXRlIiwiYmFzZTY0V3JpdGUiLCJ1Y3MyV3JpdGUiLCJ1dGYxNmxlVG9CeXRlcyIsIl9hcnIiLCJmcm9tQnl0ZUFycmF5IiwicmVzIiwiZmlyc3RCeXRlIiwiY29kZVBvaW50IiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsIk1BWF9BUkdVTUVOVFNfTEVOR1RIIiwiY29kZVBvaW50cyIsImZyb21DaGFyQ29kZSIsIm91dCIsInRvSGV4IiwiYnl0ZXMiLCJuZXdCdWYiLCJzbGljZUxlbiIsImNoZWNrT2Zmc2V0IiwiZXh0IiwicmVhZFVJbnRMRSIsIm5vQXNzZXJ0IiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnRMRSIsInBvdyIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIm1heEJ5dGVzIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVJbnQ4Iiwib2JqZWN0V3JpdGVVSW50MTYiLCJsaXR0bGVFbmRpYW4iLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MTZCRSIsIm9iamVjdFdyaXRlVUludDMyIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZUludExFIiwid3JpdGVJbnRCRSIsIndyaXRlSW50OCIsIndyaXRlSW50MTZMRSIsIndyaXRlSW50MTZCRSIsIndyaXRlSW50MzJMRSIsIndyaXRlSW50MzJCRSIsImNoZWNrSUVFRTc1NCIsIndyaXRlRmxvYXQiLCJ3cml0ZUZsb2F0TEUiLCJ3cml0ZUZsb2F0QkUiLCJ3cml0ZURvdWJsZSIsIndyaXRlRG91YmxlTEUiLCJ3cml0ZURvdWJsZUJFIiwidGFyZ2V0U3RhcnQiLCJjb2RlIiwiSU5WQUxJRF9CQVNFNjRfUkUiLCJiYXNlNjRjbGVhbiIsInN0cmluZ3RyaW0iLCJ1bml0cyIsImxlYWRTdXJyb2dhdGUiLCJieXRlQXJyYXkiLCJoaSIsImxvIiwidG9CeXRlQXJyYXkiLCJkc3QiLCJpc051bGxPclVuZGVmaW5lZCIsInJlIiwiZCIsImlzUHJpbWl0aXZlIiwiX2NvbmZpZyIsIl9jdXJyZW50SW1hZ2VXcmFwcGVyIiwiX3NrZWxJbWFnZVdyYXBwZXIiLCJfc3ViSW1hZ2VXcmFwcGVyIiwiX2xhYmVsSW1hZ2VXcmFwcGVyIiwiX3BhdGNoR3JpZCIsIl9wYXRjaExhYmVsR3JpZCIsIl9pbWFnZVRvUGF0Y2hHcmlkIiwiX2JpbmFyeUltYWdlV3JhcHBlciIsIl9wYXRjaFNpemUiLCJfY2FudmFzQ29udGFpbmVyIiwiYmluYXJ5IiwiZG9tIiwiX251bVBhdGNoZXMiLCJfaW5wdXRJbWFnZVdyYXBwZXIiLCJfc2tlbGV0b25pemVyIiwiaW5pdEJ1ZmZlcnMiLCJza2VsZXRvbkltYWdlRGF0YSIsInNrZWxldG9uaXplciIsImluaXRDYW52YXMiLCJ1c2VXb3JrZXIiLCJjbGFzc05hbWUiLCJFTlYiLCJkZWJ1ZyIsInNob3dDYW52YXMiLCJxdWVyeVNlbGVjdG9yIiwiYXBwZW5kQ2hpbGQiLCJib3hGcm9tUGF0Y2hlcyIsInBhdGNoZXMiLCJvdmVyQXZnIiwicGF0Y2giLCJ0cmFuc01hdCIsIm1pbngiLCJtaW55IiwibWF4eCIsIm1heHkiLCJib3giLCJzaG93UGF0Y2hlcyIsIkltYWdlRGVidWciLCJtYXQyIiwic2hvd1RyYW5zZm9ybWVkIiwic2hvd1RyYW5zZm9ybWVkQm94Iiwic2hvd0JCIiwiYmluYXJpemVJbWFnZSIsInplcm9Cb3JkZXIiLCJzaG93IiwiZmluZFBhdGNoZXMiLCJtb21lbnRzIiwicGF0Y2hlc0ZvdW5kIiwicmFzdGVyaXplciIsInJhc3RlclJlc3VsdCIsInNrZWxldG9uaXplIiwiUmFzdGVyaXplciIsInJhc3Rlcml6ZSIsInNob3dMYWJlbHMiLCJvdmVybGF5IiwiZGVzY3JpYmVQYXRjaCIsInNob3dGb3VuZFBhdGNoZXMiLCJmaW5kQmlnZ2VzdENvbm5lY3RlZEFyZWFzIiwibWF4TGFiZWwiLCJsYWJlbEhpc3QiLCJ0b3BMYWJlbHMiLCJlbCIsImZpbmRCb3hlcyIsImJveGVzIiwic2hvd1JlbWFpbmluZ1BhdGNoTGFiZWxzIiwic2ltaWxhck1vbWVudHMiLCJ0b3BDbHVzdGVyIiwic3ViSW1hZ2VBc0NvcHkiLCJzaG93U2tlbGV0b24iLCJwYXRjaFBvcyIsImVsaWdpYmxlTW9tZW50cyIsIm1hdGNoaW5nTW9tZW50cyIsIm1pbkNvbXBvbmVudFdlaWdodCIsInJhc3Rlcml6ZUFuZ3VsYXJTaW1pbGFyaXR5IiwiY3VycklkeCIsIm5vdFlldFByb2Nlc3NlZCIsImN1cnJlbnRJZHgiLCJjdXJyZW50UGF0Y2giLCJzaG93UGF0Y2hMYWJlbHMiLCJpbnB1dEltYWdlV3JhcHBlciIsImxvY2F0ZSIsImNoZWNrSW1hZ2VDb25zdHJhaW50cyIsImlucHV0U3RyZWFtIiwiZ2V0V2lkdGgiLCJnZXRIZWlnaHQiLCJ0aGlzSGFsZlNhbXBsZSIsImdldENvbmZpZyIsInNldFRvcFJpZ2h0Iiwic2V0Q2FudmFzU2l6ZSIsImNvbnNvbGUiLCJsb2ciLCJKU09OIiwic3RyaW5naWZ5Iiwic2V0V2lkdGgiLCJzZXRIZWlnaHQiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJhZnRlclRpY2tPbmUiLCJhZnRlclRpY2tUd28iLCJhZnRlclRpY2tUaHJlZSIsImFmdGVyVGljayIsImFycmF5V2l0aEhvbGVzIiwiaXRlcmFibGVUb0FycmF5TGltaXQiLCJ1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIm5vbkl0ZXJhYmxlUmVzdCIsIl9zbGljZWRUb0FycmF5IiwiYXJyYXlXaXRob3V0SG9sZXMiLCJpdGVyYWJsZVRvQXJyYXkiLCJub25JdGVyYWJsZVNwcmVhZCIsIl90b0NvbnN1bWFibGVBcnJheSIsImFzeW5jR2VuZXJhdG9yU3RlcCIsImdlbiIsIl9uZXh0IiwiX3Rocm93IiwiaW5mbyIsImVycm9yIiwidGhlbiIsIl9hc3luY1RvR2VuZXJhdG9yIiwiZGV0ZXJtaW5hbnQiLCJ0cmFuc3Bvc2UiLCJhZGpvaW50IiwiZnJvYiIsImxkdSIsImlvdGEiLCJoYXNUeXBlZEFycmF5cyIsIkZsb2F0NjRBcnJheSIsImNvbXBhcmUxc3QiLCJzdHJpZGUiLCJ0ZXJtcyIsImNvbXBpbGVDb25zdHJ1Y3RvciIsImR0eXBlIiwidXNlR2V0dGVycyIsInByb2NlZHVyZSIsIkNBQ0hFRF9DT05TVFJVQ1RPUlMiLCJpbmRpY2VzIiwiaW5kZXhfc3RyIiwic2hhcGVBcmciLCJzdHJpZGVBcmciLCJhX3ZhcnMiLCJjX3ZhcnMiLCJ0U2hhcGUiLCJ0U3RyaWRlIiwiYXJyYXlEVHlwZSIsIndyYXBwZWROREFycmF5Q3RvciIsInNoYXBlIiwic3oiLCJjdG9yX2xpc3QiLCJSIiwiUmVmbGVjdEFwcGx5IiwiUmVmbGVjdE93bktleXMiLCJvd25LZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIlByb2Nlc3NFbWl0V2FybmluZyIsIndhcm5pbmciLCJ3YXJuIiwiTnVtYmVySXNOYU4iLCJFdmVudEVtaXR0ZXIiLCJfZXZlbnRzIiwiX2V2ZW50c0NvdW50IiwiX21heExpc3RlbmVycyIsImRlZmF1bHRNYXhMaXN0ZW5lcnMiLCJjaGVja0xpc3RlbmVyIiwibGlzdGVuZXIiLCJzZXRNYXhMaXN0ZW5lcnMiLCJfZ2V0TWF4TGlzdGVuZXJzIiwiZ2V0TWF4TGlzdGVuZXJzIiwiZG9FcnJvciIsImV2ZW50cyIsImVyIiwiaGFuZGxlciIsImFycmF5Q2xvbmUiLCJfYWRkTGlzdGVuZXIiLCJwcmVwZW5kIiwiZXhpc3RpbmciLCJuZXdMaXN0ZW5lciIsIndhcm5lZCIsInciLCJlbWl0dGVyIiwib25jZVdyYXBwZXIiLCJmaXJlZCIsIndyYXBGbiIsIl9vbmNlV3JhcCIsInN0YXRlIiwib3JpZ2luYWxMaXN0ZW5lciIsInNoaWZ0Iiwic3BsaWNlT25lIiwiX2xpc3RlbmVycyIsInVud3JhcCIsImV2bGlzdGVuZXIiLCJ1bndyYXBMaXN0ZW5lcnMiLCJyYXdMaXN0ZW5lcnMiLCJsaXN0ZW5lckNvdW50IiwiZXZlbnROYW1lcyIsImV2ZW50TGlzdGVuZXIiLCJlcnJvckxpc3RlbmVyIiwiU3RyZWFtIiwiVHJhbnNmb3JtIiwiUGFzc1Rocm91Z2giLCJjb3B5UHJvcHMiLCJTYWZlQnVmZmVyIiwiV3JpdGVSZXEiLCJDb3JrZWRSZXF1ZXN0IiwiX3RoaXMiLCJmaW5pc2giLCJvbkNvcmtlZEZpbmlzaCIsImFzeW5jV3JpdGUiLCJzZXRJbW1lZGlhdGUiLCJXcml0YWJsZVN0YXRlIiwiaW50ZXJuYWxVdGlsIiwiZGVwcmVjYXRlIiwiT3VyVWludDhBcnJheSIsIl91aW50OEFycmF5VG9CdWZmZXIiLCJfaXNVaW50OEFycmF5IiwiZGVzdHJveUltcGwiLCJub3AiLCJzdHJlYW0iLCJpc0R1cGxleCIsIm9iamVjdE1vZGUiLCJ3cml0YWJsZU9iamVjdE1vZGUiLCJod20iLCJ3cml0YWJsZUh3bSIsIndyaXRhYmxlSGlnaFdhdGVyTWFyayIsImRlZmF1bHRId20iLCJmaW5hbENhbGxlZCIsIm5lZWREcmFpbiIsImVuZGluZyIsImZpbmlzaGVkIiwibm9EZWNvZGUiLCJkZWNvZGVTdHJpbmdzIiwiZGVmYXVsdEVuY29kaW5nIiwid3JpdGluZyIsImNvcmtlZCIsInN5bmMiLCJidWZmZXJQcm9jZXNzaW5nIiwib253cml0ZSIsIndyaXRlY2IiLCJ3cml0ZWxlbiIsImJ1ZmZlcmVkUmVxdWVzdCIsImxhc3RCdWZmZXJlZFJlcXVlc3QiLCJwZW5kaW5nY2IiLCJwcmVmaW5pc2hlZCIsImVycm9yRW1pdHRlZCIsImJ1ZmZlcmVkUmVxdWVzdENvdW50IiwiY29ya2VkUmVxdWVzdHNGcmVlIiwiZ2V0QnVmZmVyIiwicmVhbEhhc0luc3RhbmNlIiwiaGFzSW5zdGFuY2UiLCJfd3JpdGUiLCJ3cml0ZXYiLCJfd3JpdGV2IiwiZGVzdHJveSIsImZpbmFsIiwiX2ZpbmFsIiwicGlwZSIsIndyaXRlQWZ0ZXJFbmQiLCJ2YWxpZENodW5rIiwidmFsaWQiLCJpc0J1ZiIsIndyaXRlT3JCdWZmZXIiLCJjb3JrIiwidW5jb3JrIiwiY2xlYXJCdWZmZXIiLCJzZXREZWZhdWx0RW5jb2RpbmciLCJkZWNvZGVDaHVuayIsIm5ld0NodW5rIiwiZG9Xcml0ZSIsIm9ud3JpdGVFcnJvciIsImZpbmlzaE1heWJlIiwib253cml0ZVN0YXRlVXBkYXRlIiwibmVlZEZpbmlzaCIsImFmdGVyV3JpdGUiLCJvbndyaXRlRHJhaW4iLCJob2xkZXIiLCJhbGxCdWZmZXJzIiwiZW5kV3JpdGFibGUiLCJjYWxsRmluYWwiLCJwcmVmaW5pc2giLCJuZWVkIiwiY29ya1JlcSIsIl91bmRlc3Ryb3kiLCJ1bmRlc3Ryb3kiLCJhcnJheUxpa2VUb0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJ6IiwiUmVhZGFibGVTdGF0ZSIsIkVFIiwiRUVsaXN0ZW5lckNvdW50IiwiZGVidWdVdGlsIiwiZGVidWdsb2ciLCJCdWZmZXJMaXN0IiwiU3RyaW5nRGVjb2RlciIsImtQcm94eUV2ZW50cyIsImV2ZW50IiwicmVhZGFibGVPYmplY3RNb2RlIiwicmVhZGFibGVId20iLCJyZWFkYWJsZUhpZ2hXYXRlck1hcmsiLCJwaXBlcyIsInBpcGVzQ291bnQiLCJmbG93aW5nIiwiZW5kRW1pdHRlZCIsInJlYWRpbmciLCJuZWVkUmVhZGFibGUiLCJlbWl0dGVkUmVhZGFibGUiLCJyZWFkYWJsZUxpc3RlbmluZyIsInJlc3VtZVNjaGVkdWxlZCIsImF3YWl0RHJhaW4iLCJyZWFkaW5nTW9yZSIsImRlY29kZXIiLCJfcmVhZCIsInNraXBDaHVua0NoZWNrIiwicmVhZGFibGVBZGRDaHVuayIsImFkZFRvRnJvbnQiLCJvbkVvZkNodW5rIiwiY2h1bmtJbnZhbGlkIiwiYWRkQ2h1bmsiLCJtYXliZVJlYWRNb3JlIiwibmVlZE1vcmVEYXRhIiwiZW1pdFJlYWRhYmxlIiwiaXNQYXVzZWQiLCJzZXRFbmNvZGluZyIsImVuYyIsIk1BWF9IV00iLCJjb21wdXRlTmV3SGlnaFdhdGVyTWFyayIsImhvd011Y2hUb1JlYWQiLCJuT3JpZyIsImVuZFJlYWRhYmxlIiwiZG9SZWFkIiwiZnJvbUxpc3QiLCJlbWl0UmVhZGFibGVfIiwibWF5YmVSZWFkTW9yZV8iLCJkZXN0IiwicGlwZU9wdHMiLCJkb0VuZCIsInN0ZG91dCIsInN0ZGVyciIsImVuZEZuIiwidW5waXBlIiwib251bnBpcGUiLCJ1bnBpcGVJbmZvIiwiaGFzVW5waXBlZCIsImNsZWFudXAiLCJvbmRyYWluIiwicGlwZU9uRHJhaW4iLCJjbGVhbmVkVXAiLCJvbmNsb3NlIiwib25maW5pc2giLCJvbmVycm9yIiwib25kYXRhIiwiaW5jcmVhc2VkQXdhaXREcmFpbiIsInBhdXNlIiwicmVzdW1lIiwiZGVzdHMiLCJldiIsIm5SZWFkaW5nTmV4dFRpY2siLCJyZXN1bWVfIiwicGF1c2VkIiwiX2Zyb21MaXN0IiwiZnJvbUxpc3RQYXJ0aWFsIiwiaGFzU3RyaW5ncyIsImNvcHlGcm9tQnVmZmVyU3RyaW5nIiwiY29weUZyb21CdWZmZXIiLCJuYiIsImVuZFJlYWRhYmxlTlQiLCJ4cyIsInJlYWRhYmxlRGVzdHJveWVkIiwid3JpdGFibGVEZXN0cm95ZWQiLCJlbWl0RXJyb3JOVCIsIl9ub3JtYWxpemVFbmNvZGluZyIsInJldHJpZWQiLCJub3JtYWxpemVFbmNvZGluZyIsIm5lbmMiLCJ0ZXh0IiwidXRmMTZUZXh0IiwidXRmMTZFbmQiLCJmaWxsTGFzdCIsInV0ZjhGaWxsTGFzdCIsImJhc2U2NFRleHQiLCJiYXNlNjRFbmQiLCJzaW1wbGVXcml0ZSIsInNpbXBsZUVuZCIsImxhc3ROZWVkIiwibGFzdFRvdGFsIiwibGFzdENoYXIiLCJ1dGY4RW5kIiwidXRmOFRleHQiLCJ1dGY4Q2hlY2tCeXRlIiwiYnl0ZSIsInV0ZjhDaGVja0luY29tcGxldGUiLCJ1dGY4Q2hlY2tFeHRyYUJ5dGVzIiwidG90YWwiLCJhZnRlclRyYW5zZm9ybSIsInRzIiwiX3RyYW5zZm9ybVN0YXRlIiwidHJhbnNmb3JtaW5nIiwid3JpdGVjaHVuayIsInJzIiwibmVlZFRyYW5zZm9ybSIsIndyaXRlZW5jb2RpbmciLCJfdHJhbnNmb3JtIiwiX2ZsdXNoIiwiX3RoaXMyIiwiZXJyMiIsIkNWVXRpbHMiLCJOZGFycmF5IiwiSW50ZXJwMkQiLCJkMiIsIkZyYW1lR3JhYmJlciIsIl90aGF0IiwiX3ZpZGVvU2l6ZSIsImdldFJlYWxXaWR0aCIsImdldFJlYWxIZWlnaHQiLCJfY2FudmFzU2l6ZSIsImdldENhbnZhc1NpemUiLCJfc2l6ZSIsIl90b3BSaWdodCIsImdldFRvcFJpZ2h0IiwiX2RhdGEiLCJfZ3JheURhdGEiLCJfY2FudmFzRGF0YSIsIl9ncmF5SW1hZ2VBcnJheSIsIl9jYW52YXNJbWFnZUFycmF5IiwiX3RhcmdldEltYWdlQXJyYXkiLCJfc3RlcFNpemVYIiwiX3N0ZXBTaXplWSIsInZpZGVvU2l6ZSIsImNhbnZhc1NpemUiLCJzdGVwU2l6ZSIsInRvcFJpZ2h0IiwiYXR0YWNoRGF0YSIsImdyYWIiLCJnZXRGcmFtZSIsInNjYWxlQW5kQ3JvcCIsImdldFNpemUiLCJhbmdsZSIsInRyYW5zZm9ybVF1YXQiLCJyb3RhdGVYIiwicm90YXRlWSIsInJvdGF0ZVoiLCJjcmVhdGVDb250b3VyMkQiLCJmaXJzdFZlcnRleCIsImluc2lkZUNvbnRvdXJzIiwibmV4dHBlZXIiLCJwcmV2cGVlciIsIkNPTlRPVVJfRElSIiwiQ1dfRElSIiwiQ0NXX0RJUiIsIlVOS05PV05fRElSIiwiRElSIiwiT1VUU0lERV9FREdFIiwiSU5TSURFX0VER0UiLCJ0cmFjZXIiLCJkZXB0aGxhYmVsIiwiYmMiLCJsYyIsImxhYmVsaW5kZXgiLCJjb2xvck1hcCIsInZlcnRleCIsImNjIiwic2MiLCJjb25uZWN0ZWRDb3VudCIsImRyYXdDb250b3VyIiwiZmlyc3RDb250b3VyIiwicHEiLCJpcSIsInEiLCJTa2VsZXRvbml6ZXIiLCJzdGRsaWIiLCJmb3JlaWduIiwiaW1hZ2VzIiwiaW11bCIsImluSW1hZ2VQdHIiLCJvdXRJbWFnZVB0ciIsImFJbWFnZVB0ciIsImJJbWFnZVB0ciIsImltYWdlUHRyIiwibWVtY3B5Iiwic3JjSW1hZ2VQdHIiLCJkc3RJbWFnZVB0ciIsInN1YkltYWdlUHRyIiwiZXJvZGVkSW1hZ2VQdHIiLCJ0ZW1wSW1hZ2VQdHIiLCJza2VsSW1hZ2VQdHIiLCJuZGFycmF5IiwiR2lmUmVhZGVyIiwicGFjayIsInRocm91Z2giLCJwYXJzZURhdGFVUkkiLCJkZWZhdWx0SW1hZ2UiLCJ1cmwiLCJjcm9zc09yaWdpbiIsInBpeGVscyIsImhhbmRsZUdpZiIsInJlYWRlciIsIm51bUZyYW1lcyIsIm5zaGFwZSIsIm5kYXRhIiwiZGVjb2RlQW5kQmxpdEZyYW1lUkdCQSIsImh0dHBHaWYiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJyZXNwb25zZVR5cGUiLCJvdmVycmlkZU1pbWVUeXBlIiwicmVhZHlTdGF0ZSIsInJlc3BvbnNlIiwic2VuZCIsImNvcHlCdWZmZXIiLCJkYXRhR2lmIiwiZ2V0UGl4ZWxzIiwiZXh0bmFtZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsImFoIiwiYWwiLCJiaCIsImJsIiwibmV4dFNvdXJjZSIsIm5leHRLZXkiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfbiIsIl9kIiwiX2UiLCJfaSIsIl9zIiwiX25vbkl0ZXJhYmxlUmVzdCIsImEwIiwiYTEiLCJiMCIsImIxIiwidCIsImF4IiwiYXkiLCJtU3EiLCJ0ZW1wQSIsInRlbXBCIiwiY29zaW5lIiwiYWNvcyIsImEyIiwiYjIiLCJheiIsImJ4IiwiYnkiLCJieiIsInpTY2FsZSIsInF4IiwicXkiLCJxeiIsInF3IiwiaXgiLCJpeSIsIml6IiwiaXciLCJweSIsInB6IiwiX3NldFByb3RvdHlwZU9mIiwid2VicGFja1BvbHlmaWxsIiwiY2hpbGRyZW4iLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiaXRlciIsIl9ub25JdGVyYWJsZVNwcmVhZCIsIl9zdXBlclByb3BCYXNlIiwicnVudGltZSIsIk9wIiwiaGFzT3duIiwiJFN5bWJvbCIsIml0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJ0b1N0cmluZ1RhZ1N5bWJvbCIsImlubmVyRm4iLCJvdXRlckZuIiwidHJ5TG9jc0xpc3QiLCJwcm90b0dlbmVyYXRvciIsIkdlbmVyYXRvciIsImdlbmVyYXRvciIsIkNvbnRleHQiLCJfaW52b2tlIiwibWFrZUludm9rZU1ldGhvZCIsInRyeUNhdGNoIiwiR2VuU3RhdGVTdXNwZW5kZWRTdGFydCIsIkdlblN0YXRlU3VzcGVuZGVkWWllbGQiLCJHZW5TdGF0ZUV4ZWN1dGluZyIsIkdlblN0YXRlQ29tcGxldGVkIiwiQ29udGludWVTZW50aW5lbCIsIkdlbmVyYXRvckZ1bmN0aW9uIiwiR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUiLCJJdGVyYXRvclByb3RvdHlwZSIsImdldFByb3RvIiwiTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUiLCJHcCIsImRpc3BsYXlOYW1lIiwiZGVmaW5lSXRlcmF0b3JNZXRob2RzIiwiaXNHZW5lcmF0b3JGdW5jdGlvbiIsImdlbkZ1biIsIm1hcmsiLCJhd3JhcCIsIl9fYXdhaXQiLCJBc3luY0l0ZXJhdG9yIiwiUHJvbWlzZUltcGwiLCJyZWNvcmQiLCJ1bndyYXBwZWQiLCJwcmV2aW91c1Byb21pc2UiLCJlbnF1ZXVlIiwiY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmciLCJhc3luYyIsImRvbmVSZXN1bHQiLCJkZWxlZ2F0ZSIsImRlbGVnYXRlUmVzdWx0IiwibWF5YmVJbnZva2VEZWxlZ2F0ZSIsInNlbnQiLCJfc2VudCIsImRpc3BhdGNoRXhjZXB0aW9uIiwiYWJydXB0IiwicmVzdWx0TmFtZSIsIm5leHRMb2MiLCJwdXNoVHJ5RW50cnkiLCJsb2NzIiwidHJ5TG9jIiwiY2F0Y2hMb2MiLCJmaW5hbGx5TG9jIiwiYWZ0ZXJMb2MiLCJ0cnlFbnRyaWVzIiwicmVzZXRUcnlFbnRyeSIsImNvbXBsZXRpb24iLCJyZXNldCIsIml0ZXJhdG9yTWV0aG9kIiwic2tpcFRlbXBSZXNldCIsInN0b3AiLCJyb290RW50cnkiLCJyb290UmVjb3JkIiwicnZhbCIsImV4Y2VwdGlvbiIsImhhbmRsZSIsImxvYyIsImNhdWdodCIsImhhc0NhdGNoIiwiaGFzRmluYWxseSIsImZpbmFsbHlFbnRyeSIsImNvbXBsZXRlIiwidGhyb3duIiwiZGVsZWdhdGVZaWVsZCIsInJlZ2VuZXJhdG9yUnVudGltZSIsImFjY2lkZW50YWxTdHJpY3RNb2RlIiwiYTMiLCJiMyIsImRldCIsInYwIiwidjEiLCJMIiwiVSIsImxvb2t1cCIsInJldkxvb2t1cCIsIkFyciIsImdldExlbnMiLCJiNjQiLCJ2YWxpZExlbiIsInBsYWNlSG9sZGVyc0xlbiIsImxlbnMiLCJfYnl0ZUxlbmd0aCIsImN1ckJ5dGUiLCJ0cmlwbGV0VG9CYXNlNjQiLCJudW0iLCJlbmNvZGVDaHVuayIsInVpbnQ4Iiwib3V0cHV0IiwiZXh0cmFCeXRlcyIsInBhcnRzIiwibWF4Q2h1bmtMZW5ndGgiLCJsZW4yIiwiaXNMRSIsIm1MZW4iLCJuQnl0ZXMiLCJlTGVuIiwiZU1heCIsImVCaWFzIiwibkJpdHMiLCJOYU4iLCJydCIsIkxOMiIsIm5vcm1hbGl6ZUFycmF5IiwiYWxsb3dBYm92ZVJvb3QiLCJ1cCIsInJlc29sdmVkUGF0aCIsInJlc29sdmVkQWJzb2x1dGUiLCJpc0Fic29sdXRlIiwidHJhaWxpbmdTbGFzaCIsInJlbGF0aXZlIiwiZnJvbVBhcnRzIiwidG9QYXJ0cyIsInNhbWVQYXJ0c0xlbmd0aCIsIm91dHB1dFBhcnRzIiwic2VwIiwiZGVsaW1pdGVyIiwiZGlybmFtZSIsImhhc1Jvb3QiLCJtYXRjaGVkU2xhc2giLCJiYXNlbmFtZSIsImYiLCJzdGFydERvdCIsInN0YXJ0UGFydCIsInByZURvdFN0YXRlIiwiaXNTbG93QnVmZmVyIiwiR2lmV3JpdGVyIiwiZ29wdHMiLCJsb29wX2NvdW50IiwibG9vcCIsImdsb2JhbF9wYWxldHRlIiwicGFsZXR0ZSIsImNoZWNrX3BhbGV0dGVfYW5kX251bV9jb2xvcnMiLCJudW1fY29sb3JzIiwiZ3BfbnVtX2NvbG9yc19wb3cyIiwiYmFja2dyb3VuZCIsImdwX251bV9jb2xvcnMiLCJpbCIsImFkZEZyYW1lIiwiaW5kZXhlZF9waXhlbHMiLCJvcHRzIiwidXNpbmdfbG9jYWxfcGFsZXR0ZSIsIm1pbl9jb2RlX3NpemUiLCJkaXNwb3NhbCIsInVzZV90cmFuc3BhcmVuY3kiLCJ0cmFuc3BhcmVudF9pbmRleCIsInRyYW5zcGFyZW50IiwiR2lmV3JpdGVyT3V0cHV0TFpXQ29kZVN0cmVhbSIsImdldE91dHB1dEJ1ZmZlciIsInNldE91dHB1dEJ1ZmZlciIsImdldE91dHB1dEJ1ZmZlclBvc2l0aW9uIiwic2V0T3V0cHV0QnVmZmVyUG9zaXRpb24iLCJpbmRleF9zdHJlYW0iLCJjdXJfc3ViYmxvY2siLCJjbGVhcl9jb2RlIiwiY29kZV9tYXNrIiwiZW9pX2NvZGUiLCJuZXh0X2NvZGUiLCJjdXJfY29kZV9zaXplIiwiY3VyX3NoaWZ0IiwiY3VyIiwiZW1pdF9ieXRlc190b19idWZmZXIiLCJiaXRfYmxvY2tfc2l6ZSIsImVtaXRfY29kZSIsImliX2NvZGUiLCJjb2RlX3RhYmxlIiwiY3VyX2tleSIsImN1cl9jb2RlIiwicGYwIiwiZ2xvYmFsX3BhbGV0dGVfZmxhZyIsIm51bV9nbG9iYWxfY29sb3JzX3BvdzIiLCJudW1fZ2xvYmFsX2NvbG9ycyIsImdsb2JhbF9wYWxldHRlX29mZnNldCIsImdsb2JhbF9wYWxldHRlX3NpemUiLCJub19lb2YiLCJmcmFtZXMiLCJibG9ja19zaXplIiwicGYxIiwicGYyIiwibG9jYWxfcGFsZXR0ZV9mbGFnIiwiaW50ZXJsYWNlX2ZsYWciLCJudW1fbG9jYWxfY29sb3JzX3BvdzIiLCJudW1fbG9jYWxfY29sb3JzIiwicGFsZXR0ZV9vZmZzZXQiLCJwYWxldHRlX3NpemUiLCJoYXNfbG9jYWxfcGFsZXR0ZSIsImRhdGFfb2Zmc2V0IiwiZGF0YV9sZW5ndGgiLCJpbnRlcmxhY2VkIiwibG9vcENvdW50IiwiZnJhbWVJbmZvIiwiZnJhbWVfbnVtIiwiZGVjb2RlQW5kQmxpdEZyYW1lQkdSQSIsIm51bV9waXhlbHMiLCJHaWZSZWFkZXJMWldPdXRwdXRJbmRleFN0cmVhbSIsInRyYW5zIiwiZnJhbWV3aWR0aCIsImZyYW1lc3RyaWRlIiwieGxlZnQiLCJvcGJlZyIsIm9wZW5kIiwib3AiLCJzY2Fuc3RyaWRlIiwiaW50ZXJsYWNlc2tpcCIsImNvZGVfc3RyZWFtIiwib3V0cHV0X2xlbmd0aCIsInN1YmJsb2NrX3NpemUiLCJwcmV2X2NvZGUiLCJjaGFzZV9jb2RlIiwiY2hhc2VfbGVuZ3RoIiwiY2hhc2UiLCJvcF9lbmQiLCJkb19jb252ZXJ0IiwiY3JlYXRlVGh1bmsiLCJQcm9jZWR1cmUiLCJhcmdUeXBlcyIsInNoaW1BcmdzIiwiYXJyYXlBcmdzIiwiYXJyYXlCbG9ja0luZGljZXMiLCJzY2FsYXJBcmdzIiwib2Zmc2V0QXJncyIsIm9mZnNldEFyZ0luZGV4IiwiaW5kZXhBcmdzIiwic2hhcGVBcmdzIiwicHJlIiwiYm9keSIsInBvc3QiLCJjb21waWxlQ3dpc2UiLCJ1c2VyX2FyZ3MiLCJwcm9jIiwicHJvY19hcmdzIiwiYXJnX3R5cGUiLCJibG9ja0luZGljZXMiLCJsdmFsdWUiLCJwcmludENvZGUiLCJibG9ja1NpemUiLCJjb21waWxlIiwidmFycyIsInRodW5rTmFtZSIsInR5cGVzaWciLCJzdHJpbmdfdHlwZXNpZyIsInNoYXBlTGVuZ3RoQ29uZGl0aW9ucyIsInNoYXBlQ29uZGl0aW9ucyIsInRodW5rIiwiaW5uZXJGaWxsIiwibmFyZ3MiLCJoYXNfaW5kZXgiLCJwaWR4Iiwib3V0ZXJGaWxsIiwibWF0Y2hlZCIsImluZGV4U3RyIiwiY291bnRNYXRjaGVzIiwicHJvY2Vzc0Jsb2NrIiwiYmxvY2siLCJkdHlwZXMiLCJjYXJnIiwicHRyU3RyIiwiYXJyTnVtIiwib2ZmQXJnSW5kZXgiLCJvZmZBcmciLCJsb2NhbFN0ciIsImFyclN0ciIsInJlU3RyQXJyIiwicHRyU3RyQXJyIiwidHlwZVN1bW1hcnkiLCJzdW1tYXJ5IiwiYWxsRXF1YWwiLCJkaWdpdHMiLCJnZW5lcmF0ZUNXaXNlT3AiLCJibG9ja0JlZ2luIiwiYmxvY2tFbmQiLCJsb29wQmVnaW4iLCJsb29wRW5kIiwibG9vcE9yZGVycyIsIm5ld09yZGVyIiwiYXJnbGlzdCIsInplcm9zIiwib2ZmX2FyZyIsImluaXRfc3RyaW5nIiwidGhpc1ZhcnMiLCJsb29wTmFtZSIsInVuaXF1ZV9wcmVkIiwicHRyIiwidW5pcXVlX2VxIiwidW5pcXVlIiwic29ydGVkIiwiX2VuZGVkIiwiYXV0b0Rlc3Ryb3kiLCJkcmFpbiIsIl9lbmQiLCJfaXNTdGRpbyIsImRpZE9uRW5kIiwiY3VzdG9tIiwic2NvcGUiLCJUaW1lb3V0Iiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiY2xvc2UiLCJjbGVhckZuIiwiX2lkIiwiX2NsZWFyRm4iLCJ1bnJlZiIsInJlZiIsImVucm9sbCIsIm1zZWNzIiwiX2lkbGVUaW1lb3V0SWQiLCJfaWRsZVRpbWVvdXQiLCJ1bmVucm9sbCIsIl91bnJlZkFjdGl2ZSIsImFjdGl2ZSIsIm9uVGltZW91dCIsIl9vblRpbWVvdXQiLCJjbGVhckltbWVkaWF0ZSIsIm5leHRIYW5kbGUiLCJ0YXNrc0J5SGFuZGxlIiwiY3VycmVudGx5UnVubmluZ0FUYXNrIiwiZG9jIiwicmVnaXN0ZXJJbW1lZGlhdGUiLCJ0YXNrIiwicnVuSWZQcmVzZW50IiwiaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24iLCJjYW5Vc2VQb3N0TWVzc2FnZSIsInBvc3RNZXNzYWdlIiwiaW1wb3J0U2NyaXB0cyIsInBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMiLCJvbGRPbk1lc3NhZ2UiLCJvbm1lc3NhZ2UiLCJpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbiIsIm1lc3NhZ2VQcmVmaXgiLCJvbkdsb2JhbE1lc3NhZ2UiLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbiIsImNoYW5uZWwiLCJNZXNzYWdlQ2hhbm5lbCIsInBvcnQxIiwicG9ydDIiLCJpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uIiwiaHRtbCIsImRvY3VtZW50RWxlbWVudCIsInNjcmlwdCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlbW92ZUNoaWxkIiwiaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbiIsImF0dGFjaFRvIiwibXNnIiwiZGVwcmVjYXRlZCIsImxvY2FsU3RvcmFnZSIsImRhdGFVcmlUb0J1ZmZlciIsInVyaSIsImZpcnN0Q29tbWEiLCJtZXRhIiwiY2hhcnNldCIsImludGVycDFkIiwiZngiLCJzMCIsInMxIiwidzAiLCJ3MSIsImludGVycDJkIiwiZnkiLCJ0MCIsInQxIiwidzAwIiwidzAxIiwidzEwIiwidzExIiwiaW50ZXJwM2QiLCJmeiIsInUwIiwidTEiLCJ3MDAwIiwidzAxMCIsIncxMDAiLCJ3MTEwIiwidzAwMSIsIncwMTEiLCJ3MTAxIiwidzExMSIsImludGVycE5kIiwiaV9sb29wIiwiZDEiLCJkMyIsIkJyZXNlbmhhbSIsIlNsb3BlIiwiVVAiLCJET1dOIiwiZ2V0QmFyY29kZUxpbmUiLCJ4MCIsInkwIiwieDEiLCJ5MSIsInN0ZWVwIiwiZGVsdGFYIiwiZGVsdGFZIiwieVN0ZXAiLCJ0b0JpbmFyeUxpbmUiLCJzbG9wZSIsInNsb3BlMiIsImV4dHJlbWEiLCJjdXJyZW50RGlyIiwiclRocmVzaG9sZCIsInByaW50RnJlcXVlbmN5IiwicHJpbnRQYXR0ZXJuIiwiZmlsbENvbG9yIiwiZmlsbFJlY3QiLCJCYXJjb2RlRGlyZWN0aW9uIiwiQmFyY29kZVJlYWRlciIsIlN0YXJ0Tm90Rm91bmRFeGNlcHRpb24iLCJDb2RlTm90Rm91bmRFeGNlcHRpb24iLCJQYXR0ZXJuTm90Rm91bmRFeGNlcHRpb24iLCJzdXBwbGVtZW50cyIsIl9yb3ciLCJjb3VudGVyIiwibWF4U2luZ2xlRXJyb3IiLCJzaW5nbGVFcnJvciIsIm1vZHVsbyIsImJhcldpZHRoIiwic2NhbGVkIiwiU0lOR0xFX0NPREVfRVJST1IiLCJjb3JyZWN0aW9uIiwiX2RlY29kZSIsImRpcmVjdGlvbiIsIlJldmVyc2UiLCJGb3J3YXJkIiwiZm9ybWF0IiwiRk9STUFUIiwiX25leHRVbnNldCIsImlzV2hpdGUiLCJjb3VudGVycyIsImNvdW50ZXJQb3MiLCJudW1Db3VudGVycyIsIkNvZGUxMjhSZWFkZXIiLCJiYXIiLCJzcGFjZSIsImJlc3RNYXRjaCIsIl9jb3JyZWN0IiwiQ09ERV9QQVRURVJOIiwiX21hdGNoUGF0dGVybiIsIkFWR19DT0RFX0VSUk9SIiwiY2FsY3VsYXRlQ29ycmVjdGlvbiIsIk1PRFVMRV9JTkRJQ0VTIiwiX2NvcnJlY3RCYXJzIiwiX25leHRTZXQiLCJTVEFSVF9DT0RFX0EiLCJTVEFSVF9DT0RFX0MiLCJzdGFydEluZm8iLCJfZmluZFN0YXJ0IiwiZGVjb2RlZENvZGVzIiwiY2hlY2tzdW0iLCJjb2Rlc2V0IiwiQ09ERV9BIiwiU1RBUlRfQ09ERV9CIiwiQ09ERV9CIiwiQ09ERV9DIiwic2hpZnROZXh0IiwicmVtb3ZlTGFzdENoYXJhY3RlciIsInJhd1Jlc3VsdCIsIl9kZWNvZGVDb2RlIiwiU1RPUF9DT0RFIiwiQ09ERV9TSElGVCIsIl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UiLCJlbmRJbmZvIiwidHJhaWxpbmdXaGl0ZXNwYWNlRW5kIiwiX21hdGNoUmFuZ2UiLCJleHBlY3RlZCIsIm5vcm1hbGl6ZWQiLCJzdW1Ob3JtYWxpemVkIiwic3VtRXhwZWN0ZWQiLCJDT0RFX0dfU1RBUlQiLCJTVEFSVF9QQVRURVJOIiwiTUlERExFX1BBVFRFUk4iLCJFWFRFTlNJT05fU1RBUlRfUEFUVEVSTiIsIkNPREVfRlJFUVVFTkNZIiwiRUFOUmVhZGVyIiwidHJ5SGFyZGVyIiwiZXBzaWxvbiIsImNvZGVyYW5nZSIsIl9maW5kUGF0dGVybiIsImxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQiLCJjb2RlRnJlcXVlbmN5IiwiaW5Db2RlIiwib3V0Q29kZSIsImZpcnN0RGlnaXQiLCJfY2FsY3VsYXRlRmlyc3REaWdpdCIsIm1pZGRsZVBhdHRlcm4iLCJTVE9QX1BBVFRFUk4iLCJyZXN1bHRJbmZvIiwiX2RlY29kZVBheWxvYWQiLCJfZmluZEVuZCIsIl9jaGVja3N1bSIsInN1cHBsZW1lbnQiLCJfZGVjb2RlRXh0ZW5zaW9ucyIsImxhc3RDb2RlIiwiQUxQSEFCRVRIX1NUUklORyIsIkFMUEhBQkVUIiwiVWludDE2QXJyYXkiLCJjaGFyIiwiQ0hBUkFDVEVSX0VOQ09ESU5HUyIsIkFTVEVSSVNLIiwiQ29kZTM5UmVhZGVyIiwicGF0dGVyblN0YXJ0IiwiX3RvUGF0dGVybiIsIndoaXRlU3BhY2VNdXN0U3RhcnQiLCJtYXhOYXJyb3dXaWR0aCIsIm51bVdpZGVCYXJzIiwid2lkZUJhcldpZHRoIiwiX2ZpbmROZXh0V2lkdGgiLCJtaW5XaWR0aCIsImxhc3RTdGFydCIsIm5leHRTdGFydCIsInBhdHRlcm5TaXplIiwiZGVjb2RlZENoYXIiLCJfdG9Db3VudGVycyIsIl9wYXR0ZXJuVG9DaGFyIiwicGF0dGVybnMiLCJJT1EiLCJBWjA5IiwiQ29kZTM5VklOUmVhZGVyIiwiX2NoZWNrQ2hlY2tzdW0iLCJTVEFSVF9FTkQiLCJNSU5fRU5DT0RFRF9DSEFSUyIsIk1BWF9BQ0NFUFRBQkxFIiwiUEFERElORyIsIk5ld0NvZGFiYXJSZWFkZXIiLCJfY291bnRlcnMiLCJiYXJUaHJlc2hvbGQiLCJfY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkIiwic3BhY2VUaHJlc2hvbGQiLCJfaXNTdGFydEVuZCIsIl9zdW1Db3VudGVycyIsInN0YXJ0Q291bnRlciIsImVuZENvdW50ZXIiLCJfY2FsY3VsYXRlUGF0dGVybkxlbmd0aCIsImNoYXJDb2RlIiwiY2F0ZWdvcml6YXRpb24iLCJuYXJyb3ciLCJjb3VudHMiLCJ3aWRlIiwiX2NoYXJUb1BhdHRlcm4iLCJraW5kIiwiY2F0IiwibmV3a2luZCIsInRocmVzaG9sZHMiLCJfdGhyZXNob2xkUmVzdWx0UGF0dGVybiIsIl9maWxsQ291bnRlcnMiLCJfdmVyaWZ5V2hpdGVzcGFjZSIsIl92YWxpZGF0ZVJlc3VsdCIsIlVQQ1JlYWRlciIsIkVBTjhSZWFkZXIiLCJFQU4yUmVhZGVyIiwiQ0hFQ0tfRElHSVRfRU5DT0RJTkdTIiwiZGV0ZXJtaW5lQ2hlY2tEaWdpdCIsImV4dGVuc2lvbkNoZWNrc3VtIiwiRUFONVJlYWRlciIsIlVQQ0VSZWFkZXIiLCJfZGV0ZXJtaW5lUGFyaXR5IiwibnJTeXN0ZW0iLCJ1cGNhIiwibGFzdERpZ2l0IiwiX2NvbnZlcnRUb1VQQ0EiLCJOIiwiVyIsIkkyb2Y1UmVhZGVyIiwibm9ybWFsaXplQmFyU3BhY2VXaWR0aCIsImNvdW50ZXJTdW0iLCJjb2RlU3VtIiwiY29ycmVjdGlvblJhdGlvIiwiTUFYX0NPUlJFQ1RJT05fRkFDVE9SIiwiY29ycmVjdGlvblJhdGlvSW52ZXJzZSIsImJhclNwYWNlUmF0aW8iLCJuYXJyb3dCYXJXaWR0aCIsImNvdW50ZXJQYWlyIiwiY29kZXMiLCJjb3VudGVyTGVuZ3RoIiwiX2RlY29kZVBhaXIiLCJfdmVyaWZ5Q291bnRlckxlbmd0aCIsIlNUQVJUX1BBVFRFUk5fTEVOR1RIIiwiVHdvT2ZGaXZlUmVhZGVyIiwiQ29kZTkzUmVhZGVyIiwiY2hhckFycmF5IiwibmV4dENoYXIiLCJuZXh0Q2hhckNvZGUiLCJtYXhXZWlnaHQiLCJhcnJheVRvQ2hlY2siLCJ3ZWlnaHRlZFN1bXMiLCJ3ZWlnaHQiLCJjaGVja0NoYXIiLCJfbWF0Y2hDaGVja0NoYXIiLCJfdmVyaWZ5RW5kIiwiX3ZlcmlmeUNoZWNrc3VtcyIsIl9kZWNvZGVFeHRlbmRlZCIsIkFFSU8iLCJjb2RlMzJzZXQiLCJDb2RlMzJSZWFkZXIiLCJjb2RlMzIiLCJfZGVjb2RlQ29kZTMyIiwiUkVBREVSUyIsImNvZGVfMTI4X3JlYWRlciIsImVhbl9yZWFkZXIiLCJlYW5fNV9yZWFkZXIiLCJlYW5fMl9yZWFkZXIiLCJlYW5fOF9yZWFkZXIiLCJjb2RlXzM5X3JlYWRlciIsImNvZGVfMzlfdmluX3JlYWRlciIsImNvZGFiYXJfcmVhZGVyIiwiQ29kYWJhclJlYWRlciIsInVwY19yZWFkZXIiLCJ1cGNfZV9yZWFkZXIiLCJpMm9mNV9yZWFkZXIiLCJjb2RlXzkzX3JlYWRlciIsImNvZGVfMzJfcmVhZGVyIiwicmVnaXN0ZXJSZWFkZXIiLCJfY2FudmFzIiwiZnJlcXVlbmN5IiwiX2JhcmNvZGVSZWFkZXJzIiwiaW5pdFJlYWRlcnMiLCJpbml0Q29uZmlnIiwiJGRlYnVnIiwicmVhZGVycyIsInJlYWRlckNvbmZpZyIsImNvbmZpZ3VyYXRpb24iLCJyZWFkZXJPYmoiLCJ2aXMiLCJub2RlIiwic2hvd0ZyZXF1ZW5jeSIsInNob3dQYXR0ZXJuIiwiZGlzcGxheSIsImdldEV4dGVuZGVkTGluZSIsImV4dGVuZExpbmUiLCJhbW91bnQiLCJleHRlbnNpb24iLCJpbkltYWdlV2l0aEJvcmRlciIsImdldExpbmUiLCJ0cnlEZWNvZGUiLCJiYXJjb2RlTGluZSIsImRlY29kZVBhdHRlcm4iLCJjb2RlUmVzdWx0IiwidHJ5RGVjb2RlQnJ1dGVGb3JjZSIsImxpbmVBbmdsZSIsInNpZGVMZW5ndGgiLCJzbGljZXMiLCJ4ZGlyIiwieWRpciIsImdldExpbmVMZW5ndGgiLCJkZWNvZGVGcm9tSW1hZ2UiLCJkZWNvZGVJbWFnZSIsImRlY29kZUZyb21Cb3VuZGluZ0JveCIsImRyYXdCb3VuZGluZ0JveCIsImxpbmVMZW5ndGgiLCJhdGFuMiIsImRyYXdTY2FubGluZSIsImRlY29kZUZyb21Cb3VuZGluZ0JveGVzIiwiYmFyY29kZXMiLCJtdWx0aXBsZSIsInNldFJlYWRlcnMiLCJFdmVudEludGVyZmFjZSIsImdldEV2ZW50IiwiZXZlbnROYW1lIiwic3Vic2NyaWJlcnMiLCJjbGVhckV2ZW50cyIsInB1Ymxpc2hTdWJzY3JpcHRpb24iLCJzdWJzY3JpcHRpb24iLCJfc3Vic2NyaWJlIiwic3Vic2NyaWJlIiwicHVibGlzaCIsInN1YnNjcmliZXIiLCJ1bnN1YnNjcmliZSIsImVudW1lcmF0ZURldmljZXMiLCJuYXZpZ2F0b3IiLCJtZWRpYURldmljZXMiLCJnZXRVc2VyTWVkaWEiLCJjb25zdHJhaW50cyIsInN0cmVhbVJlZiIsIndhaXRGb3JWaWRlbyIsInZpZGVvIiwiYXR0ZW1wdHMiLCJjaGVja1ZpZGVvIiwidmlkZW9XaWR0aCIsInZpZGVvSGVpZ2h0IiwiaW5pdENhbWVyYSIsInNldEF0dHJpYnV0ZSIsInNyY09iamVjdCIsInBsYXkiLCJkZXByZWNhdGVkQ29uc3RyYWludHMiLCJ2aWRlb0NvbnN0cmFpbnRzIiwibWluQXNwZWN0UmF0aW8iLCJhc3BlY3RSYXRpbyIsImZhY2luZyIsImZhY2luZ01vZGUiLCJwaWNrQ29uc3RyYWludHMiLCJkZXZpY2VJZCIsImF1ZGlvIiwiZW51bWVyYXRlVmlkZW9EZXZpY2VzIiwiZGV2aWNlcyIsImRldmljZSIsImdldEFjdGl2ZVRyYWNrIiwidHJhY2tzIiwiZ2V0VmlkZW9UcmFja3MiLCJRdWFnZ2FKU0NhbWVyYUFjY2VzcyIsInJlcXVlc3QiLCJuZXdDb25zdHJhaW50cyIsInJlbGVhc2UiLCJnZXRBY3RpdmVTdHJlYW1MYWJlbCIsInRyYWNrIiwiY29udGFpbnMiLCJwYXNzZXNGaWx0ZXIiLCJyZXN1bHRzIiwiY2FwYWNpdHkiLCJjYXB0dXJlIiwibWF0Y2hlc0NvbnN0cmFpbnRzIiwiYmxhY2tsaXN0IiwiYWRkUmVzdWx0IiwiaW1hZ2VTaXplIiwidG9EYXRhVVJMIiwiZ2V0UmVzdWx0cyIsIkRldkNvbmZpZyIsIm51bU9mV29ya2VycyIsImxvY2F0b3IiLCJOb2RlQ29uZmlnIiwic2VxdWVuY2UiLCJQcm9kQ29uZmlnIiwiUXVhZ2dhQ29uZmlnIiwiUXVhZ2dhQ29udGV4dCIsIkNhbnZhc0NvbnRhaW5lciIsIkNhbnZhc0luZm8iLCJib3hTaXplIiwiQmFyY29kZUxvY2F0b3IiLCJnZXRWaWV3UG9ydCIsIkhUTUxFbGVtZW50Iiwibm9kZU5hbWUiLCJzZWxlY3RvciIsImZpbmRPckNyZWF0ZUNhbnZhcyIsImdldENhbnZhc0FuZENvbnRleHQiLCJpbml0Q2FudmFzZXMiLCJpbWFnZSIsInZpZXdwb3J0IiwiY29udGFpbmVyIiwiRXhpZlRhZ3MiLCJBdmFpbGFibGVUYWdzIiwiZmluZFRhZ3NJbk9iamVjdFVSTCIsInRhZ3MiLCJvYmplY3RVUkxUb0Jsb2IiLCJyZWFkVG9CdWZmZXIiLCJmaW5kVGFnc0luQnVmZmVyIiwiYmFzZTY0VG9BcnJheUJ1ZmZlciIsImRhdGFVcmwiLCJhdG9iIiwiYmxvYiIsImZpbGVSZWFkZXIiLCJGaWxlUmVhZGVyIiwicmVhZEFzQXJyYXlCdWZmZXIiLCJodHRwIiwiRE9ORSIsInN0YXR1cyIsImZpbGUiLCJzZWxlY3RlZFRhZ3MiLCJleGlmVGFncyIsInNlbGVjdGVkVGFnIiwiZXhpZlRhZyIsImdldFVpbnQ4IiwicmVhZEVYSUZEYXRhIiwiZ2V0VWludDE2IiwiZ2V0U3RyaW5nRnJvbUJ1ZmZlciIsInRpZmZPZmZzZXQiLCJiaWdFbmQiLCJmaXJzdElGRE9mZnNldCIsImdldFVpbnQzMiIsInJlYWRUYWdzIiwidGlmZlN0YXJ0IiwiZGlyU3RhcnQiLCJzdHJpbmdzIiwiZW50cnlPZmZzZXQiLCJyZWFkVGFnVmFsdWUiLCJudW1WYWx1ZXMiLCJvdXRzdHIiLCJJbWFnZUxvYWRlciIsImxvYWQiLCJkaXJlY3RvcnkiLCJodG1sSW1hZ2VzU3JjQXJyYXkiLCJodG1sSW1hZ2VzQXJyYXkiLCJub3RMb2FkZWQiLCJhZGRJbWFnZSIsImxvYWRlZCIsImxvYWRlZEltZyIsIm5vdGxvYWRlZEltZ3MiLCJpbWdOYW1lIiwiYWRkT25sb2FkSGFuZGxlciIsImlucHV0U3RyZWFtRmFjdG9yeSIsImNyZWF0ZVZpZGVvU3RyZWFtIiwiX2V2ZW50TmFtZXMiLCJfZXZlbnRIYW5kbGVycyIsIl9jYWxjdWxhdGVkV2lkdGgiLCJfY2FsY3VsYXRlZEhlaWdodCIsImluaXRTaXplIiwic2V0SW5wdXRTdHJlYW0iLCJzZXRDdXJyZW50VGltZSIsImJvb2wiLCJjbGVhckV2ZW50SGFuZGxlcnMiLCJoYW5kbGVycyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ0cmlnZ2VyIiwiY3JlYXRlTGl2ZVN0cmVhbSIsImNyZWF0ZUltYWdlU3RyZWFtIiwiZnJhbWVJZHgiLCJpbWdBcnJheSIsImJhc2VVcmwiLCJjYWxjdWxhdGVkV2lkdGgiLCJjYWxjdWxhdGVkSGVpZ2h0IiwibG9hZEltYWdlcyIsImltZ3MiLCJvcmllbnRhdGlvbiIsInB1Ymxpc2hFdmVudCIsIm5ld1dpZHRoIiwibmV3SGVpZ2h0IiwiaW5kIiwiR2V0UGl4ZWxzIiwibWltZSIsIkJyb3dzZXJJbnB1dFN0cmVhbSIsIlRPX1JBRElBTlMiLCJhZGp1c3RDYW52YXNTaXplIiwidGFyZ2V0U2l6ZSIsIl9zdHJlYW1Db25maWciLCJfc3giLCJfc3kiLCJfY3R4IiwiZG9IYWxmU2FtcGxlIiwiZHJhd2FibGUiLCJkcmF3QW5nbGUiLCJ0cmFuc2xhdGUiLCJ3b3JrZXJQb29sIiwidXBkYXRlV29ya2VycyIsImZyYW1lR3JhYmJlciIsImF2YWlsYWJsZVdvcmtlciIsIndvcmtlclRocmVhZCIsImJ1c3kiLCJ3b3JrZXIiLCJjbWQiLCJjb25maWdGb3JXb3JrZXIiLCJ3b3JrZXJJbnRlcmZhY2UiLCJmYWN0b3J5IiwiUXVhZ2dhIiwib25Qcm9jZXNzZWQiLCJ3b3JrZXJJbnRlcmZhY2VSZWFkeSIsImdlbmVyYXRlV29ya2VyQmxvYiIsImZhY3RvcnlTb3VyY2UiLCJfX2ZhY3RvcnlTb3VyY2VfXyIsIkJsb2IiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJpbml0V29ya2VyIiwiYmxvYlVSTCIsIldvcmtlciIsInJldm9rZU9iamVjdFVSTCIsImFkanVzdFdvcmtlclBvb2wiLCJpbmNyZWFzZUJ5Iiwid29ya2Vyc1RvVGVybWluYXRlIiwidGVybWluYXRlIiwid29ya2VySW5pdGlhbGl6ZWQiLCJzZXR1cElucHV0U3RyZWFtIiwiSW5wdXRTdHJlYW0iLCJtb3ZlQm94IiwieE9mZnNldCIsInlPZmZzZXQiLCJjb3JuZXIiLCJtb3ZlTGluZSIsIk5vZGVJbnB1dFN0cmVhbSIsIk5vZGVGcmFtZUdyYWJiZXIiLCJCcm93c2VyRnJhbWVHcmFiYmVyIiwiZnJhbWVncmFiYmVyIiwiY2FudmFzQ29udGFpbmVyIiwiUVdvcmtlcnMiLCJpbml0aWFsaXplRGF0YSIsInJlYWR5Iiwib25VSVRocmVhZCIsIndvcmtlcnNVcGRhdGVkIiwibG9jYXRlQW5kRGVjb2RlIiwiX2luaXRCdWZmZXJzIiwiQmFyY29kZURlY29kZXIiLCJfZ2V0Vmlld1BvcnQiLCJfaW5pdENhbnZhcyIsImlucHV0VHlwZSIsIkNhbWVyYUFjY2VzcyIsImNhblJlY29yZCIsImJhcmNvZGUiLCJ0cmFuc2Zvcm1SZXN1bHQiLCJyZXN1bHRDb2xsZWN0b3IiLCJyZXN1bHRUb1B1Ymxpc2giLCJFdmVudHMiLCJoYXNDb2RlUmVzdWx0IiwiZ2V0Qm91bmRpbmdCb3hlcyIsImRlY29kZVJlc3VsdCIsInB1Ymxpc2hSZXN1bHQiLCJpbWFnZVJlc3VsdCIsInN0b3BwZWQiLCJ0aW1lc3RhbXAiLCJwZXJmb3JtYW5jZSIsInN0YXJ0Q29udGludW91c1VwZGF0ZSIsIl9jb250ZXh0IiwiUXVhZ2dhSlNTdGF0aWNJbnRlcmZhY2UiLCJxdWFnZ2FJbnN0YW5jZSIsInByb21pc2UiLCJDb25maWciLCJpbml0SW5wdXRTdHJlYW0iLCJvbkRldGVjdGVkIiwib2ZmRGV0ZWN0ZWQiLCJvZmZQcm9jZXNzZWQiLCJyZWdpc3RlclJlc3VsdENvbGxlY3RvciIsImRlY29kZVNpbmdsZSIsInJlc3VsdENhbGxiYWNrIiwiZGVmYXVsdCIsIlJlc3VsdENvbGxlY3RvciJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87UUNWQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7QUNsRkEsU0FBU0EsZUFBVCxDQUF5QkMsR0FBekIsRUFBOEJDLEdBQTlCLEVBQW1DQyxLQUFuQyxFQUEwQztBQUN4QyxNQUFJRCxHQUFHLElBQUlELEdBQVgsRUFBZ0I7QUFDZEcsVUFBTSxDQUFDQyxjQUFQLENBQXNCSixHQUF0QixFQUEyQkMsR0FBM0IsRUFBZ0M7QUFDOUJDLFdBQUssRUFB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RUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FITyxFQUlQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FKTyxFQUtQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FMTyxFQU1QLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FOTyxFQU9QLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FQTyxFQVFQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FSTyxFQVNQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FUTyxFQVVQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FWTyxFQVdQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FYTyxFQVlQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FaTyxFQWFQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FiTyxFQWNQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FkTyxFQWVQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0Is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RjtBQUMzRnAwQyxhQUFPLENBQUNrRSxJQUFSLENBQWEsNkRBQWI7QUFDQW5xRCxZQUFNLENBQUM4eEYsWUFBUCxHQUFzQixDQUF0QjtBQUNIOztBQUNELFdBQU8sSUFBSW56RSxPQUFKLENBQVksVUFBQ29kLE9BQUQsRUFBVXNILE1BQVYsRUFBcUI7QUFDcEMsVUFBSTtBQUNBLGFBQUksQ0FBQ3hzQyxJQUFMLENBQVVtSixNQUFWLEVBQWtCLFlBQU07QUFDcEJ5OEYsZ0JBQU0sQ0FBQzMyRCxJQUFQLENBQVksV0FBWixFQUF5QixVQUFDL3BDLE1BQUQsRUFBWTtBQUNqQ3NoRywwQkFBYyxDQUFDajFCLElBQWY7O0FBQ0EsZ0JBQUkwMUIsY0FBSixFQUFvQjtBQUNoQkEsNEJBQWMsQ0FBQ2pyRyxJQUFmLENBQW9CLElBQXBCLEVBQTBCa0osTUFBMUI7QUFDSDs7QUFDRGdnQyxtQkFBTyxDQUFDaGdDLE1BQUQsQ0FBUDtBQUNILFdBTkQsRUFNRyxJQU5IO0FBT0FzaEcsd0JBQWMsQ0FBQzE3RSxLQUFmO0FBQ0gsU0FURCxFQVNHLElBVEgsRUFTUzA3RSxjQVRUO0FBVUgsT0FYRCxDQVdFLE9BQU9ob0QsR0FBUCxFQUFZO0FBQ1ZoUyxjQUFNLENBQUNnUyxHQUFELENBQU47QUFDSDtBQUNKLEtBZk0sQ0FBUDtBQWdCSCxHQXhIMkI7O0FBeUg1QjtBQUNBO0FBQ0EsTUFBSTBvRCxPQUFKLEdBQWM7QUFDVixXQUFPWCx1QkFBUDtBQUNILEdBN0gyQjs7QUE4SDVCNWUsZUFBYSxFQUFiQSxjQTlINEI7QUErSDVCMmQsY0FBWSxFQUFaQSxhQS9INEI7QUFnSTVCdDVDLFlBQVUsRUFBVkEsOEJBaEk0QjtBQWlJNUJqOEMsY0FBWSxFQUFaQSxnQ0FqSTRCO0FBa0k1Qm8zRixpQkFBZSxFQUFmQSxnQkFBZUE7QUFsSWEsQ0FBaEM7QUFxSWVaLG1HQUFmLEUsQ0FDQSIsImZpbGUiOiJxdWFnZ2EuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJRdWFnZ2FcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiUXVhZ2dhXCJdID0gZmFjdG9yeSgpO1xufSkod2luZG93LCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9cIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDY3KTtcbiIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eTsiLCJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQ7IiwiZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrOyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSByZXF1aXJlKFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIik7XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm47IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2ZcIik7XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW5oZXJpdHM7IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVQU0lMT046IHJlcXVpcmUoJy4vZXBzaWxvbicpXG4gICwgY3JlYXRlOiByZXF1aXJlKCcuL2NyZWF0ZScpXG4gICwgY2xvbmU6IHJlcXVpcmUoJy4vY2xvbmUnKVxuICAsIGZyb21WYWx1ZXM6IHJlcXVpcmUoJy4vZnJvbVZhbHVlcycpXG4gICwgY29weTogcmVxdWlyZSgnLi9jb3B5JylcbiAgLCBzZXQ6IHJlcXVpcmUoJy4vc2V0JylcbiAgLCBlcXVhbHM6IHJlcXVpcmUoJy4vZXF1YWxzJylcbiAgLCBleGFjdEVxdWFsczogcmVxdWlyZSgnLi9leGFjdEVxdWFscycpXG4gICwgYWRkOiByZXF1aXJlKCcuL2FkZCcpXG4gICwgc3VidHJhY3Q6IHJlcXVpcmUoJy4vc3VidHJhY3QnKVxuICAsIHN1YjogcmVxdWlyZSgnLi9zdWInKVxuICAsIG11bHRpcGx5OiByZXF1aXJlKCcuL211bHRpcGx5JylcbiAgLCBtdWw6IHJlcXVpcmUoJy4vbXVsJylcbiAgLCBkaXZpZGU6IHJlcXVpcmUoJy4vZGl2aWRlJylcbiAgLCBkaXY6IHJlcXVpcmUoJy4vZGl2JylcbiAgLCBpbnZlcnNlOiByZXF1aXJlKCcuL2ludmVyc2UnKVxuICAsIG1pbjogcmVxdWlyZSgnLi9taW4nKVxuICAsIG1heDogcmVxdWlyZSgnLi9tYXgnKVxuICAsIHJvdGF0ZTogcmVxdWlyZSgnLi9yb3RhdGUnKVxuICAsIGZsb29yOiByZXF1aXJlKCcuL2Zsb29yJylcbiAgLCBjZWlsOiByZXF1aXJlKCcuL2NlaWwnKVxuICAsIHJvdW5kOiByZXF1aXJlKCcuL3JvdW5kJylcbiAgLCBzY2FsZTogcmVxdWlyZSgnLi9zY2FsZScpXG4gICwgc2NhbGVBbmRBZGQ6IHJlcXVpcmUoJy4vc2NhbGVBbmRBZGQnKVxuICAsIGRpc3RhbmNlOiByZXF1aXJlKCcuL2Rpc3RhbmNlJylcbiAgLCBkaXN0OiByZXF1aXJlKCcuL2Rpc3QnKVxuICAsIHNxdWFyZWREaXN0YW5jZTogcmVxdWlyZSgnLi9zcXVhcmVkRGlzdGFuY2UnKVxuICAsIHNxckRpc3Q6IHJlcXVpcmUoJy4vc3FyRGlzdCcpXG4gICwgbGVuZ3RoOiByZXF1aXJlKCcuL2xlbmd0aCcpXG4gICwgbGVuOiByZXF1aXJlKCcuL2xlbicpXG4gICwgc3F1YXJlZExlbmd0aDogcmVxdWlyZSgnLi9zcXVhcmVkTGVuZ3RoJylcbiAgLCBzcXJMZW46IHJlcXVpcmUoJy4vc3FyTGVuJylcbiAgLCBuZWdhdGU6IHJlcXVpcmUoJy4vbmVnYXRlJylcbiAgLCBub3JtYWxpemU6IHJlcXVpcmUoJy4vbm9ybWFsaXplJylcbiAgLCBkb3Q6IHJlcXVpcmUoJy4vZG90JylcbiAgLCBjcm9zczogcmVxdWlyZSgnLi9jcm9zcycpXG4gICwgbGVycDogcmVxdWlyZSgnLi9sZXJwJylcbiAgLCByYW5kb206IHJlcXVpcmUoJy4vcmFuZG9tJylcbiAgLCB0cmFuc2Zvcm1NYXQyOiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDInKVxuICAsIHRyYW5zZm9ybU1hdDJkOiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDJkJylcbiAgLCB0cmFuc2Zvcm1NYXQzOiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDMnKVxuICAsIHRyYW5zZm9ybU1hdDQ6IHJlcXVpcmUoJy4vdHJhbnNmb3JtTWF0NCcpXG4gICwgZm9yRWFjaDogcmVxdWlyZSgnLi9mb3JFYWNoJylcbiAgLCBsaW1pdDogcmVxdWlyZSgnLi9saW1pdCcpXG59XG4iLCIvLyBUT0RPOiBjbHVzdGVyLmpzIGFuZCBjdl91dGlscy5qcyBhcmUgcHJldHR5IHRpZ2h0bHkgaW50ZXJ0d2luZWQsIG1ha2luZyBmb3IgYSBjb21wbGV4IGNvbnZlcnNpb25cbi8vIGludG8gdHlwZXNjcmlwdC4gYmUgd2FybmVkLiA6LSlcblxuaW1wb3J0IHsgY2xvbmUsIGRvdCB9IGZyb20gJ2dsLXZlYzInO1xuXG5jb25zdCB2ZWMyID0geyBjbG9uZSwgZG90IH07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsdXN0ZXIgZm9yIGdyb3VwaW5nIHNpbWlsYXIgb3JpZW50YXRpb25zIG9mIGRhdGFwb2ludHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIGNyZWF0ZShwb2ludCwgdGhyZXNob2xkKSB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICBjb25zdCBjZW50ZXIgPSB7XG4gICAgICAgICAgICByYWQ6IDAsXG4gICAgICAgICAgICB2ZWM6IHZlYzIuY2xvbmUoWzAsIDBdKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcG9pbnRNYXAgPSB7fTtcblxuICAgICAgICBmdW5jdGlvbiBhZGQocG9pbnRUb0FkZCkge1xuICAgICAgICAgICAgcG9pbnRNYXBbcG9pbnRUb0FkZC5pZF0gPSBwb2ludFRvQWRkO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnRUb0FkZCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVDZW50ZXIoKSB7XG4gICAgICAgICAgICBsZXQgaTsgbGV0XG4gICAgICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gcG9pbnRzW2ldLnJhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbnRlci5yYWQgPSBzdW0gLyBwb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgY2VudGVyLnZlYyA9IHZlYzIuY2xvbmUoW01hdGguY29zKGNlbnRlci5yYWQpLCBNYXRoLnNpbihjZW50ZXIucmFkKV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgICAgIGFkZChwb2ludCk7XG4gICAgICAgICAgICB1cGRhdGVDZW50ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluaXQoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkKHBvaW50VG9BZGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBvaW50TWFwW3BvaW50VG9BZGQuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZChwb2ludFRvQWRkKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2VudGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpdHMob3RoZXJQb2ludCkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGNvc2luZSBzaW1pbGFyaXR5IHRvIGNlbnRlci1hbmdsZVxuICAgICAgICAgICAgICAgIGNvbnN0IHNpbWlsYXJpdHkgPSBNYXRoLmFicyh2ZWMyLmRvdChvdGhlclBvaW50LnBvaW50LnZlYywgY2VudGVyLnZlYykpO1xuICAgICAgICAgICAgICAgIGlmIChzaW1pbGFyaXR5ID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UG9pbnRzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q2VudGVyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjZW50ZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY3JlYXRlUG9pbnQobmV3UG9pbnQsIGlkLCBwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFkOiBuZXdQb2ludFtwcm9wZXJ0eV0sXG4gICAgICAgICAgICBwb2ludDogbmV3UG9pbnQsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLW1peGVkLW9wZXJhdG9ycyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuaW1wb3J0IHsgY2xvbmUgYXMgdjJjbG9uZSB9IGZyb20gJ2dsLXZlYzInO1xuaW1wb3J0IHsgY2xvbmUgYXMgdjNjbG9uZSB9IGZyb20gJ2dsLXZlYzMnO1xuaW1wb3J0IENsdXN0ZXIyIGZyb20gJy4vY2x1c3Rlcic7XG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi9hcnJheV9oZWxwZXInO1xuXG5jb25zdCB2ZWMyID0geyBjbG9uZTogdjJjbG9uZSB9O1xuY29uc3QgdmVjMyA9IHsgY2xvbmU6IHYzY2xvbmUgfTtcblxuLyoqXG4gKiBAcGFyYW0geCB4LWNvb3JkaW5hdGVcbiAqIEBwYXJhbSB5IHktY29vcmRpbmF0ZVxuICogQHJldHVybiBJbWFnZVJlZmVyZW5jZSB7eCx5fSBDb29yZGluYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbWFnZVJlZih4LCB5KSB7XG4gICAgY29uc3QgdGhhdCA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgdG9WZWMyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZlYzIuY2xvbmUoW3RoaXMueCwgdGhpcy55XSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvVmVjMygpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZWMzLmNsb25lKFt0aGlzLngsIHRoaXMueSwgMV0pO1xuICAgICAgICB9LFxuICAgICAgICByb3VuZCgpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHRoaXMueCA+IDAuMCA/IE1hdGguZmxvb3IodGhpcy54ICsgMC41KSA6IE1hdGguZmxvb3IodGhpcy54IC0gMC41KTtcbiAgICAgICAgICAgIHRoaXMueSA9IHRoaXMueSA+IDAuMCA/IE1hdGguZmxvb3IodGhpcy55ICsgMC41KSA6IE1hdGguZmxvb3IodGhpcy55IC0gMC41KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHRoYXQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYW4gaW50ZWdyYWwgaW1hZ2Ugb2YgYSBnaXZlbiBncmF5c2NhbGUgaW1hZ2UuXG4gKiBAcGFyYW0gaW1hZ2VEYXRhQ29udGFpbmVyIHtJbWFnZURhdGFDb250YWluZXJ9IHRoZSBpbWFnZSB0byBiZSBpbnRlZ3JhdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSW50ZWdyYWxJbWFnZTIoaW1hZ2VXcmFwcGVyLCBpbnRlZ3JhbFdyYXBwZXIpIHtcbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xuICAgIGxldCBzdW0gPSAwOyBsZXQgcG9zQSA9IDA7IGxldCBwb3NCID0gMDsgbGV0IHBvc0MgPSAwOyBsZXQgcG9zRCA9IDA7IGxldCB4OyBsZXRcbiAgICAgICAgeTtcblxuICAgIC8vIHN1bSB1cCBmaXJzdCBjb2x1bW5cbiAgICBwb3NCID0gd2lkdGg7XG4gICAgc3VtID0gMDtcbiAgICBmb3IgKHkgPSAxOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgc3VtICs9IGltYWdlRGF0YVtwb3NBXTtcbiAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKz0gc3VtO1xuICAgICAgICBwb3NBICs9IHdpZHRoO1xuICAgICAgICBwb3NCICs9IHdpZHRoO1xuICAgIH1cblxuICAgIHBvc0EgPSAwO1xuICAgIHBvc0IgPSAxO1xuICAgIHN1bSA9IDA7XG4gICAgZm9yICh4ID0gMTsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgc3VtICs9IGltYWdlRGF0YVtwb3NBXTtcbiAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKz0gc3VtO1xuICAgICAgICBwb3NBKys7XG4gICAgICAgIHBvc0IrKztcbiAgICB9XG5cbiAgICBmb3IgKHkgPSAxOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgcG9zQSA9IHkgKiB3aWR0aCArIDE7XG4gICAgICAgIHBvc0IgPSAoeSAtIDEpICogd2lkdGggKyAxO1xuICAgICAgICBwb3NDID0geSAqIHdpZHRoO1xuICAgICAgICBwb3NEID0gKHkgLSAxKSAqIHdpZHRoO1xuICAgICAgICBmb3IgKHggPSAxOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQV1cbiAgICAgICAgICAgICAgICArPSBpbWFnZURhdGFbcG9zQV0gKyBpbnRlZ3JhbEltYWdlRGF0YVtwb3NCXSArIGludGVncmFsSW1hZ2VEYXRhW3Bvc0NdIC0gaW50ZWdyYWxJbWFnZURhdGFbcG9zRF07XG4gICAgICAgICAgICBwb3NBKys7XG4gICAgICAgICAgICBwb3NCKys7XG4gICAgICAgICAgICBwb3NDKys7XG4gICAgICAgICAgICBwb3NEKys7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSW50ZWdyYWxJbWFnZShpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlcikge1xuICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGNvbnN0IGludGVncmFsSW1hZ2VEYXRhID0gaW50ZWdyYWxXcmFwcGVyLmRhdGE7XG4gICAgbGV0IHN1bSA9IDA7XG5cbiAgICAvLyBzdW0gdXAgZmlyc3Qgcm93XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgIHN1bSArPSBpbWFnZURhdGFbaV07XG4gICAgICAgIGludGVncmFsSW1hZ2VEYXRhW2ldID0gc3VtO1xuICAgIH1cblxuICAgIGZvciAobGV0IHYgPSAxOyB2IDwgaGVpZ2h0OyB2KyspIHtcbiAgICAgICAgc3VtID0gMDtcbiAgICAgICAgZm9yIChsZXQgdSA9IDA7IHUgPCB3aWR0aDsgdSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gaW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdO1xuICAgICAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gc3VtICsgaW50ZWdyYWxJbWFnZURhdGFbKHYgLSAxKSAqIHdpZHRoICsgdV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aHJlc2hvbGRJbWFnZShpbWFnZVdyYXBwZXIsIHRocmVzaG9sZCwgdGFyZ2V0V3JhcHBlcikge1xuICAgIGlmICghdGFyZ2V0V3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgdGFyZ2V0V3JhcHBlciA9IGltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7IGxldCB7IGxlbmd0aCB9ID0gaW1hZ2VEYXRhOyBjb25zdFxuICAgICAgICB0YXJnZXREYXRhID0gdGFyZ2V0V3JhcHBlci5kYXRhO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHRhcmdldERhdGFbbGVuZ3RoXSA9IGltYWdlRGF0YVtsZW5ndGhdIDwgdGhyZXNob2xkID8gMSA6IDA7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUhpc3RvZ3JhbShpbWFnZVdyYXBwZXIsIGJpdHNQZXJQaXhlbCkge1xuICAgIGlmICghYml0c1BlclBpeGVsKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBiaXRzUGVyUGl4ZWwgPSA4O1xuICAgIH1cbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBsZXQgeyBsZW5ndGggfSA9IGltYWdlRGF0YTtcbiAgICBjb25zdCBiaXRTaGlmdCA9IDggLSBiaXRzUGVyUGl4ZWw7XG4gICAgY29uc3QgYnVja2V0Q250ID0gMSA8PCBiaXRzUGVyUGl4ZWw7XG4gICAgY29uc3QgaGlzdCA9IG5ldyBJbnQzMkFycmF5KGJ1Y2tldENudCk7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaGlzdFtpbWFnZURhdGFbbGVuZ3RoXSA+PiBiaXRTaGlmdF0rKztcbiAgICB9XG4gICAgcmV0dXJuIGhpc3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGFycGVuTGluZShsaW5lKSB7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGxpbmU7XG4gICAgbGV0IGxlZnQgPSBsaW5lWzBdO1xuICAgIGxldCBjZW50ZXIgPSBsaW5lWzFdO1xuICAgIGxldCByaWdodDtcblxuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgcmlnaHQgPSBsaW5lW2kgKyAxXTtcbiAgICAgICAgLy8gIC0xIDQgLTEga2VybmVsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBsaW5lW2kgLSAxXSA9ICgoKGNlbnRlciAqIDIpIC0gbGVmdCAtIHJpZ2h0KSkgJiAyNTU7XG4gICAgICAgIGxlZnQgPSBjZW50ZXI7XG4gICAgICAgIGNlbnRlciA9IHJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gbGluZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluZU90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyLCBiaXRzUGVyUGl4ZWwgPSA4KSB7XG4gICAgbGV0IGhpc3Q7XG4gICAgY29uc3QgYml0U2hpZnQgPSA4IC0gYml0c1BlclBpeGVsO1xuXG4gICAgZnVuY3Rpb24gcHgoaW5pdCwgZW5kKSB7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gaW5pdDsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IGhpc3RbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBteChpbml0LCBlbmQpIHtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IGluaXQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBpICogaGlzdFtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGV0ZXJtaW5lVGhyZXNob2xkKCkge1xuICAgICAgICBjb25zdCB2ZXQgPSBbMF07XG4gICAgICAgIGxldCBwMTtcbiAgICAgICAgbGV0IHAyO1xuICAgICAgICBsZXQgcDEyO1xuICAgICAgICBsZXQgbTE7XG4gICAgICAgIGxldCBtMjtcbiAgICAgICAgbGV0IG0xMjtcbiAgICAgICAgY29uc3QgbWF4ID0gKDEgPDwgYml0c1BlclBpeGVsKSAtIDE7XG5cbiAgICAgICAgaGlzdCA9IGNvbXB1dGVIaXN0b2dyYW0oaW1hZ2VXcmFwcGVyLCBiaXRzUGVyUGl4ZWwpO1xuICAgICAgICBmb3IgKGxldCBrID0gMTsgayA8IG1heDsgaysrKSB7XG4gICAgICAgICAgICBwMSA9IHB4KDAsIGspO1xuICAgICAgICAgICAgcDIgPSBweChrICsgMSwgbWF4KTtcbiAgICAgICAgICAgIHAxMiA9IHAxICogcDI7XG4gICAgICAgICAgICBpZiAocDEyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcDEyID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG0xID0gbXgoMCwgaykgKiBwMjtcbiAgICAgICAgICAgIG0yID0gbXgoayArIDEsIG1heCkgKiBwMTtcbiAgICAgICAgICAgIG0xMiA9IG0xIC0gbTI7XG4gICAgICAgICAgICB2ZXRba10gPSBtMTIgKiBtMTIgLyBwMTI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5SGVscGVyLm1heEluZGV4KHZldCk7XG4gICAgfVxuXG4gICAgY29uc3QgdGhyZXNob2xkID0gZGV0ZXJtaW5lVGhyZXNob2xkKCk7XG4gICAgcmV0dXJuIHRocmVzaG9sZCA8PCBiaXRTaGlmdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyLCB0YXJnZXRXcmFwcGVyKSB7XG4gICAgY29uc3QgdGhyZXNob2xkID0gZGV0ZXJtaW5lT3RzdVRocmVzaG9sZChpbWFnZVdyYXBwZXIpO1xuXG4gICAgdGhyZXNob2xkSW1hZ2UoaW1hZ2VXcmFwcGVyLCB0aHJlc2hvbGQsIHRhcmdldFdyYXBwZXIpO1xuICAgIHJldHVybiB0aHJlc2hvbGQ7XG59XG5cbi8vIGxvY2FsIHRocmVzaG9sZGluZ1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVCaW5hcnlJbWFnZShpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlciwgdGFyZ2V0V3JhcHBlcikge1xuICAgIGNvbXB1dGVJbnRlZ3JhbEltYWdlKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyKTtcblxuICAgIGlmICghdGFyZ2V0V3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgdGFyZ2V0V3JhcHBlciA9IGltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgdGFyZ2V0RGF0YSA9IHRhcmdldFdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xuICAgIGxldCBzdW0gPSAwOyBsZXQgdjsgbGV0IHU7IGNvbnN0IGtlcm5lbCA9IDM7IGxldCBBOyBsZXQgQjsgbGV0IEM7IGxldCBEOyBsZXQgYXZnOyBjb25zdFxuICAgICAgICBzaXplID0gKGtlcm5lbCAqIDIgKyAxKSAqIChrZXJuZWwgKiAyICsgMSk7XG5cbiAgICAvLyBjbGVhciBvdXQgdG9wICYgYm90dG9tLWJvcmRlclxuICAgIGZvciAodiA9IDA7IHYgPD0ga2VybmVsOyB2KyspIHtcbiAgICAgICAgZm9yICh1ID0gMDsgdSA8IHdpZHRoOyB1KyspIHtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gMDtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCgoaGVpZ2h0IC0gMSkgLSB2KSAqIHdpZHRoKSArIHVdID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNsZWFyIG91dCBsZWZ0ICYgcmlnaHQgYm9yZGVyXG4gICAgZm9yICh2ID0ga2VybmVsOyB2IDwgaGVpZ2h0IC0ga2VybmVsOyB2KyspIHtcbiAgICAgICAgZm9yICh1ID0gMDsgdSA8PSBrZXJuZWw7IHUrKykge1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVsoKHYpICogd2lkdGgpICsgdV0gPSAwO1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVsoKHYpICogd2lkdGgpICsgKHdpZHRoIC0gMSAtIHUpXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHYgPSBrZXJuZWwgKyAxOyB2IDwgaGVpZ2h0IC0ga2VybmVsIC0gMTsgdisrKSB7XG4gICAgICAgIGZvciAodSA9IGtlcm5lbCArIDE7IHUgPCB3aWR0aCAtIGtlcm5lbDsgdSsrKSB7XG4gICAgICAgICAgICBBID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgLSBrZXJuZWwgLSAxKSAqIHdpZHRoICsgKHUgLSBrZXJuZWwgLSAxKV07XG4gICAgICAgICAgICBCID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgLSBrZXJuZWwgLSAxKSAqIHdpZHRoICsgKHUgKyBrZXJuZWwpXTtcbiAgICAgICAgICAgIEMgPSBpbnRlZ3JhbEltYWdlRGF0YVsodiArIGtlcm5lbCkgKiB3aWR0aCArICh1IC0ga2VybmVsIC0gMSldO1xuICAgICAgICAgICAgRCA9IGludGVncmFsSW1hZ2VEYXRhWyh2ICsga2VybmVsKSAqIHdpZHRoICsgKHUgKyBrZXJuZWwpXTtcbiAgICAgICAgICAgIHN1bSA9IEQgLSBDIC0gQiArIEE7XG4gICAgICAgICAgICBhdmcgPSBzdW0gLyAoc2l6ZSk7XG4gICAgICAgICAgICB0YXJnZXREYXRhW3YgKiB3aWR0aCArIHVdID0gaW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdID4gKGF2ZyArIDUpID8gMCA6IDE7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbHVzdGVyKHBvaW50cywgdGhyZXNob2xkLCBwcm9wZXJ0eSkge1xuICAgIGxldCBpOyBsZXQgazsgbGV0IHRoaXNDbHVzdGVyOyBsZXQgcG9pbnQ7IGNvbnN0XG4gICAgICAgIGNsdXN0ZXJzID0gW107XG5cbiAgICBpZiAoIXByb3BlcnR5KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBwcm9wZXJ0eSA9ICdyYWQnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRvQ2x1c3RlcihuZXdQb2ludCkge1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGNsdXN0ZXJzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB0aGlzQ2x1c3RlciA9IGNsdXN0ZXJzW2tdO1xuICAgICAgICAgICAgaWYgKHRoaXNDbHVzdGVyLmZpdHMobmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpc0NsdXN0ZXIuYWRkKG5ld1BvaW50KTtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cblxuICAgIC8vIGl0ZXJhdGUgb3ZlciBlYWNoIGNsb3VkXG4gICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwb2ludCA9IENsdXN0ZXIyLmNyZWF0ZVBvaW50KHBvaW50c1tpXSwgaSwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoIWFkZFRvQ2x1c3Rlcihwb2ludCkpIHtcbiAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2goQ2x1c3RlcjIuY3JlYXRlKHBvaW50LCB0aHJlc2hvbGQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2x1c3RlcnM7XG59XG5cbmV4cG9ydCBjb25zdCBUcmFjZXIgPSB7XG4gICAgdHJhY2UocG9pbnRzLCB2ZWMpIHtcbiAgICAgICAgbGV0IGl0ZXJhdGlvbjtcbiAgICAgICAgY29uc3QgbWF4SXRlcmF0aW9ucyA9IDEwO1xuICAgICAgICBsZXQgdG9wID0gW107XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGNlbnRlclBvcyA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50UG9zID0gMDtcblxuICAgICAgICBmdW5jdGlvbiB0cmFjZShpZHgsIGZvcndhcmQpIHtcbiAgICAgICAgICAgIGxldCB0bztcbiAgICAgICAgICAgIGxldCB0b0lkeDtcbiAgICAgICAgICAgIGxldCBwcmVkaWN0ZWRQb3M7XG4gICAgICAgICAgICBjb25zdCB0aHJlc2hvbGRYID0gMTtcbiAgICAgICAgICAgIGNvbnN0IHRocmVzaG9sZFkgPSBNYXRoLmFicyh2ZWNbMV0gLyAxMCk7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gbWF0Y2gocG9zLCBwcmVkaWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zLnggPiAocHJlZGljdGVkLnggLSB0aHJlc2hvbGRYKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnggPCAocHJlZGljdGVkLnggKyB0aHJlc2hvbGRYKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnkgPiAocHJlZGljdGVkLnkgLSB0aHJlc2hvbGRZKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnkgPCAocHJlZGljdGVkLnkgKyB0aHJlc2hvbGRZKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgbmV4dCBpbmRleCBpcyB3aXRoaW4gdGhlIHZlYyBzcGVjaWZpY2F0aW9uc1xuICAgICAgICAgICAgLy8gaWYgbm90LCBjaGVjayBhcyBsb25nIGFzIHRoZSB0aHJlc2hvbGQgaXMgbWV0XG5cbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBwb2ludHNbaWR4XTtcbiAgICAgICAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICAgICAgICAgcHJlZGljdGVkUG9zID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBmcm9tLnggKyB2ZWNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHk6IGZyb20ueSArIHZlY1sxXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVkaWN0ZWRQb3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGZyb20ueCAtIHZlY1swXSxcbiAgICAgICAgICAgICAgICAgICAgeTogZnJvbS55IC0gdmVjWzFdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvSWR4ID0gZm9yd2FyZCA/IGlkeCArIDEgOiBpZHggLSAxO1xuICAgICAgICAgICAgdG8gPSBwb2ludHNbdG9JZHhdO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICAgICAgICB3aGlsZSAodG8gJiYgKGZvdW5kID0gbWF0Y2godG8sIHByZWRpY3RlZFBvcykpICE9PSB0cnVlICYmIChNYXRoLmFicyh0by55IC0gZnJvbS55KSA8IHZlY1sxXSkpIHtcbiAgICAgICAgICAgICAgICB0b0lkeCA9IGZvcndhcmQgPyB0b0lkeCArIDEgOiB0b0lkeCAtIDE7XG4gICAgICAgICAgICAgICAgdG8gPSBwb2ludHNbdG9JZHhdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZm91bmQgPyB0b0lkeCA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGl0ZXJhdGlvbiA9IDA7IGl0ZXJhdGlvbiA8IG1heEl0ZXJhdGlvbnM7IGl0ZXJhdGlvbisrKSB7XG4gICAgICAgICAgICAvLyByYW5kb21seSBzZWxlY3QgcG9pbnQgdG8gc3RhcnQgd2l0aFxuICAgICAgICAgICAgY2VudGVyUG9zID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcG9pbnRzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIC8vIHRyYWNlIGZvcndhcmRcbiAgICAgICAgICAgIHRvcCA9IFtdO1xuICAgICAgICAgICAgY3VycmVudFBvcyA9IGNlbnRlclBvcztcbiAgICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgICAgICAgIHdoaWxlICgoY3VycmVudFBvcyA9IHRyYWNlKGN1cnJlbnRQb3MsIHRydWUpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2VudGVyUG9zID4gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgPSBjZW50ZXJQb3M7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50UG9zID0gdHJhY2UoY3VycmVudFBvcywgZmFsc2UpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0b3AucHVzaChwb2ludHNbY3VycmVudFBvc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRvcC5sZW5ndGggPiByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBESUxBVEUgPSAxO1xuZXhwb3J0IGNvbnN0IEVST0RFID0gMjtcblxuZXhwb3J0IGZ1bmN0aW9uIGRpbGF0ZShpbkltYWdlV3JhcHBlciwgb3V0SW1hZ2VXcmFwcGVyKSB7XG4gICAgbGV0IHY7XG4gICAgbGV0IHU7XG4gICAgY29uc3QgaW5JbWFnZURhdGEgPSBpbkltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IG91dEltYWdlRGF0YSA9IG91dEltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGhlaWdodCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCB3aWR0aCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgc3VtO1xuICAgIGxldCB5U3RhcnQxO1xuICAgIGxldCB5U3RhcnQyO1xuICAgIGxldCB4U3RhcnQxO1xuICAgIGxldCB4U3RhcnQyO1xuXG4gICAgZm9yICh2ID0gMTsgdiA8IGhlaWdodCAtIDE7IHYrKykge1xuICAgICAgICBmb3IgKHUgPSAxOyB1IDwgd2lkdGggLSAxOyB1KyspIHtcbiAgICAgICAgICAgIHlTdGFydDEgPSB2IC0gMTtcbiAgICAgICAgICAgIHlTdGFydDIgPSB2ICsgMTtcbiAgICAgICAgICAgIHhTdGFydDEgPSB1IC0gMTtcbiAgICAgICAgICAgIHhTdGFydDIgPSB1ICsgMTtcbiAgICAgICAgICAgIHN1bSA9IGluSW1hZ2VEYXRhW3lTdGFydDEgKiB3aWR0aCArIHhTdGFydDFdICsgaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0Ml1cbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbdiAqIHdpZHRoICsgdV1cbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbeVN0YXJ0MiAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQyXTtcbiAgICAgICAgICAgIG91dEltYWdlRGF0YVt2ICogd2lkdGggKyB1XSA9IHN1bSA+IDAgPyAxIDogMDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVyb2RlKGluSW1hZ2VXcmFwcGVyLCBvdXRJbWFnZVdyYXBwZXIpIHtcbiAgICBsZXQgdjtcbiAgICBsZXQgdTtcbiAgICBjb25zdCBpbkltYWdlRGF0YSA9IGluSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3Qgb3V0SW1hZ2VEYXRhID0gb3V0SW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGNvbnN0IHdpZHRoID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGxldCBzdW07XG4gICAgbGV0IHlTdGFydDE7XG4gICAgbGV0IHlTdGFydDI7XG4gICAgbGV0IHhTdGFydDE7XG4gICAgbGV0IHhTdGFydDI7XG5cbiAgICBmb3IgKHYgPSAxOyB2IDwgaGVpZ2h0IC0gMTsgdisrKSB7XG4gICAgICAgIGZvciAodSA9IDE7IHUgPCB3aWR0aCAtIDE7IHUrKykge1xuICAgICAgICAgICAgeVN0YXJ0MSA9IHYgLSAxO1xuICAgICAgICAgICAgeVN0YXJ0MiA9IHYgKyAxO1xuICAgICAgICAgICAgeFN0YXJ0MSA9IHUgLSAxO1xuICAgICAgICAgICAgeFN0YXJ0MiA9IHUgKyAxO1xuICAgICAgICAgICAgc3VtID0gaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQxICogd2lkdGggKyB4U3RhcnQyXVxuICAgICAgICAgICAgKyBpbkltYWdlRGF0YVt2ICogd2lkdGggKyB1XVxuICAgICAgICAgICAgKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQxXSArIGluSW1hZ2VEYXRhW3lTdGFydDIgKiB3aWR0aCArIHhTdGFydDJdO1xuICAgICAgICAgICAgb3V0SW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdID0gc3VtID09PSA1ID8gMSA6IDA7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChhSW1hZ2VXcmFwcGVyLCBiSW1hZ2VXcmFwcGVyLCByZXN1bHRJbWFnZVdyYXBwZXIpIHtcbiAgICBpZiAoIXJlc3VsdEltYWdlV3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgcmVzdWx0SW1hZ2VXcmFwcGVyID0gYUltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgbGV0IHsgbGVuZ3RoIH0gPSBhSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgYUltYWdlRGF0YSA9IGFJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBiSW1hZ2VEYXRhID0gYkltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGNJbWFnZURhdGEgPSByZXN1bHRJbWFnZVdyYXBwZXIuZGF0YTtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBjSW1hZ2VEYXRhW2xlbmd0aF0gPSBhSW1hZ2VEYXRhW2xlbmd0aF0gLSBiSW1hZ2VEYXRhW2xlbmd0aF07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYml0d2lzZU9yKGFJbWFnZVdyYXBwZXIsIGJJbWFnZVdyYXBwZXIsIHJlc3VsdEltYWdlV3JhcHBlcikge1xuICAgIGlmICghcmVzdWx0SW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICByZXN1bHRJbWFnZVdyYXBwZXIgPSBhSW1hZ2VXcmFwcGVyO1xuICAgIH1cbiAgICBsZXQgeyBsZW5ndGggfSA9IGFJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBhSW1hZ2VEYXRhID0gYUltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGJJbWFnZURhdGEgPSBiSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgY0ltYWdlRGF0YSA9IHJlc3VsdEltYWdlV3JhcHBlci5kYXRhO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGNJbWFnZURhdGFbbGVuZ3RoXSA9IGFJbWFnZURhdGFbbGVuZ3RoXSB8fCBiSW1hZ2VEYXRhW2xlbmd0aF07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY291bnROb25aZXJvKGltYWdlV3JhcHBlcikge1xuICAgIGxldCB7IGxlbmd0aCB9ID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBpbWFnZVdyYXBwZXI7XG4gICAgbGV0IHN1bSA9IDA7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgc3VtICs9IGRhdGFbbGVuZ3RoXTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvcEdlbmVyaWMobGlzdCwgdG9wLCBzY29yZUZ1bmMpIHtcbiAgICBsZXQgaTsgbGV0IG1pbklkeCA9IDA7IGxldCBtaW4gPSAwOyBjb25zdCBxdWV1ZSA9IFtdOyBsZXQgc2NvcmU7IGxldCBoaXQ7IGxldFxuICAgICAgICBwb3M7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9wOyBpKyspIHtcbiAgICAgICAgcXVldWVbaV0gPSB7XG4gICAgICAgICAgICBzY29yZTogMCxcbiAgICAgICAgICAgIGl0ZW06IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2NvcmUgPSBzY29yZUZ1bmMuYXBwbHkodGhpcywgW2xpc3RbaV1dKTtcbiAgICAgICAgaWYgKHNjb3JlID4gbWluKSB7XG4gICAgICAgICAgICBoaXQgPSBxdWV1ZVttaW5JZHhdO1xuICAgICAgICAgICAgaGl0LnNjb3JlID0gc2NvcmU7XG4gICAgICAgICAgICBoaXQuaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgZm9yIChwb3MgPSAwOyBwb3MgPCB0b3A7IHBvcysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlW3Bvc10uc2NvcmUgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gcXVldWVbcG9zXS5zY29yZTtcbiAgICAgICAgICAgICAgICAgICAgbWluSWR4ID0gcG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBxdWV1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyYXlBcnJheUZyb21JbWFnZShodG1sSW1hZ2UsIG9mZnNldFgsIGN0eCwgYXJyYXkpIHtcbiAgICBjdHguZHJhd0ltYWdlKGh0bWxJbWFnZSwgb2Zmc2V0WCwgMCwgaHRtbEltYWdlLndpZHRoLCBodG1sSW1hZ2UuaGVpZ2h0KTtcbiAgICBjb25zdCBjdHhEYXRhID0gY3R4LmdldEltYWdlRGF0YShvZmZzZXRYLCAwLCBodG1sSW1hZ2Uud2lkdGgsIGh0bWxJbWFnZS5oZWlnaHQpLmRhdGE7XG4gICAgY29tcHV0ZUdyYXkoY3R4RGF0YSwgYXJyYXkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JheUFycmF5RnJvbUNvbnRleHQoY3R4LCBzaXplLCBvZmZzZXQsIGFycmF5KSB7XG4gICAgY29uc3QgY3R4RGF0YSA9IGN0eC5nZXRJbWFnZURhdGEob2Zmc2V0LngsIG9mZnNldC55LCBzaXplLngsIHNpemUueSkuZGF0YTtcbiAgICBjb21wdXRlR3JheShjdHhEYXRhLCBhcnJheSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhKGNhbnZhc0RhdGEsIHNpemUsIG91dEFycmF5KSB7XG4gICAgbGV0IHRvcFJvd0lkeCA9IDA7XG4gICAgbGV0IGJvdHRvbVJvd0lkeCA9IHNpemUueDtcbiAgICBjb25zdCBlbmRJZHggPSBNYXRoLmZsb29yKGNhbnZhc0RhdGEubGVuZ3RoIC8gNCk7XG4gICAgY29uc3Qgb3V0V2lkdGggPSBzaXplLnggLyAyO1xuICAgIGxldCBvdXRJbWdJZHggPSAwO1xuICAgIGNvbnN0IGluV2lkdGggPSBzaXplLng7XG4gICAgbGV0IGk7XG5cbiAgICB3aGlsZSAoYm90dG9tUm93SWR4IDwgZW5kSWR4KSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvdXRXaWR0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIG91dEFycmF5W291dEltZ0lkeF0gPSAoXG4gICAgICAgICAgICAgICAgKDAuMjk5ICogY2FudmFzRGF0YVt0b3BSb3dJZHggKiA0ICsgMF1cbiAgICAgICAgICAgICAgICAgKyAwLjU4NyAqIGNhbnZhc0RhdGFbdG9wUm93SWR4ICogNCArIDFdXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhW3RvcFJvd0lkeCAqIDQgKyAyXSlcbiAgICAgICAgICAgICAgICArICgwLjI5OSAqIGNhbnZhc0RhdGFbKHRvcFJvd0lkeCArIDEpICogNCArIDBdXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhWyh0b3BSb3dJZHggKyAxKSAqIDQgKyAxXVxuICAgICAgICAgICAgICAgICArIDAuMTE0ICogY2FudmFzRGF0YVsodG9wUm93SWR4ICsgMSkgKiA0ICsgMl0pXG4gICAgICAgICAgICAgICAgKyAoMC4yOTkgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDBdXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDFdXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDJdKVxuICAgICAgICAgICAgICAgICsgKDAuMjk5ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4ICsgMSkgKiA0ICsgMF1cbiAgICAgICAgICAgICAgICAgKyAwLjU4NyAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCArIDEpICogNCArIDFdXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHggKyAxKSAqIDQgKyAyXSkpIC8gNDtcbiAgICAgICAgICAgIG91dEltZ0lkeCsrO1xuICAgICAgICAgICAgdG9wUm93SWR4ICs9IDI7XG4gICAgICAgICAgICBib3R0b21Sb3dJZHggKz0gMjtcbiAgICAgICAgfVxuICAgICAgICB0b3BSb3dJZHggKz0gaW5XaWR0aDtcbiAgICAgICAgYm90dG9tUm93SWR4ICs9IGluV2lkdGg7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUdyYXkoaW1hZ2VEYXRhLCBvdXRBcnJheSwgY29uZmlnKSB7XG4gICAgY29uc3QgbCA9IChpbWFnZURhdGEubGVuZ3RoIC8gNCkgfCAwO1xuICAgIGNvbnN0IHNpbmdsZUNoYW5uZWwgPSBjb25maWcgJiYgY29uZmlnLnNpbmdsZUNoYW5uZWwgPT09IHRydWU7XG5cbiAgICBpZiAoc2luZ2xlQ2hhbm5lbCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBvdXRBcnJheVtpXSA9IGltYWdlRGF0YVtpICogNCArIDBdO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgb3V0QXJyYXlbaV0gPSAwLjI5OSAqIGltYWdlRGF0YVtpICogNCArIDBdICsgMC41ODcgKiBpbWFnZURhdGFbaSAqIDQgKyAxXSArIDAuMTE0ICogaW1hZ2VEYXRhW2kgKiA0ICsgMl07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkSW1hZ2VBcnJheShzcmMsIGNhbGxiYWNrLCBjYW52YXMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSkge1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLCAwLCAwKTtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheSh0aGlzLndpZHRoICogdGhpcy5oZWlnaHQpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMsIDAsIDApO1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICBjb21wdXRlR3JheShkYXRhLCBhcnJheSk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soYXJyYXksIHtcbiAgICAgICAgICAgIHg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICB5OiB0aGlzLmhlaWdodCxcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcbiAgICBpbWcuc3JjID0gc3JjO1xufVxuXG4vKipcbiAqIEBwYXJhbSBpbkltZyB7SW1hZ2VXcmFwcGVyfSBpbnB1dCBpbWFnZSB0byBiZSBzYW1wbGVkXG4gKiBAcGFyYW0gb3V0SW1nIHtJbWFnZVdyYXBwZXJ9IHRvIGJlIHN0b3JlZCBpblxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFsZlNhbXBsZShpbkltZ1dyYXBwZXIsIG91dEltZ1dyYXBwZXIpIHtcbiAgICBjb25zdCBpbkltZyA9IGluSW1nV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGluV2lkdGggPSBpbkltZ1dyYXBwZXIuc2l6ZS54O1xuICAgIGNvbnN0IG91dEltZyA9IG91dEltZ1dyYXBwZXIuZGF0YTtcbiAgICBsZXQgdG9wUm93SWR4ID0gMDtcbiAgICBsZXQgYm90dG9tUm93SWR4ID0gaW5XaWR0aDtcbiAgICBjb25zdCBlbmRJZHggPSBpbkltZy5sZW5ndGg7XG4gICAgY29uc3Qgb3V0V2lkdGggPSBpbldpZHRoIC8gMjtcbiAgICBsZXQgb3V0SW1nSWR4ID0gMDtcbiAgICB3aGlsZSAoYm90dG9tUm93SWR4IDwgZW5kSWR4KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0V2lkdGg7IGkrKykge1xuICAgICAgICAgICAgb3V0SW1nW291dEltZ0lkeF0gPSBNYXRoLmZsb29yKFxuICAgICAgICAgICAgICAgIChpbkltZ1t0b3BSb3dJZHhdICsgaW5JbWdbdG9wUm93SWR4ICsgMV0gKyBpbkltZ1tib3R0b21Sb3dJZHhdICsgaW5JbWdbYm90dG9tUm93SWR4ICsgMV0pIC8gNCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvdXRJbWdJZHgrKztcbiAgICAgICAgICAgIHRvcFJvd0lkeCArPSAyO1xuICAgICAgICAgICAgYm90dG9tUm93SWR4ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgdG9wUm93SWR4ICs9IGluV2lkdGg7XG4gICAgICAgIGJvdHRvbVJvd0lkeCArPSBpbldpZHRoO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhzdjJyZ2IoaHN2LCByZ2IgPSBbMCwgMCwgMF0pIHtcbiAgICBjb25zdCBoID0gaHN2WzBdO1xuICAgIGNvbnN0IHMgPSBoc3ZbMV07XG4gICAgY29uc3QgdiA9IGhzdlsyXTtcbiAgICBjb25zdCBjID0gdiAqIHM7XG4gICAgY29uc3QgeCA9IGMgKiAoMSAtIE1hdGguYWJzKChoIC8gNjApICUgMiAtIDEpKTtcbiAgICBjb25zdCBtID0gdiAtIGM7XG4gICAgbGV0IHIgPSAwO1xuICAgIGxldCBnID0gMDtcbiAgICBsZXQgYiA9IDA7XG5cbiAgICBpZiAoaCA8IDYwKSB7XG4gICAgICAgIHIgPSBjO1xuICAgICAgICBnID0geDtcbiAgICB9IGVsc2UgaWYgKGggPCAxMjApIHtcbiAgICAgICAgciA9IHg7XG4gICAgICAgIGcgPSBjO1xuICAgIH0gZWxzZSBpZiAoaCA8IDE4MCkge1xuICAgICAgICBnID0gYztcbiAgICAgICAgYiA9IHg7XG4gICAgfSBlbHNlIGlmIChoIDwgMjQwKSB7XG4gICAgICAgIGcgPSB4O1xuICAgICAgICBiID0gYztcbiAgICB9IGVsc2UgaWYgKGggPCAzMDApIHtcbiAgICAgICAgciA9IHg7XG4gICAgICAgIGIgPSBjO1xuICAgIH0gZWxzZSBpZiAoaCA8IDM2MCkge1xuICAgICAgICByID0gYztcbiAgICAgICAgYiA9IHg7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHJnYlswXSA9ICgociArIG0pICogMjU1KSB8IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcmdiWzFdID0gKChnICsgbSkgKiAyNTUpIHwgMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICByZ2JbMl0gPSAoKGIgKyBtKSAqIDI1NSkgfCAwO1xuICAgIHJldHVybiByZ2I7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfY29tcHV0ZURpdmlzb3JzKG4pIHtcbiAgICBjb25zdCBsYXJnZURpdmlzb3JzID0gW107XG4gICAgY29uc3QgZGl2aXNvcnMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgTWF0aC5zcXJ0KG4pICsgMTsgaSsrKSB7XG4gICAgICAgIGlmIChuICUgaSA9PT0gMCkge1xuICAgICAgICAgICAgZGl2aXNvcnMucHVzaChpKTtcbiAgICAgICAgICAgIGlmIChpICE9PSBuIC8gaSkge1xuICAgICAgICAgICAgICAgIGxhcmdlRGl2aXNvcnMudW5zaGlmdChNYXRoLmZsb29yKG4gLyBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpdmlzb3JzLmNvbmNhdChsYXJnZURpdmlzb3JzKTtcbn1cblxuZnVuY3Rpb24gX2NvbXB1dGVJbnRlcnNlY3Rpb24oYXJyMSwgYXJyMikge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgaiA9IDA7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoaSA8IGFycjEubGVuZ3RoICYmIGogPCBhcnIyLmxlbmd0aCkge1xuICAgICAgICBpZiAoYXJyMVtpXSA9PT0gYXJyMltqXSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyMVtpXSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJyMVtpXSA+IGFycjJbal0pIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUGF0Y2hTaXplKHBhdGNoU2l6ZSwgaW1nU2l6ZSkge1xuICAgIGNvbnN0IGRpdmlzb3JzWCA9IF9jb21wdXRlRGl2aXNvcnMoaW1nU2l6ZS54KTtcbiAgICBjb25zdCBkaXZpc29yc1kgPSBfY29tcHV0ZURpdmlzb3JzKGltZ1NpemUueSk7XG4gICAgY29uc3Qgd2lkZVNpZGUgPSBNYXRoLm1heChpbWdTaXplLngsIGltZ1NpemUueSk7XG4gICAgY29uc3QgY29tbW9uID0gX2NvbXB1dGVJbnRlcnNlY3Rpb24oZGl2aXNvcnNYLCBkaXZpc29yc1kpO1xuICAgIGNvbnN0IG5yT2ZQYXRjaGVzTGlzdCA9IFs4LCAxMCwgMTUsIDIwLCAzMiwgNjAsIDgwXTtcbiAgICBjb25zdCBuck9mUGF0Y2hlc01hcCA9IHtcbiAgICAgICAgJ3gtc21hbGwnOiA1LFxuICAgICAgICBzbWFsbDogNCxcbiAgICAgICAgbWVkaXVtOiAzLFxuICAgICAgICBsYXJnZTogMixcbiAgICAgICAgJ3gtbGFyZ2UnOiAxLFxuICAgIH07XG4gICAgY29uc3QgbnJPZlBhdGNoZXNJZHggPSBuck9mUGF0Y2hlc01hcFtwYXRjaFNpemVdIHx8IG5yT2ZQYXRjaGVzTWFwLm1lZGl1bTtcbiAgICBjb25zdCBuck9mUGF0Y2hlcyA9IG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeF07XG4gICAgY29uc3QgZGVzaXJlZFBhdGNoU2l6ZSA9IE1hdGguZmxvb3Iod2lkZVNpZGUgLyBuck9mUGF0Y2hlcyk7XG4gICAgbGV0IG9wdGltYWxQYXRjaFNpemU7XG5cbiAgICBmdW5jdGlvbiBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoZGl2aXNvcnMpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgZm91bmQgPSBkaXZpc29yc1tNYXRoLmZsb29yKGRpdmlzb3JzLmxlbmd0aCAvIDIpXTtcblxuICAgICAgICB3aGlsZSAoaSA8IChkaXZpc29ycy5sZW5ndGggLSAxKSAmJiBkaXZpc29yc1tpXSA8IGRlc2lyZWRQYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkaXZpc29yc1tpXSAtIGRlc2lyZWRQYXRjaFNpemUpID4gTWF0aC5hYnMoZGl2aXNvcnNbaSAtIDFdIC0gZGVzaXJlZFBhdGNoU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IGRpdmlzb3JzW2kgLSAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBkaXZpc29yc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzaXJlZFBhdGNoU2l6ZSAvIGZvdW5kIDwgbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4ICsgMV0gLyBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHhdXG4gICAgICAgICAgICAmJiBkZXNpcmVkUGF0Y2hTaXplIC8gZm91bmQgPiBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHggLSAxXSAvIG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeF0pIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZvdW5kLCB5OiBmb3VuZCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIG9wdGltYWxQYXRjaFNpemUgPSBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoY29tbW9uKTtcbiAgICBpZiAoIW9wdGltYWxQYXRjaFNpemUpIHtcbiAgICAgICAgb3B0aW1hbFBhdGNoU2l6ZSA9IGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycyhfY29tcHV0ZURpdmlzb3JzKHdpZGVTaWRlKSk7XG4gICAgICAgIGlmICghb3B0aW1hbFBhdGNoU2l6ZSkge1xuICAgICAgICAgICAgb3B0aW1hbFBhdGNoU2l6ZSA9IGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycygoX2NvbXB1dGVEaXZpc29ycyhkZXNpcmVkUGF0Y2hTaXplICogbnJPZlBhdGNoZXMpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGltYWxQYXRjaFNpemU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfcGFyc2VDU1NEaW1lbnNpb25WYWx1ZXModmFsdWUpIHtcbiAgICBjb25zdCBkaW1lbnNpb24gPSB7XG4gICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KHZhbHVlKSxcbiAgICAgICAgdW5pdDogdmFsdWUuaW5kZXhPZignJScpID09PSB2YWx1ZS5sZW5ndGggLSAxID8gJyUnIDogJyUnLFxuICAgIH07XG5cbiAgICByZXR1cm4gZGltZW5zaW9uO1xufVxuXG5leHBvcnQgY29uc3QgX2RpbWVuc2lvbnNDb252ZXJ0ZXJzID0ge1xuICAgIHRvcChkaW1lbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQuaGVpZ2h0ICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpIDogbnVsbDtcbiAgICB9LFxuICAgIHJpZ2h0KGRpbWVuc2lvbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZGltZW5zaW9uLnVuaXQgPT09ICclJyA/IE1hdGguZmxvb3IoY29udGV4dC53aWR0aCAtIChjb250ZXh0LndpZHRoICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpKSA6IG51bGw7XG4gICAgfSxcbiAgICBib3R0b20oZGltZW5zaW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBkaW1lbnNpb24udW5pdCA9PT0gJyUnID8gTWF0aC5mbG9vcihjb250ZXh0LmhlaWdodCAtIChjb250ZXh0LmhlaWdodCAqIChkaW1lbnNpb24udmFsdWUgLyAxMDApKSkgOiBudWxsO1xuICAgIH0sXG4gICAgbGVmdChkaW1lbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQud2lkdGggKiAoZGltZW5zaW9uLnZhbHVlIC8gMTAwKSkgOiBudWxsO1xuICAgIH0sXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUltYWdlQXJlYShpbnB1dFdpZHRoLCBpbnB1dEhlaWdodCwgYXJlYSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7IHdpZHRoOiBpbnB1dFdpZHRoLCBoZWlnaHQ6IGlucHV0SGVpZ2h0IH07XG5cbiAgICBjb25zdCBwYXJzZWRBcmVhID0gT2JqZWN0LmtleXMoYXJlYSkucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFyZWFba2V5XTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzKHZhbHVlKTtcbiAgICAgICAgY29uc3QgY2FsY3VsYXRlZCA9IF9kaW1lbnNpb25zQ29udmVydGVyc1trZXldKHBhcnNlZCwgY29udGV4dCk7XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHJlc3VsdFtrZXldID0gY2FsY3VsYXRlZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzeDogcGFyc2VkQXJlYS5sZWZ0LFxuICAgICAgICBzeTogcGFyc2VkQXJlYS50b3AsXG4gICAgICAgIHN3OiBwYXJzZWRBcmVhLnJpZ2h0IC0gcGFyc2VkQXJlYS5sZWZ0LFxuICAgICAgICBzaDogcGFyc2VkQXJlYS5ib3R0b20gLSBwYXJzZWRBcmVhLnRvcCxcbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgWFlTaXplIH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbi8vIFRPRE86IFhZUG9zaXRpb24gc2hvdWxkIGJlIGFuIFhZT2JqZWN0LCBidXQgdGhhdCBicmVha3MgWFlEZWZpbml0aW9uLCB3aGljaCBicmVha3MgZHJhd1BhdGgoKSBiZWxvdy5cbmRlY2xhcmUgaW50ZXJmYWNlIFhZUG9zaXRpb24ge1xuICAgIHg6IG51bWJlcjtcbiAgICB5OiBudW1iZXI7XG59XG5cbmRlY2xhcmUgaW50ZXJmYWNlIENhbnZhc1N0eWxlIHtcbiAgICBjb2xvcjogc3RyaW5nO1xuICAgIGxpbmVXaWR0aDogbnVtYmVyO1xufVxuXG4vLyBYWURlZmluaXRpb24gdGVsbHMgdXMgd2hpY2ggY29tcG9uZW50IG9mIGEgZ2l2ZW4gYXJyYXkgb3Igb2JqZWN0IGlzIHRoZSBcIlhcIiBhbmQgd2hpY2ggaXMgdGhlIFwiWVwiLlxuLy8gVXN1YWxseSB0aGlzIGlzIDAgZm9yIFggYW5kIDEgZm9yIFksIGJ1dCBtaWdodCBiZSB1c2VkIGFzICd4JyBmb3IgeCBhbmQgJ3knIGZvciBZLlxuZGVjbGFyZSBpbnRlcmZhY2UgWFlEZWZpbml0aW9uIHtcbiAgICB4OiBrZXlvZiBYWVBvc2l0aW9uO1xuICAgIHk6IGtleW9mIFhZUG9zaXRpb247XG59XG5cbmRlY2xhcmUgdHlwZSBQYXRoID0gQXJyYXk8WFlQb3NpdGlvbj47XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBkcmF3UmVjdChwb3M6IFhZUG9zaXRpb24sIHNpemU6IFhZU2l6ZSwgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHN0eWxlOiBDYW52YXNTdHlsZSk6IHZvaWQge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoIHx8IDE7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3QocG9zLngsIHBvcy55LCBzaXplLngsIHNpemUueSk7XG4gICAgfSxcbiAgICBkcmF3UGF0aChwYXRoOiBQYXRoLCBkZWY6IFhZRGVmaW5pdGlvbiwgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHN0eWxlOiBDYW52YXNTdHlsZSk6IHZvaWQge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8ocGF0aFswXVtkZWYueF0sIHBhdGhbMF1bZGVmLnldKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBwYXRoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHBhdGhbal1bZGVmLnhdLCBwYXRoW2pdW2RlZi55XSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSxcbiAgICBkcmF3SW1hZ2UoaW1hZ2VEYXRhOiBBcnJheTxudW1iZXI+LCBzaXplOiBYWVNpemUsIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGNhbnZhc0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNpemUueCwgc2l6ZS55KTtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBjYW52YXNEYXRhO1xuICAgICAgICBsZXQgY2FudmFzRGF0YVBvcyA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBsZXQgaW1hZ2VEYXRhUG9zID0gaW1hZ2VEYXRhLmxlbmd0aDtcblxuICAgICAgICBpZiAoY2FudmFzRGF0YVBvcyAvIGltYWdlRGF0YVBvcyAhPT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpbWFnZURhdGFQb3MtLSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpbWFnZURhdGFbaW1hZ2VEYXRhUG9zXTtcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IDI1NTtcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IHZhbHVlO1xuICAgICAgICAgICAgZGF0YVstLWNhbnZhc0RhdGFQb3NdID0gdmFsdWU7XG4gICAgICAgICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGNhbnZhc0RhdGEsIDAsIDApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxufTtcbiIsImltcG9ydCB7IFR5cGVkQXJyYXkgfSBmcm9tIFwiLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2FcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGluaXQ6IGZ1bmN0aW9uKGFycjogVHlwZWRBcnJheSB8IEFycmF5PGFueT4sIHZhbDogYW55KSB7XG4gICAgICAgIC8vIGFyci5maWxsKHZhbCk7XG4gICAgICAgIGxldCBsID0gYXJyLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGwtLSkge1xuICAgICAgICAgICAgYXJyW2xdID0gdmFsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNodWZmbGVzIHRoZSBjb250ZW50IG9mIGFuIGFycmF5XG4gICAgICovXG4gICAgc2h1ZmZsZTogZnVuY3Rpb24oYXJyOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGxldCBpID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAoaTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBpKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBhcnJbaV07XG4gICAgICAgICAgICBhcnJbaV0gPSBhcnJbal07XG4gICAgICAgICAgICBhcnJbal0gPSB4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcblxuICAgIHRvUG9pbnRMaXN0OiBmdW5jdGlvbihhcnI6IEFycmF5PEFycmF5PG51bWJlcj4+KSB7XG4gICAgICAgIGNvbnN0IHJvd3MgPSBhcnIucmVkdWNlKChwLCBuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByb3cgPSBgWyR7bi5qb2luKCcsJyl9XWA7XG4gICAgICAgICAgICBwLnB1c2gocm93KTtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LCBbXSBhcyBBcnJheTxzdHJpbmc+KTtcbiAgICAgICAgcmV0dXJuIGBbJHtyb3dzLmpvaW4oJyxcXHJcXG4nKX1dYDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgZWxlbWVudHMgd2hpY2gncyBzY29yZSBpcyBiaWdnZXIgdGhhbiB0aGUgdGhyZXNob2xkXG4gICAgICovXG4gICAgdGhyZXNob2xkOiBmdW5jdGlvbihhcnI6IEFycmF5PG51bWJlcj4sIHRocmVzaG9sZDogbnVtYmVyLCBzY29yZUZ1bmM6ICgoc2NvcmU6IG51bWJlcikgPT4gbnVtYmVyKSkge1xuICAgICAgICBjb25zdCBxdWV1ZSA9IGFyci5yZWR1Y2UoKHByZXY6IEFycmF5PG51bWJlcj4sIG5leHQpID0+IHtcbiAgICAgICAgICAgIGlmIChzY29yZUZ1bmMuYXBwbHkoYXJyLCBbbmV4dF0pID49IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHByZXYucHVzaChuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHJldHVybiBxdWV1ZTtcbiAgICB9LFxuXG4gICAgbWF4SW5kZXg6IGZ1bmN0aW9uKGFycjogQXJyYXk8YW55Pikge1xuICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbaV0gPiBhcnJbbWF4XSkge1xuICAgICAgICAgICAgICAgIG1heCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9LFxuXG4gICAgbWF4OiBmdW5jdGlvbihhcnI6IEFycmF5PGFueT4pIHtcbiAgICAgICAgbGV0IG1heCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2ldID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gYXJyW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfSxcblxuICAgIHN1bTogZnVuY3Rpb24oYXJyOiBBcnJheTxhbnk+IHwgVHlwZWRBcnJheSk6IG51bWJlciB7XG4gICAgICAgIGxldCBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgICAgICBsZXQgc3VtID0gMDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHN1bSArPSBhcnJbbGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH0sXG59O1xuIiwiaW1wb3J0IHsgY2xvbmUgfSBmcm9tICdnbC12ZWMyJztcbmltcG9ydCB7IGhzdjJyZ2IgfSBmcm9tICcuL2N2X3V0aWxzJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuL2FycmF5X2hlbHBlcic7XG5pbXBvcnQge1xuICAgIFhZU2l6ZSxcbiAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IsXG4gICAgVHlwZWRBcnJheSxcbiAgICBXcmFwcGVySW5kZXhNYXBwaW5nLFxuICAgIE1vbWVudCxcbiAgICBTcGFyc2VJbWFnZVdyYXBwZXIsXG59IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5jb25zdCB2ZWMyID0geyBjbG9uZSB9O1xuXG50eXBlIFBvc2l0aXZlTnVtYmVyID0gbnVtYmVyO1xuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyUG9zaXRpdmUodmFsOiBudW1iZXIpOiBhc3NlcnRzIHZhbCBpcyBQb3NpdGl2ZU51bWJlciB7XG4gICAgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBwb3NpdGl2ZSBudW1iZXIsIHJlY2VpdmVkICR7dmFsfWApO1xuICAgIH1cbn1cblxuY2xhc3MgSW1hZ2VXcmFwcGVyIGltcGxlbWVudHMgU3BhcnNlSW1hZ2VXcmFwcGVyIHtcbiAgICBkYXRhOiBUeXBlZEFycmF5IHwgQXJyYXk8bnVtYmVyPjtcblxuICAgIHNpemU6IFhZU2l6ZTtcblxuICAgIGluZGV4TWFwcGluZz86IFdyYXBwZXJJbmRleE1hcHBpbmc7XG5cbiAgICAvLyBSZXByZXNlbnRzIGEgYmFzaWMgaW1hZ2UgY29tYmluaW5nIHRoZSBkYXRhIGFuZCBzaXplLiBJbiBhZGRpdGlvbiwgc29tZSBtZXRob2RzIGZvclxuICAgIC8vIG1hbmlwdWxhdGlvbiBhcmUgY29udGFpbmVkIHdpdGhpbi5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgc2l6ZTogWFlTaXplLFxuICAgICAgICBkYXRhPzogVHlwZWRBcnJheSB8IEFycmF5PG51bWJlcj4sXG4gICAgICAgIEFycmF5VHlwZTogVHlwZWRBcnJheUNvbnN0cnVjdG9yIHwgQXJyYXlDb25zdHJ1Y3RvciA9IFVpbnQ4QXJyYXksXG4gICAgICAgIGluaXRpYWxpemU/OiBib29sZWFuLFxuICAgICkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyAoQXJyYXlUeXBlKShzaXplLnggKiBzaXplLnkpO1xuICAgICAgICAgICAgaWYgKGluaXRpYWxpemUpIHtcbiAgICAgICAgICAgICAgICBBcnJheUhlbHBlci5pbml0KHRoaXMuZGF0YSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgfVxuXG4gICAgLy8gdGVzdHMgaWYgYSBwb3NpdGlvbiBpcyB3aXRoaW4gdGhlIGltYWdlLCBleHRlbmRlZCBvdXQgYnkgYSBib3JkZXIgb24gZWFjaCBzaWRlXG4gICAgaW5JbWFnZVdpdGhCb3JkZXIoaW1nUmVmOiBYWVNpemUsIGJvcmRlcjogUG9zaXRpdmVOdW1iZXIgPSAwKTogYm9vbGVhbiB7XG4gICAgICAgIGFzc2VydE51bWJlclBvc2l0aXZlKGJvcmRlcik7XG4gICAgICAgIC8vIFRPRE86IGNvZGVfMTI4IHN0YXJ0cyBmYWlsaW5nIG1pc2VyYWJseSB3aGVuIGkgb25seSBhbGxvdyBpbWdSZWYgdG8gY29udGFpbiBwb3NpdGl2ZSBudW1iZXJzLlxuICAgICAgICAvLyBUT0RPOiB0aGlzIGRvZXNuJ3QgbWFrZSBtdWNoIHNlbnNlIHRvIG1lLCB3aHkgZG9lcyBpdCBnbyBuZWdhdGl2ZT8gIFRlc3RzIGFyZSBub3QgYWZmZWN0ZWQgYnlcbiAgICAgICAgLy8gcmV0dXJuaW5nIGZhbHNlLCBidXQgdGhlIHdob2xlIGNvZGVfMTI4IHJlYWRlciBibG93cyB1cCB3aGVuIGkgdGhyb3cgb24gbmVnYXRpdmUgaW1nUmVmLlxuICAgICAgICAvLyBhc3NlcnROdW1iZXJQb3NpdGl2ZShpbWdSZWYueCk7XG4gICAgICAgIC8vIGFzc2VydE51bWJlclBvc2l0aXZlKGltZ1JlZi55KTtcbiAgICAgICAgcmV0dXJuIChpbWdSZWYueCA+PSAwKVxuICAgICAgICAgICAgJiYgKGltZ1JlZi55ID49IDApXG4gICAgICAgICAgICAmJiAoaW1nUmVmLnggPCAodGhpcy5zaXplLnggKyAoYm9yZGVyICogMikpKVxuICAgICAgICAgICAgJiYgKGltZ1JlZi55IDwgKHRoaXMuc2l6ZS55ICsgKGJvcmRlciAqIDIpKSk7XG4gICAgfVxuXG4gICAgLy8gQ29weSBmcm9tIFRISVMgSW1hZ2VXcmFwcGVyIHRvIHRoZSBuZXcgaW1hZ2VXcmFwcGVyIHBhcmFtZXRlciwgc3RhcnRpbmcgYXQgZnJvbSwgc3RvcHBpbmcgYXRcbiAgICAvLyBlbmQgb2YgbmV3IGltYWdlV3JhcHBlciBzaXplLlxuICAgIHN1YkltYWdlQXNDb3B5KGltYWdlV3JhcHBlcjogSW1hZ2VXcmFwcGVyLCBmcm9tOiBYWVNpemUpOiBJbWFnZVdyYXBwZXIge1xuICAgICAgICBhc3NlcnROdW1iZXJQb3NpdGl2ZShmcm9tLngpO1xuICAgICAgICBhc3NlcnROdW1iZXJQb3NpdGl2ZShmcm9tLnkpO1xuICAgICAgICBjb25zdCB7IHg6IHNpemVYLCB5OiBzaXplWSB9ID0gaW1hZ2VXcmFwcGVyLnNpemU7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgc2l6ZVg7IHgrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBzaXplWTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgaW1hZ2VXcmFwcGVyLmRhdGFbeSAqIHNpemVYICsgeF0gPSB0aGlzLmRhdGFbKGZyb20ueSArIHkpICogdGhpcy5zaXplLnggKyBmcm9tLnggKyB4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1hZ2VXcmFwcGVyO1xuICAgICAgICAvLyBUT0RPOiB0aGlzIGZ1bmN0aW9uIHJlYWxseSBwcm9iYWJseSBzaG91bGQgY2FsbCBpbnRvIEltYWdlV3JhcHBlciBzb21ld2hlcmUgdG8gbWFrZVxuICAgICAgICAvLyBzdXJlIHRoYXQgYWxsIG9mIGl0J3MgcGFyYW1ldGVycyBhcmUgc2V0IHByb3Blcmx5LCBzb21ldGhpbmcgbGlrZVxuICAgICAgICAvLyBJbWFnZVdyYXBwZXIuVXBkYXRlRnJvbSgpXG4gICAgICAgIC8vIHRoYXQgbWlnaHQgdGFrZSBhIHByb3ZpZGVkIGRhdGEgYW5kIHNpemUsIGFuZCBtYWtlIHN1cmUgdGhlcmUncyBubyBpbnZhbGlkIGluZGV4TWFwcGluZ1xuICAgICAgICAvLyBoYW5naW5nIGFyb3VuZCwgYW5kIHN1Y2guXG4gICAgfVxuXG4gICAgLy8gUmV0cmlldmUgYSBncmF5c2NhbGUgdmFsdWUgYXQgdGhlIGdpdmVuIHBpeGVsIHBvc2l0aW9uIG9mIHRoZSBpbWFnZVxuICAgIGdldCh4OiBudW1iZXIsIHk6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbeSAqIHRoaXMuc2l6ZS54ICsgeF07XG4gICAgfVxuXG4gICAgLy8gUmV0cmlldmUgYSBncmF5c2NhbGUgdmFsdWUgYXQgdGhlIGdpdmVuIHBpeGVsIHBvc2l0aW9uIG9mIHRoZSBpbWFnZSAoc2FmZSwgd2hhdGV2ZXIgdGhhdFxuICAgIC8vIG1lYW5zKVxuICAgIGdldFNhZmUoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICAvLyBjYWNoZSBpbmRleE1hcHBpbmcgYmVjYXVzZSBpZiB3ZSdyZSB1c2luZyBpdCBvbmNlLCB3ZSdsbCBwcm9iYWJseSBuZWVkIGl0IGEgYnVuY2ggbW9yZVxuICAgICAgICAvLyB0b29cbiAgICAgICAgaWYgKCF0aGlzLmluZGV4TWFwcGluZykge1xuICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcgPSB7XG4gICAgICAgICAgICAgICAgeDogW10sXG4gICAgICAgICAgICAgICAgeTogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpemUueDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcueFtpXSA9IGk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcueFtpICsgdGhpcy5zaXplLnhdID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplLnk7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnlbaV0gPSBpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnlbaSArIHRoaXMuc2l6ZS55XSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVsodGhpcy5pbmRleE1hcHBpbmcueVt5ICsgdGhpcy5zaXplLnldKSAqIHRoaXMuc2l6ZS54ICsgdGhpcy5pbmRleE1hcHBpbmcueFt4ICsgdGhpcy5zaXplLnhdXTtcbiAgICB9XG5cbiAgICAvLyBTZXRzIGEgZ2l2ZW4gcGl4ZWwgcG9zaXRpb24gaW4gdGhlIGltYWdlIHRvIHRoZSBnaXZlbiBncmF5c2NhbGUgdmFsdWVcbiAgICBzZXQoeDogbnVtYmVyLCB5OiBudW1iZXIsIHZhbHVlOiBudW1iZXIpOiBJbWFnZVdyYXBwZXIge1xuICAgICAgICB0aGlzLmRhdGFbeSAqIHRoaXMuc2l6ZS54ICsgeF0gPSB2YWx1ZTtcbiAgICAgICAgZGVsZXRlIHRoaXMuaW5kZXhNYXBwaW5nO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBTZXRzIHRoZSBib3JkZXIgb2YgdGhlIGltYWdlICgxIHBpeGVsKSB0byB6ZXJvXG4gICAgemVyb0JvcmRlcigpOiBJbWFnZVdyYXBwZXIge1xuICAgICAgICBjb25zdCB7IHg6IHdpZHRoLCB5OiBoZWlnaHQgfSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbXVsdGktYXNzaWduXG4gICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSB0aGlzLmRhdGFbKGhlaWdodCAtIDEpICogd2lkdGggKyBpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBoZWlnaHQgLSAxOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tdWx0aS1hc3NpZ25cbiAgICAgICAgICAgIHRoaXMuZGF0YVtpICogd2lkdGhdID0gdGhpcy5kYXRhW2kgKiB3aWR0aCArICh3aWR0aCAtIDEpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuaW5kZXhNYXBwaW5nO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiB0aGlzIGZ1bmN0aW9uIGlzIGVudGlyZWx5IHRvbyBsYXJnZSBmb3IgbWUgdG8gcmVhc29uIG91dCByaWdodCBhdCB0aGlzIG1vbWVudCB0aGF0IGknbSBoYW5kbGluZ1xuICAgIC8vIGFsbCB0aGUgcmVzdCBvZiBpdCwgc28gdGhpcyBpcyBhIHZlcmJhdGltIGNvcHkgb2YgdGhlIGphdmFzY3JpcHQgc291cmNlLCB3aXRoIG9ubHkgdHdlYWtzXG4gICAgLy8gbmVjZXNzYXJ5IHRvIGdldCBpdCB0byBydW4sIG5vIHRob3VnaHQgcHV0IGludG8gaXQgeWV0LlxuICAgIG1vbWVudHMobGFiZWxDb3VudDogbnVtYmVyKTogQXJyYXk8TW9tZW50PiB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHg7XG4gICAgICAgIGxldCB5O1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLnNpemUueTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLnNpemUueDtcbiAgICAgICAgbGV0IHZhbDtcbiAgICAgICAgbGV0IHlzcTtcbiAgICAgICAgY29uc3QgbGFiZWxTdW06IEFycmF5PE1vbWVudD4gPSBbXTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBsYWJlbDtcbiAgICAgICAgbGV0IG11MTE7XG4gICAgICAgIGxldCBtdTAyO1xuICAgICAgICBsZXQgbXUyMDtcbiAgICAgICAgbGV0IHhfO1xuICAgICAgICBsZXQgeV87XG4gICAgICAgIGxldCB0bXA7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8TW9tZW50PiA9IFtdO1xuICAgICAgICBjb25zdCB7IFBJIH0gPSBNYXRoO1xuICAgICAgICBjb25zdCBQSV80ID0gUEkgLyA0O1xuXG4gICAgICAgIGlmIChsYWJlbENvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGFiZWxDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsYWJlbFN1bVtpXSA9IHtcbiAgICAgICAgICAgICAgICBtMDA6IDAsXG4gICAgICAgICAgICAgICAgbTAxOiAwLFxuICAgICAgICAgICAgICAgIG0xMDogMCxcbiAgICAgICAgICAgICAgICBtMTE6IDAsXG4gICAgICAgICAgICAgICAgbTAyOiAwLFxuICAgICAgICAgICAgICAgIG0yMDogMCxcbiAgICAgICAgICAgICAgICB0aGV0YTogMCxcbiAgICAgICAgICAgICAgICByYWQ6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICB5c3EgPSB5ICogeTtcbiAgICAgICAgICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gZGF0YVt5ICogd2lkdGggKyB4XTtcbiAgICAgICAgICAgICAgICBpZiAodmFsID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsU3VtW3ZhbCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMDAgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTAxICs9IHk7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0xMCArPSB4O1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMTEgKz0geCAqIHk7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0wMiArPSB5c3E7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0yMCArPSB4ICogeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGFiZWxDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsYWJlbCA9IGxhYmVsU3VtW2ldO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgICAgICAgICAgaWYgKCFpc05hTihsYWJlbC5tMDApICYmIGxhYmVsLm0wMCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHhfID0gbGFiZWwubTEwIC8gbGFiZWwubTAwO1xuICAgICAgICAgICAgICAgIHlfID0gbGFiZWwubTAxIC8gbGFiZWwubTAwO1xuICAgICAgICAgICAgICAgIG11MTEgPSBsYWJlbC5tMTEgLyBsYWJlbC5tMDAgLSB4XyAqIHlfO1xuICAgICAgICAgICAgICAgIG11MDIgPSBsYWJlbC5tMDIgLyBsYWJlbC5tMDAgLSB5XyAqIHlfO1xuICAgICAgICAgICAgICAgIG11MjAgPSBsYWJlbC5tMjAgLyBsYWJlbC5tMDAgLSB4XyAqIHhfO1xuICAgICAgICAgICAgICAgIHRtcCA9IChtdTAyIC0gbXUyMCkgLyAoMiAqIG11MTEpO1xuICAgICAgICAgICAgICAgIHRtcCA9IDAuNSAqIE1hdGguYXRhbih0bXApICsgKG11MTEgPj0gMCA/IFBJXzQgOiAtUElfNCkgKyBQSTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWl4ZWQtb3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgbGFiZWwudGhldGEgPSAodG1wICogMTgwIC8gUEkgKyA5MCkgJSAxODAgLSA5MDtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWwudGhldGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLnRoZXRhICs9IDE4MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFiZWwucmFkID0gdG1wID4gUEkgPyB0bXAgLSBQSSA6IHRtcDtcbiAgICAgICAgICAgICAgICBsYWJlbC52ZWMgPSB2ZWMyLmNsb25lKFtNYXRoLmNvcyh0bXApLCBNYXRoLnNpbih0bXApXSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIGEgVWludDhDbGFtcGVkQXJyYXkgY29udGFpbmluZyB0aGlzIGdyYXlzY2FsZSBpbWFnZSBjb252ZXJ0ZWQgdG8gUkdCQSBmb3JtXG4gICAgZ2V0QXNSR0JBKHNjYWxlID0gMS4wKTogVWludDhDbGFtcGVkQXJyYXkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoNCAqIHRoaXMuc2l6ZS54ICogdGhpcy5zaXplLnkpO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuc2l6ZS55OyB5KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5zaXplLng7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsID0geSAqIHRoaXMuc2l6ZS54ICsgeDtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5nZXQoeCwgeSkgKiBzY2FsZTtcbiAgICAgICAgICAgICAgICByZXRbcGl4ZWwgKiA0ICsgMF0gPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIHJldFtwaXhlbCAqIDQgKyAxXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgcmV0W3BpeGVsICogNCArIDJdID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICByZXRbcGl4ZWwgKiA0ICsgM10gPSAyNTU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvLyBEaXNwbGF5IHRoaXMgSW1hZ2VXcmFwcGVyIGluIGEgZ2l2ZW4gQ2FudmFzIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBzY2FsZVxuICAgIHNob3coY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgc2NhbGUgPSAxLjApOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgY2FudmFzIGNvbnRleHQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcmFtZSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0QXNSR0JBKHNjYWxlKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuc2l6ZS54O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuc2l6ZS55O1xuICAgICAgICBjb25zdCBuZXdGcmFtZSA9IG5ldyBJbWFnZURhdGEoZGF0YSwgZnJhbWUud2lkdGgsIGZyYW1lLmhlaWdodCk7XG4gICAgICAgIGN0eC5wdXRJbWFnZURhdGEobmV3RnJhbWUsIDAsIDApO1xuICAgIH1cblxuICAgIC8vIERpc3BsYXlzIGEgc3BlY2lmaWVkIFN1YkltYWdlIGFyZWEgaW4gYSBnaXZlbiBjYW52YXMuIFRoaXMgZGlmZmVycyBkcmFzdGljYWxseSBmcm9tXG4gICAgLy8gY3JlYXRpbmcgYSBuZXcgU3ViSW1hZ2UgYW5kIHVzaW5nIGl0J3Mgc2hvdygpIG1ldGhvZC4gV2h5PyBJIGRvbid0IGhhdmUgdGhlIGFuc3dlciB0byB0aGF0XG4gICAgLy8geWV0LiAgSSBzdXNwZWN0IHRoZSBIU1YvUkdCIG9wZXJhdGlvbnMgaW52b2x2ZWQgaGVyZSBhcmUgbWFraW5nIGl0IHNpZ25pZmljYW50bHkgZGlmZmVyZW50LFxuICAgIC8vIGJ1dCB1bnRpbCBJIGNhbiB2aXN1YWxpemUgdGhlc2UgZnVuY3Rpb25zIHNpZGUgYnkgc2lkZSwgSSdtIGp1c3QgZ29pbmcgdG8gY29weSB0aGUgZXhpc3RpbmdcbiAgICAvLyBpbXBsZW1lbnRhdGlvbi5cbiAgICBvdmVybGF5KGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIGluU2NhbGU6IG51bWJlciwgZnJvbTogWFlTaXplKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkU2NhbGUgPSAoaW5TY2FsZSA8IDAgfHwgaW5TY2FsZSA+IDM2MCkgPyAzNjAgOiBpblNjYWxlO1xuICAgICAgICBjb25zdCBoc3YgPSBbMCwgMSwgMV07XG4gICAgICAgIGNvbnN0IHJnYiA9IFswLCAwLCAwXTtcbiAgICAgICAgY29uc3Qgd2hpdGVSZ2IgPSBbMjU1LCAyNTUsIDI1NV07XG4gICAgICAgIGNvbnN0IGJsYWNrUmdiID0gWzAsIDAsIDBdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IGNhbnZhcyBjb250ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJhbWUgPSBjdHguZ2V0SW1hZ2VEYXRhKGZyb20ueCwgZnJvbS55LCB0aGlzLnNpemUueCwgdGhpcy5zaXplLnkpO1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGZyYW1lO1xuICAgICAgICBsZXQgeyBsZW5ndGggfSA9IHRoaXMuZGF0YTtcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICBoc3ZbMF0gPSB0aGlzLmRhdGFbbGVuZ3RoXSAqIGFkanVzdGVkU2NhbGU7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgIHJlc3VsdCA9IGhzdlswXSA8PSAwID8gd2hpdGVSZ2IgOiBoc3ZbMF0gPj0gMzYwID8gYmxhY2tSZ2IgOiBoc3YycmdiKGhzdiwgcmdiKTtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IGxlbmd0aCAqIDQ7XG4gICAgICAgICAgICBbZGF0YVtwb3NdLCBkYXRhW3BvcyArIDFdLCBkYXRhW3BvcyArIDJdXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGRhdGFbcG9zICsgM10gPSAyNTU7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShmcmFtZSwgZnJvbS54LCBmcm9tLnkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VXcmFwcGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogTG9kYXNoIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vb3BlbmpzZi5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG47KGZ1bmN0aW9uKCkge1xuXG4gIC8qKiBVc2VkIGFzIGEgc2FmZSByZWZlcmVuY2UgZm9yIGB1bmRlZmluZWRgIGluIHByZS1FUzUgZW52aXJvbm1lbnRzLiAqL1xuICB2YXIgdW5kZWZpbmVkO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci4gKi9cbiAgdmFyIFZFUlNJT04gPSAnNC4xNy4yMCc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG4gIHZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4gIC8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbiAgdmFyIENPUkVfRVJST1JfVEVYVCA9ICdVbnN1cHBvcnRlZCBjb3JlLWpzIHVzZS4gVHJ5IGh0dHBzOi8vbnBtcy5pby9zZWFyY2g/cT1wb255ZmlsbC4nLFxuICAgICAgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4gIC8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbiAgdmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbiAgdmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIGludGVybmFsIGFyZ3VtZW50IHBsYWNlaG9sZGVyLiAqL1xuICB2YXIgUExBQ0VIT0xERVIgPSAnX19sb2Rhc2hfcGxhY2Vob2xkZXJfXyc7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbiAgdmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbiAgdmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICB2YXIgV1JBUF9CSU5EX0ZMQUcgPSAxLFxuICAgICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICAgIFdSQVBfQ1VSUllfQk9VTkRfRkxBRyA9IDQsXG4gICAgICBXUkFQX0NVUlJZX0ZMQUcgPSA4LFxuICAgICAgV1JBUF9DVVJSWV9SSUdIVF9GTEFHID0gMTYsXG4gICAgICBXUkFQX1BBUlRJQUxfRkxBRyA9IDMyLFxuICAgICAgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgPSA2NCxcbiAgICAgIFdSQVBfQVJZX0ZMQUcgPSAxMjgsXG4gICAgICBXUkFQX1JFQVJHX0ZMQUcgPSAyNTYsXG4gICAgICBXUkFQX0ZMSVBfRkxBRyA9IDUxMjtcblxuICAvKiogVXNlZCBhcyBkZWZhdWx0IG9wdGlvbnMgZm9yIGBfLnRydW5jYXRlYC4gKi9cbiAgdmFyIERFRkFVTFRfVFJVTkNfTEVOR1RIID0gMzAsXG4gICAgICBERUZBVUxUX1RSVU5DX09NSVNTSU9OID0gJy4uLic7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xuICB2YXIgSE9UX0NPVU5UID0gODAwLFxuICAgICAgSE9UX1NQQU4gPSAxNjtcblxuICAvKiogVXNlZCB0byBpbmRpY2F0ZSB0aGUgdHlwZSBvZiBsYXp5IGl0ZXJhdGVlcy4gKi9cbiAgdmFyIExBWllfRklMVEVSX0ZMQUcgPSAxLFxuICAgICAgTEFaWV9NQVBfRkxBRyA9IDIsXG4gICAgICBMQVpZX1dISUxFX0ZMQUcgPSAzO1xuXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xuICB2YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICAgIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxLFxuICAgICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCxcbiAgICAgIE5BTiA9IDAgLyAwO1xuXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHRoZSBtYXhpbXVtIGxlbmd0aCBhbmQgaW5kZXggb2YgYW4gYXJyYXkuICovXG4gIHZhciBNQVhfQVJSQVlfTEVOR1RIID0gNDI5NDk2NzI5NSxcbiAgICAgIE1BWF9BUlJBWV9JTkRFWCA9IE1BWF9BUlJBWV9MRU5HVEggLSAxLFxuICAgICAgSEFMRl9NQVhfQVJSQVlfTEVOR1RIID0gTUFYX0FSUkFZX0xFTkdUSCA+Pj4gMTtcblxuICAvKiogVXNlZCB0byBhc3NvY2lhdGUgd3JhcCBtZXRob2RzIHdpdGggdGhlaXIgYml0IGZsYWdzLiAqL1xuICB2YXIgd3JhcEZsYWdzID0gW1xuICAgIFsnYXJ5JywgV1JBUF9BUllfRkxBR10sXG4gICAgWydiaW5kJywgV1JBUF9CSU5EX0ZMQUddLFxuICAgIFsnYmluZEtleScsIFdSQVBfQklORF9LRVlfRkxBR10sXG4gICAgWydjdXJyeScsIFdSQVBfQ1VSUllfRkxBR10sXG4gICAgWydjdXJyeVJpZ2h0JywgV1JBUF9DVVJSWV9SSUdIVF9GTEFHXSxcbiAgICBbJ2ZsaXAnLCBXUkFQX0ZMSVBfRkxBR10sXG4gICAgWydwYXJ0aWFsJywgV1JBUF9QQVJUSUFMX0ZMQUddLFxuICAgIFsncGFydGlhbFJpZ2h0JywgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUddLFxuICAgIFsncmVhcmcnLCBXUkFQX1JFQVJHX0ZMQUddXG4gIF07XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICB2YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICAgIGRvbUV4Y1RhZyA9ICdbb2JqZWN0IERPTUV4Y2VwdGlvbl0nLFxuICAgICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nLFxuICAgICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJyxcbiAgICAgIHdlYWtTZXRUYWcgPSAnW29iamVjdCBXZWFrU2V0XSc7XG5cbiAgdmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuICAvKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlLiAqL1xuICB2YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlZEh0bWwgPSAvJig/OmFtcHxsdHxndHxxdW90fCMzOSk7L2csXG4gICAgICByZVVuZXNjYXBlZEh0bWwgPSAvWyY8PlwiJ10vZyxcbiAgICAgIHJlSGFzRXNjYXBlZEh0bWwgPSBSZWdFeHAocmVFc2NhcGVkSHRtbC5zb3VyY2UpLFxuICAgICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG4gIHZhciByZUVzY2FwZSA9IC88JS0oW1xcc1xcU10rPyklPi9nLFxuICAgICAgcmVFdmFsdWF0ZSA9IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAgICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gICAqL1xuICB2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nLFxuICAgICAgcmVIYXNSZWdFeHBDaGFyID0gUmVnRXhwKHJlUmVnRXhwQ2hhci5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG4gIHZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZyxcbiAgICAgIHJlVHJpbVN0YXJ0ID0gL15cXHMrLyxcbiAgICAgIHJlVHJpbUVuZCA9IC9cXHMrJC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggd3JhcCBkZXRhaWwgY29tbWVudHMuICovXG4gIHZhciByZVdyYXBDb21tZW50ID0gL1xceyg/OlxcblxcL1xcKiBcXFt3cmFwcGVkIHdpdGggLitcXF0gXFwqXFwvKT9cXG4/LyxcbiAgICAgIHJlV3JhcERldGFpbHMgPSAvXFx7XFxuXFwvXFwqIFxcW3dyYXBwZWQgd2l0aCAoLispXFxdIFxcKi8sXG4gICAgICByZVNwbGl0RGV0YWlscyA9IC8sPyAmIC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggd29yZHMgY29tcG9zZWQgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuICovXG4gIHZhciByZUFzY2lpV29yZCA9IC9bXlxceDAwLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceDdmXSsvZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgdmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoXG4gICAqIFtFUyB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10ZW1wbGF0ZS1saXRlcmFsLWxleGljYWwtY29tcG9uZW50cykuXG4gICAqL1xuICB2YXIgcmVFc1RlbXBsYXRlID0gL1xcJFxceyhbXlxcXFx9XSooPzpcXFxcLlteXFxcXH1dKikqKVxcfS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbiAgdmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuICAvKiogVXNlZCB0byBtYXRjaCBMYXRpbiBVbmljb2RlIGxldHRlcnMgKGV4Y2x1ZGluZyBtYXRoZW1hdGljYWwgb3BlcmF0b3JzKS4gKi9cbiAgdmFyIHJlTGF0aW4gPSAvW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHhmZlxcdTAxMDAtXFx1MDE3Zl0vZztcblxuICAvKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG4gIHZhciByZU5vTWF0Y2ggPSAvKCReKS87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuICB2YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xuICB2YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICAgIHJzRGluZ2JhdFJhbmdlID0gJ1xcXFx1MjcwMC1cXFxcdTI3YmYnLFxuICAgICAgcnNMb3dlclJhbmdlID0gJ2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZicsXG4gICAgICByc01hdGhPcFJhbmdlID0gJ1xcXFx4YWNcXFxceGIxXFxcXHhkN1xcXFx4ZjcnLFxuICAgICAgcnNOb25DaGFyUmFuZ2UgPSAnXFxcXHgwMC1cXFxceDJmXFxcXHgzYS1cXFxceDQwXFxcXHg1Yi1cXFxceDYwXFxcXHg3Yi1cXFxceGJmJyxcbiAgICAgIHJzUHVuY3R1YXRpb25SYW5nZSA9ICdcXFxcdTIwMDAtXFxcXHUyMDZmJyxcbiAgICAgIHJzU3BhY2VSYW5nZSA9ICcgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMCcsXG4gICAgICByc1VwcGVyUmFuZ2UgPSAnQS1aXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGRlJyxcbiAgICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJyxcbiAgICAgIHJzQnJlYWtSYW5nZSA9IHJzTWF0aE9wUmFuZ2UgKyByc05vbkNoYXJSYW5nZSArIHJzUHVuY3R1YXRpb25SYW5nZSArIHJzU3BhY2VSYW5nZTtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG4gIHZhciByc0Fwb3MgPSBcIlsnXFx1MjAxOV1cIixcbiAgICAgIHJzQXN0cmFsID0gJ1snICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICAgIHJzQnJlYWsgPSAnWycgKyByc0JyZWFrUmFuZ2UgKyAnXScsXG4gICAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nLFxuICAgICAgcnNEaWdpdHMgPSAnXFxcXGQrJyxcbiAgICAgIHJzRGluZ2JhdCA9ICdbJyArIHJzRGluZ2JhdFJhbmdlICsgJ10nLFxuICAgICAgcnNMb3dlciA9ICdbJyArIHJzTG93ZXJSYW5nZSArICddJyxcbiAgICAgIHJzTWlzYyA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgcnNCcmVha1JhbmdlICsgcnNEaWdpdHMgKyByc0RpbmdiYXRSYW5nZSArIHJzTG93ZXJSYW5nZSArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICAgIHJzRml0eiA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nLFxuICAgICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgICByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nLFxuICAgICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgICAgcnNVcHBlciA9ICdbJyArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG4gIHZhciByc01pc2NMb3dlciA9ICcoPzonICsgcnNMb3dlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICAgIHJzTWlzY1VwcGVyID0gJyg/OicgKyByc1VwcGVyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgICAgcnNPcHRDb250ckxvd2VyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86ZHxsbHxtfHJlfHN8dHx2ZSkpPycsXG4gICAgICByc09wdENvbnRyVXBwZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpEfExMfE18UkV8U3xUfFZFKSk/JyxcbiAgICAgIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgICAgcnNPcmRMb3dlciA9ICdcXFxcZCooPzoxc3R8Mm5kfDNyZHwoPyFbMTIzXSlcXFxcZHRoKSg/PVxcXFxifFtBLVpfXSknLFxuICAgICAgcnNPcmRVcHBlciA9ICdcXFxcZCooPzoxU1R8Mk5EfDNSRHwoPyFbMTIzXSlcXFxcZFRIKSg/PVxcXFxifFthLXpfXSknLFxuICAgICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgICAgcnNFbW9qaSA9ICcoPzonICsgW3JzRGluZ2JhdCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNTZXEsXG4gICAgICByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyArICc/JywgcnNDb21ibywgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuICAvKiogVXNlZCB0byBtYXRjaCBhcG9zdHJvcGhlcy4gKi9cbiAgdmFyIHJlQXBvcyA9IFJlZ0V4cChyc0Fwb3MsICdnJyk7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKSBhbmRcbiAgICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrcyBmb3Igc3ltYm9sc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzX2Zvcl9TeW1ib2xzKS5cbiAgICovXG4gIHZhciByZUNvbWJvTWFyayA9IFJlZ0V4cChyc0NvbWJvLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG4gIHZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBjb21wbGV4IG9yIGNvbXBvdW5kIHdvcmRzLiAqL1xuICB2YXIgcmVVbmljb2RlV29yZCA9IFJlZ0V4cChbXG4gICAgcnNVcHBlciArICc/JyArIHJzTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgICByc01pc2NVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIgKyByc01pc2NMb3dlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gICAgcnNVcHBlciArICc/JyArIHJzTWlzY0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyLFxuICAgIHJzVXBwZXIgKyAnKycgKyByc09wdENvbnRyVXBwZXIsXG4gICAgcnNPcmRVcHBlcixcbiAgICByc09yZExvd2VyLFxuICAgIHJzRGlnaXRzLFxuICAgIHJzRW1vamlcbiAgXS5qb2luKCd8JyksICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG4gIHZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoJ1snICsgcnNaV0ogKyByc0FzdHJhbFJhbmdlICArIHJzQ29tYm9SYW5nZSArIHJzVmFyUmFuZ2UgKyAnXScpO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHRoYXQgbmVlZCBhIG1vcmUgcm9idXN0IHJlZ2V4cCB0byBtYXRjaCB3b3Jkcy4gKi9cbiAgdmFyIHJlSGFzVW5pY29kZVdvcmQgPSAvW2Etel1bQS1aXXxbQS1aXXsyfVthLXpdfFswLTldW2EtekEtWl18W2EtekEtWl1bMC05XXxbXmEtekEtWjAtOSBdLztcblxuICAvKiogVXNlZCB0byBhc3NpZ24gZGVmYXVsdCBgY29udGV4dGAgb2JqZWN0IHByb3BlcnRpZXMuICovXG4gIHZhciBjb250ZXh0UHJvcHMgPSBbXG4gICAgJ0FycmF5JywgJ0J1ZmZlcicsICdEYXRhVmlldycsICdEYXRlJywgJ0Vycm9yJywgJ0Zsb2F0MzJBcnJheScsICdGbG9hdDY0QXJyYXknLFxuICAgICdGdW5jdGlvbicsICdJbnQ4QXJyYXknLCAnSW50MTZBcnJheScsICdJbnQzMkFycmF5JywgJ01hcCcsICdNYXRoJywgJ09iamVjdCcsXG4gICAgJ1Byb21pc2UnLCAnUmVnRXhwJywgJ1NldCcsICdTdHJpbmcnLCAnU3ltYm9sJywgJ1R5cGVFcnJvcicsICdVaW50OEFycmF5JyxcbiAgICAnVWludDhDbGFtcGVkQXJyYXknLCAnVWludDE2QXJyYXknLCAnVWludDMyQXJyYXknLCAnV2Vha01hcCcsXG4gICAgJ18nLCAnY2xlYXJUaW1lb3V0JywgJ2lzRmluaXRlJywgJ3BhcnNlSW50JywgJ3NldFRpbWVvdXQnXG4gIF07XG5cbiAgLyoqIFVzZWQgdG8gbWFrZSB0ZW1wbGF0ZSBzb3VyY2VVUkxzIGVhc2llciB0byBpZGVudGlmeS4gKi9cbiAgdmFyIHRlbXBsYXRlQ291bnRlciA9IC0xO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbiAgdmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG4gIHR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gIHR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xuICB2YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuICBjbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICBjbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuICBjbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgLyoqIFVzZWQgdG8gbWFwIExhdGluIFVuaWNvZGUgbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLiAqL1xuICB2YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xuICAgIC8vIExhdGluLTEgU3VwcGxlbWVudCBibG9jay5cbiAgICAnXFx4YzAnOiAnQScsICAnXFx4YzEnOiAnQScsICdcXHhjMic6ICdBJywgJ1xceGMzJzogJ0EnLCAnXFx4YzQnOiAnQScsICdcXHhjNSc6ICdBJyxcbiAgICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgICAnXFx4YzcnOiAnQycsICAnXFx4ZTcnOiAnYycsXG4gICAgJ1xceGQwJzogJ0QnLCAgJ1xceGYwJzogJ2QnLFxuICAgICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICAgJ1xceGU4JzogJ2UnLCAgJ1xceGU5JzogJ2UnLCAnXFx4ZWEnOiAnZScsICdcXHhlYic6ICdlJyxcbiAgICAnXFx4Y2MnOiAnSScsICAnXFx4Y2QnOiAnSScsICdcXHhjZSc6ICdJJywgJ1xceGNmJzogJ0knLFxuICAgICdcXHhlYyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICAgJ1xceGQxJzogJ04nLCAgJ1xceGYxJzogJ24nLFxuICAgICdcXHhkMic6ICdPJywgICdcXHhkMyc6ICdPJywgJ1xceGQ0JzogJ08nLCAnXFx4ZDUnOiAnTycsICdcXHhkNic6ICdPJywgJ1xceGQ4JzogJ08nLFxuICAgICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAgICdcXHhkOSc6ICdVJywgICdcXHhkYSc6ICdVJywgJ1xceGRiJzogJ1UnLCAnXFx4ZGMnOiAnVScsXG4gICAgJ1xceGY5JzogJ3UnLCAgJ1xceGZhJzogJ3UnLCAnXFx4ZmInOiAndScsICdcXHhmYyc6ICd1JyxcbiAgICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgICAnXFx4YzYnOiAnQWUnLCAnXFx4ZTYnOiAnYWUnLFxuICAgICdcXHhkZSc6ICdUaCcsICdcXHhmZSc6ICd0aCcsXG4gICAgJ1xceGRmJzogJ3NzJyxcbiAgICAvLyBMYXRpbiBFeHRlbmRlZC1BIGJsb2NrLlxuICAgICdcXHUwMTAwJzogJ0EnLCAgJ1xcdTAxMDInOiAnQScsICdcXHUwMTA0JzogJ0EnLFxuICAgICdcXHUwMTAxJzogJ2EnLCAgJ1xcdTAxMDMnOiAnYScsICdcXHUwMTA1JzogJ2EnLFxuICAgICdcXHUwMTA2JzogJ0MnLCAgJ1xcdTAxMDgnOiAnQycsICdcXHUwMTBhJzogJ0MnLCAnXFx1MDEwYyc6ICdDJyxcbiAgICAnXFx1MDEwNyc6ICdjJywgICdcXHUwMTA5JzogJ2MnLCAnXFx1MDEwYic6ICdjJywgJ1xcdTAxMGQnOiAnYycsXG4gICAgJ1xcdTAxMGUnOiAnRCcsICAnXFx1MDExMCc6ICdEJywgJ1xcdTAxMGYnOiAnZCcsICdcXHUwMTExJzogJ2QnLFxuICAgICdcXHUwMTEyJzogJ0UnLCAgJ1xcdTAxMTQnOiAnRScsICdcXHUwMTE2JzogJ0UnLCAnXFx1MDExOCc6ICdFJywgJ1xcdTAxMWEnOiAnRScsXG4gICAgJ1xcdTAxMTMnOiAnZScsICAnXFx1MDExNSc6ICdlJywgJ1xcdTAxMTcnOiAnZScsICdcXHUwMTE5JzogJ2UnLCAnXFx1MDExYic6ICdlJyxcbiAgICAnXFx1MDExYyc6ICdHJywgICdcXHUwMTFlJzogJ0cnLCAnXFx1MDEyMCc6ICdHJywgJ1xcdTAxMjInOiAnRycsXG4gICAgJ1xcdTAxMWQnOiAnZycsICAnXFx1MDExZic6ICdnJywgJ1xcdTAxMjEnOiAnZycsICdcXHUwMTIzJzogJ2cnLFxuICAgICdcXHUwMTI0JzogJ0gnLCAgJ1xcdTAxMjYnOiAnSCcsICdcXHUwMTI1JzogJ2gnLCAnXFx1MDEyNyc6ICdoJyxcbiAgICAnXFx1MDEyOCc6ICdJJywgICdcXHUwMTJhJzogJ0knLCAnXFx1MDEyYyc6ICdJJywgJ1xcdTAxMmUnOiAnSScsICdcXHUwMTMwJzogJ0knLFxuICAgICdcXHUwMTI5JzogJ2knLCAgJ1xcdTAxMmInOiAnaScsICdcXHUwMTJkJzogJ2knLCAnXFx1MDEyZic6ICdpJywgJ1xcdTAxMzEnOiAnaScsXG4gICAgJ1xcdTAxMzQnOiAnSicsICAnXFx1MDEzNSc6ICdqJyxcbiAgICAnXFx1MDEzNic6ICdLJywgICdcXHUwMTM3JzogJ2snLCAnXFx1MDEzOCc6ICdrJyxcbiAgICAnXFx1MDEzOSc6ICdMJywgICdcXHUwMTNiJzogJ0wnLCAnXFx1MDEzZCc6ICdMJywgJ1xcdTAxM2YnOiAnTCcsICdcXHUwMTQxJzogJ0wnLFxuICAgICdcXHUwMTNhJzogJ2wnLCAgJ1xcdTAxM2MnOiAnbCcsICdcXHUwMTNlJzogJ2wnLCAnXFx1MDE0MCc6ICdsJywgJ1xcdTAxNDInOiAnbCcsXG4gICAgJ1xcdTAxNDMnOiAnTicsICAnXFx1MDE0NSc6ICdOJywgJ1xcdTAxNDcnOiAnTicsICdcXHUwMTRhJzogJ04nLFxuICAgICdcXHUwMTQ0JzogJ24nLCAgJ1xcdTAxNDYnOiAnbicsICdcXHUwMTQ4JzogJ24nLCAnXFx1MDE0Yic6ICduJyxcbiAgICAnXFx1MDE0Yyc6ICdPJywgICdcXHUwMTRlJzogJ08nLCAnXFx1MDE1MCc6ICdPJyxcbiAgICAnXFx1MDE0ZCc6ICdvJywgICdcXHUwMTRmJzogJ28nLCAnXFx1MDE1MSc6ICdvJyxcbiAgICAnXFx1MDE1NCc6ICdSJywgICdcXHUwMTU2JzogJ1InLCAnXFx1MDE1OCc6ICdSJyxcbiAgICAnXFx1MDE1NSc6ICdyJywgICdcXHUwMTU3JzogJ3InLCAnXFx1MDE1OSc6ICdyJyxcbiAgICAnXFx1MDE1YSc6ICdTJywgICdcXHUwMTVjJzogJ1MnLCAnXFx1MDE1ZSc6ICdTJywgJ1xcdTAxNjAnOiAnUycsXG4gICAgJ1xcdTAxNWInOiAncycsICAnXFx1MDE1ZCc6ICdzJywgJ1xcdTAxNWYnOiAncycsICdcXHUwMTYxJzogJ3MnLFxuICAgICdcXHUwMTYyJzogJ1QnLCAgJ1xcdTAxNjQnOiAnVCcsICdcXHUwMTY2JzogJ1QnLFxuICAgICdcXHUwMTYzJzogJ3QnLCAgJ1xcdTAxNjUnOiAndCcsICdcXHUwMTY3JzogJ3QnLFxuICAgICdcXHUwMTY4JzogJ1UnLCAgJ1xcdTAxNmEnOiAnVScsICdcXHUwMTZjJzogJ1UnLCAnXFx1MDE2ZSc6ICdVJywgJ1xcdTAxNzAnOiAnVScsICdcXHUwMTcyJzogJ1UnLFxuICAgICdcXHUwMTY5JzogJ3UnLCAgJ1xcdTAxNmInOiAndScsICdcXHUwMTZkJzogJ3UnLCAnXFx1MDE2Zic6ICd1JywgJ1xcdTAxNzEnOiAndScsICdcXHUwMTczJzogJ3UnLFxuICAgICdcXHUwMTc0JzogJ1cnLCAgJ1xcdTAxNzUnOiAndycsXG4gICAgJ1xcdTAxNzYnOiAnWScsICAnXFx1MDE3Nyc6ICd5JywgJ1xcdTAxNzgnOiAnWScsXG4gICAgJ1xcdTAxNzknOiAnWicsICAnXFx1MDE3Yic6ICdaJywgJ1xcdTAxN2QnOiAnWicsXG4gICAgJ1xcdTAxN2EnOiAneicsICAnXFx1MDE3Yyc6ICd6JywgJ1xcdTAxN2UnOiAneicsXG4gICAgJ1xcdTAxMzInOiAnSUonLCAnXFx1MDEzMyc6ICdpaicsXG4gICAgJ1xcdTAxNTInOiAnT2UnLCAnXFx1MDE1Myc6ICdvZScsXG4gICAgJ1xcdTAxNDknOiBcIiduXCIsICdcXHUwMTdmJzogJ3MnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cbiAgdmFyIGh0bWxFc2NhcGVzID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7J1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuICovXG4gIHZhciBodG1sVW5lc2NhcGVzID0ge1xuICAgICcmYW1wOyc6ICcmJyxcbiAgICAnJmx0Oyc6ICc8JyxcbiAgICAnJmd0Oyc6ICc+JyxcbiAgICAnJnF1b3Q7JzogJ1wiJyxcbiAgICAnJiMzOTsnOiBcIidcIlxuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuICB2YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFxyJzogJ3InLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICAvKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xuICB2YXIgZnJlZVBhcnNlRmxvYXQgPSBwYXJzZUZsb2F0LFxuICAgICAgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG4gIHZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4gIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xuICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuICB2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xuICB2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4gIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG4gIHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xuICB2YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuICAvKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbiAgdmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgICBpZiAodHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgICAgfVxuXG4gICAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH0oKSk7XG5cbiAgLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIG5vZGVJc0FycmF5QnVmZmVyID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNBcnJheUJ1ZmZlcixcbiAgICAgIG5vZGVJc0RhdGUgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc0RhdGUsXG4gICAgICBub2RlSXNNYXAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc01hcCxcbiAgICAgIG5vZGVJc1JlZ0V4cCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzUmVnRXhwLFxuICAgICAgbm9kZUlzU2V0ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNTZXQsXG4gICAgICBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQWdncmVnYXRvcmAgZm9yIGFycmF5cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlBZ2dyZWdhdG9yKGFycmF5LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RWFjaFJpZ2h0KGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5ldmVyeWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFdmVyeShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmICghcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5jbHVkZXNgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBzcGVjaWZ5aW5nIGFuIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gISFsZW5ndGggJiYgYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCAwKSA+IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlJbmNsdWRlc1dpdGgoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAqIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICAgKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICAgIH1cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZVJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAgICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVJlZHVjZVJpZ2h0KGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBhcnJheVstLWxlbmd0aF07XG4gICAgfVxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAqIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc2l6ZSBvZiBhbiBBU0NJSSBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgdmFyIGFzY2lpU2l6ZSA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIGFuIEFTQ0lJIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXNjaWlXb3JkcyhzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlQXNjaWlXb3JkKSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZmluZEtleWAgYW5kIGBfLmZpbmRMYXN0S2V5YCxcbiAgICogd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYFxuICAgKiB1c2luZyBgZWFjaEZ1bmNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50IG9yIGl0cyBrZXksIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRmluZEtleShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGVhY2hGdW5jKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICAgKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgICA/IHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpXG4gICAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGJhc2VJbmRleE9mYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZldpdGgoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgsIGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGNvbXBhcmF0b3IoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZWFuYCBhbmQgYF8ubWVhbkJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlTWVhbihhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgcmV0dXJuIGxlbmd0aCA/IChiYXNlU3VtKGFycmF5LCBpdGVyYXRlZSkgLyBsZW5ndGgpIDogTkFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgLCB3aXRob3V0IHN1cHBvcnRcbiAgICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gIHVzaW5nIGBlYWNoRnVuY2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpbml0QWNjdW0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3Qgb3IgbGFzdCBlbGVtZW50IG9mXG4gICAqICBgY29sbGVjdGlvbmAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBlYWNoRnVuYykge1xuICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgYWNjdW11bGF0b3IgPSBpbml0QWNjdW1cbiAgICAgICAgPyAoaW5pdEFjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgICA6IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmUgdGhlXG4gICAqIHNvcnQgb3JkZXIgb2YgYGFycmF5YCBhbmQgcmVwbGFjZXMgY3JpdGVyaWEgb2JqZWN0cyB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAgICogdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc29ydC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VTb3J0QnkoYXJyYXksIGNvbXBhcmVyKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zdW1gIGFuZCBgXy5zdW1CeWAgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlU3VtKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciByZXN1bHQsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSk7XG4gICAgICBpZiAoY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gY3VycmVudCA6IChyZXN1bHQgKyBjdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gICAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9QYWlyc2AgYW5kIGBfLnRvUGFpcnNJbmAgd2hpY2ggY3JlYXRlcyBhbiBhcnJheVxuICAgKiBvZiBrZXktdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzIG9mIGBwcm9wc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVG9QYWlycyhvYmplY3QsIHByb3BzKSB7XG4gICAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBba2V5LCBvYmplY3Rba2V5XV07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICAgKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAgICogb2YgYHByb3BzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICAgIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltU3RhcnRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHN0cmluZyBzeW1ib2xcbiAgICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNoclN5bWJvbHMsIHN0clN5bWJvbHNbaW5kZXhdLCAwKSA+IC0xKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltRW5kYCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHN0cmluZyBzeW1ib2xcbiAgICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCB1bm1hdGNoZWQgc3RyaW5nIHN5bWJvbC5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgIHZhciBpbmRleCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4LS0gJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBgcGxhY2Vob2xkZXJgIG9jY3VycmVuY2VzIGluIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBjb3VudC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvdW50SG9sZGVycyhhcnJheSwgcGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSAwO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoYXJyYXlbbGVuZ3RoXSA9PT0gcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgKytyZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgTGF0aW4tMSBTdXBwbGVtZW50IGFuZCBMYXRpbiBFeHRlbmRlZC1BXG4gICAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gICAqL1xuICB2YXIgZGVidXJyTGV0dGVyID0gYmFzZVByb3BlcnR5T2YoZGVidXJyZWRMZXR0ZXJzKTtcblxuICAvKipcbiAgICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgdmFyIGVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbEVzY2FwZXMpO1xuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIGEgd29yZCBjb21wb3NlZCBvZiBVbmljb2RlIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSB3b3JkIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNVbmljb2RlV29yZChzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVIYXNVbmljb2RlV29yZC50ZXN0KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYGl0ZXJhdG9yYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZXJhdG9yIFRoZSBpdGVyYXRvciB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGl0ZXJhdG9yVG9BcnJheShpdGVyYXRvcikge1xuICAgIHZhciBkYXRhLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICghKGRhdGEgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGRhdGEudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBgcGxhY2Vob2xkZXJgIGVsZW1lbnRzIGluIGBhcnJheWAgd2l0aCBhbiBpbnRlcm5hbCBwbGFjZWhvbGRlclxuICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGVpciBpbmRleGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byByZXBsYWNlLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZUhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAodmFsdWUgPT09IHBsYWNlaG9sZGVyIHx8IHZhbHVlID09PSBQTEFDRUhPTERFUikge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBQTEFDRUhPTERFUjtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHNldGAgdG8gaXRzIHZhbHVlLXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIHNldFRvUGFpcnMoc2V0KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSBbdmFsdWUsIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAgICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5sYXN0SW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaWN0TGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggKyAxO1xuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2Ygc3ltYm9scyBpbiBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5nU2l6ZShzdHJpbmcpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHVuaWNvZGVTaXplKHN0cmluZylcbiAgICAgIDogYXNjaWlTaXplKHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyB1bmljb2RlVG9BcnJheShzdHJpbmcpXG4gICAgICA6IGFzY2lpVG9BcnJheShzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udW5lc2NhcGVgIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIHZhciB1bmVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbFVuZXNjYXBlcyk7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpemUgb2YgYSBVbmljb2RlIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlU2l6ZShzdHJpbmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gcmVVbmljb2RlLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKHJlVW5pY29kZS50ZXN0KHN0cmluZykpIHtcbiAgICAgICsrcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgVW5pY29kZSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyBhIFVuaWNvZGUgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlV29yZHMoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGVXb3JkKSB8fCBbXTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdXNpbmcgdGhlIGBjb250ZXh0YCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDEuMS4wXG4gICAqIEBjYXRlZ29yeSBVdGlsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1yb290XSBUaGUgY29udGV4dCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIG5ldyBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5taXhpbih7ICdmb28nOiBfLmNvbnN0YW50KCdmb28nKSB9KTtcbiAgICpcbiAgICogdmFyIGxvZGFzaCA9IF8ucnVuSW5Db250ZXh0KCk7XG4gICAqIGxvZGFzaC5taXhpbih7ICdiYXInOiBsb2Rhc2guY29uc3RhbnQoJ2JhcicpIH0pO1xuICAgKlxuICAgKiBfLmlzRnVuY3Rpb24oXy5mb28pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqIF8uaXNGdW5jdGlvbihfLmJhcik7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5mb28pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guYmFyKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiAvLyBDcmVhdGUgYSBzdXBlZC11cCBgZGVmZXJgIGluIE5vZGUuanMuXG4gICAqIHZhciBkZWZlciA9IF8ucnVuSW5Db250ZXh0KHsgJ3NldFRpbWVvdXQnOiBzZXRJbW1lZGlhdGUgfSkuZGVmZXI7XG4gICAqL1xuICB2YXIgcnVuSW5Db250ZXh0ID0gKGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0KSB7XG4gICAgY29udGV4dCA9IGNvbnRleHQgPT0gbnVsbCA/IHJvb3QgOiBfLmRlZmF1bHRzKHJvb3QuT2JqZWN0KCksIGNvbnRleHQsIF8ucGljayhyb290LCBjb250ZXh0UHJvcHMpKTtcblxuICAgIC8qKiBCdWlsdC1pbiBjb25zdHJ1Y3RvciByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBBcnJheSA9IGNvbnRleHQuQXJyYXksXG4gICAgICAgIERhdGUgPSBjb250ZXh0LkRhdGUsXG4gICAgICAgIEVycm9yID0gY29udGV4dC5FcnJvcixcbiAgICAgICAgRnVuY3Rpb24gPSBjb250ZXh0LkZ1bmN0aW9uLFxuICAgICAgICBNYXRoID0gY29udGV4dC5NYXRoLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0Lk9iamVjdCxcbiAgICAgICAgUmVnRXhwID0gY29udGV4dC5SZWdFeHAsXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHQuU3RyaW5nLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0LlR5cGVFcnJvcjtcblxuICAgIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICAgICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgICAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG4gICAgdmFyIGNvcmVKc0RhdGEgPSBjb250ZXh0WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbiAgICB2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgICAvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLiAqL1xuICAgIHZhciBpZENvdW50ZXIgPSAwO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbiAgICB2YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gICAgICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAgICAgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICAgKiBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgdmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG4gICAgdmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgYF9gIHJlZmVyZW5jZSBpbiBgXy5ub0NvbmZsaWN0YC4gKi9cbiAgICB2YXIgb2xkRGFzaCA9IHJvb3QuXztcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG4gICAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgICAgIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gICAgICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbiAgICApO1xuXG4gICAgLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyBjb250ZXh0LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICAgICAgU3ltYm9sID0gY29udGV4dC5TeW1ib2wsXG4gICAgICAgIFVpbnQ4QXJyYXkgPSBjb250ZXh0LlVpbnQ4QXJyYXksXG4gICAgICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkLFxuICAgICAgICBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KSxcbiAgICAgICAgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSxcbiAgICAgICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICAgICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgICAgIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1JdGVyYXRvciA9IFN5bWJvbCA/IFN5bWJvbC5pdGVyYXRvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgICAgICBmdW5jKHt9LCAnJywge30pO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfSgpKTtcblxuICAgIC8qKiBNb2NrZWQgYnVpbHQtaW5zLiAqL1xuICAgIHZhciBjdHhDbGVhclRpbWVvdXQgPSBjb250ZXh0LmNsZWFyVGltZW91dCAhPT0gcm9vdC5jbGVhclRpbWVvdXQgJiYgY29udGV4dC5jbGVhclRpbWVvdXQsXG4gICAgICAgIGN0eE5vdyA9IERhdGUgJiYgRGF0ZS5ub3cgIT09IHJvb3QuRGF0ZS5ub3cgJiYgRGF0ZS5ub3csXG4gICAgICAgIGN0eFNldFRpbWVvdXQgPSBjb250ZXh0LnNldFRpbWVvdXQgIT09IHJvb3Quc2V0VGltZW91dCAmJiBjb250ZXh0LnNldFRpbWVvdXQ7XG5cbiAgICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG4gICAgdmFyIG5hdGl2ZUNlaWwgPSBNYXRoLmNlaWwsXG4gICAgICAgIG5hdGl2ZUZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgICAgICBuYXRpdmVJc0Zpbml0ZSA9IGNvbnRleHQuaXNGaW5pdGUsXG4gICAgICAgIG5hdGl2ZUpvaW4gPSBhcnJheVByb3RvLmpvaW4sXG4gICAgICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpLFxuICAgICAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXG4gICAgICAgIG5hdGl2ZU5vdyA9IERhdGUubm93LFxuICAgICAgICBuYXRpdmVQYXJzZUludCA9IGNvbnRleHQucGFyc2VJbnQsXG4gICAgICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tLFxuICAgICAgICBuYXRpdmVSZXZlcnNlID0gYXJyYXlQcm90by5yZXZlcnNlO1xuXG4gICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xuICAgIHZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShjb250ZXh0LCAnRGF0YVZpZXcnKSxcbiAgICAgICAgTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdNYXAnKSxcbiAgICAgICAgUHJvbWlzZSA9IGdldE5hdGl2ZShjb250ZXh0LCAnUHJvbWlzZScpLFxuICAgICAgICBTZXQgPSBnZXROYXRpdmUoY29udGV4dCwgJ1NldCcpLFxuICAgICAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdXZWFrTWFwJyksXG4gICAgICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuICAgIC8qKiBVc2VkIHRvIHN0b3JlIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICAgIHZhciBtZXRhTWFwID0gV2Vha01hcCAmJiBuZXcgV2Vha01hcDtcblxuICAgIC8qKiBVc2VkIHRvIGxvb2t1cCB1bm1pbmlmaWVkIGZ1bmN0aW9uIG5hbWVzLiAqL1xuICAgIHZhciByZWFsTmFtZXMgPSB7fTtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG4gICAgdmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICAgICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgICAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4gICAgLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG4gICAgdmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBpbXBsaWNpdCBtZXRob2RcbiAgICAgKiBjaGFpbiBzZXF1ZW5jZXMuIE1ldGhvZHMgdGhhdCBvcGVyYXRlIG9uIGFuZCByZXR1cm4gYXJyYXlzLCBjb2xsZWN0aW9ucyxcbiAgICAgKiBhbmQgZnVuY3Rpb25zIGNhbiBiZSBjaGFpbmVkIHRvZ2V0aGVyLiBNZXRob2RzIHRoYXQgcmV0cmlldmUgYSBzaW5nbGUgdmFsdWVcbiAgICAgKiBvciBtYXkgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlIHdpbGwgYXV0b21hdGljYWxseSBlbmQgdGhlIGNoYWluIHNlcXVlbmNlXG4gICAgICogYW5kIHJldHVybiB0aGUgdW53cmFwcGVkIHZhbHVlLiBPdGhlcndpc2UsIHRoZSB2YWx1ZSBtdXN0IGJlIHVud3JhcHBlZFxuICAgICAqIHdpdGggYF8jdmFsdWVgLlxuICAgICAqXG4gICAgICogRXhwbGljaXQgY2hhaW4gc2VxdWVuY2VzLCB3aGljaCBtdXN0IGJlIHVud3JhcHBlZCB3aXRoIGBfI3ZhbHVlYCwgbWF5IGJlXG4gICAgICogZW5hYmxlZCB1c2luZyBgXy5jaGFpbmAuXG4gICAgICpcbiAgICAgKiBUaGUgZXhlY3V0aW9uIG9mIGNoYWluZWQgbWV0aG9kcyBpcyBsYXp5LCB0aGF0IGlzLCBpdCdzIGRlZmVycmVkIHVudGlsXG4gICAgICogYF8jdmFsdWVgIGlzIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBMYXp5IGV2YWx1YXRpb24gYWxsb3dzIHNldmVyYWwgbWV0aG9kcyB0byBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbi5cbiAgICAgKiBTaG9ydGN1dCBmdXNpb24gaXMgYW4gb3B0aW1pemF0aW9uIHRvIG1lcmdlIGl0ZXJhdGVlIGNhbGxzOyB0aGlzIGF2b2lkc1xuICAgICAqIHRoZSBjcmVhdGlvbiBvZiBpbnRlcm1lZGlhdGUgYXJyYXlzIGFuZCBjYW4gZ3JlYXRseSByZWR1Y2UgdGhlIG51bWJlciBvZlxuICAgICAqIGl0ZXJhdGVlIGV4ZWN1dGlvbnMuIFNlY3Rpb25zIG9mIGEgY2hhaW4gc2VxdWVuY2UgcXVhbGlmeSBmb3Igc2hvcnRjdXRcbiAgICAgKiBmdXNpb24gaWYgdGhlIHNlY3Rpb24gaXMgYXBwbGllZCB0byBhbiBhcnJheSBhbmQgaXRlcmF0ZWVzIGFjY2VwdCBvbmx5XG4gICAgICogb25lIGFyZ3VtZW50LiBUaGUgaGV1cmlzdGljIGZvciB3aGV0aGVyIGEgc2VjdGlvbiBxdWFsaWZpZXMgZm9yIHNob3J0Y3V0XG4gICAgICogZnVzaW9uIGlzIHN1YmplY3QgdG8gY2hhbmdlLlxuICAgICAqXG4gICAgICogQ2hhaW5pbmcgaXMgc3VwcG9ydGVkIGluIGN1c3RvbSBidWlsZHMgYXMgbG9uZyBhcyB0aGUgYF8jdmFsdWVgIG1ldGhvZCBpc1xuICAgICAqIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24gdG8gbG9kYXNoIG1ldGhvZHMsIHdyYXBwZXJzIGhhdmUgYEFycmF5YCBhbmQgYFN0cmluZ2AgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGBBcnJheWAgbWV0aG9kcyBhcmU6XG4gICAgICogYGNvbmNhdGAsIGBqb2luYCwgYHBvcGAsIGBwdXNoYCwgYHNoaWZ0YCwgYHNvcnRgLCBgc3BsaWNlYCwgYW5kIGB1bnNoaWZ0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgYFN0cmluZ2AgbWV0aG9kcyBhcmU6XG4gICAgICogYHJlcGxhY2VgIGFuZCBgc3BsaXRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24gYXJlOlxuICAgICAqIGBhdGAsIGBjb21wYWN0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGRyb3BXaGlsZWAsIGBmaWx0ZXJgLCBgZmluZGAsXG4gICAgICogYGZpbmRMYXN0YCwgYGhlYWRgLCBgaW5pdGlhbGAsIGBsYXN0YCwgYG1hcGAsIGByZWplY3RgLCBgcmV2ZXJzZWAsIGBzbGljZWAsXG4gICAgICogYHRhaWxgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYW5kIGB0b0FycmF5YFxuICAgICAqXG4gICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhZnRlcmAsIGBhcnlgLCBgYXNzaWduYCwgYGFzc2lnbkluYCwgYGFzc2lnbkluV2l0aGAsIGBhc3NpZ25XaXRoYCwgYGF0YCxcbiAgICAgKiBgYmVmb3JlYCwgYGJpbmRgLCBgYmluZEFsbGAsIGBiaW5kS2V5YCwgYGNhc3RBcnJheWAsIGBjaGFpbmAsIGBjaHVua2AsXG4gICAgICogYGNvbW1pdGAsIGBjb21wYWN0YCwgYGNvbmNhdGAsIGBjb25mb3Jtc2AsIGBjb25zdGFudGAsIGBjb3VudEJ5YCwgYGNyZWF0ZWAsXG4gICAgICogYGN1cnJ5YCwgYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBkZWZlcmAsIGBkZWxheWAsXG4gICAgICogYGRpZmZlcmVuY2VgLCBgZGlmZmVyZW5jZUJ5YCwgYGRpZmZlcmVuY2VXaXRoYCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCxcbiAgICAgKiBgZHJvcFJpZ2h0V2hpbGVgLCBgZHJvcFdoaWxlYCwgYGV4dGVuZGAsIGBleHRlbmRXaXRoYCwgYGZpbGxgLCBgZmlsdGVyYCxcbiAgICAgKiBgZmxhdE1hcGAsIGBmbGF0TWFwRGVlcGAsIGBmbGF0TWFwRGVwdGhgLCBgZmxhdHRlbmAsIGBmbGF0dGVuRGVlcGAsXG4gICAgICogYGZsYXR0ZW5EZXB0aGAsIGBmbGlwYCwgYGZsb3dgLCBgZmxvd1JpZ2h0YCwgYGZyb21QYWlyc2AsIGBmdW5jdGlvbnNgLFxuICAgICAqIGBmdW5jdGlvbnNJbmAsIGBncm91cEJ5YCwgYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludGVyc2VjdGlvbkJ5YCxcbiAgICAgKiBgaW50ZXJzZWN0aW9uV2l0aGAsIGBpbnZlcnRgLCBgaW52ZXJ0QnlgLCBgaW52b2tlTWFwYCwgYGl0ZXJhdGVlYCwgYGtleUJ5YCxcbiAgICAgKiBga2V5c2AsIGBrZXlzSW5gLCBgbWFwYCwgYG1hcEtleXNgLCBgbWFwVmFsdWVzYCwgYG1hdGNoZXNgLCBgbWF0Y2hlc1Byb3BlcnR5YCxcbiAgICAgKiBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtZXJnZVdpdGhgLCBgbWV0aG9kYCwgYG1ldGhvZE9mYCwgYG1peGluYCwgYG5lZ2F0ZWAsXG4gICAgICogYG50aEFyZ2AsIGBvbWl0YCwgYG9taXRCeWAsIGBvbmNlYCwgYG9yZGVyQnlgLCBgb3ZlcmAsIGBvdmVyQXJnc2AsXG4gICAgICogYG92ZXJFdmVyeWAsIGBvdmVyU29tZWAsIGBwYXJ0aWFsYCwgYHBhcnRpYWxSaWdodGAsIGBwYXJ0aXRpb25gLCBgcGlja2AsXG4gICAgICogYHBpY2tCeWAsIGBwbGFudGAsIGBwcm9wZXJ0eWAsIGBwcm9wZXJ0eU9mYCwgYHB1bGxgLCBgcHVsbEFsbGAsIGBwdWxsQWxsQnlgLFxuICAgICAqIGBwdWxsQWxsV2l0aGAsIGBwdWxsQXRgLCBgcHVzaGAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlYXJnYCwgYHJlamVjdGAsXG4gICAgICogYHJlbW92ZWAsIGByZXN0YCwgYHJldmVyc2VgLCBgc2FtcGxlU2l6ZWAsIGBzZXRgLCBgc2V0V2l0aGAsIGBzaHVmZmxlYCxcbiAgICAgKiBgc2xpY2VgLCBgc29ydGAsIGBzb3J0QnlgLCBgc3BsaWNlYCwgYHNwcmVhZGAsIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAgICAgKiBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aHJ1YCwgYHRvQXJyYXlgLFxuICAgICAqIGB0b1BhaXJzYCwgYHRvUGFpcnNJbmAsIGB0b1BhdGhgLCBgdG9QbGFpbk9iamVjdGAsIGB0cmFuc2Zvcm1gLCBgdW5hcnlgLFxuICAgICAqIGB1bmlvbmAsIGB1bmlvbkJ5YCwgYHVuaW9uV2l0aGAsIGB1bmlxYCwgYHVuaXFCeWAsIGB1bmlxV2l0aGAsIGB1bnNldGAsXG4gICAgICogYHVuc2hpZnRgLCBgdW56aXBgLCBgdW56aXBXaXRoYCwgYHVwZGF0ZWAsIGB1cGRhdGVXaXRoYCwgYHZhbHVlc2AsXG4gICAgICogYHZhbHVlc0luYCwgYHdpdGhvdXRgLCBgd3JhcGAsIGB4b3JgLCBgeG9yQnlgLCBgeG9yV2l0aGAsIGB6aXBgLFxuICAgICAqIGB6aXBPYmplY3RgLCBgemlwT2JqZWN0RGVlcGAsIGFuZCBgemlwV2l0aGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBhcmUgKipub3QqKiBjaGFpbmFibGUgYnkgZGVmYXVsdCBhcmU6XG4gICAgICogYGFkZGAsIGBhdHRlbXB0YCwgYGNhbWVsQ2FzZWAsIGBjYXBpdGFsaXplYCwgYGNlaWxgLCBgY2xhbXBgLCBgY2xvbmVgLFxuICAgICAqIGBjbG9uZURlZXBgLCBgY2xvbmVEZWVwV2l0aGAsIGBjbG9uZVdpdGhgLCBgY29uZm9ybXNUb2AsIGBkZWJ1cnJgLFxuICAgICAqIGBkZWZhdWx0VG9gLCBgZGl2aWRlYCwgYGVhY2hgLCBgZWFjaFJpZ2h0YCwgYGVuZHNXaXRoYCwgYGVxYCwgYGVzY2FwZWAsXG4gICAgICogYGVzY2FwZVJlZ0V4cGAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsIGBmaW5kS2V5YCwgYGZpbmRMYXN0YCxcbiAgICAgKiBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBmaXJzdGAsIGBmbG9vcmAsIGBmb3JFYWNoYCwgYGZvckVhY2hSaWdodGAsXG4gICAgICogYGZvckluYCwgYGZvckluUmlnaHRgLCBgZm9yT3duYCwgYGZvck93blJpZ2h0YCwgYGdldGAsIGBndGAsIGBndGVgLCBgaGFzYCxcbiAgICAgKiBgaGFzSW5gLCBgaGVhZGAsIGBpZGVudGl0eWAsIGBpbmNsdWRlc2AsIGBpbmRleE9mYCwgYGluUmFuZ2VgLCBgaW52b2tlYCxcbiAgICAgKiBgaXNBcmd1bWVudHNgLCBgaXNBcnJheWAsIGBpc0FycmF5QnVmZmVyYCwgYGlzQXJyYXlMaWtlYCwgYGlzQXJyYXlMaWtlT2JqZWN0YCxcbiAgICAgKiBgaXNCb29sZWFuYCwgYGlzQnVmZmVyYCwgYGlzRGF0ZWAsIGBpc0VsZW1lbnRgLCBgaXNFbXB0eWAsIGBpc0VxdWFsYCxcbiAgICAgKiBgaXNFcXVhbFdpdGhgLCBgaXNFcnJvcmAsIGBpc0Zpbml0ZWAsIGBpc0Z1bmN0aW9uYCwgYGlzSW50ZWdlcmAsIGBpc0xlbmd0aGAsXG4gICAgICogYGlzTWFwYCwgYGlzTWF0Y2hgLCBgaXNNYXRjaFdpdGhgLCBgaXNOYU5gLCBgaXNOYXRpdmVgLCBgaXNOaWxgLCBgaXNOdWxsYCxcbiAgICAgKiBgaXNOdW1iZXJgLCBgaXNPYmplY3RgLCBgaXNPYmplY3RMaWtlYCwgYGlzUGxhaW5PYmplY3RgLCBgaXNSZWdFeHBgLFxuICAgICAqIGBpc1NhZmVJbnRlZ2VyYCwgYGlzU2V0YCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGlzVHlwZWRBcnJheWAsXG4gICAgICogYGlzV2Vha01hcGAsIGBpc1dlYWtTZXRgLCBgam9pbmAsIGBrZWJhYkNhc2VgLCBgbGFzdGAsIGBsYXN0SW5kZXhPZmAsXG4gICAgICogYGxvd2VyQ2FzZWAsIGBsb3dlckZpcnN0YCwgYGx0YCwgYGx0ZWAsIGBtYXhgLCBgbWF4QnlgLCBgbWVhbmAsIGBtZWFuQnlgLFxuICAgICAqIGBtaW5gLCBgbWluQnlgLCBgbXVsdGlwbHlgLCBgbm9Db25mbGljdGAsIGBub29wYCwgYG5vd2AsIGBudGhgLCBgcGFkYCxcbiAgICAgKiBgcGFkRW5kYCwgYHBhZFN0YXJ0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCwgYHJlZHVjZVJpZ2h0YCxcbiAgICAgKiBgcmVwZWF0YCwgYHJlc3VsdGAsIGByb3VuZGAsIGBydW5JbkNvbnRleHRgLCBgc2FtcGxlYCwgYHNoaWZ0YCwgYHNpemVgLFxuICAgICAqIGBzbmFrZUNhc2VgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBzb3J0ZWRJbmRleEJ5YCwgYHNvcnRlZExhc3RJbmRleGAsXG4gICAgICogYHNvcnRlZExhc3RJbmRleEJ5YCwgYHN0YXJ0Q2FzZWAsIGBzdGFydHNXaXRoYCwgYHN0dWJBcnJheWAsIGBzdHViRmFsc2VgLFxuICAgICAqIGBzdHViT2JqZWN0YCwgYHN0dWJTdHJpbmdgLCBgc3R1YlRydWVgLCBgc3VidHJhY3RgLCBgc3VtYCwgYHN1bUJ5YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdGltZXNgLCBgdG9GaW5pdGVgLCBgdG9JbnRlZ2VyYCwgYHRvSlNPTmAsIGB0b0xlbmd0aGAsXG4gICAgICogYHRvTG93ZXJgLCBgdG9OdW1iZXJgLCBgdG9TYWZlSW50ZWdlcmAsIGB0b1N0cmluZ2AsIGB0b1VwcGVyYCwgYHRyaW1gLFxuICAgICAqIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGB0cnVuY2F0ZWAsIGB1bmVzY2FwZWAsIGB1bmlxdWVJZGAsIGB1cHBlckNhc2VgLFxuICAgICAqIGB1cHBlckZpcnN0YCwgYHZhbHVlYCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIEBuYW1lIF9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICAgICAqXG4gICAgICogLy8gUmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogd3JhcHBlZC5yZWR1Y2UoXy5hZGQpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIC8vIFJldHVybnMgYSB3cmFwcGVkIHZhbHVlLlxuICAgICAqIHZhciBzcXVhcmVzID0gd3JhcHBlZC5tYXAoc3F1YXJlKTtcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMudmFsdWUoKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaCh2YWx1ZSkge1xuICAgICAgaWYgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTG9kYXNoV3JhcHBlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpIHtcbiAgICAgICAgICByZXR1cm4gd3JhcHBlckNsb25lKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gICAgICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIHZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgICAgIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiB3aG9zZSBwcm90b3R5cGUgY2hhaW4gc2VxdWVuY2Ugd3JhcHBlcnMgaW5oZXJpdCBmcm9tLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTG9kYXNoKCkge1xuICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBjb25zdHJ1Y3RvciBmb3IgY3JlYXRpbmcgYGxvZGFzaGAgd3JhcHBlciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NoYWluQWxsXSBFbmFibGUgZXhwbGljaXQgbWV0aG9kIGNoYWluIHNlcXVlbmNlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2Rhc2hXcmFwcGVyKHZhbHVlLCBjaGFpbkFsbCkge1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICAgICAgdGhpcy5fX2NoYWluX18gPSAhIWNoYWluQWxsO1xuICAgICAgdGhpcy5fX2luZGV4X18gPSAwO1xuICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgbG9kYXNoIGFyZSBsaWtlIHRob3NlIGluXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKSBhcyB3ZWxsIGFzIEVTMjAxNSB0ZW1wbGF0ZSBzdHJpbmdzLiBDaGFuZ2UgdGhlXG4gICAgICogZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogcmVFc2NhcGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2V2YWx1YXRlJzogcmVFdmFsdWF0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGluamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgJ2ltcG9ydHMnOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgICdfJzogbG9kYXNoXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEVuc3VyZSB3cmFwcGVycyBhcmUgaW5zdGFuY2VzIG9mIGBiYXNlTG9kYXNoYC5cbiAgICBsb2Rhc2gucHJvdG90eXBlID0gYmFzZUxvZGFzaC5wcm90b3R5cGU7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGxvZGFzaDtcblxuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2Rhc2hXcmFwcGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxhenkgd3JhcHBlciBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgbGF6eSBldmFsdWF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExhenlXcmFwcGVyKHZhbHVlKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICB0aGlzLl9fZGlyX18gPSAxO1xuICAgICAgdGhpcy5fX2ZpbHRlcmVkX18gPSBmYWxzZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlZXNfXyA9IFtdO1xuICAgICAgdGhpcy5fX3Rha2VDb3VudF9fID0gTUFYX0FSUkFZX0xFTkdUSDtcbiAgICAgIHRoaXMuX192aWV3c19fID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBsYXp5IHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbG9uZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5Q2xvbmUoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMuX193cmFwcGVkX18pO1xuICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHRoaXMuX19hY3Rpb25zX18pO1xuICAgICAgcmVzdWx0Ll9fZGlyX18gPSB0aGlzLl9fZGlyX187XG4gICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdGhpcy5fX2ZpbHRlcmVkX187XG4gICAgICByZXN1bHQuX19pdGVyYXRlZXNfXyA9IGNvcHlBcnJheSh0aGlzLl9faXRlcmF0ZWVzX18pO1xuICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSB0aGlzLl9fdGFrZUNvdW50X187XG4gICAgICByZXN1bHQuX192aWV3c19fID0gY29weUFycmF5KHRoaXMuX192aWV3c19fKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgdGhlIGRpcmVjdGlvbiBvZiBsYXp5IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyByZXZlcnNlZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5UmV2ZXJzZSgpIHtcbiAgICAgIGlmICh0aGlzLl9fZmlsdGVyZWRfXykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICByZXN1bHQuX19kaXJfXyA9IC0xO1xuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gKj0gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSB1bndyYXBwZWQgdmFsdWUgZnJvbSBpdHMgbGF6eSB3cmFwcGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVZhbHVlKCkge1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5fX3dyYXBwZWRfXy52YWx1ZSgpLFxuICAgICAgICAgIGRpciA9IHRoaXMuX19kaXJfXyxcbiAgICAgICAgICBpc0FyciA9IGlzQXJyYXkoYXJyYXkpLFxuICAgICAgICAgIGlzUmlnaHQgPSBkaXIgPCAwLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGlzQXJyID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICB2aWV3ID0gZ2V0VmlldygwLCBhcnJMZW5ndGgsIHRoaXMuX192aWV3c19fKSxcbiAgICAgICAgICBzdGFydCA9IHZpZXcuc3RhcnQsXG4gICAgICAgICAgZW5kID0gdmlldy5lbmQsXG4gICAgICAgICAgbGVuZ3RoID0gZW5kIC0gc3RhcnQsXG4gICAgICAgICAgaW5kZXggPSBpc1JpZ2h0ID8gZW5kIDogKHN0YXJ0IC0gMSksXG4gICAgICAgICAgaXRlcmF0ZWVzID0gdGhpcy5fX2l0ZXJhdGVlc19fLFxuICAgICAgICAgIGl0ZXJMZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICB0YWtlQ291bnQgPSBuYXRpdmVNaW4obGVuZ3RoLCB0aGlzLl9fdGFrZUNvdW50X18pO1xuXG4gICAgICBpZiAoIWlzQXJyIHx8ICghaXNSaWdodCAmJiBhcnJMZW5ndGggPT0gbGVuZ3RoICYmIHRha2VDb3VudCA9PSBsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKGFycmF5LCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAobGVuZ3RoLS0gJiYgcmVzSW5kZXggPCB0YWtlQ291bnQpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuXG4gICAgICAgIHZhciBpdGVySW5kZXggPSAtMSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIHdoaWxlICgrK2l0ZXJJbmRleCA8IGl0ZXJMZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGl0ZXJhdGVlc1tpdGVySW5kZXhdLFxuICAgICAgICAgICAgICBpdGVyYXRlZSA9IGRhdGEuaXRlcmF0ZWUsXG4gICAgICAgICAgICAgIHR5cGUgPSBkYXRhLnR5cGUsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9NQVBfRkxBRykge1xuICAgICAgICAgICAgdmFsdWUgPSBjb21wdXRlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFjb21wdXRlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRykge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIGBMYXp5V3JhcHBlcmAgaXMgYW4gaW5zdGFuY2Ugb2YgYGJhc2VMb2Rhc2hgLlxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExhenlXcmFwcGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICAgICAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG4gICAgSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG4gICAgSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbiAgICBIYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuICAgIEhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG4gICAgSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICAgICAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgICAgICBkYXRhLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICAgICAgfVxuICAgICAgLS10aGlzLnNpemU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgKyt0aGlzLnNpemU7XG4gICAgICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAgICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgYWRkXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQGFsaWFzIHB1c2hcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICAgICAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICAgICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICAgICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gICAgICB9XG4gICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG4gICAgU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcbiAgICBTdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG4gICAgU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuICAgIFN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcbiAgICBTdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICAgICAgKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zYW1wbGVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2FtcGxlKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2Jhc2VSYW5kb20oMCwgbGVuZ3RoIC0gMSldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zYW1wbGVTaXplYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2FtcGxlU2l6ZShhcnJheSwgbikge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSksIGJhc2VDbGFtcChuLCAwLCBhcnJheS5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTaHVmZmxlKGFycmF5KSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAgICAgKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFnZ3JlZ2F0ZXMgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIG9uIGBhY2N1bXVsYXRvcmAgd2l0aCBrZXlzIHRyYW5zZm9ybWVkXG4gICAgICogYnkgYGl0ZXJhdGVlYCBhbmQgdmFsdWVzIHNldCBieSBgc2V0dGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFnZ3JlZ2F0b3IoY29sbGVjdGlvbiwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gICAgICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICAgICAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICAgICAqIHZhbHVlIGNoZWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcGlja2VkIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBdChvYmplY3QsIHBhdGhzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICBza2lwID0gb2JqZWN0ID09IG51bGw7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBza2lwID8gdW5kZWZpbmVkIDogZ2V0KG9iamVjdCwgcGF0aHNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xhbXBgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICAgICAgaWYgKG51bWJlciA9PT0gbnVtYmVyKSB7XG4gICAgICAgIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbnVtYmVyID0gbnVtYmVyIDw9IHVwcGVyID8gbnVtYmVyIDogdXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvd2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBudW1iZXIgPSBudW1iZXIgPj0gbG93ZXIgPyBudW1iZXIgOiBsb3dlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gICAgICogdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgMSAtIERlZXAgY2xvbmVcbiAgICAgKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAgICAgKiAgNCAtIENsb25lIHN5bWJvbHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgICAgIGlzRmxhdCA9IGJpdG1hc2sgJiBDTE9ORV9GTEFUX0ZMQUcsXG4gICAgICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcbiAgICAgICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZDtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICAgICAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN1YlZhbHVlLCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gICAgICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgICAgIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb25mb3Jtc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb25mb3Jtcyhzb3VyY2UpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMoc291cmNlKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBwcm9wcyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbmZvcm1zVG9gIHdoaWNoIGFjY2VwdHMgYHByb3BzYCB0byBjaGVjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgY29uZm9ybXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwgcHJvcHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbbGVuZ3RoXSxcbiAgICAgICAgICAgIHByZWRpY2F0ZSA9IHNvdXJjZVtrZXldLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICBpZiAoKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkgfHwgIXByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRlbGF5YCBhbmQgYF8uZGVmZXJgIHdoaWNoIGFjY2VwdHMgYGFyZ3NgXG4gICAgICogdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8T2JqZWN0fSBSZXR1cm5zIHRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGVsYXkoZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgd2FpdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRpZmZlcmVuY2VgIHdpdGhvdXQgc3VwcG9ydFxuICAgICAqIGZvciBleGNsdWRpbmcgbXVsdGlwbGUgYXJyYXlzIG9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFsdWVzID0gYXJyYXlNYXAodmFsdWVzLCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh2YWx1ZXMubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzID0gbmV3IFNldENhY2hlKHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPT0gbnVsbCA/IHZhbHVlIDogaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgdmFyIHZhbHVlc0luZGV4ID0gdmFsdWVzTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICh2YWx1ZXNJbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzW3ZhbHVlc0luZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5jbHVkZXModmFsdWVzLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hSaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2hSaWdodCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd25SaWdodCwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ldmVyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFdmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9ICEhcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLm1heGAgYW5kIGBfLm1pbmAgd2hpY2ggYWNjZXB0cyBhXG4gICAgICogYGNvbXBhcmF0b3JgIHRvIGRldGVybWluZSB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFeHRyZW11bShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY3VycmVudCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICBpZiAoY3VycmVudCAhPSBudWxsICYmIChjb21wdXRlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gKGN1cnJlbnQgPT09IGN1cnJlbnQgJiYgIWlzU3ltYm9sKGN1cnJlbnQpKVxuICAgICAgICAgICAgICA6IGNvbXBhcmF0b3IoY3VycmVudCwgY29tcHV0ZWQpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgdmFyIGNvbXB1dGVkID0gY3VycmVudCxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsbGAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBzdGFydCA9IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gICAgICB9XG4gICAgICBlbmQgPSAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gbGVuZ3RoKSA/IGxlbmd0aCA6IHRvSW50ZWdlcihlbmQpO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVuZCA9IHN0YXJ0ID4gZW5kID8gMCA6IHRvTGVuZ3RoKGVuZCk7XG4gICAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgYXJyYXlbc3RhcnQrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gICAgICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICAgICAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUZvcmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzXG4gICAgICogaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yUmlnaHQgPSBjcmVhdGVCYXNlRm9yKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93blJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd25SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JSaWdodChvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mdW5jdGlvbnNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2ZcbiAgICAgKiBgb2JqZWN0YCBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmaWx0ZXJlZCBmcm9tIGBwcm9wc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBmaWx0ZXIuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRnVuY3Rpb25zKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIHJldHVybiBhcnJheUZpbHRlcihwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG9iamVjdFtrZXldKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gICAgICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgICAgIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgICAgIH1cbiAgICAgIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICAgICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmd0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc2Agd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VIYXMob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pblJhbmdlYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbnVtYmVyYCBpcyBpbiB0aGUgcmFuZ2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiBudW1iZXIgPj0gbmF0aXZlTWluKHN0YXJ0LCBlbmQpICYmIG51bWJlciA8IG5hdGl2ZU1heChzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCwgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHNoYXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludGVyc2VjdGlvbihhcnJheXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5jbHVkZXMgPSBjb21wYXJhdG9yID8gYXJyYXlJbmNsdWRlc1dpdGggOiBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5c1swXS5sZW5ndGgsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgICAgICBvdGhJbmRleCA9IG90aExlbmd0aCxcbiAgICAgICAgICBjYWNoZXMgPSBBcnJheShvdGhMZW5ndGgpLFxuICAgICAgICAgIG1heExlbmd0aCA9IEluZmluaXR5LFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAob3RoSW5kZXgtLSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcnJheXNbb3RoSW5kZXhdO1xuICAgICAgICBpZiAob3RoSW5kZXggJiYgaXRlcmF0ZWUpIHtcbiAgICAgICAgICBhcnJheSA9IGFycmF5TWFwKGFycmF5LCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhMZW5ndGggPSBuYXRpdmVNaW4oYXJyYXkubGVuZ3RoLCBtYXhMZW5ndGgpO1xuICAgICAgICBjYWNoZXNbb3RoSW5kZXhdID0gIWNvbXBhcmF0b3IgJiYgKGl0ZXJhdGVlIHx8IChsZW5ndGggPj0gMTIwICYmIGFycmF5Lmxlbmd0aCA+PSAxMjApKVxuICAgICAgICAgID8gbmV3IFNldENhY2hlKG90aEluZGV4ICYmIGFycmF5KVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYXJyYXkgPSBhcnJheXNbMF07XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHNlZW4gPSBjYWNoZXNbMF07XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA8IG1heExlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmICghKHNlZW5cbiAgICAgICAgICAgICAgPyBjYWNoZUhhcyhzZWVuLCBjb21wdXRlZClcbiAgICAgICAgICAgICAgOiBpbmNsdWRlcyhyZXN1bHQsIGNvbXB1dGVkLCBjb21wYXJhdG9yKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgtLW90aEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNbb3RoSW5kZXhdO1xuICAgICAgICAgICAgaWYgKCEoY2FjaGVcbiAgICAgICAgICAgICAgICAgID8gY2FjaGVIYXMoY2FjaGUsIGNvbXB1dGVkKVxuICAgICAgICAgICAgICAgICAgOiBpbmNsdWRlcyhhcnJheXNbb3RoSW5kZXhdLCBjb21wdXRlZCwgY29tcGFyYXRvcikpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmludmVydGAgYW5kIGBfLmludmVydEJ5YCB3aGljaCBpbnZlcnRzXG4gICAgICogYG9iamVjdGAgd2l0aCB2YWx1ZXMgdHJhbnNmb3JtZWQgYnkgYGl0ZXJhdGVlYCBhbmQgc2V0IGJ5IGBzZXR0ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0gdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludmVydGVyKG9iamVjdCwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCBpdGVyYXRlZSh2YWx1ZSksIGtleSwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmludm9rZWAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogbWV0aG9kIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICAgICAgdmFyIGZ1bmMgPSBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG4gICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogYXBwbHkoZnVuYywgb2JqZWN0LCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcnJheUJ1ZmZlcmAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0FycmF5QnVmZmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcnJheUJ1ZmZlclRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0RhdGVgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGRhdGUgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gZGF0ZVRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gICAgICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gICAgICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICAgICAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gICAgICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICAgICAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICAgICAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICAgICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgICAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICAgICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzU2FtZVRhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1JlZ0V4cGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzUmVnRXhwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSByZWdleHBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNTZXRgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1NldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAgICAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgICAgIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICAgICAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmx0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VMdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gICAgICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gICAgICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgICAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgICAgID8gY3VzdG9taXplcihzYWZlR2V0KG9iamVjdCwga2V5KSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgICAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpLFxuICAgICAgICAgIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksXG4gICAgICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHNyY1ZhbHVlKSxcbiAgICAgICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgaXNGdW5jdGlvbihvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5udGhgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG50aCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU50aChhcnJheSwgbikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG4gKz0gbiA8IDAgPyBsZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIGlzSW5kZXgobiwgbGVuZ3RoKSA/IGFycmF5W25dIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm9yZGVyQnlgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gICAgICBpZiAoaXRlcmF0ZWVzLmxlbmd0aCkge1xuICAgICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoaXRlcmF0ZWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2VHZXQodmFsdWUsIGl0ZXJhdGVlLmxlbmd0aCA9PT0gMSA/IGl0ZXJhdGVlWzBdIDogaXRlcmF0ZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXRlcmF0ZWU7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW2lkZW50aXR5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGNyaXRlcmlhID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyAnY3JpdGVyaWEnOiBjcml0ZXJpYSwgJ2luZGV4JzogKytpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucGlja2Agd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gICAgICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgICAgICByZXR1cm4gaGFzSW4ob2JqZWN0LCBwYXRoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mICBgXy5waWNrQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBwYXRoKSkge1xuICAgICAgICAgIGJhc2VTZXQocmVzdWx0LCBjYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBbGxCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgICAqIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleE9mID0gY29tcGFyYXRvciA/IGJhc2VJbmRleE9mV2l0aCA6IGJhc2VJbmRleE9mLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICBzZWVuID0gYXJyYXk7XG5cbiAgICAgIGlmIChhcnJheSA9PT0gdmFsdWVzKSB7XG4gICAgICAgIHZhbHVlcyA9IGNvcHlBcnJheSh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHNlZW4gPSBhcnJheU1hcChhcnJheSwgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZnJvbUluZGV4ID0gMCxcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzW2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB3aGlsZSAoKGZyb21JbmRleCA9IGluZGV4T2Yoc2VlbiwgY29tcHV0ZWQsIGZyb21JbmRleCwgY29tcGFyYXRvcikpID4gLTEpIHtcbiAgICAgICAgICBpZiAoc2VlbiAhPT0gYXJyYXkpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKHNlZW4sIGZyb21JbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBmcm9tSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHVsbEF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBpbmRleGVzIG9yIGNhcHR1cmluZyB0aGUgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBpbmRleGVzIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBpbmRleGVzLmxlbmd0aCA6IDAsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKGxlbmd0aCA9PSBsYXN0SW5kZXggfHwgaW5kZXggIT09IHByZXZpb3VzKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzID0gaW5kZXg7XG4gICAgICAgICAgaWYgKGlzSW5kZXgoaW5kZXgpKSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgsIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlVW5zZXQoYXJyYXksIGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5kb21gIHdpdGhvdXQgc3VwcG9ydCBmb3IgcmV0dXJuaW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpIHtcbiAgICAgIHJldHVybiBsb3dlciArIG5hdGl2ZUZsb29yKG5hdGl2ZVJhbmRvbSgpICogKHVwcGVyIC0gbG93ZXIgKyAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZ2VgIGFuZCBgXy5yYW5nZVJpZ2h0YCB3aGljaCBkb2Vzbid0XG4gICAgICogY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KG5hdGl2ZUNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XSA9IHN0YXJ0O1xuICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXBlYXRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVwZWF0KHN0cmluZywgbikge1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgaWYgKCFzdHJpbmcgfHwgbiA8IDEgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIC8vIExldmVyYWdlIHRoZSBleHBvbmVudGlhdGlvbiBieSBzcXVhcmluZyBhbGdvcml0aG0gZm9yIGEgZmFzdGVyIHJlcGVhdC5cbiAgICAgIC8vIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FeHBvbmVudGlhdGlvbl9ieV9zcXVhcmluZyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgZG8ge1xuICAgICAgICBpZiAobiAlIDIpIHtcbiAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBuYXRpdmVGbG9vcihuIC8gMik7XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgc3RyaW5nICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAobik7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2FtcGxlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2FtcGxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBhcnJheVNhbXBsZSh2YWx1ZXMoY29sbGVjdGlvbikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNhbXBsZVNpemVgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNhbXBsZVNpemUoY29sbGVjdGlvbiwgbikge1xuICAgICAgdmFyIGFycmF5ID0gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGFycmF5LCBiYXNlQ2xhbXAobiwgMCwgYXJyYXkubGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICAgICAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycgfHwga2V5ID09PSAnY29uc3RydWN0b3InIHx8IGtleSA9PT0gJ3Byb3RvdHlwZScpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXREYXRhYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGJhc2VTZXREYXRhID0gIW1ldGFNYXAgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIGRhdGEpIHtcbiAgICAgIG1ldGFNYXAuc2V0KGZ1bmMsIGRhdGEpO1xuICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2h1ZmZsZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKHZhbHVlcyhjb2xsZWN0aW9uKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IGVuZCA+IGxlbmd0aCA/IGxlbmd0aCA6IGVuZDtcbiAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gICAgICBzdGFydCA+Pj49IDA7XG5cbiAgICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb21lYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQgPSBwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuICFyZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRJbmRleGAgYW5kIGBfLnNvcnRlZExhc3RJbmRleGAgd2hpY2hcbiAgICAgKiBwZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggb2YgYGFycmF5YCB0byBkZXRlcm1pbmUgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWBcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCByZXRIaWdoZXN0KSB7XG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IGxvdyA6IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PT0gdmFsdWUgJiYgaGlnaCA8PSBIQUxGX01BWF9BUlJBWV9MRU5HVEgpIHtcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxLFxuICAgICAgICAgICAgICBjb21wdXRlZCA9IGFycmF5W21pZF07XG5cbiAgICAgICAgICBpZiAoY29tcHV0ZWQgIT09IG51bGwgJiYgIWlzU3ltYm9sKGNvbXB1dGVkKSAmJlxuICAgICAgICAgICAgICAocmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSkpKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGlkZW50aXR5LCByZXRIaWdoZXN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRJbmRleEJ5YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4QnlgXG4gICAgICogd2hpY2ggaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlXG4gICAgICogdGhlaXIgc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gaXRlcmF0ZWUodmFsdWUpO1xuICAgICAgdmFyIHZhbElzTmFOID0gdmFsdWUgIT09IHZhbHVlLFxuICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpLFxuICAgICAgICAgIHZhbElzVW5kZWZpbmVkID0gdmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgdmFyIG1pZCA9IG5hdGl2ZUZsb29yKChsb3cgKyBoaWdoKSAvIDIpLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZShhcnJheVttaWRdKSxcbiAgICAgICAgICAgIG90aElzRGVmaW5lZCA9IGNvbXB1dGVkICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBvdGhJc051bGwgPSBjb21wdXRlZCA9PT0gbnVsbCxcbiAgICAgICAgICAgIG90aElzUmVmbGV4aXZlID0gY29tcHV0ZWQgPT09IGNvbXB1dGVkLFxuICAgICAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChjb21wdXRlZCk7XG5cbiAgICAgICAgaWYgKHZhbElzTmFOKSB7XG4gICAgICAgICAgdmFyIHNldExvdyA9IHJldEhpZ2hlc3QgfHwgb3RoSXNSZWZsZXhpdmU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNVbmRlZmluZWQpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiAocmV0SGlnaGVzdCB8fCBvdGhJc0RlZmluZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzTnVsbCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAocmV0SGlnaGVzdCB8fCAhb3RoSXNOdWxsKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1N5bWJvbCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAhb3RoSXNOdWxsICYmIChyZXRIaWdoZXN0IHx8ICFvdGhJc1N5bWJvbCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3RoSXNOdWxsIHx8IG90aElzU3ltYm9sKSB7XG4gICAgICAgICAgc2V0TG93ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0TG93ID0gcmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldExvdykge1xuICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZU1pbihoaWdoLCBNQVhfQVJSQVlfSU5ERVgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZFVuaXFgIGFuZCBgXy5zb3J0ZWRVbmlxQnlgIHdpdGhvdXRcbiAgICAgKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRVbmlxKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIGlmICghaW5kZXggfHwgIWVxKGNvbXB1dGVkLCBzZWVuKSkge1xuICAgICAgICAgIHZhciBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9OdW1iZXJgIHdoaWNoIGRvZXNuJ3QgZW5zdXJlIGNvcnJlY3RcbiAgICAgKiBjb252ZXJzaW9ucyBvZiBiaW5hcnksIGhleGFkZWNpbWFsLCBvciBvY3RhbCBzdHJpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVG9OdW1iZXIodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gTkFOO1xuICAgICAgfVxuICAgICAgcmV0dXJuICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAgICAgKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICAgICAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgc2VlbiA9IHJlc3VsdDtcblxuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgICAgIHZhciBzZXQgPSBpdGVyYXRlZSA/IG51bGwgOiBjcmVhdGVTZXQoYXJyYXkpO1xuICAgICAgICBpZiAoc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgICAgICBzZWVuID0gbmV3IFNldENhY2hlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlZW4gPSBpdGVyYXRlZSA/IFtdIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWluY2x1ZGVzKHNlZW4sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgICAgIGlmIChzZWVuICE9PSByZXN1bHQpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bnNldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHByb3BlcnR5IHBhdGggdG8gdW5zZXQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBkZWxldGUgb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51cGRhdGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIHVwZGF0ZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHJldHVybiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdXBkYXRlcihiYXNlR2V0KG9iamVjdCwgcGF0aCkpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZHJvcFdoaWxlYCBhbmQgYF8udGFrZVdoaWxlYFxuICAgICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRHJvcF0gU3BlY2lmeSBkcm9wcGluZyBlbGVtZW50cyBpbnN0ZWFkIG9mIHRha2luZyB0aGVtLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgaXNEcm9wLCBmcm9tUmlnaHQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcblxuICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkgJiZcbiAgICAgICAgcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge31cblxuICAgICAgcmV0dXJuIGlzRHJvcFxuICAgICAgICA/IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IDAgOiBpbmRleCksIChmcm9tUmlnaHQgPyBpbmRleCArIDEgOiBsZW5ndGgpKVxuICAgICAgICA6IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IDApLCAoZnJvbVJpZ2h0ID8gbGVuZ3RoIDogaW5kZXgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgd3JhcHBlclZhbHVlYCB3aGljaCByZXR1cm5zIHRoZSByZXN1bHQgb2ZcbiAgICAgKiBwZXJmb3JtaW5nIGEgc2VxdWVuY2Ugb2YgYWN0aW9ucyBvbiB0aGUgdW53cmFwcGVkIGB2YWx1ZWAsIHdoZXJlIGVhY2hcbiAgICAgKiBzdWNjZXNzaXZlIGFjdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFjdGlvbnMgQWN0aW9ucyB0byBwZXJmb3JtIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVdyYXBwZXJWYWx1ZSh2YWx1ZSwgYWN0aW9ucykge1xuICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC52YWx1ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKGFjdGlvbnMsIGZ1bmN0aW9uKHJlc3VsdCwgYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb24uZnVuYy5hcHBseShhY3Rpb24udGhpc0FyZywgYXJyYXlQdXNoKFtyZXN1bHRdLCBhY3Rpb24uYXJncykpO1xuICAgICAgfSwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ueG9yYCwgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlWG9yKGFycmF5cywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VVbmlxKGFycmF5c1swXSkgOiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tpbmRleF0sXG4gICAgICAgICAgICBvdGhJbmRleCA9IC0xO1xuXG4gICAgICAgIHdoaWxlICgrK290aEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG90aEluZGV4ICE9IGluZGV4KSB7XG4gICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gYmFzZURpZmZlcmVuY2UocmVzdWx0W2luZGV4XSB8fCBhcnJheSwgYXJyYXlzW290aEluZGV4XSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKHJlc3VsdCwgMSksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uemlwT2JqZWN0YCB3aGljaCBhc3NpZ25zIHZhbHVlcyB1c2luZyBgYXNzaWduRnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25GdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVppcE9iamVjdChwcm9wcywgdmFsdWVzLCBhc3NpZ25GdW5jKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgdmFsc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGluZGV4IDwgdmFsc0xlbmd0aCA/IHZhbHVlc1tpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGFzc2lnbkZ1bmMocmVzdWx0LCBwcm9wc1tpbmRleF0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBhbiBlbXB0eSBhcnJheSBpZiBpdCdzIG5vdCBhbiBhcnJheSBsaWtlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIHRoZSBjYXN0IGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYGlkZW50aXR5YCBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgYGJhc2VSZXN0YCBhbGlhcyB3aGljaCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBgaWRlbnRpdHlgIGJ5IG1vZHVsZVxuICAgICAqIHJlcGxhY2VtZW50IHBsdWdpbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHZhciBjYXN0UmVzdCA9IGJhc2VSZXN0O1xuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdFNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQ7XG4gICAgICByZXR1cm4gKCFzdGFydCAmJiBlbmQgPj0gbGVuZ3RoKSA/IGFycmF5IDogYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2xvYmFsIFtgY2xlYXJUaW1lb3V0YF0oaHR0cHM6Ly9tZG4uaW8vY2xlYXJUaW1lb3V0KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ8T2JqZWN0fSBpZCBUaGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3Qgb2YgdGhlIHRpbWVyIHRvIGNsZWFyLlxuICAgICAqL1xuICAgIHZhciBjbGVhclRpbWVvdXQgPSBjdHhDbGVhclRpbWVvdXQgfHwgZnVuY3Rpb24oaWQpIHtcbiAgICAgIHJldHVybiByb290LmNsZWFyVGltZW91dChpZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gICAgICBidWZmZXIuY29weShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gICAgICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICAgICAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gICAgICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gICAgICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gICAgICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgICAgIHZhciB2YWxJc0RlZmluZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpO1xuXG4gICAgICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlcixcbiAgICAgICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2wob3RoZXIpO1xuXG4gICAgICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICAgICAodmFsSXNTeW1ib2wgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICF2YWxJc1JlZmxleGl2ZSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wgJiYgIW90aElzU3ltYm9sICYmIHZhbHVlIDwgb3RoZXIpIHx8XG4gICAgICAgICAgICAob3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIW90aElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICFvdGhJc1JlZmxleGl2ZSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gICAgICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXG4gICAgICpcbiAgICAgKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICAgICAqIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXJcbiAgICAgKiBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW5bXXxzdHJpbmdbXX0gb3JkZXJzIFRoZSBvcmRlciB0byBzb3J0IGJ5IGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgICAgIGxlbmd0aCA9IG9iakNyaXRlcmlhLmxlbmd0aCxcbiAgICAgICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY29tcGFyZUFzY2VuZGluZyhvYmpDcml0ZXJpYVtpbmRleF0sIG90aENyaXRlcmlhW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xuICAgICAgICAgIHJldHVybiByZXN1bHQgKiAob3JkZXIgPT0gJ2Rlc2MnID8gLTEgOiAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRml4ZXMgYW4gYEFycmF5I3NvcnRgIGJ1ZyBpbiB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIGFwcGxpY2F0aW9uc1xuICAgICAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgICAgIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMsXG4gICAgICogcGxhY2Vob2xkZXJzLCBhbmQgcHJvdmlkZWQgYXJndW1lbnRzIGludG8gYSBzaW5nbGUgYXJyYXkgb2YgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKSB7XG4gICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZWZ0TGVuZ3RoICsgcmFuZ2VMZW5ndGgpLFxuICAgICAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcblxuICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W2hvbGRlcnNbYXJnc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChyYW5nZUxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtsZWZ0SW5kZXgrK10gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBjb21wb3NlQXJnc2AgZXhjZXB0IHRoYXQgdGhlIGFyZ3VtZW50cyBjb21wb3NpdGlvblxuICAgICAqIGlzIHRhaWxvcmVkIGZvciBgXy5wYXJ0aWFsUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBob2xkZXJzSW5kZXggPSAtMSxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgcmlnaHRJbmRleCA9IC0xLFxuICAgICAgICAgIHJpZ2h0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShyYW5nZUxlbmd0aCArIHJpZ2h0TGVuZ3RoKSxcbiAgICAgICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XG5cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IHJhbmdlTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFthcmdzSW5kZXhdID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgfVxuICAgICAgdmFyIG9mZnNldCA9IGFyZ3NJbmRleDtcbiAgICAgIHdoaWxlICgrK3JpZ2h0SW5kZXggPCByaWdodExlbmd0aCkge1xuICAgICAgICByZXN1bHRbb2Zmc2V0ICsgcmlnaHRJbmRleF0gPSBwYXJ0aWFsc1tyaWdodEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2hvbGRlcnNJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgaWYgKGlzVW5jdXJyaWVkIHx8IGFyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbb2Zmc2V0ICsgaG9sZGVyc1tob2xkZXJzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICAgICAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICAgICAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgICAgIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05ldykge1xuICAgICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBvd24gYW5kIGluaGVyaXRlZCBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICAgICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5ncm91cEJ5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpbml0aWFsaXplcl0gVGhlIGFjY3VtdWxhdG9yIG9iamVjdCBpbml0aWFsaXplci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyLCBpbml0aWFsaXplcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5QWdncmVnYXRvciA6IGJhc2VBZ2dyZWdhdG9yLFxuICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBpbml0aWFsaXplciA/IGluaXRpYWxpemVyKCkgOiB7fTtcblxuICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBzZXR0ZXIsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYWNjdW11bGF0b3IpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5sb3dlckZpcnN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBTdHJpbmdgIGNhc2UgbWV0aG9kIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhc2VGaXJzdChtZXRob2ROYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgICAgICA/IHN0cmluZ1RvQXJyYXkoc3RyaW5nKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIHZhciBjaHIgPSBzdHJTeW1ib2xzXG4gICAgICAgICAgPyBzdHJTeW1ib2xzWzBdXG4gICAgICAgICAgOiBzdHJpbmcuY2hhckF0KDApO1xuXG4gICAgICAgIHZhciB0cmFpbGluZyA9IHN0clN5bWJvbHNcbiAgICAgICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAxKS5qb2luKCcnKVxuICAgICAgICAgIDogc3RyaW5nLnNsaWNlKDEpO1xuXG4gICAgICAgIHJldHVybiBjaHJbbWV0aG9kTmFtZV0oKSArIHRyYWlsaW5nO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5jYW1lbENhc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSBlYWNoIHdvcmQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBhcnJheVJlZHVjZSh3b3JkcyhkZWJ1cnIoc3RyaW5nKS5yZXBsYWNlKHJlQXBvcywgJycpKSwgY2FsbGJhY2ssICcnKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYW4gaW5zdGFuY2Ugb2YgYEN0b3JgIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgKiB3aGV0aGVyIGl0IHdhcyBpbnZva2VkIGFzIHBhcnQgb2YgYSBgbmV3YCBleHByZXNzaW9uIG9yIGJ5IGBjYWxsYCBvciBgYXBwbHlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBDdG9yIFRoZSBjb25zdHJ1Y3RvciB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3RvcihDdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFVzZSBhIGBzd2l0Y2hgIHN0YXRlbWVudCB0byB3b3JrIHdpdGggY2xhc3MgY29uc3RydWN0b3JzLiBTZWVcbiAgICAgICAgLy8gaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1mdW5jdGlvbi1vYmplY3RzLWNhbGwtdGhpc2FyZ3VtZW50LWFyZ3VtZW50c2xpc3RcbiAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQ3RvcjtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcbiAgICAgICAgICBjYXNlIDc6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdLCBhcmdzWzZdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKEN0b3IucHJvdG90eXBlKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IEN0b3IuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuXG4gICAgICAgIC8vIE1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBlbmFibGUgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJpdHkgVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KSB7XG4gICAgICB2YXIgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aCxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpO1xuXG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBob2xkZXJzID0gKGxlbmd0aCA8IDMgJiYgYXJnc1swXSAhPT0gcGxhY2Vob2xkZXIgJiYgYXJnc1tsZW5ndGggLSAxXSAhPT0gcGxhY2Vob2xkZXIpXG4gICAgICAgICAgPyBbXVxuICAgICAgICAgIDogcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuXG4gICAgICAgIGxlbmd0aCAtPSBob2xkZXJzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFyZ3MsIGhvbGRlcnMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSAtIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmRJbmRleEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNvbGxlY3Rpb24gaW5kZXguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGaW5kKGZpbmRJbmRleEZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgICB2YXIgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG4gICAgICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgICAgIGNvbGxlY3Rpb24gPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gZmluZEluZGV4RnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCk7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gaXRlcmFibGVbaXRlcmF0ZWUgPyBjb2xsZWN0aW9uW2luZGV4XSA6IGluZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZsb3dgIG9yIGBfLmZsb3dSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsb3cgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmxvdyhmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmbGF0UmVzdChmdW5jdGlvbihmdW5jcykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gZnVuY3MubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICBwcmVyZXEgPSBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS50aHJ1O1xuXG4gICAgICAgIGlmIChmcm9tUmlnaHQpIHtcbiAgICAgICAgICBmdW5jcy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGZ1bmNzW2luZGV4XTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJlcmVxICYmICF3cmFwcGVyICYmIGdldEZ1bmNOYW1lKGZ1bmMpID09ICd3cmFwcGVyJykge1xuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBuZXcgTG9kYXNoV3JhcHBlcihbXSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gd3JhcHBlciA/IGluZGV4IDogbGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGZ1bmMgPSBmdW5jc1tpbmRleF07XG5cbiAgICAgICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICAgICAgZGF0YSA9IGZ1bmNOYW1lID09ICd3cmFwcGVyJyA/IGdldERhdGEoZnVuYykgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoZGF0YSAmJiBpc0xhemlhYmxlKGRhdGFbMF0pICYmXG4gICAgICAgICAgICAgICAgZGF0YVsxXSA9PSAoV1JBUF9BUllfRkxBRyB8IFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfUEFSVElBTF9GTEFHIHwgV1JBUF9SRUFSR19GTEFHKSAmJlxuICAgICAgICAgICAgICAgICFkYXRhWzRdLmxlbmd0aCAmJiBkYXRhWzldID09IDFcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gd3JhcHBlcltnZXRGdW5jTmFtZShkYXRhWzBdKV0uYXBwbHkod3JhcHBlciwgZGF0YVszXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdyYXBwZXIgPSAoZnVuYy5sZW5ndGggPT0gMSAmJiBpc0xhemlhYmxlKGZ1bmMpKVxuICAgICAgICAgICAgICA/IHdyYXBwZXJbZnVuY05hbWVdKClcbiAgICAgICAgICAgICAgOiB3cmFwcGVyLnRocnUoZnVuYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgdmFsdWUgPSBhcmdzWzBdO1xuXG4gICAgICAgICAgaWYgKHdyYXBwZXIgJiYgYXJncy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXIucGxhbnQodmFsdWUpLnZhbHVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGxlbmd0aCA/IGZ1bmNzW2luZGV4XS5hcHBseSh0aGlzLCBhcmdzKSA6IHZhbHVlO1xuXG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmNzW2luZGV4XS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AsIHBhcnRpYWwgYXBwbGljYXRpb24sIGFuZCBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzUmlnaHRdIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkXG4gICAgICogIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNSaWdodF0gVGhlIGBwYXJ0aWFsc1JpZ2h0YCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUh5YnJpZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0FyeSA9IGJpdG1hc2sgJiBXUkFQX0FSWV9GTEFHLFxuICAgICAgICAgIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHLFxuICAgICAgICAgIGlzQ3VycmllZCA9IGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSxcbiAgICAgICAgICBpc0ZsaXAgPSBiaXRtYXNrICYgV1JBUF9GTElQX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDdXJyaWVkKSB7XG4gICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpLFxuICAgICAgICAgICAgICBob2xkZXJzQ291bnQgPSBjb3VudEhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFscykge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHNSaWdodCkge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgaXNDdXJyaWVkKTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggLT0gaG9sZGVyc0NvdW50O1xuICAgICAgICBpZiAoaXNDdXJyaWVkICYmIGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgdmFyIG5ld0hvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHRoaXNBcmcsXG4gICAgICAgICAgICBhcmdzLCBuZXdIb2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkgLSBsZW5ndGhcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLFxuICAgICAgICAgICAgZm4gPSBpc0JpbmRLZXkgPyB0aGlzQmluZGluZ1tmdW5jXSA6IGZ1bmM7XG5cbiAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICAgIGlmIChhcmdQb3MpIHtcbiAgICAgICAgICBhcmdzID0gcmVvcmRlcihhcmdzLCBhcmdQb3MpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRmxpcCAmJiBsZW5ndGggPiAxKSB7XG4gICAgICAgICAgYXJncy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJ5ICYmIGFyeSA8IGxlbmd0aCkge1xuICAgICAgICAgIGFyZ3MubGVuZ3RoID0gYXJ5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpIHtcbiAgICAgICAgICBmbiA9IEN0b3IgfHwgY3JlYXRlQ3Rvcihmbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmludmVydEJ5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRvSXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgaXRlcmF0ZWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludmVydGVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmVydGVyKHNldHRlciwgdG9JdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZlcnRlcihvYmplY3QsIHNldHRlciwgdG9JdGVyYXRlZShpdGVyYXRlZSksIHt9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBtYXRoZW1hdGljYWwgb3BlcmF0aW9uIG9uIHR3byB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wZXJhdG9yIFRoZSBmdW5jdGlvbiB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSB1c2VkIGZvciBgdW5kZWZpbmVkYCBhcmd1bWVudHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVNYXRoT3BlcmF0aW9uKG9wZXJhdG9yLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgb3RoZXIgPSBiYXNlVG9TdHJpbmcob3RoZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VUb051bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBvdGhlciA9IGJhc2VUb051bWJlcihvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IG9wZXJhdG9yKHZhbHVlLCBvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ub3ZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFycmF5RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGl0ZXJhdGVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBvdmVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU92ZXIoYXJyYXlGdW5jKSB7XG4gICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oaXRlcmF0ZWVzKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcbiAgICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICB2YXIgdGhpc0FyZyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGFycmF5RnVuYyhpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkoaXRlcmF0ZWUsIHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHBhZGRpbmcgZm9yIGBzdHJpbmdgIGJhc2VkIG9uIGBsZW5ndGhgLiBUaGUgYGNoYXJzYCBzdHJpbmdcbiAgICAgKiBpcyB0cnVuY2F0ZWQgaWYgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGV4Y2VlZHMgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkaW5nIGZvciBgc3RyaW5nYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYWRkaW5nKGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIGNoYXJzID0gY2hhcnMgPT09IHVuZGVmaW5lZCA/ICcgJyA6IGJhc2VUb1N0cmluZyhjaGFycyk7XG5cbiAgICAgIHZhciBjaGFyc0xlbmd0aCA9IGNoYXJzLmxlbmd0aDtcbiAgICAgIGlmIChjaGFyc0xlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJzTGVuZ3RoID8gYmFzZVJlcGVhdChjaGFycywgbGVuZ3RoKSA6IGNoYXJzO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VSZXBlYXQoY2hhcnMsIG5hdGl2ZUNlaWwobGVuZ3RoIC8gc3RyaW5nU2l6ZShjaGFycykpKTtcbiAgICAgIHJldHVybiBoYXNVbmljb2RlKGNoYXJzKVxuICAgICAgICA/IGNhc3RTbGljZShzdHJpbmdUb0FycmF5KHJlc3VsdCksIDAsIGxlbmd0aCkuam9pbignJylcbiAgICAgICAgOiByZXN1bHQuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nXG4gICAgICogb2YgYHRoaXNBcmdgIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZWZ0TGVuZ3RoICsgYXJnc0xlbmd0aCksXG4gICAgICAgICAgICBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG5cbiAgICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4KytdID0gYXJndW1lbnRzWysrYXJnc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZm4sIGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5yYW5nZWAgb3IgYF8ucmFuZ2VSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJhbmdlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAgICAgaWYgKHN0ZXAgJiYgdHlwZW9mIHN0ZXAgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RhcnQsIGVuZCwgc3RlcCkpIHtcbiAgICAgICAgICBlbmQgPSBzdGVwID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAgPSBzdGVwID09PSB1bmRlZmluZWQgPyAoc3RhcnQgPCBlbmQgPyAxIDogLTEpIDogdG9GaW5pdGUoc3RlcCk7XG4gICAgICAgIHJldHVybiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSByZWxhdGlvbmFsIG9wZXJhdGlvbiBvbiB0d28gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcGVyYXRvciBUaGUgZnVuY3Rpb24gdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlbGF0aW9uYWwgb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24ob3BlcmF0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnICYmIHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICBvdGhlciA9IHRvTnVtYmVyKG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BlcmF0b3IodmFsdWUsIG90aGVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGNvbnRpbnVlIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgYGZ1bmNgIHdyYXBwZXIuXG4gICAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlY3VycnkoZnVuYywgYml0bWFzaywgd3JhcEZ1bmMsIHBsYWNlaG9sZGVyLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNDdXJyeSA9IGJpdG1hc2sgJiBXUkFQX0NVUlJZX0ZMQUcsXG4gICAgICAgICAgbmV3SG9sZGVycyA9IGlzQ3VycnkgPyBob2xkZXJzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5ld0hvbGRlcnNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBob2xkZXJzLFxuICAgICAgICAgIG5ld1BhcnRpYWxzID0gaXNDdXJyeSA/IHBhcnRpYWxzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5ld1BhcnRpYWxzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogcGFydGlhbHM7XG5cbiAgICAgIGJpdG1hc2sgfD0gKGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfRkxBRyA6IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgIGJpdG1hc2sgJj0gfihpc0N1cnJ5ID8gV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgOiBXUkFQX1BBUlRJQUxfRkxBRyk7XG5cbiAgICAgIGlmICghKGJpdG1hc2sgJiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcpKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyk7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RGF0YSA9IFtcbiAgICAgICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgbmV3UGFydGlhbHMsIG5ld0hvbGRlcnMsIG5ld1BhcnRpYWxzUmlnaHQsXG4gICAgICAgIG5ld0hvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5XG4gICAgICBdO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gd3JhcEZ1bmMuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgICAgIGlmIChpc0xhemlhYmxlKGZ1bmMpKSB7XG4gICAgICAgIHNldERhdGEocmVzdWx0LCBuZXdEYXRhKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhyZXN1bHQsIGZ1bmMsIGJpdG1hc2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLnJvdW5kYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBNYXRoYCBtZXRob2QgdG8gdXNlIHdoZW4gcm91bmRpbmcuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUm91bmQobWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBNYXRoW21ldGhvZE5hbWVdO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG51bWJlciwgcHJlY2lzaW9uKSB7XG4gICAgICAgIG51bWJlciA9IHRvTnVtYmVyKG51bWJlcik7XG4gICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PSBudWxsID8gMCA6IG5hdGl2ZU1pbih0b0ludGVnZXIocHJlY2lzaW9uKSwgMjkyKTtcbiAgICAgICAgaWYgKHByZWNpc2lvbiAmJiBuYXRpdmVJc0Zpbml0ZShudW1iZXIpKSB7XG4gICAgICAgICAgLy8gU2hpZnQgd2l0aCBleHBvbmVudGlhbCBub3RhdGlvbiB0byBhdm9pZCBmbG9hdGluZy1wb2ludCBpc3N1ZXMuXG4gICAgICAgICAgLy8gU2VlIFtNRE5dKGh0dHBzOi8vbWRuLmlvL3JvdW5kI0V4YW1wbGVzKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgIHZhciBwYWlyID0gKHRvU3RyaW5nKG51bWJlcikgKyAnZScpLnNwbGl0KCdlJyksXG4gICAgICAgICAgICAgIHZhbHVlID0gZnVuYyhwYWlyWzBdICsgJ2UnICsgKCtwYWlyWzFdICsgcHJlY2lzaW9uKSk7XG5cbiAgICAgICAgICBwYWlyID0gKHRvU3RyaW5nKHZhbHVlKSArICdlJykuc3BsaXQoJ2UnKTtcbiAgICAgICAgICByZXR1cm4gKyhwYWlyWzBdICsgJ2UnICsgKCtwYWlyWzFdIC0gcHJlY2lzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMobnVtYmVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNldCBvYmplY3Qgb2YgYHZhbHVlc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFkZCB0byB0aGUgc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBzZXQuXG4gICAgICovXG4gICAgdmFyIGNyZWF0ZVNldCA9ICEoU2V0ICYmICgxIC8gc2V0VG9BcnJheShuZXcgU2V0KFssLTBdKSlbMV0pID09IElORklOSVRZKSA/IG5vb3AgOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBuZXcgU2V0KHZhbHVlcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy50b1BhaXJzYCBvciBgXy50b1BhaXJzSW5gIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhaXJzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVRvUGFpcnMoa2V5c0Z1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIHRhZyA9IGdldFRhZyhvYmplY3QpO1xuICAgICAgICBpZiAodGFnID09IG1hcFRhZykge1xuICAgICAgICAgIHJldHVybiBtYXBUb0FycmF5KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VG9QYWlycyhvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlVG9QYWlycyhvYmplY3QsIGtleXNGdW5jKG9iamVjdCkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBlaXRoZXIgY3VycmllcyBvciBpbnZva2VzIGBmdW5jYCB3aXRoIG9wdGlvbmFsXG4gICAgICogYHRoaXNgIGJpbmRpbmcgYW5kIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gICAgICogICAgMSAtIGBfLmJpbmRgXG4gICAgICogICAgMiAtIGBfLmJpbmRLZXlgXG4gICAgICogICAgNCAtIGBfLmN1cnJ5YCBvciBgXy5jdXJyeVJpZ2h0YCBvZiBhIGJvdW5kIGZ1bmN0aW9uXG4gICAgICogICAgOCAtIGBfLmN1cnJ5YFxuICAgICAqICAgMTYgLSBgXy5jdXJyeVJpZ2h0YFxuICAgICAqICAgMzIgLSBgXy5wYXJ0aWFsYFxuICAgICAqICAgNjQgLSBgXy5wYXJ0aWFsUmlnaHRgXG4gICAgICogIDEyOCAtIGBfLnJlYXJnYFxuICAgICAqICAyNTYgLSBgXy5hcnlgXG4gICAgICogIDUxMiAtIGBfLmZsaXBgXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlV3JhcChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRztcbiAgICAgIGlmICghaXNCaW5kS2V5ICYmIHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IHBhcnRpYWxzID8gcGFydGlhbHMubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYXJ5ID0gYXJ5ID09PSB1bmRlZmluZWQgPyBhcnkgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKGFyeSksIDApO1xuICAgICAgYXJpdHkgPSBhcml0eSA9PT0gdW5kZWZpbmVkID8gYXJpdHkgOiB0b0ludGVnZXIoYXJpdHkpO1xuICAgICAgbGVuZ3RoIC09IGhvbGRlcnMgPyBob2xkZXJzLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmIChiaXRtYXNrICYgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxzUmlnaHQgPSBwYXJ0aWFscyxcbiAgICAgICAgICAgIGhvbGRlcnNSaWdodCA9IGhvbGRlcnM7XG5cbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBnZXREYXRhKGZ1bmMpO1xuXG4gICAgICB2YXIgbmV3RGF0YSA9IFtcbiAgICAgICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCxcbiAgICAgICAgYXJnUG9zLCBhcnksIGFyaXR5XG4gICAgICBdO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBtZXJnZURhdGEobmV3RGF0YSwgZGF0YSk7XG4gICAgICB9XG4gICAgICBmdW5jID0gbmV3RGF0YVswXTtcbiAgICAgIGJpdG1hc2sgPSBuZXdEYXRhWzFdO1xuICAgICAgdGhpc0FyZyA9IG5ld0RhdGFbMl07XG4gICAgICBwYXJ0aWFscyA9IG5ld0RhdGFbM107XG4gICAgICBob2xkZXJzID0gbmV3RGF0YVs0XTtcbiAgICAgIGFyaXR5ID0gbmV3RGF0YVs5XSA9IG5ld0RhdGFbOV0gPT09IHVuZGVmaW5lZFxuICAgICAgICA/IChpc0JpbmRLZXkgPyAwIDogZnVuYy5sZW5ndGgpXG4gICAgICAgIDogbmF0aXZlTWF4KG5ld0RhdGFbOV0gLSBsZW5ndGgsIDApO1xuXG4gICAgICBpZiAoIWFyaXR5ICYmIGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKTtcbiAgICAgIH1cbiAgICAgIGlmICghYml0bWFzayB8fCBiaXRtYXNrID09IFdSQVBfQklORF9GTEFHKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVCaW5kKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcpO1xuICAgICAgfSBlbHNlIGlmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRyB8fCBiaXRtYXNrID09IFdSQVBfQ1VSUllfUklHSFRfRkxBRykge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVDdXJyeShmdW5jLCBiaXRtYXNrLCBhcml0eSk7XG4gICAgICB9IGVsc2UgaWYgKChiaXRtYXNrID09IFdSQVBfUEFSVElBTF9GTEFHIHx8IGJpdG1hc2sgPT0gKFdSQVBfQklORF9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcpKSAmJiAhaG9sZGVycy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVIeWJyaWQuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgICAgIH1cbiAgICAgIHZhciBzZXR0ZXIgPSBkYXRhID8gYmFzZVNldERhdGEgOiBzZXREYXRhO1xuICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhzZXR0ZXIocmVzdWx0LCBuZXdEYXRhKSwgZnVuYywgYml0bWFzayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5kZWZhdWx0c2AgdG8gY3VzdG9taXplIGl0cyBgXy5hc3NpZ25JbmAgdXNlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzXG4gICAgICogb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXNcbiAgICAgKiB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgKGVxKG9ialZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgIHJldHVybiBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLmRlZmF1bHRzRGVlcGAgdG8gY3VzdG9taXplIGl0cyBgXy5tZXJnZWAgdXNlIHRvIG1lcmdlIHNvdXJjZVxuICAgICAqIG9iamVjdHMgaW50byBkZXN0aW5hdGlvbiBvYmplY3RzIHRoYXQgYXJlIHBhc3NlZCB0aHJ1LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBtZXJnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgcGFyZW50IG9iamVjdCBvZiBgc3JjVmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gICAgICogIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykge1xuICAgICAgaWYgKGlzT2JqZWN0KG9ialZhbHVlKSAmJiBpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgb2JqVmFsdWUpO1xuICAgICAgICBiYXNlTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCB1bmRlZmluZWQsIGN1c3RvbURlZmF1bHRzTWVyZ2UsIHN0YWNrKTtcbiAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLm9taXRgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uY2xvbmVEZWVwYCB1c2UgdG8gb25seSBjbG9uZSBwbGFpblxuICAgICAqIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bmNsb25lZCB2YWx1ZSBvciBgdW5kZWZpbmVkYCB0byBkZWZlciBjbG9uaW5nIHRvIGBfLmNsb25lRGVlcGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tT21pdENsb25lKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gICAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gICAgICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgYXJyU3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gICAgICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gICAgICBpZiAoYXJyU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBhcnJTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gYXJyYXk7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gICAgICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgICAgIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gICAgICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICAgICAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgICAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gICAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgICAgIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgb2JqU3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICAgICAgaWYgKG9ialN0YWNrZWQgJiYgb3RoU3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gb2JqU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IG9iamVjdDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gICAgICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgICAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgICAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIGZsYXR0ZW5zIHRoZSByZXN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRSZXN0KGZ1bmMpIHtcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCB1bmRlZmluZWQsIGZsYXR0ZW4pLCBmdW5jICsgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGdldERhdGEgPSAhbWV0YU1hcCA/IG5vb3AgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICByZXR1cm4gbWV0YU1hcC5nZXQoZnVuYyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hbWUgb2YgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEZ1bmNOYW1lKGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSAoZnVuYy5uYW1lICsgJycpLFxuICAgICAgICAgIGFycmF5ID0gcmVhbE5hbWVzW3Jlc3VsdF0sXG4gICAgICAgICAgbGVuZ3RoID0gaGFzT3duUHJvcGVydHkuY2FsbChyZWFsTmFtZXMsIHJlc3VsdCkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBhcnJheVtsZW5ndGhdLFxuICAgICAgICAgICAgb3RoZXJGdW5jID0gZGF0YS5mdW5jO1xuICAgICAgICBpZiAob3RoZXJGdW5jID09IG51bGwgfHwgb3RoZXJGdW5jID09IGZ1bmMpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YS5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFyZ3VtZW50IHBsYWNlaG9sZGVyIHZhbHVlIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEhvbGRlcihmdW5jKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gsICdwbGFjZWhvbGRlcicpID8gbG9kYXNoIDogZnVuYztcbiAgICAgIHJldHVybiBvYmplY3QucGxhY2Vob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpdGVyYXRlZVwiIGZ1bmN0aW9uLiBJZiBgXy5pdGVyYXRlZWAgaXMgY3VzdG9taXplZCxcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGN1c3RvbSBtZXRob2QsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBiYXNlSXRlcmF0ZWVgLlxuICAgICAqIElmIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIHRoZSBjaG9zZW4gZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIHRoZW0gYW5kXG4gICAgICogaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWVdIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiB0aGUgY3JlYXRlZCBpdGVyYXRlZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNob3NlbiBmdW5jdGlvbiBvciBpdHMgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEl0ZXJhdGVlKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaC5pdGVyYXRlZSB8fCBpdGVyYXRlZTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gaXRlcmF0ZWUgPyBiYXNlSXRlcmF0ZWUgOiByZXN1bHQ7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHJlc3VsdChhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgICAgIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgICAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgICAgICA6IGRhdGEubWFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gICAgICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICAgICAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgaWYgKHVubWFza2VkKSB7XG4gICAgICAgIGlmIChpc093bikge1xuICAgICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB3aGlsZSAob2JqZWN0KSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIHZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4gICAgLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuICAgIGlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAgICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgICAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAgICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICAgICAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgICAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZpZXcsIGFwcGx5aW5nIGFueSBgdHJhbnNmb3Jtc2AgdG8gdGhlIGBzdGFydGAgYW5kIGBlbmRgIHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtcyBUaGUgdHJhbnNmb3JtYXRpb25zIHRvIGFwcGx5IHRvIHRoZSB2aWV3LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBzdGFydGAgYW5kIGBlbmRgXG4gICAgICogIHBvc2l0aW9ucyBvZiB0aGUgdmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRWaWV3KHN0YXJ0LCBlbmQsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRyYW5zZm9ybXNbaW5kZXhdLFxuICAgICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2Ryb3AnOiAgICAgIHN0YXJ0ICs9IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Ryb3BSaWdodCc6IGVuZCAtPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlJzogICAgICBlbmQgPSBuYXRpdmVNaW4oZW5kLCBzdGFydCArIHNpemUpOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlUmlnaHQnOiBzdGFydCA9IG5hdGl2ZU1heChzdGFydCwgZW5kIC0gc2l6ZSk7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyAnc3RhcnQnOiBzdGFydCwgJ2VuZCc6IGVuZCB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHdyYXBwZXIgZGV0YWlscyBmcm9tIHRoZSBgc291cmNlYCBib2R5IGNvbW1lbnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgVGhlIHNvdXJjZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd3JhcHBlciBkZXRhaWxzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFdyYXBEZXRhaWxzKHNvdXJjZSkge1xuICAgICAgdmFyIG1hdGNoID0gc291cmNlLm1hdGNoKHJlV3JhcERldGFpbHMpO1xuICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQocmVTcGxpdERldGFpbHMpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICAgICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICAgICAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAgICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gICAgICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgICAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICAgICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgICAgIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgICAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgICAgIDoge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE1hcGAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgYFNldGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgICAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB3cmFwcGVyIGBkZXRhaWxzYCBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgYHNvdXJjZWAgYm9keS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIG1vZGlmeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gaW5zZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHNvdXJjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnRXcmFwRGV0YWlscyhzb3VyY2UsIGRldGFpbHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBkZXRhaWxzLmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgIGRldGFpbHNbbGFzdEluZGV4XSA9IChsZW5ndGggPiAxID8gJyYgJyA6ICcnKSArIGRldGFpbHNbbGFzdEluZGV4XTtcbiAgICAgIGRldGFpbHMgPSBkZXRhaWxzLmpvaW4obGVuZ3RoID4gMiA/ICcsICcgOiAnICcpO1xuICAgICAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKHJlV3JhcENvbW1lbnQsICd7XFxuLyogW3dyYXBwZWQgd2l0aCAnICsgZGV0YWlscyArICddICovXFxuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICAgICAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICAgICApIHtcbiAgICAgICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgICAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICAgICAgOiAodmFsdWUgPT09IG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMYXppYWJsZShmdW5jKSB7XG4gICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICBvdGhlciA9IGxvZGFzaFtmdW5jTmFtZV07XG5cbiAgICAgIGlmICh0eXBlb2Ygb3RoZXIgIT0gJ2Z1bmN0aW9uJyB8fCAhKGZ1bmNOYW1lIGluIExhenlXcmFwcGVyLnByb3RvdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGZ1bmMgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBnZXREYXRhKG90aGVyKTtcbiAgICAgIHJldHVybiAhIWRhdGEgJiYgZnVuYyA9PT0gZGF0YVswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gICAgICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaXMgY2FwYWJsZSBvZiBiZWluZyBtYXNrZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2FibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICB2YXIgaXNNYXNrYWJsZSA9IGNvcmVKc0RhdGEgPyBpc0Z1bmN0aW9uIDogc3R1YkZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICAgICAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICAgICAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gICAgICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gICAgICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gICAgICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICAgICAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHRoZSBmdW5jdGlvbiBtZXRhZGF0YSBvZiBgc291cmNlYCBpbnRvIGBkYXRhYC5cbiAgICAgKlxuICAgICAqIE1lcmdpbmcgbWV0YWRhdGEgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHdyYXBwZXJzIHVzZWQgdG8gaW52b2tlIGEgZnVuY3Rpb24uXG4gICAgICogVGhpcyBpcyBwb3NzaWJsZSBiZWNhdXNlIG1ldGhvZHMgbGlrZSBgXy5iaW5kYCwgYF8uY3VycnlgLCBhbmQgYF8ucGFydGlhbGBcbiAgICAgKiBtYXkgYmUgYXBwbGllZCByZWdhcmRsZXNzIG9mIGV4ZWN1dGlvbiBvcmRlci4gTWV0aG9kcyBsaWtlIGBfLmFyeWAgYW5kXG4gICAgICogYF8ucmVhcmdgIG1vZGlmeSBmdW5jdGlvbiBhcmd1bWVudHMsIG1ha2luZyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcmVcbiAgICAgKiBleGVjdXRlZCBpbXBvcnRhbnQsIHByZXZlbnRpbmcgdGhlIG1lcmdpbmcgb2YgbWV0YWRhdGEuIEhvd2V2ZXIsIHdlIG1ha2VcbiAgICAgKiBhbiBleGNlcHRpb24gZm9yIGEgc2FmZSBjb21iaW5lZCBjYXNlIHdoZXJlIGN1cnJpZWQgZnVuY3Rpb25zIGhhdmUgYF8uYXJ5YFxuICAgICAqIGFuZCBvciBgXy5yZWFyZ2AgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSBUaGUgZGVzdGluYXRpb24gbWV0YWRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBzb3VyY2UgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkYXRhYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZURhdGEoZGF0YSwgc291cmNlKSB7XG4gICAgICB2YXIgYml0bWFzayA9IGRhdGFbMV0sXG4gICAgICAgICAgc3JjQml0bWFzayA9IHNvdXJjZVsxXSxcbiAgICAgICAgICBuZXdCaXRtYXNrID0gYml0bWFzayB8IHNyY0JpdG1hc2ssXG4gICAgICAgICAgaXNDb21tb24gPSBuZXdCaXRtYXNrIDwgKFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHIHwgV1JBUF9BUllfRkxBRyk7XG5cbiAgICAgIHZhciBpc0NvbWJvID1cbiAgICAgICAgKChzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpIHx8XG4gICAgICAgICgoc3JjQml0bWFzayA9PSBXUkFQX0FSWV9GTEFHKSAmJiAoYml0bWFzayA9PSBXUkFQX1JFQVJHX0ZMQUcpICYmIChkYXRhWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pKSB8fFxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpKSAmJiAoc291cmNlWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpO1xuXG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIG1ldGFkYXRhIGNhbid0IGJlIG1lcmdlZC5cbiAgICAgIGlmICghKGlzQ29tbW9uIHx8IGlzQ29tYm8pKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgdGhpc0FyZ2AgaWYgYXZhaWxhYmxlLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRykge1xuICAgICAgICBkYXRhWzJdID0gc291cmNlWzJdO1xuICAgICAgICAvLyBTZXQgd2hlbiBjdXJyeWluZyBhIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAgICBuZXdCaXRtYXNrIHw9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyA/IDAgOiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUc7XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgYXJndW1lbnRzLlxuICAgICAgdmFyIHZhbHVlID0gc291cmNlWzNdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0aWFscyA9IGRhdGFbM107XG4gICAgICAgIGRhdGFbM10gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzKHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzRdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzRdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzNdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNF07XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgcmlnaHQgYXJndW1lbnRzLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbNV07XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcGFydGlhbHMgPSBkYXRhWzVdO1xuICAgICAgICBkYXRhWzVdID0gcGFydGlhbHMgPyBjb21wb3NlQXJnc1JpZ2h0KHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzZdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzZdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzVdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNl07XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcmdQb3NgIGlmIGF2YWlsYWJsZS5cbiAgICAgIHZhbHVlID0gc291cmNlWzddO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRhdGFbN10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyeWAgaWYgaXQncyBzbWFsbGVyLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0FSWV9GTEFHKSB7XG4gICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdID09IG51bGwgPyBzb3VyY2VbOF0gOiBuYXRpdmVNaW4oZGF0YVs4XSwgc291cmNlWzhdKTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyaXR5YCBpZiBvbmUgaXMgbm90IHByb3ZpZGVkLlxuICAgICAgaWYgKGRhdGFbOV0gPT0gbnVsbCkge1xuICAgICAgICBkYXRhWzldID0gc291cmNlWzldO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgZnVuY2AgYW5kIG1lcmdlIGJpdG1hc2tzLlxuICAgICAgZGF0YVswXSA9IHNvdXJjZVswXTtcbiAgICAgIGRhdGFbMV0gPSBuZXdCaXRtYXNrO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAgICAgKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICAgICAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFyZW50IHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gZ2V0IHRoZSBwYXJlbnQgdmFsdWUgb2YuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBhcmVudCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJlbnQob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5sZW5ndGggPCAyID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlb3JkZXIgYGFycmF5YCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBpbmRleGVzIHdoZXJlIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIGZpcnN0IGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBmaXJzdCBlbGVtZW50LCB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBzZWNvbmQgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIHNlY29uZCBlbGVtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byByZW9yZGVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFycmF5IGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVvcmRlcihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oaW5kZXhlcy5sZW5ndGgsIGFyckxlbmd0aCksXG4gICAgICAgICAgb2xkQXJyYXkgPSBjb3B5QXJyYXkoYXJyYXkpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBhcnJheVtsZW5ndGhdID0gaXNJbmRleChpbmRleCwgYXJyTGVuZ3RoKSA/IG9sZEFycmF5W2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIgb3IgXCJjb25zdHJ1Y3RvclwiLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgICAgIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgdGhpcyBmdW5jdGlvbiBiZWNvbWVzIGhvdCwgaS5lLiBpcyBpbnZva2VkIGEgbG90IGluIGEgc2hvcnRcbiAgICAgKiBwZXJpb2Qgb2YgdGltZSwgaXQgd2lsbCB0cmlwIGl0cyBicmVha2VyIGFuZCB0cmFuc2l0aW9uIHRvIGFuIGlkZW50aXR5XG4gICAgICogZnVuY3Rpb24gdG8gYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uIHBhdXNlcyBpbiBWOC4gU2VlXG4gICAgICogW1Y4IGlzc3VlIDIwNzBdKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIwNzApXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBzZXREYXRhID0gc2hvcnRPdXQoYmFzZVNldERhdGEpO1xuXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBhcm91bmQgdGhlIGdsb2JhbCBbYHNldFRpbWVvdXRgXShodHRwczovL21kbi5pby9zZXRUaW1lb3V0KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfE9iamVjdH0gUmV0dXJucyB0aGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIHNldFRpbWVvdXQgPSBjdHhTZXRUaW1lb3V0IHx8IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICAgIHJldHVybiByb290LnNldFRpbWVvdXQoZnVuYywgd2FpdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGB3cmFwcGVyYCB0byBtaW1pYyB0aGUgc291cmNlIG9mIGByZWZlcmVuY2VgXG4gICAgICogd2l0aCB3cmFwcGVyIGRldGFpbHMgaW4gYSBjb21tZW50IGF0IHRoZSB0b3Agb2YgdGhlIHNvdXJjZSBib2R5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVmZXJlbmNlIFRoZSByZWZlcmVuY2UgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYHdyYXBwZXJgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFdyYXBUb1N0cmluZyh3cmFwcGVyLCByZWZlcmVuY2UsIGJpdG1hc2spIHtcbiAgICAgIHZhciBzb3VyY2UgPSAocmVmZXJlbmNlICsgJycpO1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKHdyYXBwZXIsIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgdXBkYXRlV3JhcERldGFpbHMoZ2V0V3JhcERldGFpbHMoc291cmNlKSwgYml0bWFzaykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAgICAgKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAgICAgKiBtaWxsaXNlY29uZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gICAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgd2hpY2ggbXV0YXRlcyBhbmQgc2V0cyB0aGUgc2l6ZSBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NpemU9YXJyYXkubGVuZ3RoXSBUaGUgc2l6ZSBvZiBgYXJyYXlgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGVTZWxmKGFycmF5LCBzaXplKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgc2l6ZSA9IHNpemUgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHNpemU7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IHNpemUpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLFxuICAgICAgICAgICAgdmFsdWUgPSBhcnJheVtyYW5kXTtcblxuICAgICAgICBhcnJheVtyYW5kXSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBhcnJheS5sZW5ndGggPSBzaXplO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL1xuICAgIHZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgICAgIH1cbiAgICAgIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gICAgICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gICAgICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHdyYXBwZXIgYGRldGFpbHNgIGJhc2VkIG9uIGBiaXRtYXNrYCBmbGFncy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0FycmF5fSBkZXRhaWxzIFRoZSBkZXRhaWxzIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGV0YWlsc2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlV3JhcERldGFpbHMoZGV0YWlscywgYml0bWFzaykge1xuICAgICAgYXJyYXlFYWNoKHdyYXBGbGFncywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICB2YXIgdmFsdWUgPSAnXy4nICsgcGFpclswXTtcbiAgICAgICAgaWYgKChiaXRtYXNrICYgcGFpclsxXSkgJiYgIWFycmF5SW5jbHVkZXMoZGV0YWlscywgdmFsdWUpKSB7XG4gICAgICAgICAgZGV0YWlscy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGV0YWlscy5zb3J0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB3cmFwcGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHdyYXBwZXIgVGhlIHdyYXBwZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHdyYXBwZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNsb25lKHdyYXBwZXIpIHtcbiAgICAgIGlmICh3cmFwcGVyIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXIuY2xvbmUoKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVyLl9fd3JhcHBlZF9fLCB3cmFwcGVyLl9fY2hhaW5fXyk7XG4gICAgICByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkod3JhcHBlci5fX2FjdGlvbnNfXyk7XG4gICAgICByZXN1bHQuX19pbmRleF9fICA9IHdyYXBwZXIuX19pbmRleF9fO1xuICAgICAgcmVzdWx0Ll9fdmFsdWVzX18gPSB3cmFwcGVyLl9fdmFsdWVzX187XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byBncm91cHMgdGhlIGxlbmd0aCBvZiBgc2l6ZWAuXG4gICAgICogSWYgYGFycmF5YCBjYW4ndCBiZSBzcGxpdCBldmVubHksIHRoZSBmaW5hbCBjaHVuayB3aWxsIGJlIHRoZSByZW1haW5pbmdcbiAgICAgKiBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT0xXSBUaGUgbGVuZ3RoIG9mIGVhY2ggY2h1bmtcbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNodW5rcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMik7XG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsnYycsICdkJ11dXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAzKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InLCAnYyddLCBbJ2QnXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaHVuayhhcnJheSwgc2l6ZSwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc2l6ZSwgZ3VhcmQpIDogc2l6ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBzaXplID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpemUgPSBuYXRpdmVNYXgodG9JbnRlZ2VyKHNpemUpLCAwKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoIHx8IHNpemUgPCAxKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG5hdGl2ZUNlaWwobGVuZ3RoIC8gc2l6ZSkpO1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gYmFzZVNsaWNlKGFycmF5LCBpbmRleCwgKGluZGV4ICs9IHNpemUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBmYWxzZXkgdmFsdWVzIHJlbW92ZWQuIFRoZSB2YWx1ZXMgYGZhbHNlYCwgYG51bGxgLFxuICAgICAqIGAwYCwgYFwiXCJgLCBgdW5kZWZpbmVkYCwgYW5kIGBOYU5gIGFyZSBmYWxzZXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY29tcGFjdChbMCwgMSwgZmFsc2UsIDIsICcnLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgY29uY2F0ZW5hdGluZyBgYXJyYXlgIHdpdGggYW55IGFkZGl0aW9uYWwgYXJyYXlzXG4gICAgICogYW5kL29yIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb25jYXRlbmF0ZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29uY2F0ZW5hdGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMV07XG4gICAgICogdmFyIG90aGVyID0gXy5jb25jYXQoYXJyYXksIDIsIFszXSwgW1s0XV0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob3RoZXIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF1dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uY2F0KCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCAtIDEpLFxuICAgICAgICAgIGFycmF5ID0gYXJndW1lbnRzWzBdLFxuICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICBhcmdzW2luZGV4IC0gMV0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5UHVzaChpc0FycmF5KGFycmF5KSA/IGNvcHlBcnJheShhcnJheSkgOiBbYXJyYXldLCBiYXNlRmxhdHRlbihhcmdzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBgYXJyYXlgIHZhbHVlcyBub3QgaW5jbHVkZWQgaW4gdGhlIG90aGVyIGdpdmVuIGFycmF5c1xuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy53aXRob3V0LCBfLnhvclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2UoWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGlmZmVyZW5jZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgYW5kIGB2YWx1ZXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbEJ5YCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2VCeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kaWZmZXJlbmNlQnkoW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCBbeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2VCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QodmFsdWVzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRpZmZlcmVuY2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAgdG8gYHZhbHVlc2AuIFRoZSBvcmRlciBhbmRcbiAgICAgKiByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgY29tcGFyYXRvclxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsV2l0aGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2VXaXRoKG9iamVjdHMsIFt7ICd4JzogMSwgJ3knOiAyIH1dLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2VXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KHZhbHVlcyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoY29tcGFyYXRvcikpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgbiA9IGxlbmd0aCAtIG47XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCB0cnVlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbGxzIGVsZW1lbnRzIG9mIGBhcnJheWAgd2l0aCBgdmFsdWVgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdFxuICAgICAqIGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLmZpbGwoYXJyYXksICdhJyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdhJywgJ2EnXVxuICAgICAqXG4gICAgICogXy5maWxsKEFycmF5KDMpLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgMiwgMl1cbiAgICAgKlxuICAgICAqIF8uZmlsbChbNCwgNiwgOCwgMTBdLCAnKicsIDEsIDMpO1xuICAgICAqIC8vID0+IFs0LCAnKicsICcqJywgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAmJiB0eXBlb2Ygc3RhcnQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHZhbHVlLCBzdGFydCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ3BlYmJsZXMnOyB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBsZW5ndGggLSAxO1xuICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4IDwgMFxuICAgICAgICAgID8gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKVxuICAgICAgICAgIDogbmF0aXZlTWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlZXAoWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNCwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuRGVlcChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCBJTkZJTklUWSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmbGF0dGVuIGBhcnJheWAgdXAgdG8gYGRlcHRoYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9MV0gVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIFsyLCBbMywgWzRdXSwgNV1dO1xuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVwdGgoYXJyYXksIDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlcHRoKGFycmF5LCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZXB0aChhcnJheSwgZGVwdGgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGRlcHRoID0gZGVwdGggPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGgpO1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8udG9QYWlyc2A7IHRoaXMgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkXG4gICAgICogZnJvbSBrZXktdmFsdWUgYHBhaXJzYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIFRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mcm9tUGFpcnMoW1snYScsIDFdLCBbJ2InLCAyXV0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21QYWlycyhwYWlycykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGFpcnMgPT0gbnVsbCA/IDAgOiBwYWlycy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbcGFpclswXV0gPSBwYWlyWzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgZmlyc3RcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5oZWFkKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5oZWFkKFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoZWFkKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIGluIGBhcnJheWBcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhcyB0aGVcbiAgICAgKiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBTZWFyY2ggZnJvbSB0aGUgYGZyb21JbmRleGAuXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWwoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlU2xpY2UoYXJyYXksIDAsIC0xKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGFyZSBpbmNsdWRlZCBpbiBhbGwgZ2l2ZW4gYXJyYXlzXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMl1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZClcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uaW50ZXJzZWN0aW9uQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH1dXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbkJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyksXG4gICAgICAgICAgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcblxuICAgICAgaWYgKGl0ZXJhdGVlID09PSBsYXN0KG1hcHBlZCkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzXG4gICAgICogb2YgcmVzdWx0IHZhbHVlcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBjb21wYXJhdG9yIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb25XaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9XVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKSxcbiAgICAgICAgICBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuXG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFsbCBlbGVtZW50cyBpbiBgYXJyYXlgIGludG8gYSBzdHJpbmcgc2VwYXJhdGVkIGJ5IGBzZXBhcmF0b3JgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzZXBhcmF0b3I9JywnXSBUaGUgZWxlbWVudCBzZXBhcmF0b3IuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgam9pbmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5qb2luKFsnYScsICdiJywgJ2MnXSwgJ34nKTtcbiAgICAgKiAvLyA9PiAnYX5ifmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gam9pbihhcnJheSwgc2VwYXJhdG9yKSB7XG4gICAgICByZXR1cm4gYXJyYXkgPT0gbnVsbCA/ICcnIDogbmF0aXZlSm9pbi5jYWxsKGFycmF5LCBzZXBhcmF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgYXJyYXlgIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogLy8gU2VhcmNoIGZyb20gdGhlIGBmcm9tSW5kZXhgLlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgIGlmIChmcm9tSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmRleCA9IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgICBpbmRleCA9IGluZGV4IDwgMCA/IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCkgOiBuYXRpdmVNaW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgICAgICA/IHN0cmljdExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgaW5kZXgpXG4gICAgICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZWxlbWVudCBhdCBpbmRleCBgbmAgb2YgYGFycmF5YC4gSWYgYG5gIGlzIG5lZ2F0aXZlLCB0aGUgbnRoXG4gICAgICogZWxlbWVudCBmcm9tIHRoZSBlbmQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnXTtcbiAgICAgKlxuICAgICAqIF8ubnRoKGFycmF5LCAxKTtcbiAgICAgKiAvLyA9PiAnYidcbiAgICAgKlxuICAgICAqIF8ubnRoKGFycmF5LCAtMik7XG4gICAgICogLy8gPT4gJ2MnO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG50aChhcnJheSwgbikge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZU50aChhcnJheSwgdG9JbnRlZ2VyKG4pKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBnaXZlbiB2YWx1ZXMgZnJvbSBgYXJyYXlgIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLndpdGhvdXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuIFVzZSBgXy5yZW1vdmVgXG4gICAgICogdG8gcmVtb3ZlIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2EnLCAnYicsICdjJ107XG4gICAgICpcbiAgICAgKiBfLnB1bGwoYXJyYXksICdhJywgJ2MnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydiJywgJ2InXVxuICAgICAqL1xuICAgIHZhciBwdWxsID0gYmFzZVJlc3QocHVsbEFsbCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZWAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2EnLCAnYicsICdjJ107XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGwoYXJyYXksIFsnYScsICdjJ10pO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbChhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbEFsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgYW5kIGB2YWx1ZXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZUJ5YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDMgfSwgeyAneCc6IDEgfV07XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGxCeShhcnJheSwgW3sgJ3gnOiAxIH0sIHsgJ3gnOiAzIH1dLCAneCcpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsQnkoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxBbGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAgdG8gYHZhbHVlc2AuIFRoZSBjb21wYXJhdG9yIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VXaXRoYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAzLCAneSc6IDQgfSwgeyAneCc6IDUsICd5JzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbFdpdGgoYXJyYXksIFt7ICd4JzogMywgJ3knOiA0IH1dLCBfLmlzRXF1YWwpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogNSwgJ3knOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbFdpdGgoYXJyYXksIHZhbHVlcywgY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSBgYXJyYXlgIGNvcnJlc3BvbmRpbmcgdG8gYGluZGV4ZXNgIGFuZCByZXR1cm5zIGFuXG4gICAgICogYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uYXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IFtpbmRleGVzXSBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJ107XG4gICAgICogdmFyIHB1bGxlZCA9IF8ucHVsbEF0KGFycmF5LCBbMSwgM10pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdjJ11cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKHB1bGxlZCk7XG4gICAgICogLy8gPT4gWydiJywgJ2QnXVxuICAgICAqL1xuICAgIHZhciBwdWxsQXQgPSBmbGF0UmVzdChmdW5jdGlvbihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGJhc2VBdChhcnJheSwgaW5kZXhlcyk7XG5cbiAgICAgIGJhc2VQdWxsQXQoYXJyYXksIGFycmF5TWFwKGluZGV4ZXMsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpc0luZGV4KGluZGV4LCBsZW5ndGgpID8gK2luZGV4IDogaW5kZXg7XG4gICAgICB9KS5zb3J0KGNvbXBhcmVBc2NlbmRpbmcpKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYGFycmF5YCB0aGF0IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvclxuICAgICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSByZW1vdmVkIGVsZW1lbnRzLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5maWx0ZXJgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuIFVzZSBgXy5wdWxsYFxuICAgICAqIHRvIHB1bGwgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBieSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCA0XTtcbiAgICAgKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzIsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIGBhcnJheWAgc28gdGhhdCB0aGUgZmlyc3QgZWxlbWVudCBiZWNvbWVzIHRoZSBsYXN0LCB0aGUgc2Vjb25kXG4gICAgICogZWxlbWVudCBiZWNvbWVzIHRoZSBzZWNvbmQgdG8gbGFzdCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YCBhbmQgaXMgYmFzZWQgb25cbiAgICAgKiBbYEFycmF5I3JldmVyc2VgXShodHRwczovL21kbi5pby9BcnJheS9yZXZlcnNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8ucmV2ZXJzZShhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV2ZXJzZShhcnJheSkge1xuICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyBhcnJheSA6IG5hdGl2ZVJldmVyc2UuY2FsbChhcnJheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgdXNlZCBpbnN0ZWFkIG9mXG4gICAgICogW2BBcnJheSNzbGljZWBdKGh0dHBzOi8vbWRuLmlvL0FycmF5L3NsaWNlKSB0byBlbnN1cmUgZGVuc2UgYXJyYXlzIGFyZVxuICAgICAqIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgJiYgdHlwZW9mIGVuZCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc3RhcnQsIGVuZCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbnRlZ2VyKGVuZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIGEgYmluYXJ5IHNlYXJjaCB0byBkZXRlcm1pbmUgdGhlIGxvd2VzdCBpbmRleCBhdCB3aGljaCBgdmFsdWVgXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0byBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWzMwLCA1MF0sIDQwKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRJbmRleGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpclxuICAgICAqIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDQgfSwgeyAneCc6IDUgfV07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgZnVuY3Rpb24obykgeyByZXR1cm4gby54OyB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgcGVyZm9ybXMgYSBiaW5hcnlcbiAgICAgKiBzZWFyY2ggb24gYSBzb3J0ZWQgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleE9mKFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgZXEoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBoaWdoZXN0XG4gICAgICogaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvXG4gICAgICogbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleChbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRMYXN0SW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXJcbiAgICAgKiBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiA0IH0sIHsgJ3gnOiA1IH1dO1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCBmdW5jdGlvbihvKSB7IHJldHVybiBvLng7IH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmxhc3RJbmRleE9mYCBleGNlcHQgdGhhdCBpdCBwZXJmb3JtcyBhIGJpbmFyeVxuICAgICAqIHNlYXJjaCBvbiBhIHNvcnRlZCBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleE9mKFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICB2YXIgaW5kZXggPSBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKSAtIDE7XG4gICAgICAgIGlmIChlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQncyBkZXNpZ25lZCBhbmQgb3B0aW1pemVkXG4gICAgICogZm9yIHNvcnRlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRVbmlxKFsxLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkVW5pcShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVNvcnRlZFVuaXEoYXJyYXkpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxQnlgIGV4Y2VwdCB0aGF0IGl0J3MgZGVzaWduZWQgYW5kIG9wdGltaXplZFxuICAgICAqIGZvciBzb3J0ZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRVbmlxQnkoWzEuMSwgMS4yLCAyLjMsIDIuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjEsIDIuM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU29ydGVkVW5pcShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWlsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFpbChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTbGljZShhcnJheSwgMSwgbGVuZ3RoKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2UoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICBuID0gbGVuZ3RoIC0gbjtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4sIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuIEVsZW1lbnRzIGFyZVxuICAgICAqIHRha2VuIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy4gRWxlbWVudHNcbiAgICAgKiBhcmUgdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIGZyb20gYWxsIGdpdmVuIGFycmF5cyB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbihbMl0sIFsxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgdmFyIHVuaW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieVxuICAgICAqIHdoaWNoIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFJlc3VsdCB2YWx1ZXMgYXJlIGNob3NlbiBmcm9tIHRoZSBmaXJzdFxuICAgICAqIGFycmF5IGluIHdoaWNoIHRoZSB2YWx1ZSBvY2N1cnMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbkJ5KFsyLjFdLCBbMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xLCAxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnVuaW9uQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIHVuaW9uQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gUmVzdWx0IHZhbHVlcyBhcmUgY2hvc2VuIGZyb21cbiAgICAgKiB0aGUgZmlyc3QgYXJyYXkgaW4gd2hpY2ggdGhlIHZhbHVlIG9jY3Vycy4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8udW5pb25XaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5LCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpbiB3aGljaCBvbmx5IHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGVhY2ggZWxlbWVudFxuICAgICAqIGlzIGtlcHQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXJcbiAgICAgKiBpbiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxKFsyLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXkpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdW5pcXVlbmVzcyBpcyBjb21wdXRlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGVcbiAgICAgKiBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxQnkoWzIuMSwgMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xLCAxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnVuaXFCeShbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXkuVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8udW5pcVdpdGgob2JqZWN0cywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcVdpdGgoYXJyYXksIGNvbXBhcmF0b3IpIHtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5LCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgZ3JvdXBlZFxuICAgICAqIGVsZW1lbnRzIGFuZCBjcmVhdGVzIGFuIGFycmF5IHJlZ3JvdXBpbmcgdGhlIGVsZW1lbnRzIHRvIHRoZWlyIHByZS16aXBcbiAgICAgKiBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZWdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB6aXBwZWQgPSBfLnppcChbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxLCB0cnVlXSwgWydiJywgMiwgZmFsc2VdXVxuICAgICAqXG4gICAgICogXy51bnppcCh6aXBwZWQpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW56aXAoYXJyYXkpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICBhcnJheSA9IGFycmF5RmlsdGVyKGFycmF5LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoZ3JvdXApKSB7XG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGdyb3VwLmxlbmd0aCwgbGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYmFzZVRpbWVzKGxlbmd0aCwgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKGFycmF5LCBiYXNlUHJvcGVydHkoaW5kZXgpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB0byBzcGVjaWZ5XG4gICAgICogaG93IHJlZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxuICAgICAqIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXA6ICguLi5ncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZVxuICAgICAqICByZWdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0pO1xuICAgICAqIC8vID0+IFtbMSwgMTAsIDEwMF0sIFsyLCAyMCwgMjAwXV1cbiAgICAgKlxuICAgICAqIF8udW56aXBXaXRoKHppcHBlZCwgXy5hZGQpO1xuICAgICAqIC8vID0+IFszLCAzMCwgMzAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuemlwV2l0aChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHVuemlwKGFycmF5KTtcbiAgICAgIGlmIChpdGVyYXRlZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlNYXAocmVzdWx0LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICByZXR1cm4gYXBwbHkoaXRlcmF0ZWUsIHVuZGVmaW5lZCwgZ3JvdXApO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIGdpdmVuIHZhbHVlcyB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8uZGlmZmVyZW5jZSwgXy54b3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53aXRob3V0KFsyLCAxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICovXG4gICAgdmFyIHdpdGhvdXQgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcylcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGlzIHRoZVxuICAgICAqIFtzeW1tZXRyaWMgZGlmZmVyZW5jZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3ltbWV0cmljX2RpZmZlcmVuY2UpXG4gICAgICogb2YgdGhlIGdpdmVuIGFycmF5cy4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXJcbiAgICAgKiB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy5kaWZmZXJlbmNlLCBfLndpdGhvdXRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3IoWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqL1xuICAgIHZhciB4b3IgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ueG9yYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5XG4gICAgICogd2hpY2ggYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZFxuICAgICAqIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lXG4gICAgICogYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3JCeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4yLCAzLjRdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnhvckJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciB4b3JCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy54b3JgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpc1xuICAgICAqIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ueG9yV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciB4b3JXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLCB0aGUgZmlyc3Qgb2Ygd2hpY2ggY29udGFpbnMgdGhlXG4gICAgICogZmlyc3QgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgdGhlIHNlY29uZCBvZiB3aGljaCBjb250YWlucyB0aGVcbiAgICAgKiBzZWNvbmQgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwKFsnYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snYScsIDEsIHRydWVdLCBbJ2InLCAyLCBmYWxzZV1dXG4gICAgICovXG4gICAgdmFyIHppcCA9IGJhc2VSZXN0KHVuemlwKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZnJvbVBhaXJzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIHR3byBhcnJheXMsXG4gICAgICogb25lIG9mIHByb3BlcnR5IGlkZW50aWZpZXJzIGFuZCBvbmUgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0KFsnYScsICdiJ10sIFsxLCAyXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0KHByb3BzLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMgfHwgW10sIGFzc2lnblZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcE9iamVjdGAgZXhjZXB0IHRoYXQgaXQgc3VwcG9ydHMgcHJvcGVydHkgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0RGVlcChbJ2EuYlswXS5jJywgJ2EuYlsxXS5kJ10sIFsxLCAyXSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2InOiBbeyAnYyc6IDEgfSwgeyAnZCc6IDIgfV0gfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0RGVlcChwcm9wcywgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gYmFzZVppcE9iamVjdChwcm9wcyB8fCBbXSwgdmFsdWVzIHx8IFtdLCBiYXNlU2V0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHRvIHNwZWNpZnlcbiAgICAgKiBob3cgZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxuICAgICAqIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXA6ICguLi5ncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lXG4gICAgICogIGdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwV2l0aChbMSwgMl0sIFsxMCwgMjBdLCBbMTAwLCAyMDBdLCBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gYSArIGIgKyBjO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxMTEsIDIyMl1cbiAgICAgKi9cbiAgICB2YXIgemlwV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5cy5sZW5ndGgsXG4gICAgICAgICAgaXRlcmF0ZWUgPSBsZW5ndGggPiAxID8gYXJyYXlzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpdGVyYXRlZSA9IHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nID8gKGFycmF5cy5wb3AoKSwgaXRlcmF0ZWUpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHVuemlwV2l0aChhcnJheXMsIGl0ZXJhdGVlKTtcbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlIHRoYXQgd3JhcHMgYHZhbHVlYCB3aXRoIGV4cGxpY2l0IG1ldGhvZFxuICAgICAqIGNoYWluIHNlcXVlbmNlcyBlbmFibGVkLiBUaGUgcmVzdWx0IG9mIHN1Y2ggc2VxdWVuY2VzIG11c3QgYmUgdW53cmFwcGVkXG4gICAgICogd2l0aCBgXyN2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHlvdW5nZXN0ID0gX1xuICAgICAqICAgLmNoYWluKHVzZXJzKVxuICAgICAqICAgLnNvcnRCeSgnYWdlJylcbiAgICAgKiAgIC5tYXAoZnVuY3Rpb24obykge1xuICAgICAqICAgICByZXR1cm4gby51c2VyICsgJyBpcyAnICsgby5hZ2U7XG4gICAgICogICB9KVxuICAgICAqICAgLmhlYWQoKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMgaXMgMSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFpbih2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaCh2YWx1ZSk7XG4gICAgICByZXN1bHQuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBgaW50ZXJjZXB0b3JgIGFuZCByZXR1cm5zIGB2YWx1ZWAuIFRoZSBpbnRlcmNlcHRvclxuICAgICAqIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvXG4gICAgICogXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluIHNlcXVlbmNlIGluIG9yZGVyIHRvIG1vZGlmeSBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSlcbiAgICAgKiAgLnRhcChmdW5jdGlvbihhcnJheSkge1xuICAgICAqICAgIC8vIE11dGF0ZSBpbnB1dCBhcnJheS5cbiAgICAgKiAgICBhcnJheS5wb3AoKTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnJldmVyc2UoKVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy50YXBgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwicGFzcyB0aHJ1XCIgdmFsdWVzIHJlcGxhY2luZyBpbnRlcm1lZGlhdGVcbiAgICAgKiByZXN1bHRzIGluIGEgbWV0aG9kIGNoYWluIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXygnICBhYmMgICcpXG4gICAgICogIC5jaGFpbigpXG4gICAgICogIC50cmltKClcbiAgICAgKiAgLnRocnUoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWydhYmMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocnUodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICByZXR1cm4gaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSB3cmFwcGVyIHZlcnNpb24gb2YgYF8uYXRgLlxuICAgICAqXG4gICAgICogQG5hbWUgYXRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9LCA0XSB9O1xuICAgICAqXG4gICAgICogXyhvYmplY3QpLmF0KFsnYVswXS5iLmMnLCAnYVsxXSddKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqL1xuICAgIHZhciB3cmFwcGVyQXQgPSBmbGF0UmVzdChmdW5jdGlvbihwYXRocykge1xuICAgICAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICBzdGFydCA9IGxlbmd0aCA/IHBhdGhzWzBdIDogMCxcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbihvYmplY3QpIHsgcmV0dXJuIGJhc2VBdChvYmplY3QsIHBhdGhzKTsgfTtcblxuICAgICAgaWYgKGxlbmd0aCA+IDEgfHwgdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGggfHxcbiAgICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHx8ICFpc0luZGV4KHN0YXJ0KSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2Uoc3RhcnQsICtzdGFydCArIChsZW5ndGggPyAxIDogMCkpO1xuICAgICAgdmFsdWUuX19hY3Rpb25zX18ucHVzaCh7XG4gICAgICAgICdmdW5jJzogdGhydSxcbiAgICAgICAgJ2FyZ3MnOiBbaW50ZXJjZXB0b3JdLFxuICAgICAgICAndGhpc0FyZyc6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUsIHRoaXMuX19jaGFpbl9fKS50aHJ1KGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgIGlmIChsZW5ndGggJiYgIWFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgIGFycmF5LnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlIHdpdGggZXhwbGljaXQgbWV0aG9kIGNoYWluIHNlcXVlbmNlcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQG5hbWUgY2hhaW5cbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gQSBzZXF1ZW5jZSB3aXRob3V0IGV4cGxpY2l0IGNoYWluaW5nLlxuICAgICAqIF8odXNlcnMpLmhlYWQoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICpcbiAgICAgKiAvLyBBIHNlcXVlbmNlIHdpdGggZXhwbGljaXQgY2hhaW5pbmcuXG4gICAgICogXyh1c2VycylcbiAgICAgKiAgIC5jaGFpbigpXG4gICAgICogICAuaGVhZCgpXG4gICAgICogICAucGljaygndXNlcicpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDaGFpbigpIHtcbiAgICAgIHJldHVybiBjaGFpbih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW4gc2VxdWVuY2UgYW5kIHJldHVybnMgdGhlIHdyYXBwZWQgcmVzdWx0LlxuICAgICAqXG4gICAgICogQG5hbWUgY29tbWl0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyXTtcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oYXJyYXkpLnB1c2goMyk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkID0gd3JhcHBlZC5jb21taXQoKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkLmxhc3QoKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNvbW1pdCgpIHtcbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih0aGlzLnZhbHVlKCksIHRoaXMuX19jaGFpbl9fKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuZXh0IHZhbHVlIG9uIGEgd3JhcHBlZCBvYmplY3QgZm9sbG93aW5nIHRoZVxuICAgICAqIFtpdGVyYXRvciBwcm90b2NvbF0oaHR0cHM6Ly9tZG4uaW8vaXRlcmF0aW9uX3Byb3RvY29scyNpdGVyYXRvcikuXG4gICAgICpcbiAgICAgKiBAbmFtZSBuZXh0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV4dCBpdGVyYXRvciB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSk7XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogZmFsc2UsICd2YWx1ZSc6IDEgfVxuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IGZhbHNlLCAndmFsdWUnOiAyIH1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiB0cnVlLCAndmFsdWUnOiB1bmRlZmluZWQgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJOZXh0KCkge1xuICAgICAgaWYgKHRoaXMuX192YWx1ZXNfXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX192YWx1ZXNfXyA9IHRvQXJyYXkodGhpcy52YWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIHZhciBkb25lID0gdGhpcy5fX2luZGV4X18gPj0gdGhpcy5fX3ZhbHVlc19fLmxlbmd0aCxcbiAgICAgICAgICB2YWx1ZSA9IGRvbmUgPyB1bmRlZmluZWQgOiB0aGlzLl9fdmFsdWVzX19bdGhpcy5fX2luZGV4X18rK107XG5cbiAgICAgIHJldHVybiB7ICdkb25lJzogZG9uZSwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSB3cmFwcGVyIHRvIGJlIGl0ZXJhYmxlLlxuICAgICAqXG4gICAgICogQG5hbWUgU3ltYm9sLml0ZXJhdG9yXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pO1xuICAgICAqXG4gICAgICogd3JhcHBlZFtTeW1ib2wuaXRlcmF0b3JdKCkgPT09IHdyYXBwZWQ7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogQXJyYXkuZnJvbSh3cmFwcGVkKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVG9JdGVyYXRvcigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgY2hhaW4gc2VxdWVuY2UgcGxhbnRpbmcgYHZhbHVlYCBhcyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHBsYW50XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGxhbnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSkubWFwKHNxdWFyZSk7XG4gICAgICogdmFyIG90aGVyID0gd3JhcHBlZC5wbGFudChbMywgNF0pO1xuICAgICAqXG4gICAgICogb3RoZXIudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbOSwgMTZdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclBsYW50KHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIHBhcmVudCA9IHRoaXM7XG5cbiAgICAgIHdoaWxlIChwYXJlbnQgaW5zdGFuY2VvZiBiYXNlTG9kYXNoKSB7XG4gICAgICAgIHZhciBjbG9uZSA9IHdyYXBwZXJDbG9uZShwYXJlbnQpO1xuICAgICAgICBjbG9uZS5fX2luZGV4X18gPSAwO1xuICAgICAgICBjbG9uZS5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSBjbG9uZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBjbG9uZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldmlvdXMgPSBjbG9uZTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9fd3JhcHBlZF9fO1xuICAgICAgfVxuICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdGhlIHdyYXBwZXIgdmVyc2lvbiBvZiBgXy5yZXZlcnNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIHRoZSB3cmFwcGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfKGFycmF5KS5yZXZlcnNlKCkudmFsdWUoKVxuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJSZXZlcnNlKCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXztcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHZhciB3cmFwcGVkID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCkge1xuICAgICAgICAgIHdyYXBwZWQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgd3JhcHBlZCA9IHdyYXBwZWQucmV2ZXJzZSgpO1xuICAgICAgICB3cmFwcGVkLl9fYWN0aW9uc19fLnB1c2goe1xuICAgICAgICAgICdmdW5jJzogdGhydSxcbiAgICAgICAgICAnYXJncyc6IFtyZXZlcnNlXSxcbiAgICAgICAgICAndGhpc0FyZyc6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZWQsIHRoaXMuX19jaGFpbl9fKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRocnUocmV2ZXJzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluIHNlcXVlbmNlIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHZhbHVlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgdG9KU09OLCB2YWx1ZU9mXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKHRoaXMuX193cmFwcGVkX18sIHRoaXMuX19hY3Rpb25zX18pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZlxuICAgICAqIGVhY2gga2V5IGlzIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGtleSB3YXMgcmV0dXJuZWQgYnkgYGl0ZXJhdGVlYC4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs2LjEsIDQuMiwgNi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmNvdW50QnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogMiwgJzUnOiAxIH1cbiAgICAgKi9cbiAgICB2YXIgY291bnRCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgKytyZXN1bHRba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgMSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYWxsKiogZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICogW2VtcHR5IGNvbGxlY3Rpb25zXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbXB0eV9zZXQpIGJlY2F1c2VcbiAgICAgKiBbZXZlcnl0aGluZyBpcyB0cnVlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYWN1b3VzX3RydXRoKSBvZlxuICAgICAqIGVsZW1lbnRzIG9mIGVtcHR5IGNvbGxlY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ldmVyeShbdHJ1ZSwgMSwgbnVsbCwgJ3llcyddLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFdmVyeSA6IGJhc2VFdmVyeTtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucmVtb3ZlYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAc2VlIF8ucmVqZWN0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gQ29tYmluaW5nIHNldmVyYWwgcHJlZGljYXRlcyB1c2luZyBgXy5vdmVyRXZlcnlgIG9yIGBfLm92ZXJTb21lYC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5vdmVyU29tZShbeyAnYWdlJzogMzYgfSwgWydhZ2UnLCA0MF1dKSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ2Jhcm5leSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICAgICAqL1xuICAgIHZhciBmaW5kID0gY3JlYXRlRmluZChmaW5kSW5kZXgpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9Y29sbGVjdGlvbi5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3QoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgdmFyIGZpbmRMYXN0ID0gY3JlYXRlRmluZChmaW5kTGFzdEluZGV4KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmbGF0dGVuZWQgYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYFxuICAgICAqIHRocnUgYGl0ZXJhdGVlYCBhbmQgZmxhdHRlbmluZyB0aGUgbWFwcGVkIHJlc3VsdHMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbbiwgbl07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwKFsxLCAyXSwgZHVwbGljYXRlKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMiwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbGF0TWFwYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBmbGF0dGVucyB0aGVcbiAgICAgKiBtYXBwZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbW1tuLCBuXV1dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcERlZXAoWzEsIDJdLCBkdXBsaWNhdGUpO1xuICAgICAqIC8vID0+IFsxLCAxLCAyLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXBEZWVwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgSU5GSU5JVFkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxhdE1hcGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgZmxhdHRlbnMgdGhlXG4gICAgICogbWFwcGVkIHJlc3VsdHMgdXAgdG8gYGRlcHRoYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9MV0gVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbW1tuLCBuXV1dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcERlcHRoKFsxLCAyXSwgZHVwbGljYXRlLCAyKTtcbiAgICAgKiAvLyA9PiBbWzEsIDFdLCBbMiwgMl1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcERlcHRoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBkZXB0aCkge1xuICAgICAgZGVwdGggPSBkZXB0aCA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgZGVwdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiXG4gICAgICogcHJvcGVydHkgYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIHVzZSBgXy5mb3JJbmBcbiAgICAgKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIGVhY2hcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAc2VlIF8uZm9yRWFjaFJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyBgMWAgdGhlbiBgMmAuXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckVhY2hgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGFsaWFzIGVhY2hSaWdodFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBzZWUgXy5mb3JFYWNoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaFJpZ2h0KFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzIGAyYCB0aGVuIGAxYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaFJpZ2h0IDogYmFzZUVhY2hSaWdodDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBvcmRlciBvZiBncm91cGVkIHZhbHVlc1xuICAgICAqIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gYGNvbGxlY3Rpb25gLiBUaGUgY29ycmVzcG9uZGluZ1xuICAgICAqIHZhbHVlIG9mIGVhY2gga2V5IGlzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZVxuICAgICAqIGtleS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNi4xLCA0LjIsIDYuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjNdIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZ3JvdXBCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxuICAgICAqL1xuICAgIHZhciBncm91cEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgW3ZhbHVlXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiBgY29sbGVjdGlvbmAuIElmIGBjb2xsZWN0aW9uYCBpcyBhIHN0cmluZywgaXQnc1xuICAgICAqIGNoZWNrZWQgZm9yIGEgc3Vic3RyaW5nIG9mIGB2YWx1ZWAsIG90aGVyd2lzZVxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogaXMgdXNlZCBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXNcbiAgICAgKiB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyh7ICdhJzogMSwgJ2InOiAyIH0sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoJ2FiY2QnLCAnYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5jbHVkZXMoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICAgIGNvbGxlY3Rpb24gPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24gOiB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4ICYmICFndWFyZCkgPyB0b0ludGVnZXIoZnJvbUluZGV4KSA6IDA7XG5cbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICAgIGZyb21JbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pXG4gICAgICAgID8gKGZyb21JbmRleCA8PSBsZW5ndGggJiYgY29sbGVjdGlvbi5pbmRleE9mKHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpXG4gICAgICAgIDogKCEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nXG4gICAgICogYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogYXJlIHByb3ZpZGVkIHRvIGVhY2ggaW52b2tlZCBtZXRob2QuIElmIGBwYXRoYCBpcyBhIGZ1bmN0aW9uLCBpdCdzIGludm9rZWRcbiAgICAgKiBmb3IsIGFuZCBgdGhpc2AgYm91bmQgdG8sIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZSBvclxuICAgICAqICB0aGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGVhY2ggbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludm9rZU1hcChbWzUsIDEsIDddLCBbMywgMiwgMV1dLCAnc29ydCcpO1xuICAgICAqIC8vID0+IFtbMSwgNSwgN10sIFsxLCAyLCAzXV1cbiAgICAgKlxuICAgICAqIF8uaW52b2tlTWFwKFsxMjMsIDQ1Nl0sIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsICcnKTtcbiAgICAgKiAvLyA9PiBbWycxJywgJzInLCAnMyddLCBbJzQnLCAnNScsICc2J11dXG4gICAgICovXG4gICAgdmFyIGludm9rZU1hcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHBhdGgsIGFyZ3MpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzRnVuYyA9IHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbicsXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gaXNGdW5jID8gYXBwbHkocGF0aCwgdmFsdWUsIGFyZ3MpIDogYmFzZUludm9rZSh2YWx1ZSwgcGF0aCwgYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgb2ZcbiAgICAgKiBlYWNoIGtleSBpcyB0aGUgbGFzdCBlbGVtZW50IHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFtcbiAgICAgKiAgIHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LFxuICAgICAqICAgeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmtleUJ5KGFycmF5LCBmdW5jdGlvbihvKSB7XG4gICAgICogICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvLmNvZGUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8ua2V5QnkoYXJyYXksICdkaXInKTtcbiAgICAgKiAvLyA9PiB7ICdsZWZ0JzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdyaWdodCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqL1xuICAgIHZhciBrZXlCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1XG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gICAgICogYF8uZXZlcnlgLCBgXy5maWx0ZXJgLCBgXy5tYXBgLCBgXy5tYXBWYWx1ZXNgLCBgXy5yZWplY3RgLCBhbmQgYF8uc29tZWAuXG4gICAgICpcbiAgICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAgICAgKiBgYXJ5YCwgYGNodW5rYCwgYGN1cnJ5YCwgYGN1cnJ5UmlnaHRgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZXZlcnlgLFxuICAgICAqIGBmaWxsYCwgYGludmVydGAsIGBwYXJzZUludGAsIGByYW5kb21gLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZXBlYXRgLFxuICAgICAqIGBzYW1wbGVTaXplYCwgYHNsaWNlYCwgYHNvbWVgLCBgc29ydEJ5YCwgYHNwbGl0YCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdHJpbWAsIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGFuZCBgd29yZHNgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5tYXAoWzQsIDhdLCBzcXVhcmUpO1xuICAgICAqIC8vID0+IFsxNiwgNjRdXG4gICAgICpcbiAgICAgKiBfLm1hcCh7ICdhJzogNCwgJ2InOiA4IH0sIHNxdWFyZSk7XG4gICAgICogLy8gPT4gWzE2LCA2NF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwKHVzZXJzLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRCeWAgZXhjZXB0IHRoYXQgaXQgYWxsb3dzIHNwZWNpZnlpbmcgdGhlIHNvcnRcbiAgICAgKiBvcmRlcnMgb2YgdGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlc1xuICAgICAqIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yXG4gICAgICogZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlciBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXlbXXxGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IFtvcmRlcnNdIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBTb3J0IGJ5IGB1c2VyYCBpbiBhc2NlbmRpbmcgb3JkZXIgYW5kIGJ5IGBhZ2VgIGluIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICogXy5vcmRlckJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10sIFsnYXNjJywgJ2Rlc2MnXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0MF1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycywgZ3VhcmQpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0FycmF5KGl0ZXJhdGVlcykpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gaXRlcmF0ZWVzID09IG51bGwgPyBbXSA6IFtpdGVyYXRlZXNdO1xuICAgICAgfVxuICAgICAgb3JkZXJzID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBvcmRlcnM7XG4gICAgICBpZiAoIWlzQXJyYXkob3JkZXJzKSkge1xuICAgICAgICBvcmRlcnMgPSBvcmRlcnMgPT0gbnVsbCA/IFtdIDogW29yZGVyc107XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byB0d28gZ3JvdXBzLCB0aGUgZmlyc3Qgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IsIHRoZSBzZWNvbmQgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleSBmb3IuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydwZWJibGVzJ10sIFsnYmFybmV5JywgJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsICdwZWJibGVzJ10sIFsnZnJlZCddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cbiAgICAgKi9cbiAgICB2YXIgcGFydGl0aW9uID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXkgPyAwIDogMV0ucHVzaCh2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24oKSB7IHJldHVybiBbW10sIFtdXTsgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZWR1Y2VzIGBjb2xsZWN0aW9uYCB0byBhIHZhbHVlIHdoaWNoIGlzIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLiBJZiBgYWNjdW11bGF0b3JgXG4gICAgICogaXMgbm90IGdpdmVuLCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbFxuICAgICAqIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICAgICAqIChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5yZWR1Y2VgLCBgXy5yZWR1Y2VSaWdodGAsIGFuZCBgXy50cmFuc2Zvcm1gLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFzc2lnbmAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgaW5jbHVkZXNgLCBgbWVyZ2VgLCBgb3JkZXJCeWAsXG4gICAgICogYW5kIGBzb3J0QnlgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5yZWR1Y2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlZHVjZShbMSwgMl0sIGZ1bmN0aW9uKHN1bSwgbikge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG47XG4gICAgICogfSwgMCk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAgICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZSA6IGJhc2VSZWR1Y2UsXG4gICAgICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2gpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmVkdWNlYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLnJlZHVjZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbWzAsIDFdLCBbMiwgM10sIFs0LCA1XV07XG4gICAgICpcbiAgICAgKiBfLnJlZHVjZVJpZ2h0KGFycmF5LCBmdW5jdGlvbihmbGF0dGVuZWQsIG90aGVyKSB7XG4gICAgICogICByZXR1cm4gZmxhdHRlbmVkLmNvbmNhdChvdGhlcik7XG4gICAgICogfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA1LCAyLCAzLCAwLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2VSaWdodCA6IGJhc2VSZWR1Y2UsXG4gICAgICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2hSaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmZpbHRlcmA7IHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYFxuICAgICAqIHRoYXQgYHByZWRpY2F0ZWAgZG9lcyAqKm5vdCoqIHJldHVybiB0cnV0aHkgZm9yLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBzZWUgXy5maWx0ZXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5yZWplY3QodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVqZWN0KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgbmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgcmFuZG9tIGVsZW1lbnQgZnJvbSBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNhbXBsZSA6IGJhc2VTYW1wbGU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGBuYCByYW5kb20gZWxlbWVudHMgYXQgdW5pcXVlIGtleXMgZnJvbSBgY29sbGVjdGlvbmAgdXAgdG8gdGhlXG4gICAgICogc2l6ZSBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGVTaXplKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzMsIDFdXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZVNpemUoWzEsIDIsIDNdLCA0KTtcbiAgICAgKiAvLyA9PiBbMiwgMywgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGVTaXplKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIDogbiA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICB9XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNhbXBsZVNpemUgOiBiYXNlU2FtcGxlU2l6ZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlXG4gICAgICogW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IFs0LCAxLCAzLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTaHVmZmxlIDogYmFzZVNodWZmbGU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgaXRzIGxlbmd0aCBmb3IgYXJyYXktbGlrZVxuICAgICAqIHZhbHVlcyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIGZvciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2xsZWN0aW9uIHNpemUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2l6ZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uc2l6ZSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2l6ZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+IDdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pID8gc3RyaW5nU2l6ZShjb2xsZWN0aW9uKSA6IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyhjb2xsZWN0aW9uKTtcbiAgICAgIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uc2l6ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlS2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFueSoqIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb21lKFtudWxsLCAwLCAneWVzJywgZmFsc2VdLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U29tZSA6IGJhc2VTb21lO1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhydSBlYWNoIGl0ZXJhdGVlLiBUaGlzIG1ldGhvZFxuICAgICAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZlxuICAgICAqIGVxdWFsIGVsZW1lbnRzLiBUaGUgaXRlcmF0ZWVzIGFyZSBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDMwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KHVzZXJzLCBbZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyOyB9XSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCAzMF1dXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCAzMF0sIFsnZnJlZCcsIDQ4XV1cbiAgICAgKi9cbiAgICB2YXIgc29ydEJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWVzKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA+IDEgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0pKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtdO1xuICAgICAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdLCBpdGVyYXRlZXNbMl0pKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtpdGVyYXRlZXNbMF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKGl0ZXJhdGVlcywgMSksIFtdKTtcbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICAgICAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IERhdGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gICAgICogfSwgXy5ub3coKSk7XG4gICAgICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgbm93ID0gY3R4Tm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmJlZm9yZWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXNcbiAgICAgKiBgZnVuY2Agb25jZSBpdCdzIGNhbGxlZCBgbmAgb3IgbW9yZSB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYmVmb3JlIGBmdW5jYCBpcyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXZlcyA9IFsncHJvZmlsZScsICdzZXR0aW5ncyddO1xuICAgICAqXG4gICAgICogdmFyIGRvbmUgPSBfLmFmdGVyKHNhdmVzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnZG9uZSBzYXZpbmchJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goc2F2ZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgKiAgIGFzeW5jU2F2ZSh7ICd0eXBlJzogdHlwZSwgJ2NvbXBsZXRlJzogZG9uZSB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdkb25lIHNhdmluZyEnIGFmdGVyIHRoZSB0d28gYXN5bmMgc2F2ZXMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWZ0ZXIobiwgZnVuYykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA8IDEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHVwIHRvIGBuYCBhcmd1bWVudHMsXG4gICAgICogaWdub3JpbmcgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgY2FwLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnOCcsICcxMCddLCBfLmFyeShwYXJzZUludCwgMSkpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnkoZnVuYywgbiwgZ3VhcmQpIHtcbiAgICAgIG4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IG47XG4gICAgICBuID0gKGZ1bmMgJiYgbiA9PSBudWxsKSA/IGZ1bmMubGVuZ3RoIDogbjtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQVJZX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHNcbiAgICAgKiBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hpbGUgaXQncyBjYWxsZWQgbGVzcyB0aGFuIGBuYCB0aW1lcy4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIHRoZSBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBhdCB3aGljaCBgZnVuY2AgaXMgbm8gbG9uZ2VyIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uYmVmb3JlKDUsIGFkZENvbnRhY3RUb0xpc3QpKTtcbiAgICAgKiAvLyA9PiBBbGxvd3MgYWRkaW5nIHVwIHRvIDQgY29udGFjdHMgdG8gdGhlIGxpc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmVmb3JlKG4sIGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uID4gMCkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgICAgZnVuYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgbmF0aXZlIGBGdW5jdGlvbiNiaW5kYCwgdGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCJcbiAgICAgKiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBCb3VuZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgXywgJyEnKTtcbiAgICAgKiBib3VuZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGJpdG1hc2sgPSBXUkFQX0JJTkRfRkxBRztcbiAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKGJpbmQpKTtcbiAgICAgICAgYml0bWFzayB8PSBXUkFQX1BBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgb2JqZWN0W2tleV1gIHdpdGggYHBhcnRpYWxzYFxuICAgICAqIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBfLmJpbmRgIGJ5IGFsbG93aW5nIGJvdW5kIGZ1bmN0aW9ucyB0byByZWZlcmVuY2VcbiAgICAgKiBtZXRob2RzIHRoYXQgbWF5IGJlIHJlZGVmaW5lZCBvciBkb24ndCB5ZXQgZXhpc3QuIFNlZVxuICAgICAqIFtQZXRlciBNaWNoYXV4J3MgYXJ0aWNsZV0oaHR0cDovL3BldGVyLm1pY2hhdXguY2EvYXJ0aWNsZXMvbGF6eS1mdW5jdGlvbi1kZWZpbml0aW9uLXBhdHRlcm4pXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kS2V5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52b2tlIHRoZSBtZXRob2Qgb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAndXNlcic6ICdmcmVkJyxcbiAgICAgKiAgICdncmVldCc6IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiBvYmplY3QuZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICd5YSAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBCb3VuZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCBfLCAnIScpO1xuICAgICAqIGJvdW5kKCdoaScpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kS2V5ID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBrZXksIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHO1xuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZEtleSkpO1xuICAgICAgICBiaXRtYXNrIHw9IFdSQVBfUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoa2V5LCBiaXRtYXNrLCBvYmplY3QsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYXJndW1lbnRzIG9mIGBmdW5jYCBhbmQgZWl0aGVyIGludm9rZXNcbiAgICAgKiBgZnVuY2AgcmV0dXJuaW5nIGl0cyByZXN1bHQsIGlmIGF0IGxlYXN0IGBhcml0eWAgbnVtYmVyIG9mIGFyZ3VtZW50cyBoYXZlXG4gICAgICogYmVlbiBwcm92aWRlZCwgb3IgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgcmVtYWluaW5nIGBmdW5jYFxuICAgICAqIGFyZ3VtZW50cywgYW5kIHNvIG9uLiBUaGUgYXJpdHkgb2YgYGZ1bmNgIG1heSBiZSBzcGVjaWZpZWQgaWYgYGZ1bmMubGVuZ3RoYFxuICAgICAqIGlzIG5vdCBzdWZmaWNpZW50LlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEpKDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyBDdXJyaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIGN1cnJpZWQoMSkoXywgMykoMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnkoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICBhcml0eSA9IGd1YXJkID8gdW5kZWZpbmVkIDogYXJpdHk7XG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0NVUlJZX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSk7XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeS5wbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jdXJyeWAgZXhjZXB0IHRoYXQgYXJndW1lbnRzIGFyZSBhcHBsaWVkIHRvIGBmdW5jYFxuICAgICAqIGluIHRoZSBtYW5uZXIgb2YgYF8ucGFydGlhbFJpZ2h0YCBpbnN0ZWFkIG9mIGBfLnBhcnRpYWxgLlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5UmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnlSaWdodChhYmMpO1xuICAgICAqXG4gICAgICogY3VycmllZCgzKSgyKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMiwgMykoMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogLy8gQ3VycmllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiBjdXJyaWVkKDMpKDEsIF8pKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5UmlnaHQoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICBhcml0eSA9IGd1YXJkID8gdW5kZWZpbmVkIDogYXJpdHk7XG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSk7XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeVJpZ2h0LnBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAgICAgKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAgICAgKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gICAgICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gICAgICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gICAgICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICAgICAqIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAgICAgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICAgICAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gICAgICpcbiAgICAgKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gICAgICogICAnbGVhZGluZyc6IHRydWUsXG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pKTtcbiAgICAgKlxuICAgICAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gICAgICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gICAgICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICAgICAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAgICAgKlxuICAgICAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxhc3RBcmdzLFxuICAgICAgICAgIGxhc3RUaGlzLFxuICAgICAgICAgIG1heFdhaXQsXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHRpbWVySWQsXG4gICAgICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgICAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgICAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICAgICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgICAgICB0aW1lV2FpdGluZyA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgICAgICByZXR1cm4gbWF4aW5nXG4gICAgICAgICAgPyBuYXRpdmVNaW4odGltZVdhaXRpbmcsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKVxuICAgICAgICAgIDogdGltZVdhaXRpbmc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICAgICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgICAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAgICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICAgICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICAgICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICAgICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgICAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICAgICAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gICAgICByZXR1cm4gZGVib3VuY2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmVycyBpbnZva2luZyB0aGUgYGZ1bmNgIHVudGlsIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzIGNsZWFyZWQuIEFueVxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWZlci5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbih0ZXh0KSB7XG4gICAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgKiB9LCAnZGVmZXJyZWQnKTtcbiAgICAgKiAvLyA9PiBMb2dzICdkZWZlcnJlZCcgYWZ0ZXIgb25lIG1pbGxpc2Vjb25kLlxuICAgICAqL1xuICAgIHZhciBkZWZlciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBiYXNlRGVsYXkoZnVuYywgMSwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGBmdW5jYCBhZnRlciBgd2FpdGAgbWlsbGlzZWNvbmRzLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlXG4gICAgICogcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWxheShmdW5jdGlvbih0ZXh0KSB7XG4gICAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgKiB9LCAxMDAwLCAnbGF0ZXInKTtcbiAgICAgKiAvLyA9PiBMb2dzICdsYXRlcicgYWZ0ZXIgb25lIHNlY29uZC5cbiAgICAgKi9cbiAgICB2YXIgZGVsYXkgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIHRvTnVtYmVyKHdhaXQpIHx8IDAsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgcmV2ZXJzZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBmbGlwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmxpcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZsaXBwZWQgPSBfLmZsaXAoZnVuY3Rpb24oKSB7XG4gICAgICogICByZXR1cm4gXy50b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBmbGlwcGVkKCdhJywgJ2InLCAnYycsICdkJyk7XG4gICAgICogLy8gPT4gWydkJywgJ2MnLCAnYicsICdhJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGlwKGZ1bmMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfRkxJUF9GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICAgICAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAgICAgKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICAgICAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICAgICAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gICAgICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAgICAgKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICAgICAqXG4gICAgICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB2YWx1ZXMob3RoZXIpO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqXG4gICAgICogb2JqZWN0LmEgPSAyO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gICAgICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKlxuICAgICAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gICAgICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9XG5cbiAgICAvLyBFeHBvc2UgYE1hcENhY2hlYC5cbiAgICBtZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBuZWdhdGVzIHRoZSByZXN1bHQgb2YgdGhlIHByZWRpY2F0ZSBgZnVuY2AuIFRoZVxuICAgICAqIGBmdW5jYCBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBuZWdhdGUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbmVnYXRlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNFdmVuKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFsxLCAyLCAzLCA0LCA1LCA2XSwgXy5uZWdhdGUoaXNFdmVuKSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmVnYXRlKHByZWRpY2F0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgIGNhc2UgMTogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyByZXN0cmljdGVkIHRvIGludm9raW5nIGBmdW5jYCBvbmNlLiBSZXBlYXQgY2FsbHNcbiAgICAgKiB0byB0aGUgZnVuY3Rpb24gcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgaW52b2NhdGlvbi4gVGhlIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBpbml0aWFsaXplID0gXy5vbmNlKGNyZWF0ZUFwcGxpY2F0aW9uKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIC8vID0+IGBjcmVhdGVBcHBsaWNhdGlvbmAgaXMgaW52b2tlZCBvbmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25jZShmdW5jKSB7XG4gICAgICByZXR1cm4gYmVmb3JlKDIsIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50cyB0cmFuc2Zvcm1lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFt0cmFuc2Zvcm1zPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGFyZ3VtZW50IHRyYW5zZm9ybXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGRvdWJsZWQobikge1xuICAgICAqICAgcmV0dXJuIG4gKiAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJBcmdzKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHJldHVybiBbeCwgeV07XG4gICAgICogfSwgW3NxdWFyZSwgZG91YmxlZF0pO1xuICAgICAqXG4gICAgICogZnVuYyg5LCAzKTtcbiAgICAgKiAvLyA9PiBbODEsIDZdXG4gICAgICpcbiAgICAgKiBmdW5jKDEwLCA1KTtcbiAgICAgKiAvLyA9PiBbMTAwLCAxMF1cbiAgICAgKi9cbiAgICB2YXIgb3ZlckFyZ3MgPSBjYXN0UmVzdChmdW5jdGlvbihmdW5jLCB0cmFuc2Zvcm1zKSB7XG4gICAgICB0cmFuc2Zvcm1zID0gKHRyYW5zZm9ybXMubGVuZ3RoID09IDEgJiYgaXNBcnJheSh0cmFuc2Zvcm1zWzBdKSlcbiAgICAgICAgPyBhcnJheU1hcCh0cmFuc2Zvcm1zWzBdLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpXG4gICAgICAgIDogYXJyYXlNYXAoYmFzZUZsYXR0ZW4odHJhbnNmb3JtcywgMSksIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG5cbiAgICAgIHZhciBmdW5jc0xlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oYXJncy5sZW5ndGgsIGZ1bmNzTGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gdHJhbnNmb3Jtc1tpbmRleF0uY2FsbCh0aGlzLCBhcmdzW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZVxuICAgICAqIGFyZ3VtZW50cyBpdCByZWNlaXZlcy4gVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5iaW5kYCBleGNlcHQgaXQgZG9lcyAqKm5vdCoqXG4gICAgICogYWx0ZXIgdGhlIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogVGhlIGBfLnBhcnRpYWwucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWwoZ3JlZXQsICdoZWxsbycpO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFBhcnRpYWxseSBhcHBsaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWwoZ3JlZXQsIF8sICdmcmVkJyk7XG4gICAgICogZ3JlZXRGcmVkKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqL1xuICAgIHZhciBwYXJ0aWFsID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsKSk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1BBUlRJQUxfRkxBRywgdW5kZWZpbmVkLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnBhcnRpYWxgIGV4Y2VwdCB0aGF0IHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50c1xuICAgICAqIGFyZSBhcHBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhlIGBfLnBhcnRpYWxSaWdodC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgbmFtZSkge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdmcmVkJyk7XG4gICAgICogZ3JlZXRGcmVkKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gUGFydGlhbGx5IGFwcGxpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2hlbGxvJywgXyk7XG4gICAgICogc2F5SGVsbG9UbygnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqL1xuICAgIHZhciBwYXJ0aWFsUmlnaHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKHBhcnRpYWxSaWdodCkpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcsIHVuZGVmaW5lZCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgYXJyYW5nZWQgYWNjb3JkaW5nXG4gICAgICogdG8gdGhlIHNwZWNpZmllZCBgaW5kZXhlc2Agd2hlcmUgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBmaXJzdCBpbmRleCBpc1xuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBzZWNvbmQgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZWFycmFuZ2UgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW10pfSBpbmRleGVzIFRoZSBhcnJhbmdlZCBhcmd1bWVudCBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcmVhcmdlZCA9IF8ucmVhcmcoZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9LCBbMiwgMCwgMV0pO1xuICAgICAqXG4gICAgICogcmVhcmdlZCgnYicsICdjJywgJ2EnKVxuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIHZhciByZWFyZyA9IGZsYXRSZXN0KGZ1bmN0aW9uKGZ1bmMsIGluZGV4ZXMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUkVBUkdfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaW5kZXhlcyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uIGFuZCBhcmd1bWVudHMgZnJvbSBgc3RhcnRgIGFuZCBiZXlvbmQgcHJvdmlkZWQgYXNcbiAgICAgKiBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGVcbiAgICAgKiBbcmVzdCBwYXJhbWV0ZXJdKGh0dHBzOi8vbWRuLmlvL3Jlc3RfcGFyYW1ldGVycykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNheSA9IF8ucmVzdChmdW5jdGlvbih3aGF0LCBuYW1lcykge1xuICAgICAqICAgcmV0dXJuIHdoYXQgKyAnICcgKyBfLmluaXRpYWwobmFtZXMpLmpvaW4oJywgJykgK1xuICAgICAqICAgICAoXy5zaXplKG5hbWVzKSA+IDEgPyAnLCAmICcgOiAnJykgKyBfLmxhc3QobmFtZXMpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2F5KCdoZWxsbycsICdmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3QoZnVuYywgc3RhcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jLCBzdGFydCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gICAgICogY3JlYXRlIGZ1bmN0aW9uIGFuZCBhbiBhcnJheSBvZiBhcmd1bWVudHMgbXVjaCBsaWtlXG4gICAgICogW2BGdW5jdGlvbiNhcHBseWBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1mdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZVxuICAgICAqIFtzcHJlYWQgb3BlcmF0b3JdKGh0dHBzOi8vbWRuLmlvL3NwcmVhZF9vcGVyYXRvcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBzcHJlYWQgYXJndW1lbnRzIG92ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHNwcmVhZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNheSA9IF8uc3ByZWFkKGZ1bmN0aW9uKHdobywgd2hhdCkge1xuICAgICAqICAgcmV0dXJuIHdobyArICcgc2F5cyAnICsgd2hhdDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheShbJ2ZyZWQnLCAnaGVsbG8nXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQgc2F5cyBoZWxsbydcbiAgICAgKlxuICAgICAqIHZhciBudW1iZXJzID0gUHJvbWlzZS5hbGwoW1xuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDQwKSxcbiAgICAgKiAgIFByb21pc2UucmVzb2x2ZSgzNilcbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIG51bWJlcnMudGhlbihfLnNwcmVhZChmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4geCArIHk7XG4gICAgICogfSkpO1xuICAgICAqIC8vID0+IGEgUHJvbWlzZSBvZiA3NlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNwcmVhZChmdW5jLCBzdGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6IG5hdGl2ZU1heCh0b0ludGVnZXIoc3RhcnQpLCAwKTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFyZ3Nbc3RhcnRdLFxuICAgICAgICAgICAgb3RoZXJBcmdzID0gY2FzdFNsaWNlKGFyZ3MsIDAsIHN0YXJ0KTtcblxuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBhcnJheVB1c2gob3RoZXJBcmdzLCBhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gICAgICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAgICAgKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXG4gICAgICogaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgXG4gICAgICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuICAgICAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcbiAgICAgKiB0aHJvdHRsZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiByZXR1cm4gdGhlXG4gICAgICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gICAgICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gICAgICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICAgICAqXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gICAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmcuXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICAgICAqXG4gICAgICogLy8gSW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXMuXG4gICAgICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICAgICAqXG4gICAgICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcbiAgICAgICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICAgICAnbWF4V2FpdCc6IHdhaXQsXG4gICAgICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIG9uZSBhcmd1bWVudCwgaWdub3JpbmcgYW55XG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8udW5hcnkocGFyc2VJbnQpKTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5hcnkoZnVuYykge1xuICAgICAgcmV0dXJuIGFyeShmdW5jLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBgdmFsdWVgIHRvIGB3cmFwcGVyYCBhcyBpdHMgZmlyc3RcbiAgICAgKiBhcmd1bWVudC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBmdW5jdGlvbiBhcmUgYXBwZW5kZWRcbiAgICAgKiB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgYHdyYXBwZXJgLiBUaGUgd3JhcHBlciBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFt3cmFwcGVyPWlkZW50aXR5XSBUaGUgd3JhcHBlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHAgPSBfLndyYXAoXy5lc2NhcGUsIGZ1bmN0aW9uKGZ1bmMsIHRleHQpIHtcbiAgICAgKiAgIHJldHVybiAnPHA+JyArIGZ1bmModGV4dCkgKyAnPC9wPic7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBwKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICc8cD5mcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXM8L3A+J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXAodmFsdWUsIHdyYXBwZXIpIHtcbiAgICAgIHJldHVybiBwYXJ0aWFsKGNhc3RGdW5jdGlvbih3cmFwcGVyKSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgYXMgYW4gYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoMSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSh7ICdhJzogMSB9KTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEgfV1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBbJ2FiYyddXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheShudWxsKTtcbiAgICAgKiAvLyA9PiBbbnVsbF1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gW3VuZGVmaW5lZF1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKiBjb25zb2xlLmxvZyhfLmNhc3RBcnJheShhcnJheSkgPT09IGFycmF5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdEFycmF5KCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gICAgICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwczovL21kbi5pby9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobSlcbiAgICAgKiBhbmQgc3VwcG9ydHMgY2xvbmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLCBkYXRlIG9iamVjdHMsIG1hcHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkXG4gICAgICogYXJyYXlzLiBUaGUgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFyZSBjbG9uZWRcbiAgICAgKiBhcyBwbGFpbiBvYmplY3RzLiBBbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoXG4gICAgICogYXMgZXJyb3Igb2JqZWN0cywgZnVuY3Rpb25zLCBET00gbm9kZXMsIGFuZCBXZWFrTWFwcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVEZWVwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICAgICAqXG4gICAgICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKG9iamVjdHMpO1xuICAgICAqIGNvbnNvbGUubG9nKHNoYWxsb3dbMF0gPT09IG9iamVjdHNbMF0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCxcbiAgICAgKiBjbG9uaW5nIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHVwIHRvIGZvdXIgYXJndW1lbnRzOyAodmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3QsIHN0YWNrXSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVEZWVwV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKHZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBlbCA9IF8uY2xvbmVXaXRoKGRvY3VtZW50LmJvZHksIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZWwgPT09IGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogY29uc29sZS5sb2coZWwubm9kZU5hbWUpO1xuICAgICAqIC8vID0+ICdCT0RZJ1xuICAgICAqIGNvbnNvbGUubG9nKGVsLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVXaXRoKHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChvYmplY3RzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhkZWVwWzBdID09PSBvYmplY3RzWzBdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lV2l0aGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZVdpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcih2YWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBlbCA9IF8uY2xvbmVEZWVwV2l0aChkb2N1bWVudC5ib2R5LCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGVsID09PSBkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqIGNvbnNvbGUubG9nKGVsLm5vZGVOYW1lKTtcbiAgICAgKiAvLyA9PiAnQk9EWSdcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5jaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXBXaXRoKHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgb2JqZWN0YCBjb25mb3JtcyB0byBgc291cmNlYCBieSBpbnZva2luZyB0aGUgcHJlZGljYXRlXG4gICAgICogcHJvcGVydGllcyBvZiBgc291cmNlYCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGBfLmNvbmZvcm1zYCB3aGVuIGBzb3VyY2VgIGlzXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xNC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBjb25mb3JtcywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqXG4gICAgICogXy5jb25mb3Jtc1RvKG9iamVjdCwgeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAxOyB9IH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uY29uZm9ybXNUbyhvYmplY3QsIHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMjsgfSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBzb3VyY2UgPT0gbnVsbCB8fCBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwga2V5cyhzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVxKCdhJywgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVxKE5hTiwgTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmx0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3QoMywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5ndCgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBndCA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oYmFzZUd0KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvXG4gICAgICogIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ubHRlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDMsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDMsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDEsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGd0ZSA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gb3RoZXI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheUJ1ZmZlcmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5QnVmZmVyKG5ldyBBcnJheUJ1ZmZlcigyKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5QnVmZmVyKG5ldyBBcnJheSgyKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcnJheUJ1ZmZlciA9IG5vZGVJc0FycmF5QnVmZmVyID8gYmFzZVVuYXJ5KG5vZGVJc0FycmF5QnVmZmVyKSA6IGJhc2VJc0FycmF5QnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICAgICAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAgICAgKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gICAgICogaXMgYW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYm9vbGVhbiBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJvb2xlYW4sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4oZmFsc2UpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGJvb2xUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBEYXRlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZGF0ZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUobmV3IERhdGUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKCdNb24gQXByaWwgMjMgMjAxMicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzRGF0ZSA9IG5vZGVJc0RhdGUgPyBiYXNlVW5hcnkobm9kZUlzRGF0ZSkgOiBiYXNlSXNEYXRlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoJzxib2R5PicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMSAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAgICAgKlxuICAgICAqIE9iamVjdHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIG5vIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZFxuICAgICAqIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBBcnJheS1saWtlIHZhbHVlcyBzdWNoIGFzIGBhcmd1bWVudHNgIG9iamVjdHMsIGFycmF5cywgYnVmZmVycywgc3RyaW5ncywgb3JcbiAgICAgKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gICAgICogU2ltaWxhcmx5LCBtYXBzIGFuZCBzZXRzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBzaXplYCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkodHJ1ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgICAoaXNBcnJheSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZS5zcGxpY2UgPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgaXNCdWZmZXIodmFsdWUpIHx8IGlzVHlwZWRBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpO1xuICAgICAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgICAgICByZXR1cm4gIXZhbHVlLnNpemU7XG4gICAgICB9XG4gICAgICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAhYmFzZUtleXModmFsdWUpLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICAgICAqIGVxdWl2YWxlbnQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsXG4gICAgICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxuICAgICAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXG4gICAgICogYnkgdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZ1bmN0aW9ucyBhbmQgRE9NXG4gICAgICogbm9kZXMgYXJlIGNvbXBhcmVkIGJ5IHN0cmljdCBlcXVhbGl0eSwgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogb2JqZWN0ID09PSBvdGhlcjtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzRXF1YWxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIGNvbXBhcmlzb25zXG4gICAgICogYXJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCB1cCB0b1xuICAgICAqIHNpeCBhcmd1bWVudHM6IChvYmpWYWx1ZSwgb3RoVmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3QsIG90aGVyLCBzdGFja10pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNHcmVldGluZyh2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIC9eaCg/Oml8ZWxsbykkLy50ZXN0KHZhbHVlKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSkge1xuICAgICAqICAgaWYgKGlzR3JlZXRpbmcob2JqVmFsdWUpICYmIGlzR3JlZXRpbmcob3RoVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnaGVsbG8nLCAnZ29vZGJ5ZSddO1xuICAgICAqIHZhciBvdGhlciA9IFsnaGknLCAnZ29vZGJ5ZSddO1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsV2l0aChhcnJheSwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsV2l0aCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgb3RoZXIpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCB1bmRlZmluZWQsIGN1c3RvbWl6ZXIpIDogISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYEVycm9yYCwgYEV2YWxFcnJvcmAsIGBSYW5nZUVycm9yYCwgYFJlZmVyZW5jZUVycm9yYCxcbiAgICAgKiBgU3ludGF4RXJyb3JgLCBgVHlwZUVycm9yYCwgb3IgYFVSSUVycm9yYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IoRXJyb3IpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgICAgIHJldHVybiB0YWcgPT0gZXJyb3JUYWcgfHwgdGFnID09IGRvbUV4Y1RhZyB8fFxuICAgICAgICAodHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlLm5hbWUgPT0gJ3N0cmluZycgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBwcmltaXRpdmUgbnVtYmVyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNGaW5pdGVgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNGaW5pdGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiBuYXRpdmVJc0Zpbml0ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbihfKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gICAgICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgICAgIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzSW50ZWdlcmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc0ludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPT0gdG9JbnRlZ2VyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgICAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gICAgICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICAgICAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3Qoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gICAgICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTWFwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNNYXAobmV3IE1hcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc01hcChuZXcgV2Vha01hcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNNYXAgPSBub2RlSXNNYXAgPyBiYXNlVW5hcnkobm9kZUlzTWFwKSA6IGJhc2VJc01hcDtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBgb2JqZWN0YCBhbmQgYHNvdXJjZWAgdG9cbiAgICAgKiBkZXRlcm1pbmUgaWYgYG9iamVjdGAgY29udGFpbnMgZXF1aXZhbGVudCBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgXy5tYXRjaGVzYCB3aGVuIGBzb3VyY2VgIGlzXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdCBgc291cmNlYFxuICAgICAqIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlIGBfLmlzRXF1YWxgXG4gICAgICogZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2InOiAxIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXRjaChvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBnZXRNYXRjaERhdGEoc291cmNlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc01hdGNoYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBjb21wYXJpc29uc1xuICAgICAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggZml2ZVxuICAgICAqIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwgaW5kZXh8a2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNHcmVldGluZyh2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIC9eaCg/Oml8ZWxsbykkLy50ZXN0KHZhbHVlKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgaWYgKGlzR3JlZXRpbmcob2JqVmFsdWUpICYmIGlzR3JlZXRpbmcoc3JjVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdncmVldGluZyc6ICdoZWxsbycgfTtcbiAgICAgKiB2YXIgc291cmNlID0geyAnZ3JlZXRpbmcnOiAnaGknIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2hXaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXRjaFdpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBOYU5gLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNOYU5gXShodHRwczovL21kbi5pby9OdW1iZXIvaXNOYU4pIGFuZCBpcyBub3QgdGhlIHNhbWUgYXNcbiAgICAgKiBnbG9iYWwgW2Bpc05hTmBdKGh0dHBzOi8vbWRuLmlvL2lzTmFOKSB3aGljaCByZXR1cm5zIGB0cnVlYCBmb3JcbiAgICAgKiBgdW5kZWZpbmVkYCBhbmQgb3RoZXIgbm9uLW51bWJlciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4oTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAgICAgLy8gQW4gYE5hTmAgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZi5cbiAgICAgIC8vIFBlcmZvcm0gdGhlIGB0b1N0cmluZ1RhZ2AgY2hlY2sgZmlyc3QgdG8gYXZvaWQgZXJyb3JzIHdpdGggc29tZVxuICAgICAgLy8gQWN0aXZlWCBvYmplY3RzIGluIElFLlxuICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSAhPSArdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcmlzdGluZSBuYXRpdmUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgY2FuJ3QgcmVsaWFibHkgZGV0ZWN0IG5hdGl2ZSBmdW5jdGlvbnMgaW4gdGhlIHByZXNlbmNlXG4gICAgICogb2YgdGhlIGNvcmUtanMgcGFja2FnZSBiZWNhdXNlIGNvcmUtanMgY2lyY3VtdmVudHMgdGhpcyBraW5kIG9mIGRldGVjdGlvbi5cbiAgICAgKiBEZXNwaXRlIG11bHRpcGxlIHJlcXVlc3RzLCB0aGUgY29yZS1qcyBtYWludGFpbmVyIGhhcyBtYWRlIGl0IGNsZWFyOiBhbnlcbiAgICAgKiBhdHRlbXB0IHRvIGZpeCB0aGUgZGV0ZWN0aW9uIHdpbGwgYmUgb2JzdHJ1Y3RlZC4gQXMgYSByZXN1bHQsIHdlJ3JlIGxlZnRcbiAgICAgKiB3aXRoIGxpdHRsZSBjaG9pY2UgYnV0IHRvIHRocm93IGFuIGVycm9yLiBVbmZvcnR1bmF0ZWx5LCB0aGlzIGFsc28gYWZmZWN0c1xuICAgICAqIHBhY2thZ2VzLCBsaWtlIFtiYWJlbC1wb2x5ZmlsbF0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYmFiZWwtcG9seWZpbGwpLFxuICAgICAqIHdoaWNoIHJlbHkgb24gY29yZS1qcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShfKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICBpZiAoaXNNYXNrYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKENPUkVfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBudWxsYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbCh2b2lkIDApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBudWxsaXNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05pbCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmlsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE51bWJlcmAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUbyBleGNsdWRlIGBJbmZpbml0eWAsIGAtSW5maW5pdHlgLCBhbmQgYE5hTmAsIHdoaWNoIGFyZVxuICAgICAqIGNsYXNzaWZpZWQgYXMgbnVtYmVycywgdXNlIHRoZSBgXy5pc0Zpbml0ZWAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gbnVtYmVyVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gICAgICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuOC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICAgICAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgICAgIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBSZWdFeHBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSByZWdleHAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgvYWJjLyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgnL2FiYy8nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1JlZ0V4cCA9IG5vZGVJc1JlZ0V4cCA/IGJhc2VVbmFyeShub2RlSXNSZWdFeHApIDogYmFzZUlzUmVnRXhwO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBzYWZlIGludGVnZXIuIEFuIGludGVnZXIgaXMgc2FmZSBpZiBpdCdzIGFuIElFRUUtNzU0XG4gICAgICogZG91YmxlIHByZWNpc2lvbiBudW1iZXIgd2hpY2ggaXNuJ3QgdGhlIHJlc3VsdCBvZiBhIHJvdW5kZWQgdW5zYWZlIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc1NhZmVJbnRlZ2VyYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzU2FmZUludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNhZmUgaW50ZWdlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU2FmZUludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0ludGVnZXIodmFsdWUpICYmIHZhbHVlID49IC1NQVhfU0FGRV9JTlRFR0VSICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1NldChuZXcgU2V0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICAgICAoIWlzQXJyYXkodmFsdWUpICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3RyaW5nVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZChudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFdlYWtNYXBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB3ZWFrIG1hcCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha01hcChuZXcgV2Vha01hcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtNYXAobmV3IE1hcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1dlYWtNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gd2Vha01hcFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFdlYWtTZXRgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB3ZWFrIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha1NldChuZXcgV2Vha1NldCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtTZXQobmV3IFNldCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1dlYWtTZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHdlYWtTZXRUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5ndFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmx0KDEsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHQoMywgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8ubHQoMywgMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgbHQgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGJhc2VMdCk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0b1xuICAgICAqICBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmd0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBsdGUgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlIDw9IG90aGVyO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0FycmF5KHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KDEpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkobnVsbCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSA/IHN0cmluZ1RvQXJyYXkodmFsdWUpIDogY29weUFycmF5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzeW1JdGVyYXRvciAmJiB2YWx1ZVtzeW1JdGVyYXRvcl0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVG9BcnJheSh2YWx1ZVtzeW1JdGVyYXRvcl0oKSk7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgICBmdW5jID0gdGFnID09IG1hcFRhZyA/IG1hcFRvQXJyYXkgOiAodGFnID09IHNldFRhZyA/IHNldFRvQXJyYXkgOiB2YWx1ZXMpO1xuXG4gICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMi4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoMy4yKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gNWUtMzI0XG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZSgnMy4yJyk7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gICAgICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICAgICAgdmFyIHNpZ24gPSAodmFsdWUgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYFRvSW50ZWdlcmBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2ludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcigzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICAgICAgcmVtYWluZGVyID0gcmVzdWx0ICUgMTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlciBzdWl0YWJsZSBmb3IgdXNlIGFzIHRoZSBsZW5ndGggb2YgYW5cbiAgICAgKiBhcnJheS1saWtlIG9iamVjdC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDQyOTQ5NjcyOTVcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0xlbmd0aCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID8gYmFzZUNsYW1wKHRvSW50ZWdlcih2YWx1ZSksIDAsIE1BWF9BUlJBWV9MRU5HVEgpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b051bWJlcigzLjIpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqXG4gICAgICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiA1ZS0zMjRcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IEluZmluaXR5XG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBOQU47XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gICAgICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICAgICAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgICAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gICAgICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzYWZlIGludGVnZXIuIEEgc2FmZSBpbnRlZ2VyIGNhbiBiZSBjb21wYXJlZCBhbmRcbiAgICAgKiByZXByZXNlbnRlZCBjb3JyZWN0bHkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcigzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDkwMDcxOTkyNTQ3NDA5OTFcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcignMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU2FmZUludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICA/IGJhc2VDbGFtcCh0b0ludGVnZXIodmFsdWUpLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUilcbiAgICAgICAgOiAodmFsdWUgPT09IDAgPyB2YWx1ZSA6IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gICAgICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1N0cmluZyhudWxsKTtcbiAgICAgKiAvLyA9PiAnJ1xuICAgICAqXG4gICAgICogXy50b1N0cmluZygtMCk7XG4gICAgICogLy8gPT4gJy0wJ1xuICAgICAqXG4gICAgICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+ICcxLDIsMydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGVcbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgKiBTdWJzZXF1ZW50IHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YCBhbmQgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgT2JqZWN0LmFzc2lnbmBdKGh0dHBzOi8vbWRuLmlvL09iamVjdC9hc3NpZ24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduSW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBCYXIoKSB7XG4gICAgICogICB0aGlzLmMgPSAzO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYiA9IDI7XG4gICAgICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgaWYgKGlzUHJvdG90eXBlKHNvdXJjZSkgfHwgaXNBcnJheUxpa2Uoc291cmNlKSkge1xuICAgICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIG93biBhbmRcbiAgICAgKiBpbmhlcml0ZWQgc291cmNlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBleHRlbmRcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEJhcigpIHtcbiAgICAgKiAgIHRoaXMuYyA9IDM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAgICAgKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICAgICAqXG4gICAgICogXy5hc3NpZ25Jbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMsICdkJzogNCB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbkluID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduSW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZXh0ZW5kV2l0aFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25XaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduSW5XaXRoLCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ25JbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbkluV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbldpdGgsIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIGBwYXRoc2Agb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcGlja2VkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfSwgNF0gfTtcbiAgICAgKlxuICAgICAqIF8uYXQob2JqZWN0LCBbJ2FbMF0uYi5jJywgJ2FbMV0nXSk7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICovXG4gICAgdmFyIGF0ID0gZmxhdFJlc3QoYmFzZUF0KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgYHByb3RvdHlwZWAgb2JqZWN0LiBJZiBhXG4gICAgICogYHByb3BlcnRpZXNgIG9iamVjdCBpcyBnaXZlbiwgaXRzIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzXG4gICAgICogYXJlIGFzc2lnbmVkIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gVGhlIHByb3BlcnRpZXMgdG8gYXNzaWduIHRvIHRoZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBDaXJjbGUoKSB7XG4gICAgICogICBTaGFwZS5jYWxsKHRoaXMpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIENpcmNsZS5wcm90b3R5cGUgPSBfLmNyZWF0ZShTaGFwZS5wcm90b3R5cGUsIHtcbiAgICAgKiAgICdjb25zdHJ1Y3Rvcic6IENpcmNsZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIGNpcmNsZSA9IG5ldyBDaXJjbGU7XG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgQ2lyY2xlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIFNoYXBlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXMgPT0gbnVsbCA/IHJlc3VsdCA6IGJhc2VBc3NpZ24ocmVzdWx0LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlXG4gICAgICogb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0XG4gICAgICogcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAqIE9uY2UgYSBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgdmFsdWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmRlZmF1bHRzRGVlcFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIHZhciBkZWZhdWx0cyA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgdmFyIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoO1xuICAgICAgdmFyIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICB2YXIgcHJvcHMgPSBrZXlzSW4oc291cmNlKTtcbiAgICAgICAgdmFyIHByb3BzSW5kZXggPSAtMTtcbiAgICAgICAgdmFyIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgrK3Byb3BzSW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1twcm9wc0luZGV4XTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgIChlcSh2YWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICAgICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGVmYXVsdHNgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGFzc2lnbnNcbiAgICAgKiBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmRlZmF1bHRzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdHNEZWVwKHsgJ2EnOiB7ICdiJzogMiB9IH0sIHsgJ2EnOiB7ICdiJzogMSwgJ2MnOiAzIH0gfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2InOiAyLCAnYyc6IDMgfSB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzRGVlcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIGFyZ3MucHVzaCh1bmRlZmluZWQsIGN1c3RvbURlZmF1bHRzTWVyZ2UpO1xuICAgICAgcmV0dXJuIGFwcGx5KG1lcmdlV2l0aCwgdW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUga2V5IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsXG4gICAgICogIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5JyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kS2V5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gYmFzZUZpbmRLZXkob2JqZWN0LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBiYXNlRm9yT3duKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRLZXlgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBhIGNvbGxlY3Rpb24gaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsXG4gICAgICogIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gcmV0dXJucyAncGViYmxlcycgYXNzdW1pbmcgYF8uZmluZEtleWAgcmV0dXJucyAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGJhc2VGb3JPd25SaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGFuXG4gICAgICogb2JqZWN0IGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXRcbiAgICAgKiBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvckluUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW4obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJywgJ2InLCB0aGVuICdjJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJbihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGxcbiAgICAgICAgPyBvYmplY3RcbiAgICAgICAgOiBiYXNlRm9yKG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9ySW5gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllcyBvZlxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvckluXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvckluUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdjJywgJ2InLCB0aGVuICdhJyBhc3N1bWluZyBgXy5mb3JJbmAgbG9ncyAnYScsICdiJywgdGhlbiAnYycuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ySW5SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGxcbiAgICAgICAgPyBvYmplY3RcbiAgICAgICAgOiBiYXNlRm9yUmlnaHQob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBhbiBvYmplY3QgYW5kXG4gICAgICogaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvblxuICAgICAqIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JPd25SaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JPd24obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yT3duKG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvck93bmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXG4gICAgICogYG9iamVjdGAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9yT3duXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93blJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYicgdGhlbiAnYScgYXNzdW1pbmcgYF8uZm9yT3duYCBsb2dzICdhJyB0aGVuICdiJy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JPd25SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JPd25SaWdodChvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmcm9tIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAgICAgKiBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqIEBzZWUgXy5mdW5jdGlvbnNJblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSBfLmNvbnN0YW50KCdhJyk7XG4gICAgICogICB0aGlzLmIgPSBfLmNvbnN0YW50KCdiJyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gXy5jb25zdGFudCgnYycpO1xuICAgICAqXG4gICAgICogXy5mdW5jdGlvbnMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9ucyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZUZ1bmN0aW9ucyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmcm9tIG93biBhbmQgaW5oZXJpdGVkXG4gICAgICogZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICogQHNlZSBfLmZ1bmN0aW9uc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSBfLmNvbnN0YW50KCdhJyk7XG4gICAgICogICB0aGlzLmIgPSBfLmNvbnN0YW50KCdiJyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gXy5jb25zdGFudCgnYycpO1xuICAgICAqXG4gICAgICogXy5mdW5jdGlvbnNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZUZ1bmN0aW9ucyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICAgICAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiB7ICdiJzogMiB9IH07XG4gICAgICogdmFyIG90aGVyID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgJ2EuYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob3RoZXIsICdhJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXMob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgaW52ZXJ0ZWQga2V5cyBhbmQgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqIElmIGBvYmplY3RgIGNvbnRhaW5zIGR1cGxpY2F0ZSB2YWx1ZXMsIHN1YnNlcXVlbnQgdmFsdWVzIG92ZXJ3cml0ZVxuICAgICAqIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMSc6ICdjJywgJzInOiAnYicgfVxuICAgICAqL1xuICAgIHZhciBpbnZlcnQgPSBjcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0W3ZhbHVlXSA9IGtleTtcbiAgICB9LCBjb25zdGFudChpZGVudGl0eSkpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnZlcnRgIGV4Y2VwdCB0aGF0IHRoZSBpbnZlcnRlZCBvYmplY3QgaXMgZ2VuZXJhdGVkXG4gICAgICogZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nIGVhY2ggZWxlbWVudCBvZiBgb2JqZWN0YCB0aHJ1IGBpdGVyYXRlZWAuIFRoZVxuICAgICAqIGNvcnJlc3BvbmRpbmcgaW52ZXJ0ZWQgdmFsdWUgb2YgZWFjaCBpbnZlcnRlZCBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5c1xuICAgICAqIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBpbnZlcnRlZCB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmludmVydEJ5KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuICAgICAqXG4gICAgICogXy5pbnZlcnRCeShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gJ2dyb3VwJyArIHZhbHVlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2dyb3VwMSc6IFsnYScsICdjJ10sICdncm91cDInOiBbJ2InXSB9XG4gICAgICovXG4gICAgdmFyIGludmVydEJ5ID0gY3JlYXRlSW52ZXJ0ZXIoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdFt2YWx1ZV0ucHVzaChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W3ZhbHVlXSA9IFtrZXldO1xuICAgICAgfVxuICAgIH0sIGdldEl0ZXJhdGVlKTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiBbMSwgMiwgMywgNF0gfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5pbnZva2Uob2JqZWN0LCAnYVswXS5iLmMuc2xpY2UnLCAxLCAzKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKi9cbiAgICB2YXIgaW52b2tlID0gYmFzZVJlc3QoYmFzZUludm9rZSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gICAgICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmtleXMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogXy5rZXlzKCdoaScpO1xuICAgICAqIC8vID0+IFsnMCcsICcxJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5c0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5tYXBWYWx1ZXNgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZVxuICAgICAqIHNhbWUgdmFsdWVzIGFzIGBvYmplY3RgIGFuZCBrZXlzIGdlbmVyYXRlZCBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGVcbiAgICAgKiBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBzZWUgXy5tYXBWYWx1ZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXBLZXlzKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgcmV0dXJuIGtleSArIHZhbHVlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2ExJzogMSwgJ2IyJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwS2V5cyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKTtcblxuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIGBvYmplY3RgIGFuZCB2YWx1ZXMgZ2VuZXJhdGVkXG4gICAgICogYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1XG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAgICAgKiBAc2VlIF8ubWFwS2V5c1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnZnJlZCc6ICAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWFwVmFsdWVzKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZTsgfSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXBWYWx1ZXModXNlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXG4gICAgICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAgICAgKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICAgICAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICAgICAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlciA9IHtcbiAgICAgKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCkge1xuICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1lcmdlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgbWVyZ2VkIHZhbHVlcyBvZiB0aGUgZGVzdGluYXRpb24gYW5kIHNvdXJjZVxuICAgICAqIHByb3BlcnRpZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBtZXJnaW5nIGlzIGhhbmRsZWQgYnkgdGhlXG4gICAgICogbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIHNpeCBhcmd1bWVudHM6XG4gICAgICogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gb2JqVmFsdWUuY29uY2F0KHNyY1ZhbHVlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFsxXSwgJ2InOiBbMl0gfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogWzNdLCAnYic6IFs0XSB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZVdpdGgob2JqZWN0LCBvdGhlciwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4geyAnYSc6IFsxLCAzXSwgJ2InOiBbMiwgNF0gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZVdpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGVcbiAgICAgKiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IHBhdGhzIG9mIGBvYmplY3RgIHRoYXQgYXJlIG5vdCBvbWl0dGVkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGNvbnNpZGVyYWJseSBzbG93ZXIgdGhhbiBgXy5waWNrYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIG9taXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLm9taXQob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAgICAgKiAvLyA9PiB7ICdiJzogJzInIH1cbiAgICAgKi9cbiAgICB2YXIgb21pdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGlzRGVlcCA9IGZhbHNlO1xuICAgICAgcGF0aHMgPSBhcnJheU1hcChwYXRocywgZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgICAgaXNEZWVwIHx8IChpc0RlZXAgPSBwYXRoLmxlbmd0aCA+IDEpO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH0pO1xuICAgICAgY29weU9iamVjdChvYmplY3QsIGdldEFsbEtleXNJbihvYmplY3QpLCByZXN1bHQpO1xuICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICByZXN1bHQgPSBiYXNlQ2xvbmUocmVzdWx0LCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9GTEFUX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbU9taXRDbG9uZSk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGJhc2VVbnNldChyZXN1bHQsIHBhdGhzW2xlbmd0aF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrQnlgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZlxuICAgICAqIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgIHRoYXRcbiAgICAgKiBgcHJlZGljYXRlYCBkb2Vzbid0IHJldHVybiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d29cbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwga2V5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5vbWl0Qnkob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAgICAgKiAvLyA9PiB7ICdiJzogJzInIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbWl0Qnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBwaWNrQnkob2JqZWN0LCBuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgYG9iamVjdGAgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLnBpY2sob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICB2YXIgcGljayA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgYG9iamVjdGAgcHJvcGVydGllcyBgcHJlZGljYXRlYCByZXR1cm5zXG4gICAgICogdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLnBpY2tCeShvYmplY3QsIF8uaXNOdW1iZXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBpY2tCeShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wcyA9IGFycmF5TWFwKGdldEFsbEtleXNJbihvYmplY3QpLCBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIHJldHVybiBbcHJvcF07XG4gICAgICB9KTtcbiAgICAgIHByZWRpY2F0ZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSk7XG4gICAgICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHByb3BzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlKHZhbHVlLCBwYXRoWzBdKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZ2V0YCBleGNlcHQgdGhhdCBpZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXMgYVxuICAgICAqIGZ1bmN0aW9uIGl0J3MgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBpdHMgcGFyZW50IG9iamVjdCBhbmRcbiAgICAgKiBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gcmVzb2x2ZS5cbiAgICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MxJzogMywgJ2MyJzogXy5jb25zdGFudCg0KSB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzEnKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzInKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzMnLCAnZGVmYXVsdCcpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMzJywgXy5jb25zdGFudCgnZGVmYXVsdCcpKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgICAgLy8gRW5zdXJlIHRoZSBsb29wIGlzIGVudGVyZWQgd2hlbiBwYXRoIGlzIGVtcHR5LlxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgb2JqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3RbdG9LZXkocGF0aFtpbmRleF0pXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIGEgcG9ydGlvbiBvZiBgcGF0aGAgZG9lc24ndCBleGlzdCxcbiAgICAgKiBpdCdzIGNyZWF0ZWQuIEFycmF5cyBhcmUgY3JlYXRlZCBmb3IgbWlzc2luZyBpbmRleCBwcm9wZXJ0aWVzIHdoaWxlIG9iamVjdHNcbiAgICAgKiBhcmUgY3JlYXRlZCBmb3IgYWxsIG90aGVyIG1pc3NpbmcgcHJvcGVydGllcy4gVXNlIGBfLnNldFdpdGhgIHRvIGN1c3RvbWl6ZVxuICAgICAqIGBwYXRoYCBjcmVhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uc2V0KG9iamVjdCwgJ2FbMF0uYi5jJywgNCk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnNldChvYmplY3QsIFsneCcsICcwJywgJ3knLCAneiddLCA1KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNldGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG9iamVjdHMgb2YgYHBhdGhgLiAgSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBwYXRoIGNyZWF0aW9uIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKG5zVmFsdWUsIGtleSwgbnNPYmplY3QpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHt9O1xuICAgICAqXG4gICAgICogXy5zZXRXaXRoKG9iamVjdCwgJ1swXVsxXScsICdhJywgT2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcwJzogeyAnMSc6ICdhJyB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRXaXRoKG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQtdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgXG4gICAgICogd2hpY2ggY2FuIGJlIGNvbnN1bWVkIGJ5IGBfLmZyb21QYWlyc2AuIElmIGBvYmplY3RgIGlzIGEgbWFwIG9yIHNldCwgaXRzXG4gICAgICogZW50cmllcyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZW50cmllc1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnRvUGFpcnMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gW1snYScsIDFdLCBbJ2InLCAyXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgdG9QYWlycyA9IGNyZWF0ZVRvUGFpcnMoa2V5cyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkLXZhbHVlIHBhaXJzXG4gICAgICogZm9yIGBvYmplY3RgIHdoaWNoIGNhbiBiZSBjb25zdW1lZCBieSBgXy5mcm9tUGFpcnNgLiBJZiBgb2JqZWN0YCBpcyBhIG1hcFxuICAgICAqIG9yIHNldCwgaXRzIGVudHJpZXMgYXJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGVudHJpZXNJblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnRvUGFpcnNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMV0sIFsnYicsIDJdLCBbJ2MnLCAzXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgdG9QYWlyc0luID0gY3JlYXRlVG9QYWlycyhrZXlzSW4pO1xuXG4gICAgLyoqXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYDsgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuICAgICAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBvd25cbiAgICAgKiBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIHRocnUgYGl0ZXJhdGVlYCwgd2l0aCBlYWNoIGludm9jYXRpb25cbiAgICAgKiBwb3RlbnRpYWxseSBtdXRhdGluZyB0aGUgYGFjY3VtdWxhdG9yYCBvYmplY3QuIElmIGBhY2N1bXVsYXRvcmAgaXMgbm90XG4gICAgICogcHJvdmlkZWQsIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIGBbW1Byb3RvdHlwZV1dYCB3aWxsIGJlIHVzZWQuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgY3VzdG9tIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oWzIsIDMsIDRdLCBmdW5jdGlvbihyZXN1bHQsIG4pIHtcbiAgICAgKiAgIHJlc3VsdC5wdXNoKG4gKj0gbik7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDldXG4gICAgICpcbiAgICAgKiBfLnRyYW5zZm9ybSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKG9iamVjdCwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICAgICAgaXNBcnJMaWtlID0gaXNBcnIgfHwgaXNCdWZmZXIob2JqZWN0KSB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KTtcblxuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCk7XG4gICAgICBpZiAoYWNjdW11bGF0b3IgPT0gbnVsbCkge1xuICAgICAgICB2YXIgQ3RvciA9IG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICAgIGlmIChpc0Fyckxpa2UpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGlzQXJyID8gbmV3IEN0b3IgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0Z1bmN0aW9uKEN0b3IpID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSkgOiB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAoaXNBcnJMaWtlID8gYXJyYXlFYWNoIDogYmFzZUZvck93bikob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHByb3BlcnR5IGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHVuc2V0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDcgfSB9XSB9O1xuICAgICAqIF8udW5zZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IHt9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnVuc2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzoge30gfV0gfTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnNldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHRydWUgOiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNldGAgZXhjZXB0IHRoYXQgYWNjZXB0cyBgdXBkYXRlcmAgdG8gcHJvZHVjZSB0aGVcbiAgICAgKiB2YWx1ZSB0byBzZXQuIFVzZSBgXy51cGRhdGVXaXRoYCB0byBjdXN0b21pemUgYHBhdGhgIGNyZWF0aW9uLiBUaGUgYHVwZGF0ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZShvYmplY3QsICdhWzBdLmIuYycsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gKiBuOyB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKlxuICAgICAqIF8udXBkYXRlKG9iamVjdCwgJ3hbMF0ueS56JywgZnVuY3Rpb24obikgeyByZXR1cm4gbiA/IG4gKyAxIDogMDsgfSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlKG9iamVjdCwgcGF0aCwgdXBkYXRlcikge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIGNhc3RGdW5jdGlvbih1cGRhdGVyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51cGRhdGVgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBvYmplY3RzIG9mIGBwYXRoYC4gIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogcGF0aCBjcmVhdGlvbiBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6IChuc1ZhbHVlLCBrZXksIG5zT2JqZWN0KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge307XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZVdpdGgob2JqZWN0LCAnWzBdWzFdJywgXy5jb25zdGFudCgnYScpLCBPYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzAnOiB7ICcxJzogJ2EnIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVdpdGgob2JqZWN0LCBwYXRoLCB1cGRhdGVyLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgY2FzdEZ1bmN0aW9uKHVwZGF0ZXIpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy52YWx1ZXMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLnZhbHVlcygnaGknKTtcbiAgICAgKiAvLyA9PiBbJ2gnLCAnaSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eVxuICAgICAqIHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udmFsdWVzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ2xhbXBzIGBudW1iZXJgIHdpdGhpbiB0aGUgaW5jbHVzaXZlIGBsb3dlcmAgYW5kIGB1cHBlcmAgYm91bmRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jbGFtcCgtMTAsIC01LCA1KTtcbiAgICAgKiAvLyA9PiAtNVxuICAgICAqXG4gICAgICogXy5jbGFtcCgxMCwgLTUsIDUpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICAgICAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXBwZXIgPSBsb3dlcjtcbiAgICAgICAgbG93ZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cHBlciA9IHRvTnVtYmVyKHVwcGVyKTtcbiAgICAgICAgdXBwZXIgPSB1cHBlciA9PT0gdXBwZXIgPyB1cHBlciA6IDA7XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb3dlciA9IHRvTnVtYmVyKGxvd2VyKTtcbiAgICAgICAgbG93ZXIgPSBsb3dlciA9PT0gbG93ZXIgPyBsb3dlciA6IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUNsYW1wKHRvTnVtYmVyKG51bWJlciksIGxvd2VyLCB1cHBlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBuYCBpcyBiZXR3ZWVuIGBzdGFydGAgYW5kIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIElmXG4gICAgICogYGVuZGAgaXMgbm90IHNwZWNpZmllZCwgaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICAgICAqIElmIGBzdGFydGAgaXMgZ3JlYXRlciB0aGFuIGBlbmRgIHRoZSBwYXJhbXMgYXJlIHN3YXBwZWQgdG8gc3VwcG9ydFxuICAgICAqIG5lZ2F0aXZlIHJhbmdlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjMuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBudW1iZXJgIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5yYW5nZSwgXy5yYW5nZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgzLCAyLCA0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNCwgOCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMiwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgxLjIsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg1LjIsIDQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoLTMsIC0yLCAtNik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKSB7XG4gICAgICBzdGFydCA9IHRvRmluaXRlKHN0YXJ0KTtcbiAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcbiAgICAgIH1cbiAgICAgIG51bWJlciA9IHRvTnVtYmVyKG51bWJlcik7XG4gICAgICByZXR1cm4gYmFzZUluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiB0aGUgaW5jbHVzaXZlIGBsb3dlcmAgYW5kIGB1cHBlcmAgYm91bmRzLlxuICAgICAqIElmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGEgbnVtYmVyIGJldHdlZW4gYDBgIGFuZCB0aGUgZ2l2ZW4gbnVtYmVyXG4gICAgICogaXMgcmV0dXJuZWQuIElmIGBmbG9hdGluZ2AgaXMgYHRydWVgLCBvciBlaXRoZXIgYGxvd2VyYCBvciBgdXBwZXJgIGFyZVxuICAgICAqIGZsb2F0cywgYSBmbG9hdGluZy1wb2ludCBudW1iZXIgaXMgcmV0dXJuZWQgaW5zdGVhZCBvZiBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEphdmFTY3JpcHQgZm9sbG93cyB0aGUgSUVFRS03NTQgc3RhbmRhcmQgZm9yIHJlc29sdmluZ1xuICAgICAqIGZsb2F0aW5nLXBvaW50IHZhbHVlcyB3aGljaCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcj0wXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt1cHBlcj0xXSBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZmxvYXRpbmddIFNwZWNpZnkgcmV0dXJuaW5nIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDAsIDUpO1xuICAgICAqIC8vID0+IGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1KTtcbiAgICAgKiAvLyA9PiBhbHNvIGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1LCB0cnVlKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDEuMiwgNS4yKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDEuMiBhbmQgNS4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZG9tKGxvd2VyLCB1cHBlciwgZmxvYXRpbmcpIHtcbiAgICAgIGlmIChmbG9hdGluZyAmJiB0eXBlb2YgZmxvYXRpbmcgIT0gJ2Jvb2xlYW4nICYmIGlzSXRlcmF0ZWVDYWxsKGxvd2VyLCB1cHBlciwgZmxvYXRpbmcpKSB7XG4gICAgICAgIHVwcGVyID0gZmxvYXRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHVwcGVyID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gdXBwZXI7XG4gICAgICAgICAgdXBwZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxvd2VyID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gbG93ZXI7XG4gICAgICAgICAgbG93ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciA9PT0gdW5kZWZpbmVkICYmIHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG93ZXIgPSAwO1xuICAgICAgICB1cHBlciA9IDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbG93ZXIgPSB0b0Zpbml0ZShsb3dlcik7XG4gICAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdXBwZXIgPSBsb3dlcjtcbiAgICAgICAgICBsb3dlciA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBwZXIgPSB0b0Zpbml0ZSh1cHBlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciA+IHVwcGVyKSB7XG4gICAgICAgIHZhciB0ZW1wID0gbG93ZXI7XG4gICAgICAgIGxvd2VyID0gdXBwZXI7XG4gICAgICAgIHVwcGVyID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyB8fCBsb3dlciAlIDEgfHwgdXBwZXIgJSAxKSB7XG4gICAgICAgIHZhciByYW5kID0gbmF0aXZlUmFuZG9tKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVNaW4obG93ZXIgKyAocmFuZCAqICh1cHBlciAtIGxvd2VyICsgZnJlZVBhcnNlRmxvYXQoJzFlLScgKyAoKHJhbmQgKyAnJykubGVuZ3RoIC0gMSkpKSksIHVwcGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcik7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gW2NhbWVsIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhbWVsQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYW1lbCBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCctLWZvby1iYXItLScpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqL1xuICAgIHZhciBjYW1lbENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gY2FwaXRhbGl6ZSh3b3JkKSA6IHdvcmQpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlIGFuZCB0aGUgcmVtYWluaW5nXG4gICAgICogdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjYXBpdGFsaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhcGl0YWxpemVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYXBpdGFsaXplKCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiB1cHBlckZpcnN0KHRvU3RyaW5nKHN0cmluZykudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVidXJycyBgc3RyaW5nYCBieSBjb252ZXJ0aW5nXG4gICAgICogW0xhdGluLTEgU3VwcGxlbWVudF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW4tMV9TdXBwbGVtZW50XyhVbmljb2RlX2Jsb2NrKSNDaGFyYWN0ZXJfdGFibGUpXG4gICAgICogYW5kIFtMYXRpbiBFeHRlbmRlZC1BXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbl9FeHRlbmRlZC1BKVxuICAgICAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycyBhbmQgcmVtb3ZpbmdcbiAgICAgKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGRlYnVyci5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVidXJyKCdkw6lqw6AgdnUnKTtcbiAgICAgKiAvLyA9PiAnZGVqYSB2dSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJ1cnIoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIHN0cmluZyAmJiBzdHJpbmcucmVwbGFjZShyZUxhdGluLCBkZWJ1cnJMZXR0ZXIpLnJlcGxhY2UocmVDb21ib01hcmssICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc2l0aW9uPXN0cmluZy5sZW5ndGhdIFRoZSBwb3NpdGlvbiB0byBzZWFyY2ggdXAgdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCBgdGFyZ2V0YCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJywgMik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuZHNXaXRoKHN0cmluZywgdGFyZ2V0LCBwb3NpdGlvbikge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHRhcmdldCA9IGJhc2VUb1N0cmluZyh0YXJnZXQpO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGxlbmd0aFxuICAgICAgICA6IGJhc2VDbGFtcCh0b0ludGVnZXIocG9zaXRpb24pLCAwLCBsZW5ndGgpO1xuXG4gICAgICB2YXIgZW5kID0gcG9zaXRpb247XG4gICAgICBwb3NpdGlvbiAtPSB0YXJnZXQubGVuZ3RoO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID49IDAgJiYgc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBlbmQpID09IHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBcIiZcIiwgXCI8XCIsIFwiPlwiLCAnXCInLCBhbmQgXCInXCIgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgZXNjYXBlZC4gVG8gZXNjYXBlIGFkZGl0aW9uYWxcbiAgICAgKiBjaGFyYWN0ZXJzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAgICAgKlxuICAgICAqIFRob3VnaCB0aGUgXCI+XCIgY2hhcmFjdGVyIGlzIGVzY2FwZWQgZm9yIHN5bW1ldHJ5LCBjaGFyYWN0ZXJzIGxpa2VcbiAgICAgKiBcIj5cIiBhbmQgXCIvXCIgZG9uJ3QgbmVlZCBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZ1xuICAgICAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBTZWVcbiAgICAgKiBbTWF0aGlhcyBCeW5lbnMncyBhcnRpY2xlXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMpXG4gICAgICogKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBXaGVuIHdvcmtpbmcgd2l0aCBIVE1MIHlvdSBzaG91bGQgYWx3YXlzXG4gICAgICogW3F1b3RlIGF0dHJpYnV0ZSB2YWx1ZXNdKGh0dHA6Ly93b25rby5jb20vcG9zdC9odG1sLWVzY2FwaW5nKSB0byByZWR1Y2VcbiAgICAgKiBYU1MgdmVjdG9ycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXNjYXBlcyB0aGUgYFJlZ0V4cGAgc3BlY2lhbCBjaGFyYWN0ZXJzIFwiXlwiLCBcIiRcIiwgXCJcXFwiLCBcIi5cIiwgXCIqXCIsIFwiK1wiLFxuICAgICAqIFwiP1wiLCBcIihcIiwgXCIpXCIsIFwiW1wiLCBcIl1cIiwgXCJ7XCIsIFwifVwiLCBhbmQgXCJ8XCIgaW4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZVJlZ0V4cCgnW2xvZGFzaF0oaHR0cHM6Ly9sb2Rhc2guY29tLyknKTtcbiAgICAgKiAvLyA9PiAnXFxbbG9kYXNoXFxdXFwoaHR0cHM6Ly9sb2Rhc2hcXC5jb20vXFwpJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1JlZ0V4cENoYXIudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gICAgICogW2tlYmFiIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1NwZWNpYWxfY2FzZV9zdHlsZXMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUga2ViYWIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICovXG4gICAgdmFyIGtlYmFiQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICctJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBzcGFjZSBzZXBhcmF0ZWQgd29yZHMsIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBsb3dlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubG93ZXJDYXNlKCctLUZvby1CYXItLScpO1xuICAgICAqIC8vID0+ICdmb28gYmFyJ1xuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb28gYmFyJ1xuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICovXG4gICAgdmFyIGxvd2VyQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubG93ZXJGaXJzdCgnRnJlZCcpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogXy5sb3dlckZpcnN0KCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ2ZSRUQnXG4gICAgICovXG4gICAgdmFyIGxvd2VyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvTG93ZXJDYXNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlcyBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC5cbiAgICAgKiBQYWRkaW5nIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGNhbid0IGJlIGV2ZW5seSBkaXZpZGVkIGJ5IGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4KTtcbiAgICAgKiAvLyA9PiAnICBhYmMgICAnXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgOCwgJ18tJyk7XG4gICAgICogLy8gPT4gJ18tYWJjXy1fJ1xuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIGlmICghbGVuZ3RoIHx8IHN0ckxlbmd0aCA+PSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBtaWQgPSAobGVuZ3RoIC0gc3RyTGVuZ3RoKSAvIDI7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBjcmVhdGVQYWRkaW5nKG5hdGl2ZUZsb29yKG1pZCksIGNoYXJzKSArXG4gICAgICAgIHN0cmluZyArXG4gICAgICAgIGNyZWF0ZVBhZGRpbmcobmF0aXZlQ2VpbChtaWQpLCBjaGFycylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgcmlnaHQgc2lkZSBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xuICAgICAqIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGV4Y2VlZCBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJ2FiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCA2LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjXy1fJ1xuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkRW5kKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIHJldHVybiAobGVuZ3RoICYmIHN0ckxlbmd0aCA8IGxlbmd0aClcbiAgICAgICAgPyAoc3RyaW5nICsgY3JlYXRlUGFkZGluZyhsZW5ndGggLSBzdHJMZW5ndGgsIGNoYXJzKSlcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgbGVmdCBzaWRlIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXG4gICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDYpO1xuICAgICAqIC8vID0+ICcgICBhYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCA2LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1fYWJjJ1xuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWRTdGFydChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICByZXR1cm4gKGxlbmd0aCAmJiBzdHJMZW5ndGggPCBsZW5ndGgpXG4gICAgICAgID8gKGNyZWF0ZVBhZGRpbmcobGVuZ3RoIC0gc3RyTGVuZ3RoLCBjaGFycykgKyBzdHJpbmcpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZCByYWRpeC4gSWYgYHJhZGl4YCBpc1xuICAgICAqIGB1bmRlZmluZWRgIG9yIGAwYCwgYSBgcmFkaXhgIG9mIGAxMGAgaXMgdXNlZCB1bmxlc3MgYHZhbHVlYCBpcyBhXG4gICAgICogaGV4YWRlY2ltYWwsIGluIHdoaWNoIGNhc2UgYSBgcmFkaXhgIG9mIGAxNmAgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBhbGlnbnMgd2l0aCB0aGVcbiAgICAgKiBbRVM1IGltcGxlbWVudGF0aW9uXShodHRwczovL2VzNS5naXRodWIuaW8vI3gxNS4xLjIuMikgb2YgYHBhcnNlSW50YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl4PTEwXSBUaGUgcmFkaXggdG8gaW50ZXJwcmV0IGB2YWx1ZWAgYnkuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYXJzZUludCgnMDgnKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnMDgnLCAnMTAnXSwgXy5wYXJzZUludCk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlSW50KHN0cmluZywgcmFkaXgsIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgfHwgcmFkaXggPT0gbnVsbCkge1xuICAgICAgICByYWRpeCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHJhZGl4KSB7XG4gICAgICAgIHJhZGl4ID0gK3JhZGl4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZVBhcnNlSW50KHRvU3RyaW5nKHN0cmluZykucmVwbGFjZShyZVRyaW1TdGFydCwgJycpLCByYWRpeCB8fCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBlYXRzIHRoZSBnaXZlbiBzdHJpbmcgYG5gIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXBlYXQoJyonLCAzKTtcbiAgICAgKiAvLyA9PiAnKioqJ1xuICAgICAqXG4gICAgICogXy5yZXBlYXQoJ2FiYycsIDIpO1xuICAgICAqIC8vID0+ICdhYmNhYmMnXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMCk7XG4gICAgICogLy8gPT4gJydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBuLCBndWFyZCkge1xuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgbiwgZ3VhcmQpIDogbiA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVJlcGVhdCh0b1N0cmluZyhzdHJpbmcpLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBtYXRjaGVzIGZvciBgcGF0dGVybmAgaW4gYHN0cmluZ2Agd2l0aCBgcmVwbGFjZW1lbnRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BTdHJpbmcjcmVwbGFjZWBdKGh0dHBzOi8vbWRuLmlvL1N0cmluZy9yZXBsYWNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IHJlcGxhY2VtZW50IFRoZSBtYXRjaCByZXBsYWNlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBtb2RpZmllZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVwbGFjZSgnSGkgRnJlZCcsICdGcmVkJywgJ0Jhcm5leScpO1xuICAgICAqIC8vID0+ICdIaSBCYXJuZXknXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZSgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKGFyZ3NbMF0pO1xuXG4gICAgICByZXR1cm4gYXJncy5sZW5ndGggPCAzID8gc3RyaW5nIDogc3RyaW5nLnJlcGxhY2UoYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBbc25ha2UgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU25ha2VfY2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzbmFrZSBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnLS1GT08tQkFSLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKi9cbiAgICB2YXIgc25ha2VDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJ18nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGBzdHJpbmdgIGJ5IGBzZXBhcmF0b3JgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BTdHJpbmcjc3BsaXRgXShodHRwczovL21kbi5pby9TdHJpbmcvc3BsaXQpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHNwbGl0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gc2VwYXJhdG9yIFRoZSBzZXBhcmF0b3IgcGF0dGVybiB0byBzcGxpdCBieS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBUaGUgbGVuZ3RoIHRvIHRydW5jYXRlIHJlc3VsdHMgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzdHJpbmcgc2VnbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3BsaXQoJ2EtYi1jJywgJy0nLCAyKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3BsaXQoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICBpZiAobGltaXQgJiYgdHlwZW9mIGxpbWl0ICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCkpIHtcbiAgICAgICAgc2VwYXJhdG9yID0gbGltaXQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBsaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfQVJSQVlfTEVOR1RIIDogbGltaXQgPj4+IDA7XG4gICAgICBpZiAoIWxpbWl0KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChcbiAgICAgICAgICAgIHR5cGVvZiBzZXBhcmF0b3IgPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIChzZXBhcmF0b3IgIT0gbnVsbCAmJiAhaXNSZWdFeHAoc2VwYXJhdG9yKSlcbiAgICAgICAgICApKSB7XG4gICAgICAgIHNlcGFyYXRvciA9IGJhc2VUb1N0cmluZyhzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoIXNlcGFyYXRvciAmJiBoYXNVbmljb2RlKHN0cmluZykpIHtcbiAgICAgICAgICByZXR1cm4gY2FzdFNsaWNlKHN0cmluZ1RvQXJyYXkoc3RyaW5nKSwgMCwgbGltaXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nLnNwbGl0KHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gICAgICogW3N0YXJ0IGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1N0eWxpc3RpY19vcl9zcGVjaWFsaXNlZF91c2FnZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdGFydCBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCctLWZvby1iYXItLScpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICovXG4gICAgdmFyIHN0YXJ0Q2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHVwcGVyRmlyc3Qod29yZCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249MF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCBgdGFyZ2V0YCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PSBudWxsXG4gICAgICAgID8gMFxuICAgICAgICA6IGJhc2VDbGFtcCh0b0ludGVnZXIocG9zaXRpb24pLCAwLCBzdHJpbmcubGVuZ3RoKTtcblxuICAgICAgdGFyZ2V0ID0gYmFzZVRvU3RyaW5nKHRhcmdldCk7XG4gICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIHRhcmdldC5sZW5ndGgpID09IHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24gdGhhdCBjYW4gaW50ZXJwb2xhdGUgZGF0YSBwcm9wZXJ0aWVzXG4gICAgICogaW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlcnMsIEhUTUwtZXNjYXBlIGludGVycG9sYXRlZCBkYXRhIHByb3BlcnRpZXMgaW5cbiAgICAgKiBcImVzY2FwZVwiIGRlbGltaXRlcnMsIGFuZCBleGVjdXRlIEphdmFTY3JpcHQgaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuIERhdGFcbiAgICAgKiBwcm9wZXJ0aWVzIG1heSBiZSBhY2Nlc3NlZCBhcyBmcmVlIHZhcmlhYmxlcyBpbiB0aGUgdGVtcGxhdGUuIElmIGEgc2V0dGluZ1xuICAgICAqIG9iamVjdCBpcyBnaXZlbiwgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgYF8udGVtcGxhdGVgIHV0aWxpemVzXG4gICAgICogW3NvdXJjZVVSTHNdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmwpXG4gICAgICogZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxuICAgICAqIFtsb2Rhc2gncyBjdXN0b20gYnVpbGRzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzKS5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxuICAgICAqIFtDaHJvbWUncyBleHRlbnNpb25zIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSB0ZW1wbGF0ZSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXNjYXBlXVxuICAgICAqICBUaGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXZhbHVhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmV2YWx1YXRlXVxuICAgICAqICBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0cz1fLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c11cbiAgICAgKiAgQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBmcmVlIHZhcmlhYmxlcy5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlXVxuICAgICAqICBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc291cmNlVVJMPSdsb2Rhc2gudGVtcGxhdGVTb3VyY2VzW25dJ11cbiAgICAgKiAgVGhlIHNvdXJjZVVSTCBvZiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnZhcmlhYmxlPSdvYmonXVxuICAgICAqICBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlciB0byBlc2NhcGUgZGF0YSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAgICAgKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGV4ZWN1dGUgSmF2YVNjcmlwdCBhbmQgZ2VuZXJhdGUgSFRNTC5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBfLmZvckVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyB1c2VyKTsgJT4hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdiYXJuZXknIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBiYXJuZXkhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBFUyB0ZW1wbGF0ZSBsaXRlcmFsIGRlbGltaXRlciBhcyBhbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIC8vIERpc2FibGUgc3VwcG9ydCBieSByZXBsYWNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gJHsgdXNlciB9IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAncGViYmxlcycgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIHBlYmJsZXMhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIGJhY2tzbGFzaGVzIHRvIHRyZWF0IGRlbGltaXRlcnMgYXMgcGxhaW4gdGV4dC5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JT0gXCJcXFxcPCUtIHZhbHVlICVcXFxcPlwiICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndmFsdWUnOiAnaWdub3JlZCcgfSk7XG4gICAgICogLy8gPT4gJzwlLSB2YWx1ZSAlPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYC5cbiAgICAgKiB2YXIgdGV4dCA9ICc8JSBqcS5lYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nO1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUodGV4dCwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAgICAgKiBjb21waWxlZChkYXRhKTtcbiAgICAgKiAvLyA9PiBGaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yLlxuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICAgICAqIGNvbXBpbGVkLnNvdXJjZTtcbiAgICAgKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcbiAgICAgKiAvLyAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLnVzZXIgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAgICAgKiAvLyAgIHJldHVybiBfX3A7XG4gICAgICogLy8gfVxuICAgICAqXG4gICAgICogLy8gVXNlIGN1c3RvbSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLlxuICAgICAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8ge3sgdXNlciB9fSEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ211c3RhY2hlJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gICAgICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMuXG4gICAgICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2pzdC5qcycpLCAnXFxcbiAgICAgKiAgIHZhciBKU1QgPSB7XFxcbiAgICAgKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcbiAgICAgKiAgIH07XFxcbiAgICAgKiAnKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0ZW1wbGF0ZShzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSB7XG4gICAgICAvLyBCYXNlZCBvbiBKb2huIFJlc2lnJ3MgYHRtcGxgIGltcGxlbWVudGF0aW9uXG4gICAgICAvLyAoaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy8pXG4gICAgICAvLyBhbmQgTGF1cmEgRG9rdG9yb3ZhJ3MgZG9ULmpzIChodHRwczovL2dpdGh1Yi5jb20vb2xhZG8vZG9UKS5cbiAgICAgIHZhciBzZXR0aW5ncyA9IGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzO1xuXG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBvcHRpb25zID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLCBzZXR0aW5ncywgY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbik7XG5cbiAgICAgIHZhciBpbXBvcnRzID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pLFxuICAgICAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzVmFsdWVzID0gYmFzZVZhbHVlcyhpbXBvcnRzLCBpbXBvcnRzS2V5cyk7XG5cbiAgICAgIHZhciBpc0VzY2FwaW5nLFxuICAgICAgICAgIGlzRXZhbHVhdGluZyxcbiAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XG5cbiAgICAgIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cbiAgICAgIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXG4gICAgICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgICAgIChpbnRlcnBvbGF0ZSA9PT0gcmVJbnRlcnBvbGF0ZSA/IHJlRXNUZW1wbGF0ZSA6IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCQnXG4gICAgICAsICdnJyk7XG5cbiAgICAgIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgIC8vIFRoZSBzb3VyY2VVUkwgZ2V0cyBpbmplY3RlZCBpbnRvIHRoZSBzb3VyY2UgdGhhdCdzIGV2YWwtZWQsIHNvIGJlIGNhcmVmdWxcbiAgICAgIC8vIHRvIG5vcm1hbGl6ZSBhbGwga2luZHMgb2Ygd2hpdGVzcGFjZSwgc28gZS5nLiBuZXdsaW5lcyAoYW5kIHVuaWNvZGUgdmVyc2lvbnMgb2YgaXQpIGNhbid0IHNuZWFrIGluXG4gICAgICAvLyBhbmQgZXNjYXBlIHRoZSBjb21tZW50LCB0aHVzIGluamVjdGluZyBjb2RlIHRoYXQgZ2V0cyBldmFsZWQuXG4gICAgICB2YXIgc291cmNlVVJMID0gJy8vIyBzb3VyY2VVUkw9JyArXG4gICAgICAgIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdzb3VyY2VVUkwnKVxuICAgICAgICAgID8gKG9wdGlvbnMuc291cmNlVVJMICsgJycpLnJlcGxhY2UoL1xccy9nLCAnICcpXG4gICAgICAgICAgOiAoJ2xvZGFzaC50ZW1wbGF0ZVNvdXJjZXNbJyArICgrK3RlbXBsYXRlQ291bnRlcikgKyAnXScpXG4gICAgICAgICkgKyAnXFxuJztcblxuICAgICAgc3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgICAgIC8vIEVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2FuJ3QgYmUgaW5jbHVkZWQgaW4gc3RyaW5nIGxpdGVyYWxzLlxuICAgICAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxuICAgICAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgICAvLyBUaGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIG5lZWRzIGBtYXRjaGAgcmV0dXJuZWQgaW5cbiAgICAgICAgLy8gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7XG5cbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAgIC8vIElmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpbi5cbiAgICAgIHZhciB2YXJpYWJsZSA9IGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3ZhcmlhYmxlJykgJiYgb3B0aW9ucy52YXJpYWJsZTtcbiAgICAgIGlmICghdmFyaWFibGUpIHtcbiAgICAgICAgc291cmNlID0gJ3dpdGggKG9iaikge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gICAgICB9XG4gICAgICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXG4gICAgICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ01pZGRsZSwgJyQxJylcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgICAgIC8vIEZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gICAgICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArICh2YXJpYWJsZSB8fCAnb2JqJykgKyAnKSB7XFxuJyArXG4gICAgICAgICh2YXJpYWJsZVxuICAgICAgICAgID8gJydcbiAgICAgICAgICA6ICdvYmogfHwgKG9iaiA9IHt9KTtcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBcInZhciBfX3QsIF9fcCA9ICcnXCIgK1xuICAgICAgICAoaXNFc2NhcGluZ1xuICAgICAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xuICAgICAgICAgICA6ICcnXG4gICAgICAgICkgK1xuICAgICAgICAoaXNFdmFsdWF0aW5nXG4gICAgICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcbiAgICAgICAgICA6ICc7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgc291cmNlICtcbiAgICAgICAgJ3JldHVybiBfX3BcXG59JztcblxuICAgICAgdmFyIHJlc3VsdCA9IGF0dGVtcHQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbihpbXBvcnRzS2V5cywgc291cmNlVVJMICsgJ3JldHVybiAnICsgc291cmNlKVxuICAgICAgICAgIC5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCBvclxuICAgICAgLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgICAgIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBpZiAoaXNFcnJvcihyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIGEgd2hvbGUsIHRvIGxvd2VyIGNhc2UganVzdCBsaWtlXG4gICAgICogW1N0cmluZyN0b0xvd2VyQ2FzZV0oaHR0cHM6Ly9tZG4uaW8vdG9Mb3dlckNhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbG93ZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJy0tRm9vLUJhci0tJyk7XG4gICAgICogLy8gPT4gJy0tZm9vLWJhci0tJ1xuICAgICAqXG4gICAgICogXy50b0xvd2VyKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vYmFyJ1xuICAgICAqXG4gICAgICogXy50b0xvd2VyKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdfX2Zvb19iYXJfXydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0xvd2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIGEgd2hvbGUsIHRvIHVwcGVyIGNhc2UganVzdCBsaWtlXG4gICAgICogW1N0cmluZyN0b1VwcGVyQ2FzZV0oaHR0cHM6Ly9tZG4uaW8vdG9VcHBlckNhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdXBwZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJy0tRk9PLUJBUi0tJ1xuICAgICAqXG4gICAgICogXy50b1VwcGVyKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PQkFSJ1xuICAgICAqXG4gICAgICogXy50b1VwcGVyKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdfX0ZPT19CQVJfXydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1VwcGVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltKCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8udHJpbSgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnICBmb28gICcsICcgIGJhciAgJ10sIF8udHJpbSk7XG4gICAgICogLy8gPT4gWydmb28nLCAnYmFyJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBjaHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShjaGFycyksXG4gICAgICAgICAgc3RhcnQgPSBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scyksXG4gICAgICAgICAgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSArIDE7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQsIGVuZCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltRW5kKCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJyAgYWJjJ1xuICAgICAqXG4gICAgICogXy50cmltRW5kKCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnLV8tYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1FbmQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltRW5kLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIGVuZCA9IGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgc3RyaW5nVG9BcnJheShjaGFycykpICsgMTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGVhZGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltU3RhcnQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjICAnXG4gICAgICpcbiAgICAgKiBfLnRyaW1TdGFydCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYy1fLSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltU3RhcnQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgc3RhcnQgPSBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgc3RyaW5nVG9BcnJheShjaGFycykpO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIHN0YXJ0KS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZXMgYHN0cmluZ2AgaWYgaXQncyBsb25nZXIgdGhhbiB0aGUgZ2l2ZW4gbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIFRoZSBsYXN0IGNoYXJhY3RlcnMgb2YgdGhlIHRydW5jYXRlZCBzdHJpbmcgYXJlIHJlcGxhY2VkIHdpdGggdGhlIG9taXNzaW9uXG4gICAgICogc3RyaW5nIHdoaWNoIGRlZmF1bHRzIHRvIFwiLi4uXCIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJ1bmNhdGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxlbmd0aD0zMF0gVGhlIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub21pc3Npb249Jy4uLiddIFRoZSBzdHJpbmcgdG8gaW5kaWNhdGUgdGV4dCBpcyBvbWl0dGVkLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW29wdGlvbnMuc2VwYXJhdG9yXSBUaGUgc2VwYXJhdG9yIHBhdHRlcm4gdG8gdHJ1bmNhdGUgdG8uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJ1bmNhdGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycpO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm8uLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ2xlbmd0aCc6IDI0LFxuICAgICAqICAgJ3NlcGFyYXRvcic6ICcgJ1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAvLD8gKy9cbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdvbWlzc2lvbic6ICcgWy4uLl0nXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZyBbLi4uXSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuY2F0ZShzdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBERUZBVUxUX1RSVU5DX0xFTkdUSCxcbiAgICAgICAgICBvbWlzc2lvbiA9IERFRkFVTFRfVFJVTkNfT01JU1NJT047XG5cbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gJ3NlcGFyYXRvcicgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc2VwYXJhdG9yIDogc2VwYXJhdG9yO1xuICAgICAgICBsZW5ndGggPSAnbGVuZ3RoJyBpbiBvcHRpb25zID8gdG9JbnRlZ2VyKG9wdGlvbnMubGVuZ3RoKSA6IGxlbmd0aDtcbiAgICAgICAgb21pc3Npb24gPSAnb21pc3Npb24nIGluIG9wdGlvbnMgPyBiYXNlVG9TdHJpbmcob3B0aW9ucy5vbWlzc2lvbikgOiBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgaWYgKGhhc1VuaWNvZGUoc3RyaW5nKSkge1xuICAgICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKTtcbiAgICAgICAgc3RyTGVuZ3RoID0gc3RyU3ltYm9scy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoID49IHN0ckxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIGVuZCA9IGxlbmd0aCAtIHN0cmluZ1NpemUob21pc3Npb24pO1xuICAgICAgaWYgKGVuZCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHN0clN5bWJvbHNcbiAgICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMCwgZW5kKS5qb2luKCcnKVxuICAgICAgICA6IHN0cmluZy5zbGljZSgwLCBlbmQpO1xuXG4gICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgaWYgKHN0clN5bWJvbHMpIHtcbiAgICAgICAgZW5kICs9IChyZXN1bHQubGVuZ3RoIC0gZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1JlZ0V4cChzZXBhcmF0b3IpKSB7XG4gICAgICAgIGlmIChzdHJpbmcuc2xpY2UoZW5kKS5zZWFyY2goc2VwYXJhdG9yKSkge1xuICAgICAgICAgIHZhciBtYXRjaCxcbiAgICAgICAgICAgICAgc3Vic3RyaW5nID0gcmVzdWx0O1xuXG4gICAgICAgICAgaWYgKCFzZXBhcmF0b3IuZ2xvYmFsKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgdG9TdHJpbmcocmVGbGFncy5leGVjKHNlcGFyYXRvcikpICsgJ2cnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN1YnN0cmluZykpKSB7XG4gICAgICAgICAgICB2YXIgbmV3RW5kID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBuZXdFbmQgPT09IHVuZGVmaW5lZCA/IGVuZCA6IG5ld0VuZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmluZGV4T2YoYmFzZVRvU3RyaW5nKHNlcGFyYXRvciksIGVuZCkgIT0gZW5kKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJlc3VsdC5sYXN0SW5kZXhPZihzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy5lc2NhcGVgOyB0aGlzIG1ldGhvZCBjb252ZXJ0cyB0aGUgSFRNTCBlbnRpdGllc1xuICAgICAqIGAmYW1wO2AsIGAmbHQ7YCwgYCZndDtgLCBgJnF1b3Q7YCwgYW5kIGAmIzM5O2AgaW4gYHN0cmluZ2AgdG9cbiAgICAgKiB0aGVpciBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgSFRNTCBlbnRpdGllcyBhcmUgdW5lc2NhcGVkLiBUbyB1bmVzY2FwZSBhZGRpdGlvbmFsXG4gICAgICogSFRNTCBlbnRpdGllcyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzRXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlZEh0bWwsIHVuZXNjYXBlSHRtbENoYXIpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBzcGFjZSBzZXBhcmF0ZWQgd29yZHMsIHRvIHVwcGVyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1cHBlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCctLWZvby1iYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqL1xuICAgIHZhciB1cHBlckNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB3b3JkLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVwcGVyRmlyc3QoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKlxuICAgICAqIF8udXBwZXJGaXJzdCgnRlJFRCcpO1xuICAgICAqIC8vID0+ICdGUkVEJ1xuICAgICAqL1xuICAgIHZhciB1cHBlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b1VwcGVyQ2FzZScpO1xuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbcGF0dGVybl0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd29yZHMuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycsIC9bXiwgXSsvZyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICcmJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdvcmRzKHN0cmluZywgcGF0dGVybiwgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBwYXR0ZXJuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBwYXR0ZXJuO1xuXG4gICAgICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBoYXNVbmljb2RlV29yZChzdHJpbmcpID8gdW5pY29kZVdvcmRzKHN0cmluZykgOiBhc2NpaVdvcmRzKHN0cmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHBhdHRlcm4pIHx8IFtdO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGludm9rZSBgZnVuY2AsIHJldHVybmluZyBlaXRoZXIgdGhlIHJlc3VsdCBvciB0aGUgY2F1Z2h0IGVycm9yXG4gICAgICogb2JqZWN0LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXR0ZW1wdC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYGZ1bmNgIHJlc3VsdCBvciBlcnJvciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIHRocm93aW5nIGVycm9ycyBmb3IgaW52YWxpZCBzZWxlY3RvcnMuXG4gICAgICogdmFyIGVsZW1lbnRzID0gXy5hdHRlbXB0KGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICogICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICogfSwgJz5fPicpO1xuICAgICAqXG4gICAgICogaWYgKF8uaXNFcnJvcihlbGVtZW50cykpIHtcbiAgICAgKiAgIGVsZW1lbnRzID0gW107XG4gICAgICogfVxuICAgICAqL1xuICAgIHZhciBhdHRlbXB0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBpc0Vycm9yKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEJpbmRzIG1ldGhvZHMgb2YgYW4gb2JqZWN0IHRvIHRoZSBvYmplY3QgaXRzZWxmLCBvdmVyd3JpdGluZyB0aGUgZXhpc3RpbmdcbiAgICAgKiBtZXRob2QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmluZCBhbmQgYXNzaWduIHRoZSBib3VuZCBtZXRob2RzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IG1ldGhvZE5hbWVzIFRoZSBvYmplY3QgbWV0aG9kIG5hbWVzIHRvIGJpbmQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHZpZXcgPSB7XG4gICAgICogICAnbGFiZWwnOiAnZG9jcycsXG4gICAgICogICAnY2xpY2snOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ2NsaWNrZWQgJyArIHRoaXMubGFiZWwpO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmJpbmRBbGwodmlldywgWydjbGljayddKTtcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdmlldy5jbGljayk7XG4gICAgICogLy8gPT4gTG9ncyAnY2xpY2tlZCBkb2NzJyB3aGVuIGNsaWNrZWQuXG4gICAgICovXG4gICAgdmFyIGJpbmRBbGwgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIG1ldGhvZE5hbWVzKSB7XG4gICAgICBhcnJheUVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBrZXkgPSB0b0tleShrZXkpO1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIGJpbmQob2JqZWN0W2tleV0sIG9iamVjdCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXRlcmF0ZXMgb3ZlciBgcGFpcnNgIGFuZCBpbnZva2VzIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogZnVuY3Rpb24gb2YgdGhlIGZpcnN0IHByZWRpY2F0ZSB0byByZXR1cm4gdHJ1dGh5LiBUaGUgcHJlZGljYXRlLWZ1bmN0aW9uXG4gICAgICogcGFpcnMgYXJlIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZFxuICAgICAqIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlycyBUaGUgcHJlZGljYXRlLWZ1bmN0aW9uIHBhaXJzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLmNvbmQoW1xuICAgICAqICAgW18ubWF0Y2hlcyh7ICdhJzogMSB9KSwgICAgICAgICAgIF8uY29uc3RhbnQoJ21hdGNoZXMgQScpXSxcbiAgICAgKiAgIFtfLmNvbmZvcm1zKHsgJ2InOiBfLmlzTnVtYmVyIH0pLCBfLmNvbnN0YW50KCdtYXRjaGVzIEInKV0sXG4gICAgICogICBbXy5zdHViVHJ1ZSwgICAgICAgICAgICAgICAgICAgICAgXy5jb25zdGFudCgnbm8gbWF0Y2gnKV1cbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiAnbWF0Y2hlcyBBJ1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogMCwgJ2InOiAxIH0pO1xuICAgICAqIC8vID0+ICdtYXRjaGVzIEInXG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAnMScsICdiJzogJzInIH0pO1xuICAgICAqIC8vID0+ICdubyBtYXRjaCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25kKHBhaXJzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcGFpcnMgPT0gbnVsbCA/IDAgOiBwYWlycy5sZW5ndGgsXG4gICAgICAgICAgdG9JdGVyYXRlZSA9IGdldEl0ZXJhdGVlKCk7XG5cbiAgICAgIHBhaXJzID0gIWxlbmd0aCA/IFtdIDogYXJyYXlNYXAocGFpcnMsIGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYWlyWzFdICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0b0l0ZXJhdGVlKHBhaXJbMF0pLCBwYWlyWzFdXTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2luZGV4XTtcbiAgICAgICAgICBpZiAoYXBwbHkocGFpclswXSwgdGhpcywgYXJncykpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseShwYWlyWzFdLCB0aGlzLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHByZWRpY2F0ZSBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHdpdGhcbiAgICAgKiB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB2YWx1ZXMgb2YgYSBnaXZlbiBvYmplY3QsIHJldHVybmluZyBgdHJ1ZWAgaWZcbiAgICAgKiBhbGwgcHJlZGljYXRlcyByZXR1cm4gdHJ1dGh5LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNyZWF0ZWQgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byBgXy5jb25mb3Jtc1RvYCB3aXRoXG4gICAgICogYHNvdXJjZWAgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMiwgJ2InOiAxIH0sXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5jb25mb3Jtcyh7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDE7IH0gfSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSwgJ2InOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZm9ybXMoc291cmNlKSB7XG4gICAgICByZXR1cm4gYmFzZUNvbmZvcm1zKGJhc2VDbG9uZShzb3VyY2UsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgYHZhbHVlYCB0byBkZXRlcm1pbmUgd2hldGhlciBhIGRlZmF1bHQgdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkIGluXG4gICAgICogaXRzIHBsYWNlLiBUaGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaWYgYHZhbHVlYCBpcyBgTmFOYCwgYG51bGxgLFxuICAgICAqIG9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgVGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRUbygxLCAxMCk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0VG8odW5kZWZpbmVkLCAxMCk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZhdWx0VG8odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmV0dXJuICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSkgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIGdpdmVuIGZ1bmN0aW9uc1xuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2Z1bmNzXSBUaGUgZnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQHNlZSBfLmZsb3dSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3coW18uYWRkLCBzcXVhcmVdKTtcbiAgICAgKiBhZGRTcXVhcmUoMSwgMik7XG4gICAgICogLy8gPT4gOVxuICAgICAqL1xuICAgIHZhciBmbG93ID0gY3JlYXRlRmxvdygpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbG93YCBleGNlcHQgdGhhdCBpdCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdFxuICAgICAqIGludm9rZXMgdGhlIGdpdmVuIGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbZnVuY3NdIFRoZSBmdW5jdGlvbnMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIF8uZmxvd1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3dSaWdodChbc3F1YXJlLCBfLmFkZF0pO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3dSaWdodCA9IGNyZWF0ZUZsb3codHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkXG4gICAgICogZnVuY3Rpb24uIElmIGBmdW5jYCBpcyBhIHByb3BlcnR5IG5hbWUsIHRoZSBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybnMgdGhlXG4gICAgICogcHJvcGVydHkgdmFsdWUgZm9yIGEgZ2l2ZW4gZWxlbWVudC4gSWYgYGZ1bmNgIGlzIGFuIGFycmF5IG9yIG9iamVjdCwgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbiByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBjb250YWluIHRoZSBlcXVpdmFsZW50XG4gICAgICogc291cmNlIHByb3BlcnRpZXMsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gW2Z1bmM9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLml0ZXJhdGVlKHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSkpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5pdGVyYXRlZShbJ3VzZXInLCAnZnJlZCddKSk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXAodXNlcnMsIF8uaXRlcmF0ZWUoJ3VzZXInKSk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBDcmVhdGUgY3VzdG9tIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICogXy5pdGVyYXRlZSA9IF8ud3JhcChfLml0ZXJhdGVlLCBmdW5jdGlvbihpdGVyYXRlZSwgZnVuYykge1xuICAgICAqICAgcmV0dXJuICFfLmlzUmVnRXhwKGZ1bmMpID8gaXRlcmF0ZWUoZnVuYykgOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgKiAgICAgcmV0dXJuIGZ1bmMudGVzdChzdHJpbmcpO1xuICAgICAqICAgfTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFsnYWJjJywgJ2RlZiddLCAvZWYvKTtcbiAgICAgKiAvLyA9PiBbJ2RlZiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXRlcmF0ZWUoZnVuYykge1xuICAgICAgcmV0dXJuIGJhc2VJdGVyYXRlZSh0eXBlb2YgZnVuYyA9PSAnZnVuY3Rpb24nID8gZnVuYyA6IGJhc2VDbG9uZShmdW5jLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYSBnaXZlblxuICAgICAqIG9iamVjdCBhbmQgYHNvdXJjZWAsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIG9iamVjdCBoYXMgZXF1aXZhbGVudFxuICAgICAqIHByb3BlcnR5IHZhbHVlcywgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjcmVhdGVkIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG8gYF8uaXNNYXRjaGAgd2l0aCBgc291cmNlYFxuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3QgYHNvdXJjZWBcbiAgICAgKiB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZSBgXy5pc0VxdWFsYFxuICAgICAqIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE11bHRpcGxlIHZhbHVlcyBjYW4gYmUgY2hlY2tlZCBieSBjb21iaW5pbmcgc2V2ZXJhbCBtYXRjaGVyc1xuICAgICAqIHVzaW5nIGBfLm92ZXJTb21lYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sXG4gICAgICogICB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLm1hdGNoZXMoeyAnYSc6IDQsICdjJzogNiB9KSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XVxuICAgICAqXG4gICAgICogLy8gQ2hlY2tpbmcgZm9yIHNldmVyYWwgcG9zc2libGUgdmFsdWVzXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5vdmVyU29tZShbXy5tYXRjaGVzKHsgJ2EnOiAxIH0pLCBfLm1hdGNoZXMoeyAnYSc6IDQgfSldKSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzKGJhc2VDbG9uZShzb3VyY2UsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0aGVcbiAgICAgKiB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QgdG8gYHNyY1ZhbHVlYCwgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGVcbiAgICAgKiBvYmplY3QgdmFsdWUgaXMgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0XG4gICAgICogYHNyY1ZhbHVlYCB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZVxuICAgICAqIGBfLmlzRXF1YWxgIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE11bHRpcGxlIHZhbHVlcyBjYW4gYmUgY2hlY2tlZCBieSBjb21iaW5pbmcgc2V2ZXJhbCBtYXRjaGVyc1xuICAgICAqIHVzaW5nIGBfLm92ZXJTb21lYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sXG4gICAgICogICB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmQob2JqZWN0cywgXy5tYXRjaGVzUHJvcGVydHkoJ2EnLCA0KSk7XG4gICAgICogLy8gPT4geyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKlxuICAgICAqIC8vIENoZWNraW5nIGZvciBzZXZlcmFsIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ub3ZlclNvbWUoW18ubWF0Y2hlc1Byb3BlcnR5KCdhJywgMSksIF8ubWF0Y2hlc1Byb3BlcnR5KCdhJywgNCldKSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIGJhc2VDbG9uZShzcmNWYWx1ZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludm9rZXIgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IHsgJ2InOiBfLmNvbnN0YW50KDIpIH0gfSxcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogXy5jb25zdGFudCgxKSB9IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5tZXRob2QoJ2EuYicpKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ubWV0aG9kKFsnYScsICdiJ10pKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICB2YXIgbWV0aG9kID0gYmFzZVJlc3QoZnVuY3Rpb24ocGF0aCwgYXJncykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5tZXRob2RgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzXG4gICAgICogdGhlIG1ldGhvZCBhdCBhIGdpdmVuIHBhdGggb2YgYG9iamVjdGAuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52b2tlciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gXy50aW1lcygzLCBfLmNvbnN0YW50KSxcbiAgICAgKiAgICAgb2JqZWN0ID0geyAnYSc6IGFycmF5LCAnYic6IGFycmF5LCAnYyc6IGFycmF5IH07XG4gICAgICpcbiAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLm1ldGhvZE9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqXG4gICAgICogXy5tYXAoW1snYScsICcyJ10sIFsnYycsICcwJ11dLCBfLm1ldGhvZE9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqL1xuICAgIHZhciBtZXRob2RPZiA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgYXJncykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgZnVuY3Rpb24gcHJvcGVydGllcyBvZiBhIHNvdXJjZVxuICAgICAqIG9iamVjdCB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LiBJZiBgb2JqZWN0YCBpcyBhIGZ1bmN0aW9uLCB0aGVuIG1ldGhvZHNcbiAgICAgKiBhcmUgYWRkZWQgdG8gaXRzIHByb3RvdHlwZSBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVzZSBgXy5ydW5JbkNvbnRleHRgIHRvIGNyZWF0ZSBhIHByaXN0aW5lIGBsb2Rhc2hgIGZ1bmN0aW9uIHRvXG4gICAgICogYXZvaWQgY29uZmxpY3RzIGNhdXNlZCBieSBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gW29iamVjdD1sb2Rhc2hdIFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIGZ1bmN0aW9ucyB0byBhZGQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGFpbj10cnVlXSBTcGVjaWZ5IHdoZXRoZXIgbWl4aW5zIGFyZSBjaGFpbmFibGUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufE9iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gdm93ZWxzKHN0cmluZykge1xuICAgICAqICAgcmV0dXJuIF8uZmlsdGVyKHN0cmluZywgZnVuY3Rpb24odikge1xuICAgICAqICAgICByZXR1cm4gL1thZWlvdV0vaS50ZXN0KHYpO1xuICAgICAqICAgfSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSk7XG4gICAgICogXy52b3dlbHMoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXygnZnJlZCcpLnZvd2VscygpLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0sIHsgJ2NoYWluJzogZmFsc2UgfSk7XG4gICAgICogXygnZnJlZCcpLnZvd2VscygpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWl4aW4ob2JqZWN0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMoc291cmNlKSxcbiAgICAgICAgICBtZXRob2ROYW1lcyA9IGJhc2VGdW5jdGlvbnMoc291cmNlLCBwcm9wcyk7XG5cbiAgICAgIGlmIChvcHRpb25zID09IG51bGwgJiZcbiAgICAgICAgICAhKGlzT2JqZWN0KHNvdXJjZSkgJiYgKG1ldGhvZE5hbWVzLmxlbmd0aCB8fCAhcHJvcHMubGVuZ3RoKSkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHNvdXJjZTtcbiAgICAgICAgc291cmNlID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QgPSB0aGlzO1xuICAgICAgICBtZXRob2ROYW1lcyA9IGJhc2VGdW5jdGlvbnMoc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuICAgICAgfVxuICAgICAgdmFyIGNoYWluID0gIShpc09iamVjdChvcHRpb25zKSAmJiAnY2hhaW4nIGluIG9wdGlvbnMpIHx8ICEhb3B0aW9ucy5jaGFpbixcbiAgICAgICAgICBpc0Z1bmMgPSBpc0Z1bmN0aW9uKG9iamVjdCk7XG5cbiAgICAgIGFycmF5RWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgZnVuYyA9IHNvdXJjZVttZXRob2ROYW1lXTtcbiAgICAgICAgb2JqZWN0W21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgaWYgKGlzRnVuYykge1xuICAgICAgICAgIG9iamVjdC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fO1xuICAgICAgICAgICAgaWYgKGNoYWluIHx8IGNoYWluQWxsKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvYmplY3QodGhpcy5fX3dyYXBwZWRfXyksXG4gICAgICAgICAgICAgICAgICBhY3Rpb25zID0gcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHRoaXMuX19hY3Rpb25zX18pO1xuXG4gICAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7ICdmdW5jJzogZnVuYywgJ2FyZ3MnOiBhcmd1bWVudHMsICd0aGlzQXJnJzogb2JqZWN0IH0pO1xuICAgICAgICAgICAgICByZXN1bHQuX19jaGFpbl9fID0gY2hhaW5BbGw7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShvYmplY3QsIGFycmF5UHVzaChbdGhpcy52YWx1ZSgpXSwgYXJndW1lbnRzKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJ0cyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0b1xuICAgICAqIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGxvZGFzaCA9IF8ubm9Db25mbGljdCgpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgICBpZiAocm9vdC5fID09PSB0aGlzKSB7XG4gICAgICAgIHJvb3QuXyA9IG9sZERhc2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLm5vb3ApO1xuICAgICAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub29wKCkge1xuICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBnZXRzIHRoZSBhcmd1bWVudCBhdCBpbmRleCBgbmAuIElmIGBuYCBpcyBuZWdhdGl2ZSxcbiAgICAgKiB0aGUgbnRoIGFyZ3VtZW50IGZyb20gdGhlIGVuZCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTBdIFRoZSBpbmRleCBvZiB0aGUgYXJndW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhc3MtdGhydSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm50aEFyZygxKTtcbiAgICAgKiBmdW5jKCdhJywgJ2InLCAnYycsICdkJyk7XG4gICAgICogLy8gPT4gJ2InXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ubnRoQXJnKC0yKTtcbiAgICAgKiBmdW5jKCdhJywgJ2InLCAnYycsICdkJyk7XG4gICAgICogLy8gPT4gJ2MnXG4gICAgICovXG4gICAgZnVuY3Rpb24gbnRoQXJnKG4pIHtcbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gYmFzZU50aChhcmdzLCBuKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGl0ZXJhdGVlc2Agd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzXG4gICAgICogYW5kIHJldHVybnMgdGhlaXIgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXIoW01hdGgubWF4LCBNYXRoLm1pbl0pO1xuICAgICAqXG4gICAgICogZnVuYygxLCAyLCAzLCA0KTtcbiAgICAgKiAvLyA9PiBbNCwgMV1cbiAgICAgKi9cbiAgICB2YXIgb3ZlciA9IGNyZWF0ZU92ZXIoYXJyYXlNYXApO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmICoqYWxsKiogb2YgdGhlIGBwcmVkaWNhdGVzYCByZXR1cm5cbiAgICAgKiB0cnV0aHkgd2hlbiBpbnZva2VkIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEZvbGxvd2luZyBzaG9ydGhhbmRzIGFyZSBwb3NzaWJsZSBmb3IgcHJvdmlkaW5nIHByZWRpY2F0ZXMuXG4gICAgICogUGFzcyBhbiBgT2JqZWN0YCBhbmQgaXQgd2lsbCBiZSB1c2VkIGFzIGFuIHBhcmFtZXRlciBmb3IgYF8ubWF0Y2hlc2AgdG8gY3JlYXRlIHRoZSBwcmVkaWNhdGUuXG4gICAgICogUGFzcyBhbiBgQXJyYXlgIG9mIHBhcmFtZXRlcnMgZm9yIGBfLm1hdGNoZXNQcm9wZXJ0eWAgYW5kIHRoZSBwcmVkaWNhdGUgd2lsbCBiZSBjcmVhdGVkIHVzaW5nIHRoZW0uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbcHJlZGljYXRlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBwcmVkaWNhdGVzIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlckV2ZXJ5KFtCb29sZWFuLCBpc0Zpbml0ZV0pO1xuICAgICAqXG4gICAgICogZnVuYygnMScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIGZ1bmMoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBvdmVyRXZlcnkgPSBjcmVhdGVPdmVyKGFycmF5RXZlcnkpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmICoqYW55Kiogb2YgdGhlIGBwcmVkaWNhdGVzYCByZXR1cm5cbiAgICAgKiB0cnV0aHkgd2hlbiBpbnZva2VkIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEZvbGxvd2luZyBzaG9ydGhhbmRzIGFyZSBwb3NzaWJsZSBmb3IgcHJvdmlkaW5nIHByZWRpY2F0ZXMuXG4gICAgICogUGFzcyBhbiBgT2JqZWN0YCBhbmQgaXQgd2lsbCBiZSB1c2VkIGFzIGFuIHBhcmFtZXRlciBmb3IgYF8ubWF0Y2hlc2AgdG8gY3JlYXRlIHRoZSBwcmVkaWNhdGUuXG4gICAgICogUGFzcyBhbiBgQXJyYXlgIG9mIHBhcmFtZXRlcnMgZm9yIGBfLm1hdGNoZXNQcm9wZXJ0eWAgYW5kIHRoZSBwcmVkaWNhdGUgd2lsbCBiZSBjcmVhdGVkIHVzaW5nIHRoZW0uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbcHJlZGljYXRlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBwcmVkaWNhdGVzIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlclNvbWUoW0Jvb2xlYW4sIGlzRmluaXRlXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKCcxJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIHZhciBtYXRjaGVzRnVuYyA9IF8ub3ZlclNvbWUoW3sgJ2EnOiAxIH0sIHsgJ2EnOiAyIH1dKVxuICAgICAqIHZhciBtYXRjaGVzUHJvcGVydHlGdW5jID0gXy5vdmVyU29tZShbWydhJywgMV0sIFsnYScsIDJdXSlcbiAgICAgKi9cbiAgICB2YXIgb3ZlclNvbWUgPSBjcmVhdGVPdmVyKGFycmF5U29tZSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gICAgICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucHJvcGVydHlgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zXG4gICAgICogdGhlIHZhbHVlIGF0IGEgZ2l2ZW4gcGF0aCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMCwgMSwgMl0sXG4gICAgICogICAgIG9iamVjdCA9IHsgJ2EnOiBhcnJheSwgJ2InOiBhcnJheSwgJ2MnOiBhcnJheSB9O1xuICAgICAqXG4gICAgICogXy5tYXAoWydhWzJdJywgJ2NbMF0nXSwgXy5wcm9wZXJ0eU9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqXG4gICAgICogXy5tYXAoW1snYScsICcyJ10sIFsnYycsICcwJ11dLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHlPZihvYmplY3QpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb21cbiAgICAgKiBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIEEgc3RlcCBvZiBgLTFgIGlzIHVzZWQgaWYgYSBuZWdhdGl2ZVxuICAgICAqIGBzdGFydGAgaXMgc3BlY2lmaWVkIHdpdGhvdXQgYW4gYGVuZGAgb3IgYHN0ZXBgLiBJZiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLFxuICAgICAqIGl0J3Mgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZSg0KTtcbiAgICAgKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoLTQpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFswLCA1LCAxMCwgMTVdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDQsIDApO1xuICAgICAqIC8vID0+IFsxLCAxLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIHZhciByYW5nZSA9IGNyZWF0ZVJhbmdlKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJhbmdlYCBleGNlcHQgdGhhdCBpdCBwb3B1bGF0ZXMgdmFsdWVzIGluXG4gICAgICogZGVzY2VuZGluZyBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKiBAc2VlIF8uaW5SYW5nZSwgXy5yYW5nZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoNCk7XG4gICAgICogLy8gPT4gWzMsIDIsIDEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoLTQpO1xuICAgICAqIC8vID0+IFstMywgLTIsIC0xLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDEsIDUpO1xuICAgICAqIC8vID0+IFs0LCAzLCAyLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMTUsIDEwLCA1LCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWy0zLCAtMiwgLTEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICB2YXIgcmFuZ2VSaWdodCA9IGNyZWF0ZVJhbmdlKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICAgICAqIC8vID0+IFtbXSwgW11dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gICAgICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5zdHViT2JqZWN0KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICAgICAqIC8vID0+IFt7fSwge31dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJPYmplY3QoKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViU3RyaW5nKTtcbiAgICAgKiAvLyA9PiBbJycsICcnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViVHJ1ZSk7XG4gICAgICogLy8gPT4gW3RydWUsIHRydWVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YlRydWUoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBpdGVyYXRlZSBgbmAgdGltZXMsIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZlxuICAgICAqIGVhY2ggaW52b2NhdGlvbi4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7IChpbmRleCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIFN0cmluZyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnLCAnMiddXG4gICAgICpcbiAgICAgKiAgXy50aW1lcyg0LCBfLmNvbnN0YW50KDApKTtcbiAgICAgKiAvLyA9PiBbMCwgMCwgMCwgMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lcyhuLCBpdGVyYXRlZSkge1xuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIGlmIChuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBNQVhfQVJSQVlfTEVOR1RILFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihuLCBNQVhfQVJSQVlfTEVOR1RIKTtcblxuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSk7XG4gICAgICBuIC09IE1BWF9BUlJBWV9MRU5HVEg7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlVGltZXMobGVuZ3RoLCBpdGVyYXRlZSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgICAgaXRlcmF0ZWUoaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvUGF0aCgnYS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKlxuICAgICAqIF8udG9QYXRoKCdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IFsnYScsICcwJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9QYXRoKHZhbHVlKSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCB0b0tleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTeW1ib2wodmFsdWUpID8gW3ZhbHVlXSA6IGNvcHlBcnJheShzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBnaXZlbiwgdGhlIElEIGlzIGFwcGVuZGVkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeD0nJ10gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmlxdWUgSUQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoJ2NvbnRhY3RfJyk7XG4gICAgICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgpO1xuICAgICAqIC8vID0+ICcxMDUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gICAgICB2YXIgaWQgPSArK2lkQ291bnRlcjtcbiAgICAgIHJldHVybiB0b1N0cmluZyhwcmVmaXgpICsgaWQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjQuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGF1Z2VuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGFuIGFkZGl0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhZGRlbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYW4gYWRkaXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdG90YWwuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYWRkKDYsIDQpO1xuICAgICAqIC8vID0+IDEwXG4gICAgICovXG4gICAgdmFyIGFkZCA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24oYXVnZW5kLCBhZGRlbmQpIHtcbiAgICAgIHJldHVybiBhdWdlbmQgKyBhZGRlbmQ7XG4gICAgfSwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIHVwIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kIHVwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgdXAgdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCB1cCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2VpbCg0LjAwNik7XG4gICAgICogLy8gPT4gNVxuICAgICAqXG4gICAgICogXy5jZWlsKDYuMDA0LCAyKTtcbiAgICAgKiAvLyA9PiA2LjAxXG4gICAgICpcbiAgICAgKiBfLmNlaWwoNjA0MCwgLTIpO1xuICAgICAqIC8vID0+IDYxMDBcbiAgICAgKi9cbiAgICB2YXIgY2VpbCA9IGNyZWF0ZVJvdW5kKCdjZWlsJyk7XG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGUgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXZpZGVuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGEgZGl2aXNpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdmlzb3IgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBkaXZpc2lvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBxdW90aWVudC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaXZpZGUoNiwgNCk7XG4gICAgICogLy8gPT4gMS41XG4gICAgICovXG4gICAgdmFyIGRpdmlkZSA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24oZGl2aWRlbmQsIGRpdmlzb3IpIHtcbiAgICAgIHJldHVybiBkaXZpZGVuZCAvIGRpdmlzb3I7XG4gICAgfSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIGRvd24gdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQgZG93bi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIGRvd24gdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCBkb3duIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbG9vcig0LjAwNik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5mbG9vcigwLjA0NiwgMik7XG4gICAgICogLy8gPT4gMC4wNFxuICAgICAqXG4gICAgICogXy5mbG9vcig0MDYwLCAtMik7XG4gICAgICogLy8gPT4gNDAwMFxuICAgICAqL1xuICAgIHZhciBmbG9vciA9IGNyZWF0ZVJvdW5kKCdmbG9vcicpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1heGltdW0gdmFsdWUgb2YgYGFycmF5YC4gSWYgYGFycmF5YCBpcyBlbXB0eSBvciBmYWxzZXksXG4gICAgICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWF4KFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogXy5tYXgoW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heChhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUd0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1heGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHRoZSB2YWx1ZSBpcyByYW5rZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLm1heEJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4geyAnbic6IDIgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXhCeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IHsgJ24nOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXhCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBiYXNlR3QpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtZWFuIG9mIHRoZSB2YWx1ZXMgaW4gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1lYW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVhbihhcnJheSkge1xuICAgICAgcmV0dXJuIGJhc2VNZWFuKGFycmF5LCBpZGVudGl0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tZWFuYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgdmFsdWUgdG8gYmUgYXZlcmFnZWQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiA0IH0sIHsgJ24nOiAyIH0sIHsgJ24nOiA4IH0sIHsgJ24nOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5tZWFuQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1lYW5CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZWFuQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZU1lYW4oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1pbmltdW0gdmFsdWUgb2YgYGFycmF5YC4gSWYgYGFycmF5YCBpcyBlbXB0eSBvciBmYWxzZXksXG4gICAgICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWluKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5taW4oW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbihhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUx0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1pbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHRoZSB2YWx1ZSBpcyByYW5rZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLm1pbkJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4geyAnbic6IDEgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5taW5CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IHsgJ24nOiAxIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW5CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBiYXNlTHQpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE11bHRpcGx5IHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbXVsdGlwbGllciBUaGUgZmlyc3QgbnVtYmVyIGluIGEgbXVsdGlwbGljYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG11bHRpcGxpY2FuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhIG11bHRpcGxpY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHByb2R1Y3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubXVsdGlwbHkoNiwgNCk7XG4gICAgICogLy8gPT4gMjRcbiAgICAgKi9cbiAgICB2YXIgbXVsdGlwbHkgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKG11bHRpcGxpZXIsIG11bHRpcGxpY2FuZCkge1xuICAgICAgcmV0dXJuIG11bHRpcGxpZXIgKiBtdWx0aXBsaWNhbmQ7XG4gICAgfSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNC4wMDYpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNC4wMDYsIDIpO1xuICAgICAqIC8vID0+IDQuMDFcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNDA2MCwgLTIpO1xuICAgICAqIC8vID0+IDQxMDBcbiAgICAgKi9cbiAgICB2YXIgcm91bmQgPSBjcmVhdGVSb3VuZCgncm91bmQnKTtcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0IHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWludWVuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGEgc3VidHJhY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN1YnRyYWhlbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBzdWJ0cmFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN1YnRyYWN0KDYsIDQpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICB2YXIgc3VidHJhY3QgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKG1pbnVlbmQsIHN1YnRyYWhlbmQpIHtcbiAgICAgIHJldHVybiBtaW51ZW5kIC0gc3VidHJhaGVuZDtcbiAgICB9LCAwKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzdW0gb2YgdGhlIHZhbHVlcyBpbiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdW0oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1bShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVN1bShhcnJheSwgaWRlbnRpdHkpXG4gICAgICAgIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnN1bWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIHZhbHVlIHRvIGJlIHN1bW1lZC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogNCB9LCB7ICduJzogMiB9LCB7ICduJzogOCB9LCB7ICduJzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8uc3VtQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zdW1CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU3VtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogMDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0aGF0IHJldHVybiB3cmFwcGVkIHZhbHVlcyBpbiBjaGFpbiBzZXF1ZW5jZXMuXG4gICAgbG9kYXNoLmFmdGVyID0gYWZ0ZXI7XG4gICAgbG9kYXNoLmFyeSA9IGFyeTtcbiAgICBsb2Rhc2guYXNzaWduID0gYXNzaWduO1xuICAgIGxvZGFzaC5hc3NpZ25JbiA9IGFzc2lnbkluO1xuICAgIGxvZGFzaC5hc3NpZ25JbldpdGggPSBhc3NpZ25JbldpdGg7XG4gICAgbG9kYXNoLmFzc2lnbldpdGggPSBhc3NpZ25XaXRoO1xuICAgIGxvZGFzaC5hdCA9IGF0O1xuICAgIGxvZGFzaC5iZWZvcmUgPSBiZWZvcmU7XG4gICAgbG9kYXNoLmJpbmQgPSBiaW5kO1xuICAgIGxvZGFzaC5iaW5kQWxsID0gYmluZEFsbDtcbiAgICBsb2Rhc2guYmluZEtleSA9IGJpbmRLZXk7XG4gICAgbG9kYXNoLmNhc3RBcnJheSA9IGNhc3RBcnJheTtcbiAgICBsb2Rhc2guY2hhaW4gPSBjaGFpbjtcbiAgICBsb2Rhc2guY2h1bmsgPSBjaHVuaztcbiAgICBsb2Rhc2guY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgbG9kYXNoLmNvbmNhdCA9IGNvbmNhdDtcbiAgICBsb2Rhc2guY29uZCA9IGNvbmQ7XG4gICAgbG9kYXNoLmNvbmZvcm1zID0gY29uZm9ybXM7XG4gICAgbG9kYXNoLmNvbnN0YW50ID0gY29uc3RhbnQ7XG4gICAgbG9kYXNoLmNvdW50QnkgPSBjb3VudEJ5O1xuICAgIGxvZGFzaC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgbG9kYXNoLmN1cnJ5ID0gY3Vycnk7XG4gICAgbG9kYXNoLmN1cnJ5UmlnaHQgPSBjdXJyeVJpZ2h0O1xuICAgIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICAgIGxvZGFzaC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgIGxvZGFzaC5kZWZhdWx0c0RlZXAgPSBkZWZhdWx0c0RlZXA7XG4gICAgbG9kYXNoLmRlZmVyID0gZGVmZXI7XG4gICAgbG9kYXNoLmRlbGF5ID0gZGVsYXk7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlO1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlQnkgPSBkaWZmZXJlbmNlQnk7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2VXaXRoID0gZGlmZmVyZW5jZVdpdGg7XG4gICAgbG9kYXNoLmRyb3AgPSBkcm9wO1xuICAgIGxvZGFzaC5kcm9wUmlnaHQgPSBkcm9wUmlnaHQ7XG4gICAgbG9kYXNoLmRyb3BSaWdodFdoaWxlID0gZHJvcFJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLmRyb3BXaGlsZSA9IGRyb3BXaGlsZTtcbiAgICBsb2Rhc2guZmlsbCA9IGZpbGw7XG4gICAgbG9kYXNoLmZpbHRlciA9IGZpbHRlcjtcbiAgICBsb2Rhc2guZmxhdE1hcCA9IGZsYXRNYXA7XG4gICAgbG9kYXNoLmZsYXRNYXBEZWVwID0gZmxhdE1hcERlZXA7XG4gICAgbG9kYXNoLmZsYXRNYXBEZXB0aCA9IGZsYXRNYXBEZXB0aDtcbiAgICBsb2Rhc2guZmxhdHRlbiA9IGZsYXR0ZW47XG4gICAgbG9kYXNoLmZsYXR0ZW5EZWVwID0gZmxhdHRlbkRlZXA7XG4gICAgbG9kYXNoLmZsYXR0ZW5EZXB0aCA9IGZsYXR0ZW5EZXB0aDtcbiAgICBsb2Rhc2guZmxpcCA9IGZsaXA7XG4gICAgbG9kYXNoLmZsb3cgPSBmbG93O1xuICAgIGxvZGFzaC5mbG93UmlnaHQgPSBmbG93UmlnaHQ7XG4gICAgbG9kYXNoLmZyb21QYWlycyA9IGZyb21QYWlycztcbiAgICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5mdW5jdGlvbnNJbiA9IGZ1bmN0aW9uc0luO1xuICAgIGxvZGFzaC5ncm91cEJ5ID0gZ3JvdXBCeTtcbiAgICBsb2Rhc2guaW5pdGlhbCA9IGluaXRpYWw7XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uQnkgPSBpbnRlcnNlY3Rpb25CeTtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uV2l0aCA9IGludGVyc2VjdGlvbldpdGg7XG4gICAgbG9kYXNoLmludmVydCA9IGludmVydDtcbiAgICBsb2Rhc2guaW52ZXJ0QnkgPSBpbnZlcnRCeTtcbiAgICBsb2Rhc2guaW52b2tlTWFwID0gaW52b2tlTWFwO1xuICAgIGxvZGFzaC5pdGVyYXRlZSA9IGl0ZXJhdGVlO1xuICAgIGxvZGFzaC5rZXlCeSA9IGtleUJ5O1xuICAgIGxvZGFzaC5rZXlzID0ga2V5cztcbiAgICBsb2Rhc2gua2V5c0luID0ga2V5c0luO1xuICAgIGxvZGFzaC5tYXAgPSBtYXA7XG4gICAgbG9kYXNoLm1hcEtleXMgPSBtYXBLZXlzO1xuICAgIGxvZGFzaC5tYXBWYWx1ZXMgPSBtYXBWYWx1ZXM7XG4gICAgbG9kYXNoLm1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIGxvZGFzaC5tYXRjaGVzUHJvcGVydHkgPSBtYXRjaGVzUHJvcGVydHk7XG4gICAgbG9kYXNoLm1lbW9pemUgPSBtZW1vaXplO1xuICAgIGxvZGFzaC5tZXJnZSA9IG1lcmdlO1xuICAgIGxvZGFzaC5tZXJnZVdpdGggPSBtZXJnZVdpdGg7XG4gICAgbG9kYXNoLm1ldGhvZCA9IG1ldGhvZDtcbiAgICBsb2Rhc2gubWV0aG9kT2YgPSBtZXRob2RPZjtcbiAgICBsb2Rhc2gubWl4aW4gPSBtaXhpbjtcbiAgICBsb2Rhc2gubmVnYXRlID0gbmVnYXRlO1xuICAgIGxvZGFzaC5udGhBcmcgPSBudGhBcmc7XG4gICAgbG9kYXNoLm9taXQgPSBvbWl0O1xuICAgIGxvZGFzaC5vbWl0QnkgPSBvbWl0Qnk7XG4gICAgbG9kYXNoLm9uY2UgPSBvbmNlO1xuICAgIGxvZGFzaC5vcmRlckJ5ID0gb3JkZXJCeTtcbiAgICBsb2Rhc2gub3ZlciA9IG92ZXI7XG4gICAgbG9kYXNoLm92ZXJBcmdzID0gb3ZlckFyZ3M7XG4gICAgbG9kYXNoLm92ZXJFdmVyeSA9IG92ZXJFdmVyeTtcbiAgICBsb2Rhc2gub3ZlclNvbWUgPSBvdmVyU29tZTtcbiAgICBsb2Rhc2gucGFydGlhbCA9IHBhcnRpYWw7XG4gICAgbG9kYXNoLnBhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodDtcbiAgICBsb2Rhc2gucGFydGl0aW9uID0gcGFydGl0aW9uO1xuICAgIGxvZGFzaC5waWNrID0gcGljaztcbiAgICBsb2Rhc2gucGlja0J5ID0gcGlja0J5O1xuICAgIGxvZGFzaC5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIGxvZGFzaC5wcm9wZXJ0eU9mID0gcHJvcGVydHlPZjtcbiAgICBsb2Rhc2gucHVsbCA9IHB1bGw7XG4gICAgbG9kYXNoLnB1bGxBbGwgPSBwdWxsQWxsO1xuICAgIGxvZGFzaC5wdWxsQWxsQnkgPSBwdWxsQWxsQnk7XG4gICAgbG9kYXNoLnB1bGxBbGxXaXRoID0gcHVsbEFsbFdpdGg7XG4gICAgbG9kYXNoLnB1bGxBdCA9IHB1bGxBdDtcbiAgICBsb2Rhc2gucmFuZ2UgPSByYW5nZTtcbiAgICBsb2Rhc2gucmFuZ2VSaWdodCA9IHJhbmdlUmlnaHQ7XG4gICAgbG9kYXNoLnJlYXJnID0gcmVhcmc7XG4gICAgbG9kYXNoLnJlamVjdCA9IHJlamVjdDtcbiAgICBsb2Rhc2gucmVtb3ZlID0gcmVtb3ZlO1xuICAgIGxvZGFzaC5yZXN0ID0gcmVzdDtcbiAgICBsb2Rhc2gucmV2ZXJzZSA9IHJldmVyc2U7XG4gICAgbG9kYXNoLnNhbXBsZVNpemUgPSBzYW1wbGVTaXplO1xuICAgIGxvZGFzaC5zZXQgPSBzZXQ7XG4gICAgbG9kYXNoLnNldFdpdGggPSBzZXRXaXRoO1xuICAgIGxvZGFzaC5zaHVmZmxlID0gc2h1ZmZsZTtcbiAgICBsb2Rhc2guc2xpY2UgPSBzbGljZTtcbiAgICBsb2Rhc2guc29ydEJ5ID0gc29ydEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRVbmlxID0gc29ydGVkVW5pcTtcbiAgICBsb2Rhc2guc29ydGVkVW5pcUJ5ID0gc29ydGVkVW5pcUJ5O1xuICAgIGxvZGFzaC5zcGxpdCA9IHNwbGl0O1xuICAgIGxvZGFzaC5zcHJlYWQgPSBzcHJlYWQ7XG4gICAgbG9kYXNoLnRhaWwgPSB0YWlsO1xuICAgIGxvZGFzaC50YWtlID0gdGFrZTtcbiAgICBsb2Rhc2gudGFrZVJpZ2h0ID0gdGFrZVJpZ2h0O1xuICAgIGxvZGFzaC50YWtlUmlnaHRXaGlsZSA9IHRha2VSaWdodFdoaWxlO1xuICAgIGxvZGFzaC50YWtlV2hpbGUgPSB0YWtlV2hpbGU7XG4gICAgbG9kYXNoLnRhcCA9IHRhcDtcbiAgICBsb2Rhc2gudGhyb3R0bGUgPSB0aHJvdHRsZTtcbiAgICBsb2Rhc2gudGhydSA9IHRocnU7XG4gICAgbG9kYXNoLnRvQXJyYXkgPSB0b0FycmF5O1xuICAgIGxvZGFzaC50b1BhaXJzID0gdG9QYWlycztcbiAgICBsb2Rhc2gudG9QYWlyc0luID0gdG9QYWlyc0luO1xuICAgIGxvZGFzaC50b1BhdGggPSB0b1BhdGg7XG4gICAgbG9kYXNoLnRvUGxhaW5PYmplY3QgPSB0b1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgbG9kYXNoLnVuYXJ5ID0gdW5hcnk7XG4gICAgbG9kYXNoLnVuaW9uID0gdW5pb247XG4gICAgbG9kYXNoLnVuaW9uQnkgPSB1bmlvbkJ5O1xuICAgIGxvZGFzaC51bmlvbldpdGggPSB1bmlvbldpdGg7XG4gICAgbG9kYXNoLnVuaXEgPSB1bmlxO1xuICAgIGxvZGFzaC51bmlxQnkgPSB1bmlxQnk7XG4gICAgbG9kYXNoLnVuaXFXaXRoID0gdW5pcVdpdGg7XG4gICAgbG9kYXNoLnVuc2V0ID0gdW5zZXQ7XG4gICAgbG9kYXNoLnVuemlwID0gdW56aXA7XG4gICAgbG9kYXNoLnVuemlwV2l0aCA9IHVuemlwV2l0aDtcbiAgICBsb2Rhc2gudXBkYXRlID0gdXBkYXRlO1xuICAgIGxvZGFzaC51cGRhdGVXaXRoID0gdXBkYXRlV2l0aDtcbiAgICBsb2Rhc2gudmFsdWVzID0gdmFsdWVzO1xuICAgIGxvZGFzaC52YWx1ZXNJbiA9IHZhbHVlc0luO1xuICAgIGxvZGFzaC53aXRob3V0ID0gd2l0aG91dDtcbiAgICBsb2Rhc2gud29yZHMgPSB3b3JkcztcbiAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG4gICAgbG9kYXNoLnhvciA9IHhvcjtcbiAgICBsb2Rhc2gueG9yQnkgPSB4b3JCeTtcbiAgICBsb2Rhc2gueG9yV2l0aCA9IHhvcldpdGg7XG4gICAgbG9kYXNoLnppcCA9IHppcDtcbiAgICBsb2Rhc2guemlwT2JqZWN0ID0gemlwT2JqZWN0O1xuICAgIGxvZGFzaC56aXBPYmplY3REZWVwID0gemlwT2JqZWN0RGVlcDtcbiAgICBsb2Rhc2guemlwV2l0aCA9IHppcFdpdGg7XG5cbiAgICAvLyBBZGQgYWxpYXNlcy5cbiAgICBsb2Rhc2guZW50cmllcyA9IHRvUGFpcnM7XG4gICAgbG9kYXNoLmVudHJpZXNJbiA9IHRvUGFpcnNJbjtcbiAgICBsb2Rhc2guZXh0ZW5kID0gYXNzaWduSW47XG4gICAgbG9kYXNoLmV4dGVuZFdpdGggPSBhc3NpZ25JbldpdGg7XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgbWl4aW4obG9kYXNoLCBsb2Rhc2gpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdGhhdCByZXR1cm4gdW53cmFwcGVkIHZhbHVlcyBpbiBjaGFpbiBzZXF1ZW5jZXMuXG4gICAgbG9kYXNoLmFkZCA9IGFkZDtcbiAgICBsb2Rhc2guYXR0ZW1wdCA9IGF0dGVtcHQ7XG4gICAgbG9kYXNoLmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbiAgICBsb2Rhc2guY2FwaXRhbGl6ZSA9IGNhcGl0YWxpemU7XG4gICAgbG9kYXNoLmNlaWwgPSBjZWlsO1xuICAgIGxvZGFzaC5jbGFtcCA9IGNsYW1wO1xuICAgIGxvZGFzaC5jbG9uZSA9IGNsb25lO1xuICAgIGxvZGFzaC5jbG9uZURlZXAgPSBjbG9uZURlZXA7XG4gICAgbG9kYXNoLmNsb25lRGVlcFdpdGggPSBjbG9uZURlZXBXaXRoO1xuICAgIGxvZGFzaC5jbG9uZVdpdGggPSBjbG9uZVdpdGg7XG4gICAgbG9kYXNoLmNvbmZvcm1zVG8gPSBjb25mb3Jtc1RvO1xuICAgIGxvZGFzaC5kZWJ1cnIgPSBkZWJ1cnI7XG4gICAgbG9kYXNoLmRlZmF1bHRUbyA9IGRlZmF1bHRUbztcbiAgICBsb2Rhc2guZGl2aWRlID0gZGl2aWRlO1xuICAgIGxvZGFzaC5lbmRzV2l0aCA9IGVuZHNXaXRoO1xuICAgIGxvZGFzaC5lcSA9IGVxO1xuICAgIGxvZGFzaC5lc2NhcGUgPSBlc2NhcGU7XG4gICAgbG9kYXNoLmVzY2FwZVJlZ0V4cCA9IGVzY2FwZVJlZ0V4cDtcbiAgICBsb2Rhc2guZXZlcnkgPSBldmVyeTtcbiAgICBsb2Rhc2guZmluZCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRJbmRleCA9IGZpbmRJbmRleDtcbiAgICBsb2Rhc2guZmluZEtleSA9IGZpbmRLZXk7XG4gICAgbG9kYXNoLmZpbmRMYXN0ID0gZmluZExhc3Q7XG4gICAgbG9kYXNoLmZpbmRMYXN0SW5kZXggPSBmaW5kTGFzdEluZGV4O1xuICAgIGxvZGFzaC5maW5kTGFzdEtleSA9IGZpbmRMYXN0S2V5O1xuICAgIGxvZGFzaC5mbG9vciA9IGZsb29yO1xuICAgIGxvZGFzaC5mb3JFYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZm9yRWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5mb3JJbiA9IGZvckluO1xuICAgIGxvZGFzaC5mb3JJblJpZ2h0ID0gZm9ySW5SaWdodDtcbiAgICBsb2Rhc2guZm9yT3duID0gZm9yT3duO1xuICAgIGxvZGFzaC5mb3JPd25SaWdodCA9IGZvck93blJpZ2h0O1xuICAgIGxvZGFzaC5nZXQgPSBnZXQ7XG4gICAgbG9kYXNoLmd0ID0gZ3Q7XG4gICAgbG9kYXNoLmd0ZSA9IGd0ZTtcbiAgICBsb2Rhc2guaGFzID0gaGFzO1xuICAgIGxvZGFzaC5oYXNJbiA9IGhhc0luO1xuICAgIGxvZGFzaC5oZWFkID0gaGVhZDtcbiAgICBsb2Rhc2guaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICBsb2Rhc2guaW5jbHVkZXMgPSBpbmNsdWRlcztcbiAgICBsb2Rhc2guaW5kZXhPZiA9IGluZGV4T2Y7XG4gICAgbG9kYXNoLmluUmFuZ2UgPSBpblJhbmdlO1xuICAgIGxvZGFzaC5pbnZva2UgPSBpbnZva2U7XG4gICAgbG9kYXNoLmlzQXJndW1lbnRzID0gaXNBcmd1bWVudHM7XG4gICAgbG9kYXNoLmlzQXJyYXkgPSBpc0FycmF5O1xuICAgIGxvZGFzaC5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcbiAgICBsb2Rhc2guaXNBcnJheUxpa2UgPSBpc0FycmF5TGlrZTtcbiAgICBsb2Rhc2guaXNBcnJheUxpa2VPYmplY3QgPSBpc0FycmF5TGlrZU9iamVjdDtcbiAgICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgIGxvZGFzaC5pc0J1ZmZlciA9IGlzQnVmZmVyO1xuICAgIGxvZGFzaC5pc0RhdGUgPSBpc0RhdGU7XG4gICAgbG9kYXNoLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgICBsb2Rhc2guaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgbG9kYXNoLmlzRXF1YWwgPSBpc0VxdWFsO1xuICAgIGxvZGFzaC5pc0VxdWFsV2l0aCA9IGlzRXF1YWxXaXRoO1xuICAgIGxvZGFzaC5pc0Vycm9yID0gaXNFcnJvcjtcbiAgICBsb2Rhc2guaXNGaW5pdGUgPSBpc0Zpbml0ZTtcbiAgICBsb2Rhc2guaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gICAgbG9kYXNoLmlzSW50ZWdlciA9IGlzSW50ZWdlcjtcbiAgICBsb2Rhc2guaXNMZW5ndGggPSBpc0xlbmd0aDtcbiAgICBsb2Rhc2guaXNNYXAgPSBpc01hcDtcbiAgICBsb2Rhc2guaXNNYXRjaCA9IGlzTWF0Y2g7XG4gICAgbG9kYXNoLmlzTWF0Y2hXaXRoID0gaXNNYXRjaFdpdGg7XG4gICAgbG9kYXNoLmlzTmFOID0gaXNOYU47XG4gICAgbG9kYXNoLmlzTmF0aXZlID0gaXNOYXRpdmU7XG4gICAgbG9kYXNoLmlzTmlsID0gaXNOaWw7XG4gICAgbG9kYXNoLmlzTnVsbCA9IGlzTnVsbDtcbiAgICBsb2Rhc2guaXNOdW1iZXIgPSBpc051bWJlcjtcbiAgICBsb2Rhc2guaXNPYmplY3QgPSBpc09iamVjdDtcbiAgICBsb2Rhc2guaXNPYmplY3RMaWtlID0gaXNPYmplY3RMaWtlO1xuICAgIGxvZGFzaC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgICBsb2Rhc2guaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbiAgICBsb2Rhc2guaXNTYWZlSW50ZWdlciA9IGlzU2FmZUludGVnZXI7XG4gICAgbG9kYXNoLmlzU2V0ID0gaXNTZXQ7XG4gICAgbG9kYXNoLmlzU3RyaW5nID0gaXNTdHJpbmc7XG4gICAgbG9kYXNoLmlzU3ltYm9sID0gaXNTeW1ib2w7XG4gICAgbG9kYXNoLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcbiAgICBsb2Rhc2guaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbiAgICBsb2Rhc2guaXNXZWFrTWFwID0gaXNXZWFrTWFwO1xuICAgIGxvZGFzaC5pc1dlYWtTZXQgPSBpc1dlYWtTZXQ7XG4gICAgbG9kYXNoLmpvaW4gPSBqb2luO1xuICAgIGxvZGFzaC5rZWJhYkNhc2UgPSBrZWJhYkNhc2U7XG4gICAgbG9kYXNoLmxhc3QgPSBsYXN0O1xuICAgIGxvZGFzaC5sYXN0SW5kZXhPZiA9IGxhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5sb3dlckNhc2UgPSBsb3dlckNhc2U7XG4gICAgbG9kYXNoLmxvd2VyRmlyc3QgPSBsb3dlckZpcnN0O1xuICAgIGxvZGFzaC5sdCA9IGx0O1xuICAgIGxvZGFzaC5sdGUgPSBsdGU7XG4gICAgbG9kYXNoLm1heCA9IG1heDtcbiAgICBsb2Rhc2gubWF4QnkgPSBtYXhCeTtcbiAgICBsb2Rhc2gubWVhbiA9IG1lYW47XG4gICAgbG9kYXNoLm1lYW5CeSA9IG1lYW5CeTtcbiAgICBsb2Rhc2gubWluID0gbWluO1xuICAgIGxvZGFzaC5taW5CeSA9IG1pbkJ5O1xuICAgIGxvZGFzaC5zdHViQXJyYXkgPSBzdHViQXJyYXk7XG4gICAgbG9kYXNoLnN0dWJGYWxzZSA9IHN0dWJGYWxzZTtcbiAgICBsb2Rhc2guc3R1Yk9iamVjdCA9IHN0dWJPYmplY3Q7XG4gICAgbG9kYXNoLnN0dWJTdHJpbmcgPSBzdHViU3RyaW5nO1xuICAgIGxvZGFzaC5zdHViVHJ1ZSA9IHN0dWJUcnVlO1xuICAgIGxvZGFzaC5tdWx0aXBseSA9IG11bHRpcGx5O1xuICAgIGxvZGFzaC5udGggPSBudGg7XG4gICAgbG9kYXNoLm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xuICAgIGxvZGFzaC5ub29wID0gbm9vcDtcbiAgICBsb2Rhc2gubm93ID0gbm93O1xuICAgIGxvZGFzaC5wYWQgPSBwYWQ7XG4gICAgbG9kYXNoLnBhZEVuZCA9IHBhZEVuZDtcbiAgICBsb2Rhc2gucGFkU3RhcnQgPSBwYWRTdGFydDtcbiAgICBsb2Rhc2gucGFyc2VJbnQgPSBwYXJzZUludDtcbiAgICBsb2Rhc2gucmFuZG9tID0gcmFuZG9tO1xuICAgIGxvZGFzaC5yZWR1Y2UgPSByZWR1Y2U7XG4gICAgbG9kYXNoLnJlZHVjZVJpZ2h0ID0gcmVkdWNlUmlnaHQ7XG4gICAgbG9kYXNoLnJlcGVhdCA9IHJlcGVhdDtcbiAgICBsb2Rhc2gucmVwbGFjZSA9IHJlcGxhY2U7XG4gICAgbG9kYXNoLnJlc3VsdCA9IHJlc3VsdDtcbiAgICBsb2Rhc2gucm91bmQgPSByb3VuZDtcbiAgICBsb2Rhc2gucnVuSW5Db250ZXh0ID0gcnVuSW5Db250ZXh0O1xuICAgIGxvZGFzaC5zYW1wbGUgPSBzYW1wbGU7XG4gICAgbG9kYXNoLnNpemUgPSBzaXplO1xuICAgIGxvZGFzaC5zbmFrZUNhc2UgPSBzbmFrZUNhc2U7XG4gICAgbG9kYXNoLnNvbWUgPSBzb21lO1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleCA9IHNvcnRlZEluZGV4O1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleEJ5ID0gc29ydGVkSW5kZXhCeTtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXhPZiA9IHNvcnRlZEluZGV4T2Y7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleCA9IHNvcnRlZExhc3RJbmRleDtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4QnkgPSBzb3J0ZWRMYXN0SW5kZXhCeTtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4T2YgPSBzb3J0ZWRMYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2guc3RhcnRDYXNlID0gc3RhcnRDYXNlO1xuICAgIGxvZGFzaC5zdGFydHNXaXRoID0gc3RhcnRzV2l0aDtcbiAgICBsb2Rhc2guc3VidHJhY3QgPSBzdWJ0cmFjdDtcbiAgICBsb2Rhc2guc3VtID0gc3VtO1xuICAgIGxvZGFzaC5zdW1CeSA9IHN1bUJ5O1xuICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIGxvZGFzaC50aW1lcyA9IHRpbWVzO1xuICAgIGxvZGFzaC50b0Zpbml0ZSA9IHRvRmluaXRlO1xuICAgIGxvZGFzaC50b0ludGVnZXIgPSB0b0ludGVnZXI7XG4gICAgbG9kYXNoLnRvTGVuZ3RoID0gdG9MZW5ndGg7XG4gICAgbG9kYXNoLnRvTG93ZXIgPSB0b0xvd2VyO1xuICAgIGxvZGFzaC50b051bWJlciA9IHRvTnVtYmVyO1xuICAgIGxvZGFzaC50b1NhZmVJbnRlZ2VyID0gdG9TYWZlSW50ZWdlcjtcbiAgICBsb2Rhc2gudG9TdHJpbmcgPSB0b1N0cmluZztcbiAgICBsb2Rhc2gudG9VcHBlciA9IHRvVXBwZXI7XG4gICAgbG9kYXNoLnRyaW0gPSB0cmltO1xuICAgIGxvZGFzaC50cmltRW5kID0gdHJpbUVuZDtcbiAgICBsb2Rhc2gudHJpbVN0YXJ0ID0gdHJpbVN0YXJ0O1xuICAgIGxvZGFzaC50cnVuY2F0ZSA9IHRydW5jYXRlO1xuICAgIGxvZGFzaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuICAgIGxvZGFzaC51cHBlckNhc2UgPSB1cHBlckNhc2U7XG4gICAgbG9kYXNoLnVwcGVyRmlyc3QgPSB1cHBlckZpcnN0O1xuXG4gICAgLy8gQWRkIGFsaWFzZXMuXG4gICAgbG9kYXNoLmVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5lYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZpcnN0ID0gaGVhZDtcblxuICAgIG1peGluKGxvZGFzaCwgKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHt9O1xuICAgICAgYmFzZUZvck93bihsb2Rhc2gsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGxvZGFzaC5wcm90b3R5cGUsIG1ldGhvZE5hbWUpKSB7XG4gICAgICAgICAgc291cmNlW21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc291cmNlO1xuICAgIH0oKSksIHsgJ2NoYWluJzogZmFsc2UgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGxvZGFzaC5WRVJTSU9OID0gVkVSU0lPTjtcblxuICAgIC8vIEFzc2lnbiBkZWZhdWx0IHBsYWNlaG9sZGVycy5cbiAgICBhcnJheUVhY2goWydiaW5kJywgJ2JpbmRLZXknLCAnY3VycnknLCAnY3VycnlSaWdodCcsICdwYXJ0aWFsJywgJ3BhcnRpYWxSaWdodCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICBsb2Rhc2hbbWV0aG9kTmFtZV0ucGxhY2Vob2xkZXIgPSBsb2Rhc2g7XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5kcm9wYCBhbmQgYF8udGFrZWAgdmFyaWFudHMuXG4gICAgYXJyYXlFYWNoKFsnZHJvcCcsICd0YWtlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIG4gPSBuID09PSB1bmRlZmluZWQgPyAxIDogbmF0aXZlTWF4KHRvSW50ZWdlcihuKSwgMCk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9ICh0aGlzLl9fZmlsdGVyZWRfXyAmJiAhaW5kZXgpXG4gICAgICAgICAgPyBuZXcgTGF6eVdyYXBwZXIodGhpcylcbiAgICAgICAgICA6IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAocmVzdWx0Ll9fZmlsdGVyZWRfXykge1xuICAgICAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gbmF0aXZlTWluKG4sIHJlc3VsdC5fX3Rha2VDb3VudF9fKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQuX192aWV3c19fLnB1c2goe1xuICAgICAgICAgICAgJ3NpemUnOiBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCksXG4gICAgICAgICAgICAndHlwZSc6IG1ldGhvZE5hbWUgKyAocmVzdWx0Ll9fZGlyX18gPCAwID8gJ1JpZ2h0JyA6ICcnKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZSArICdSaWdodCddID0gZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKClbbWV0aG9kTmFtZV0obikucmV2ZXJzZSgpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdGhhdCBhY2NlcHQgYW4gYGl0ZXJhdGVlYCB2YWx1ZS5cbiAgICBhcnJheUVhY2goWydmaWx0ZXInLCAnbWFwJywgJ3Rha2VXaGlsZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIHR5cGUgPSBpbmRleCArIDEsXG4gICAgICAgICAgaXNGaWx0ZXIgPSB0eXBlID09IExBWllfRklMVEVSX0ZMQUcgfHwgdHlwZSA9PSBMQVpZX1dISUxFX0ZMQUc7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJlc3VsdC5fX2l0ZXJhdGVlc19fLnB1c2goe1xuICAgICAgICAgICdpdGVyYXRlZSc6IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSxcbiAgICAgICAgICAndHlwZSc6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSByZXN1bHQuX19maWx0ZXJlZF9fIHx8IGlzRmlsdGVyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmhlYWRgIGFuZCBgXy5sYXN0YC5cbiAgICBhcnJheUVhY2goWydoZWFkJywgJ2xhc3QnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB0YWtlTmFtZSA9ICd0YWtlJyArIChpbmRleCA/ICdSaWdodCcgOiAnJyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpc1t0YWtlTmFtZV0oMSkudmFsdWUoKVswXTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5pbml0aWFsYCBhbmQgYF8udGFpbGAuXG4gICAgYXJyYXlFYWNoKFsnaW5pdGlhbCcsICd0YWlsJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgZHJvcE5hbWUgPSAnZHJvcCcgKyAoaW5kZXggPyAnJyA6ICdSaWdodCcpO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19maWx0ZXJlZF9fID8gbmV3IExhenlXcmFwcGVyKHRoaXMpIDogdGhpc1tkcm9wTmFtZV0oMSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihpZGVudGl0eSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIocHJlZGljYXRlKS5oZWFkKCk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5maW5kTGFzdCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLmZpbmQocHJlZGljYXRlKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmludm9rZU1hcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2UodmFsdWUsIHBhdGgsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIobmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgc3RhcnQgPSB0b0ludGVnZXIoc3RhcnQpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcztcbiAgICAgIGlmIChyZXN1bHQuX19maWx0ZXJlZF9fICYmIChzdGFydCA+IDAgfHwgZW5kIDwgMCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXp5V3JhcHBlcihyZXN1bHQpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQudGFrZVJpZ2h0KC1zdGFydCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5kcm9wKHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSB0b0ludGVnZXIoZW5kKTtcbiAgICAgICAgcmVzdWx0ID0gZW5kIDwgMCA/IHJlc3VsdC5kcm9wUmlnaHQoLWVuZCkgOiByZXN1bHQudGFrZShlbmQgLSBzdGFydCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudGFrZVJpZ2h0V2hpbGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS50YWtlV2hpbGUocHJlZGljYXRlKS5yZXZlcnNlKCk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50YWtlKE1BWF9BUlJBWV9MRU5HVEgpO1xuICAgIH07XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGNoZWNrSXRlcmF0ZWUgPSAvXig/OmZpbHRlcnxmaW5kfG1hcHxyZWplY3QpfFdoaWxlJC8udGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgICBpc1Rha2VyID0gL14oPzpoZWFkfGxhc3QpJC8udGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgICBsb2Rhc2hGdW5jID0gbG9kYXNoW2lzVGFrZXIgPyAoJ3Rha2UnICsgKG1ldGhvZE5hbWUgPT0gJ2xhc3QnID8gJ1JpZ2h0JyA6ICcnKSkgOiBtZXRob2ROYW1lXSxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSBpc1Rha2VyIHx8IC9eZmluZC8udGVzdChtZXRob2ROYW1lKTtcblxuICAgICAgaWYgKCFsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICAgIGFyZ3MgPSBpc1Rha2VyID8gWzFdIDogYXJndW1lbnRzLFxuICAgICAgICAgICAgaXNMYXp5ID0gdmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcixcbiAgICAgICAgICAgIGl0ZXJhdGVlID0gYXJnc1swXSxcbiAgICAgICAgICAgIHVzZUxhenkgPSBpc0xhenkgfHwgaXNBcnJheSh2YWx1ZSk7XG5cbiAgICAgICAgdmFyIGludGVyY2VwdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoRnVuYy5hcHBseShsb2Rhc2gsIGFycmF5UHVzaChbdmFsdWVdLCBhcmdzKSk7XG4gICAgICAgICAgcmV0dXJuIChpc1Rha2VyICYmIGNoYWluQWxsKSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodXNlTGF6eSAmJiBjaGVja0l0ZXJhdGVlICYmIHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nICYmIGl0ZXJhdGVlLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgICAgLy8gQXZvaWQgbGF6eSB1c2UgaWYgdGhlIGl0ZXJhdGVlIGhhcyBhIFwibGVuZ3RoXCIgdmFsdWUgb3RoZXIgdGhhbiBgMWAuXG4gICAgICAgICAgaXNMYXp5ID0gdXNlTGF6eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgaXNIeWJyaWQgPSAhIXRoaXMuX19hY3Rpb25zX18ubGVuZ3RoLFxuICAgICAgICAgICAgaXNVbndyYXBwZWQgPSByZXRVbndyYXBwZWQgJiYgIWNoYWluQWxsLFxuICAgICAgICAgICAgb25seUxhenkgPSBpc0xhenkgJiYgIWlzSHlicmlkO1xuXG4gICAgICAgIGlmICghcmV0VW53cmFwcGVkICYmIHVzZUxhenkpIHtcbiAgICAgICAgICB2YWx1ZSA9IG9ubHlMYXp5ID8gdmFsdWUgOiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgICAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXy5wdXNoKHsgJ2Z1bmMnOiB0aHJ1LCAnYXJncyc6IFtpbnRlcmNlcHRvcl0sICd0aGlzQXJnJzogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbndyYXBwZWQgJiYgb25seUxhenkpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSB0aGlzLnRocnUoaW50ZXJjZXB0b3IpO1xuICAgICAgICByZXR1cm4gaXNVbndyYXBwZWQgPyAoaXNUYWtlciA/IHJlc3VsdC52YWx1ZSgpWzBdIDogcmVzdWx0LnZhbHVlKCkpIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgQXJyYXlgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGFycmF5RWFjaChbJ3BvcCcsICdwdXNoJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBhcnJheVByb3RvW21ldGhvZE5hbWVdLFxuICAgICAgICAgIGNoYWluTmFtZSA9IC9eKD86cHVzaHxzb3J0fHVuc2hpZnQpJC8udGVzdChtZXRob2ROYW1lKSA/ICd0YXAnIDogJ3RocnUnLFxuICAgICAgICAgIHJldFVud3JhcHBlZCA9IC9eKD86cG9wfHNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSk7XG5cbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGlmIChyZXRVbndyYXBwZWQgJiYgIXRoaXMuX19jaGFpbl9fKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZSgpO1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNbY2hhaW5OYW1lXShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIE1hcCBtaW5pZmllZCBtZXRob2QgbmFtZXMgdG8gdGhlaXIgcmVhbCBuYW1lcy5cbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGxvZGFzaEZ1bmMgPSBsb2Rhc2hbbWV0aG9kTmFtZV07XG4gICAgICBpZiAobG9kYXNoRnVuYykge1xuICAgICAgICB2YXIga2V5ID0gbG9kYXNoRnVuYy5uYW1lICsgJyc7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChyZWFsTmFtZXMsIGtleSkpIHtcbiAgICAgICAgICByZWFsTmFtZXNba2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJlYWxOYW1lc1trZXldLnB1c2goeyAnbmFtZSc6IG1ldGhvZE5hbWUsICdmdW5jJzogbG9kYXNoRnVuYyB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlYWxOYW1lc1tjcmVhdGVIeWJyaWQodW5kZWZpbmVkLCBXUkFQX0JJTkRfS0VZX0ZMQUcpLm5hbWVdID0gW3tcbiAgICAgICduYW1lJzogJ3dyYXBwZXInLFxuICAgICAgJ2Z1bmMnOiB1bmRlZmluZWRcbiAgICB9XTtcblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMYXp5V3JhcHBlcmAuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNsb25lID0gbGF6eUNsb25lO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZXZlcnNlID0gbGF6eVJldmVyc2U7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnZhbHVlID0gbGF6eVZhbHVlO1xuXG4gICAgLy8gQWRkIGNoYWluIHNlcXVlbmNlIG1ldGhvZHMgdG8gdGhlIGBsb2Rhc2hgIHdyYXBwZXIuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5hdCA9IHdyYXBwZXJBdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gd3JhcHBlckNoYWluO1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY29tbWl0ID0gd3JhcHBlckNvbW1pdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLm5leHQgPSB3cmFwcGVyTmV4dDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnBsYW50ID0gd3JhcHBlclBsYW50O1xuICAgIGxvZGFzaC5wcm90b3R5cGUucmV2ZXJzZSA9IHdyYXBwZXJSZXZlcnNlO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudG9KU09OID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZU9mID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZSA9IHdyYXBwZXJWYWx1ZTtcblxuICAgIC8vIEFkZCBsYXp5IGFsaWFzZXMuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5maXJzdCA9IGxvZGFzaC5wcm90b3R5cGUuaGVhZDtcblxuICAgIGlmIChzeW1JdGVyYXRvcikge1xuICAgICAgbG9kYXNoLnByb3RvdHlwZVtzeW1JdGVyYXRvcl0gPSB3cmFwcGVyVG9JdGVyYXRvcjtcbiAgICB9XG4gICAgcmV0dXJuIGxvZGFzaDtcbiAgfSk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gRXhwb3J0IGxvZGFzaC5cbiAgdmFyIF8gPSBydW5JbkNvbnRleHQoKTtcblxuICAvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBjb25kaXRpb24gcGF0dGVybnMgbGlrZTpcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gRXhwb3NlIExvZGFzaCBvbiB0aGUgZ2xvYmFsIG9iamVjdCB0byBwcmV2ZW50IGVycm9ycyB3aGVuIExvZGFzaCBpc1xuICAgIC8vIGxvYWRlZCBieSBhIHNjcmlwdCB0YWcgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRCBsb2FkZXIuXG4gICAgLy8gU2VlIGh0dHA6Ly9yZXF1aXJlanMub3JnL2RvY3MvZXJyb3JzLmh0bWwjbWlzbWF0Y2ggZm9yIG1vcmUgZGV0YWlscy5cbiAgICAvLyBVc2UgYF8ubm9Db25mbGljdGAgdG8gcmVtb3ZlIExvZGFzaCBmcm9tIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgIHJvb3QuXyA9IF87XG5cbiAgICAvLyBEZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSBzbywgdGhyb3VnaCBwYXRoIG1hcHBpbmcsIGl0IGNhbiBiZVxuICAgIC8vIHJlZmVyZW5jZWQgYXMgdGhlIFwidW5kZXJzY29yZVwiIG1vZHVsZS5cbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxuICAvLyBDaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBpdC5cbiAgZWxzZSBpZiAoZnJlZU1vZHVsZSkge1xuICAgIC8vIEV4cG9ydCBmb3IgTm9kZS5qcy5cbiAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gXykuXyA9IF87XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBzdXBwb3J0LlxuICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIEV4cG9ydCB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICByb290Ll8gPSBfO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gYXZvaWQgc2NvcGUgY3JlZXAsIHRoZSBrZXlzIGFycmF5IGNhbiB0aGVuIGJlIGNvbGxlY3RlZFxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcG5hLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgdGhpcy5lbmQoKTtcblxuICBwbmEubmV4dFRpY2soY2IsIGVycik7XG59OyIsInZhciBzdXBlclByb3BCYXNlID0gcmVxdWlyZShcIi4vc3VwZXJQcm9wQmFzZVwiKTtcblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICB2YXIgYmFzZSA9IHN1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXQ7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZjsiLCIvKipcbiAqIGh0dHA6Ly93d3cuY29kZXByb2plY3QuY29tL1RpcHMvNDA3MTcyL0Nvbm5lY3RlZC1Db21wb25lbnQtTGFiZWxpbmctYW5kLVZlY3Rvcml6YXRpb25cbiAqL1xuY29uc3QgVHJhY2VyID0ge1xuICAgIHNlYXJjaERpcmVjdGlvbnM6IFtbMCwgMV0sIFsxLCAxXSwgWzEsIDBdLCBbMSwgLTFdLCBbMCwgLTFdLCBbLTEsIC0xXSwgWy0xLCAwXSwgWy0xLCAxXV0sXG4gICAgY3JlYXRlKGltYWdlV3JhcHBlciwgbGFiZWxXcmFwcGVyKSB7XG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgICAgICBjb25zdCBsYWJlbERhdGEgPSBsYWJlbFdyYXBwZXIuZGF0YTtcbiAgICAgICAgY29uc3QgeyBzZWFyY2hEaXJlY3Rpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgICAgIGxldCBwb3M7XG5cbiAgICAgICAgZnVuY3Rpb24gdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpIHtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgbGV0IHk7XG4gICAgICAgICAgICBsZXQgeDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgICAgIHkgPSBjdXJyZW50LmN5ICsgc2VhcmNoRGlyZWN0aW9uc1tjdXJyZW50LmRpcl1bMF07XG4gICAgICAgICAgICAgICAgeCA9IGN1cnJlbnQuY3ggKyBzZWFyY2hEaXJlY3Rpb25zW2N1cnJlbnQuZGlyXVsxXTtcbiAgICAgICAgICAgICAgICBwb3MgPSB5ICogd2lkdGggKyB4O1xuICAgICAgICAgICAgICAgIGlmICgoaW1hZ2VEYXRhW3Bvc10gPT09IGNvbG9yKSAmJiAoKGxhYmVsRGF0YVtwb3NdID09PSAwKSB8fCAobGFiZWxEYXRhW3Bvc10gPT09IGxhYmVsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRhW3Bvc10gPSBsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5jeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuY3ggPSB4O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsRGF0YVtwb3NdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsRGF0YVtwb3NdID0gZWRnZWxhYmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50LmRpciA9IChjdXJyZW50LmRpciArIDEpICUgODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHZlcnRleDJEKHgsIHksIGRpcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgcHJldjogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb250b3VyVHJhY2luZyhzeSwgc3gsIGxhYmVsLCBjb2xvciwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICBsZXQgRnYgPSBudWxsO1xuICAgICAgICAgICAgbGV0IEN2O1xuICAgICAgICAgICAgbGV0IFA7XG4gICAgICAgICAgICBsZXQgbGRpcjtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgY3g6IHN4LFxuICAgICAgICAgICAgICAgIGN5OiBzeSxcbiAgICAgICAgICAgICAgICBkaXI6IDAsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgRnYgPSB2ZXJ0ZXgyRChzeCwgc3ksIGN1cnJlbnQuZGlyKTtcbiAgICAgICAgICAgICAgICBDdiA9IEZ2O1xuICAgICAgICAgICAgICAgIGxkaXIgPSBjdXJyZW50LmRpcjtcbiAgICAgICAgICAgICAgICBQID0gdmVydGV4MkQoY3VycmVudC5jeCwgY3VycmVudC5jeSwgMCk7XG4gICAgICAgICAgICAgICAgUC5wcmV2ID0gQ3Y7XG4gICAgICAgICAgICAgICAgQ3YubmV4dCA9IFA7XG4gICAgICAgICAgICAgICAgUC5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBDdiA9IFA7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmRpciA9IChjdXJyZW50LmRpciArIDYpICUgODtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGRpciAhPT0gY3VycmVudC5kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2LmRpciA9IGN1cnJlbnQuZGlyO1xuICAgICAgICAgICAgICAgICAgICAgICAgUCA9IHZlcnRleDJEKGN1cnJlbnQuY3gsIGN1cnJlbnQuY3ksIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgUC5wcmV2ID0gQ3Y7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi5uZXh0ID0gUDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFAubmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdiA9IFA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi5kaXIgPSBsZGlyO1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YueCA9IGN1cnJlbnQuY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi55ID0gY3VycmVudC5jeTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZGlyID0gY3VycmVudC5kaXI7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoY3VycmVudC5jeCAhPT0gc3ggfHwgY3VycmVudC5jeSAhPT0gc3kpO1xuICAgICAgICAgICAgICAgIEZ2LnByZXYgPSBDdi5wcmV2O1xuICAgICAgICAgICAgICAgIEN2LnByZXYubmV4dCA9IEZ2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZ2O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250b3VyVHJhY2luZyhzeSwgc3gsIGxhYmVsLCBjb2xvciwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRvdXJUcmFjaW5nKHN5LCBzeCwgbGFiZWwsIGNvbG9yLCBlZGdlbGFiZWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgKFRyYWNlcik7XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiaW1wb3J0ICogYXMgdmVjMiBmcm9tICdnbC12ZWMyJztcbmltcG9ydCAqIGFzIG1hdDIgZnJvbSAnZ2wtbWF0Mic7XG5pbXBvcnQgSW1hZ2VXcmFwcGVyIGZyb20gJy4uL2NvbW1vbi9pbWFnZV93cmFwcGVyJztcbmltcG9ydCB7XG4gICAgY2FsY3VsYXRlUGF0Y2hTaXplLFxuICAgIG90c3VUaHJlc2hvbGQsXG4gICAgaHN2MnJnYixcbiAgICBjbHVzdGVyLFxuICAgIHRvcEdlbmVyaWMsXG4gICAgaW1hZ2VSZWYsXG4gICAgaGFsZlNhbXBsZSxcbiAgICBjb21wdXRlSW1hZ2VBcmVhLFxufSBmcm9tICcuLi9jb21tb24vY3ZfdXRpbHMnO1xuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xuaW1wb3J0IEltYWdlRGVidWcgZnJvbSAnLi4vY29tbW9uL2ltYWdlX2RlYnVnJztcbmltcG9ydCBSYXN0ZXJpemVyIGZyb20gJy4vcmFzdGVyaXplcic7XG5pbXBvcnQgVHJhY2VyIGZyb20gJy4vdHJhY2VyJztcbmltcG9ydCBza2VsZXRvbml6ZXIgZnJvbSAnLi9za2VsZXRvbml6ZXInO1xuXG5cbmxldCBfY29uZmlnO1xubGV0IF9jdXJyZW50SW1hZ2VXcmFwcGVyO1xubGV0IF9za2VsSW1hZ2VXcmFwcGVyO1xubGV0IF9zdWJJbWFnZVdyYXBwZXI7XG5sZXQgX2xhYmVsSW1hZ2VXcmFwcGVyO1xubGV0IF9wYXRjaEdyaWQ7XG5sZXQgX3BhdGNoTGFiZWxHcmlkO1xubGV0IF9pbWFnZVRvUGF0Y2hHcmlkO1xubGV0IF9iaW5hcnlJbWFnZVdyYXBwZXI7XG5sZXQgX3BhdGNoU2l6ZTtcbmNvbnN0IF9jYW52YXNDb250YWluZXIgPSB7XG4gICAgY3R4OiB7XG4gICAgICAgIGJpbmFyeTogbnVsbCxcbiAgICB9LFxuICAgIGRvbToge1xuICAgICAgICBiaW5hcnk6IG51bGwsXG4gICAgfSxcbn07XG5jb25zdCBfbnVtUGF0Y2hlcyA9IHsgeDogMCwgeTogMCB9O1xubGV0IF9pbnB1dEltYWdlV3JhcHBlcjtcbmxldCBfc2tlbGV0b25pemVyO1xuXG5mdW5jdGlvbiBpbml0QnVmZmVycygpIHtcbiAgICBpZiAoX2NvbmZpZy5oYWxmU2FtcGxlKSB7XG4gICAgICAgIF9jdXJyZW50SW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcih7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAgICAgeDogX2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueCAvIDIgfCAwLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICAgIHk6IF9pbnB1dEltYWdlV3JhcHBlci5zaXplLnkgLyAyIHwgMCxcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2N1cnJlbnRJbWFnZVdyYXBwZXIgPSBfaW5wdXRJbWFnZVdyYXBwZXI7XG4gICAgfVxuXG4gICAgX3BhdGNoU2l6ZSA9IGNhbGN1bGF0ZVBhdGNoU2l6ZShfY29uZmlnLnBhdGNoU2l6ZSwgX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZSk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIF9udW1QYXRjaGVzLnggPSBfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnggLyBfcGF0Y2hTaXplLnggfCAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgX251bVBhdGNoZXMueSA9IF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUueSAvIF9wYXRjaFNpemUueSB8IDA7XG5cbiAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcihfY3VycmVudEltYWdlV3JhcHBlci5zaXplLCB1bmRlZmluZWQsIFVpbnQ4QXJyYXksIGZhbHNlKTtcblxuICAgIF9sYWJlbEltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoX3BhdGNoU2l6ZSwgdW5kZWZpbmVkLCBBcnJheSwgdHJ1ZSk7XG5cbiAgICBjb25zdCBza2VsZXRvbkltYWdlRGF0YSA9IG5ldyBBcnJheUJ1ZmZlcig2NCAqIDEwMjQpO1xuICAgIF9zdWJJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9wYXRjaFNpemUsXG4gICAgICAgIG5ldyBVaW50OEFycmF5KHNrZWxldG9uSW1hZ2VEYXRhLCAwLCBfcGF0Y2hTaXplLnggKiBfcGF0Y2hTaXplLnkpKTtcbiAgICBfc2tlbEltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoX3BhdGNoU2l6ZSxcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoc2tlbGV0b25JbWFnZURhdGEsIF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSAqIDMsIF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSksXG4gICAgICAgIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgX3NrZWxldG9uaXplciA9IHNrZWxldG9uaXplcihcbiAgICAgICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdyA6ICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpID8gc2VsZiA6IGdsb2JhbCxcbiAgICAgICAgeyBzaXplOiBfcGF0Y2hTaXplLnggfSxcbiAgICAgICAgc2tlbGV0b25JbWFnZURhdGEsXG4gICAgKTtcblxuICAgIF9pbWFnZVRvUGF0Y2hHcmlkID0gbmV3IEltYWdlV3JhcHBlcih7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIHg6IChfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnggLyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCkgfCAwLFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB5OiAoX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS55IC8gX3N1YkltYWdlV3JhcHBlci5zaXplLnkpIHwgMCxcbiAgICB9LCB1bmRlZmluZWQsIEFycmF5LCB0cnVlKTtcbiAgICBfcGF0Y2hHcmlkID0gbmV3IEltYWdlV3JhcHBlcihfaW1hZ2VUb1BhdGNoR3JpZC5zaXplLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgX3BhdGNoTGFiZWxHcmlkID0gbmV3IEltYWdlV3JhcHBlcihfaW1hZ2VUb1BhdGNoR3JpZC5zaXplLCB1bmRlZmluZWQsIEludDMyQXJyYXksIHRydWUpO1xufVxuXG5mdW5jdGlvbiBpbml0Q2FudmFzKCkge1xuICAgIGlmIChfY29uZmlnLnVzZVdvcmtlciB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LmNsYXNzTmFtZSA9ICdiaW5hcnlCdWZmZXInO1xuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Q2FudmFzID09PSB0cnVlKSB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNkZWJ1ZycpLmFwcGVuZENoaWxkKF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSk7XG4gICAgfVxuICAgIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSA9IF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS53aWR0aCA9IF9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS5oZWlnaHQgPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYm91bmRpbmcgYm94IHdoaWNoIGVuY2xvc2VzIGFsbCB0aGUgZ2l2ZW4gcGF0Y2hlc1xuICogQHJldHVybnMge0FycmF5fSBUaGUgbWluaW1hbCBib3VuZGluZyBib3hcbiAqL1xuZnVuY3Rpb24gYm94RnJvbVBhdGNoZXMocGF0Y2hlcykge1xuICAgIGxldCBvdmVyQXZnO1xuICAgIGxldCBpO1xuICAgIGxldCBqO1xuICAgIGxldCBwYXRjaDtcbiAgICBsZXQgdHJhbnNNYXQ7XG4gICAgbGV0IG1pbnggPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgbWlueSA9IF9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGxldCBtYXh4ID0gLV9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGxldCBtYXh5ID0gLV9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGxldCBib3g7XG4gICAgbGV0IHNjYWxlO1xuXG4gICAgLy8gZHJhdyBhbGwgcGF0Y2hlcyB3aGljaCBhcmUgdG8gYmUgdGFrZW4gaW50byBjb25zaWRlcmF0aW9uXG4gICAgb3ZlckF2ZyA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuICAgICAgICBvdmVyQXZnICs9IHBhdGNoLnJhZDtcbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dQYXRjaGVzKSB7XG4gICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdSZWN0KHBhdGNoLnBvcywgX3N1YkltYWdlV3JhcHBlci5zaXplLCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHsgY29sb3I6ICdyZWQnIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3ZlckF2ZyAvPSBwYXRjaGVzLmxlbmd0aDtcbiAgICBvdmVyQXZnID0gKG92ZXJBdmcgKiAxODAgLyBNYXRoLlBJICsgOTApICUgMTgwIC0gOTA7XG4gICAgaWYgKG92ZXJBdmcgPCAwKSB7XG4gICAgICAgIG92ZXJBdmcgKz0gMTgwO1xuICAgIH1cblxuICAgIG92ZXJBdmcgPSAoMTgwIC0gb3ZlckF2ZykgKiBNYXRoLlBJIC8gMTgwO1xuICAgIHRyYW5zTWF0ID0gbWF0Mi5jb3B5KG1hdDIuY3JlYXRlKCksIFtNYXRoLmNvcyhvdmVyQXZnKSwgTWF0aC5zaW4ob3ZlckF2ZyksIC1NYXRoLnNpbihvdmVyQXZnKSwgTWF0aC5jb3Mob3ZlckF2ZyldKTtcblxuICAgIC8vIGl0ZXJhdGUgb3ZlciBwYXRjaGVzIGFuZCByb3RhdGUgYnkgYW5nbGVcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXRjaCA9IHBhdGNoZXNbaV07XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgIHZlYzIudHJhbnNmb3JtTWF0MihwYXRjaC5ib3hbal0sIHBhdGNoLmJveFtqXSwgdHJhbnNNYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLmJveEZyb21QYXRjaGVzLnNob3dUcmFuc2Zvcm1lZCkge1xuICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChwYXRjaC5ib3gsIHsgeDogMCwgeTogMSB9LCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHsgY29sb3I6ICcjOTlmZjAwJywgbGluZVdpZHRoOiAyIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmluZCBib3VuZGluZyBib3hcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXRjaCA9IHBhdGNoZXNbaV07XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMF0gPCBtaW54KSB7XG4gICAgICAgICAgICAgICAgbWlueCA9IHBhdGNoLmJveFtqXVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMF0gPiBtYXh4KSB7XG4gICAgICAgICAgICAgICAgbWF4eCA9IHBhdGNoLmJveFtqXVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMV0gPCBtaW55KSB7XG4gICAgICAgICAgICAgICAgbWlueSA9IHBhdGNoLmJveFtqXVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMV0gPiBtYXh5KSB7XG4gICAgICAgICAgICAgICAgbWF4eSA9IHBhdGNoLmJveFtqXVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJveCA9IFtbbWlueCwgbWlueV0sIFttYXh4LCBtaW55XSwgW21heHgsIG1heHldLCBbbWlueCwgbWF4eV1dO1xuXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLmJveEZyb21QYXRjaGVzLnNob3dUcmFuc2Zvcm1lZEJveCkge1xuICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGJveCwgeyB4OiAwLCB5OiAxIH0sIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSwgeyBjb2xvcjogJyNmZjAwMDAnLCBsaW5lV2lkdGg6IDIgfSk7XG4gICAgfVxuXG4gICAgc2NhbGUgPSBfY29uZmlnLmhhbGZTYW1wbGUgPyAyIDogMTtcbiAgICAvLyByZXZlcnNlIHJvdGF0aW9uO1xuICAgIHRyYW5zTWF0ID0gbWF0Mi5pbnZlcnQodHJhbnNNYXQsIHRyYW5zTWF0KTtcbiAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgIHZlYzIudHJhbnNmb3JtTWF0Mihib3hbal0sIGJveFtqXSwgdHJhbnNNYXQpO1xuICAgIH1cblxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5ib3hGcm9tUGF0Y2hlcy5zaG93QkIpIHtcbiAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChib3gsIHsgeDogMCwgeTogMSB9LCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHsgY29sb3I6ICcjZmYwMDAwJywgbGluZVdpZHRoOiAyIH0pO1xuICAgIH1cblxuICAgIGZvciAoaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgdmVjMi5zY2FsZShib3hbal0sIGJveFtqXSwgc2NhbGUpO1xuICAgIH1cblxuICAgIHJldHVybiBib3g7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJpbmFyeSBpbWFnZSBvZiB0aGUgY3VycmVudCBpbWFnZVxuICovXG5mdW5jdGlvbiBiaW5hcml6ZUltYWdlKCkge1xuICAgIG90c3VUaHJlc2hvbGQoX2N1cnJlbnRJbWFnZVdyYXBwZXIsIF9iaW5hcnlJbWFnZVdyYXBwZXIpO1xuICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIuemVyb0JvcmRlcigpO1xuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Q2FudmFzKSB7XG4gICAgICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIuc2hvdyhfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnksIDI1NSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciB0aGUgZW50aXJlIGltYWdlXG4gKiBleHRyYWN0IHBhdGNoZXNcbiAqL1xuZnVuY3Rpb24gZmluZFBhdGNoZXMoKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IGo7XG4gICAgbGV0IHg7XG4gICAgbGV0IHk7XG4gICAgbGV0IG1vbWVudHM7XG4gICAgbGV0IHBhdGNoZXNGb3VuZCA9IFtdO1xuICAgIGxldCByYXN0ZXJpemVyO1xuICAgIGxldCByYXN0ZXJSZXN1bHQ7XG4gICAgbGV0IHBhdGNoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBfbnVtUGF0Y2hlcy54OyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IF9udW1QYXRjaGVzLnk7IGorKykge1xuICAgICAgICAgICAgeCA9IF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54ICogaTtcbiAgICAgICAgICAgIHkgPSBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueSAqIGo7XG5cbiAgICAgICAgICAgIC8vIHNlcGVyYXRlIHBhcnRzXG4gICAgICAgICAgICBza2VsZXRvbml6ZSh4LCB5KTtcblxuICAgICAgICAgICAgLy8gUmFzdGVyaXplLCBmaW5kIGluZGl2aWR1YWwgYmFyc1xuICAgICAgICAgICAgX3NrZWxJbWFnZVdyYXBwZXIuemVyb0JvcmRlcigpO1xuICAgICAgICAgICAgQXJyYXlIZWxwZXIuaW5pdChfbGFiZWxJbWFnZVdyYXBwZXIuZGF0YSwgMCk7XG4gICAgICAgICAgICByYXN0ZXJpemVyID0gUmFzdGVyaXplci5jcmVhdGUoX3NrZWxJbWFnZVdyYXBwZXIsIF9sYWJlbEltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICByYXN0ZXJSZXN1bHQgPSByYXN0ZXJpemVyLnJhc3Rlcml6ZSgwKTtcblxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dMYWJlbHMpIHtcbiAgICAgICAgICAgICAgICBfbGFiZWxJbWFnZVdyYXBwZXIub3ZlcmxheShfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnksIE1hdGguZmxvb3IoMzYwIC8gcmFzdGVyUmVzdWx0LmNvdW50KSxcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgbW9tZW50cyBmcm9tIHRoZSBza2VsZXRvbml6ZWQgcGF0Y2hcbiAgICAgICAgICAgIG1vbWVudHMgPSBfbGFiZWxJbWFnZVdyYXBwZXIubW9tZW50cyhyYXN0ZXJSZXN1bHQuY291bnQpO1xuXG4gICAgICAgICAgICAvLyBleHRyYWN0IGVsaWdpYmxlIHBhdGNoZXNcbiAgICAgICAgICAgIHBhdGNoZXNGb3VuZCA9IHBhdGNoZXNGb3VuZC5jb25jYXQoZGVzY3JpYmVQYXRjaChtb21lbnRzLCBbaSwgal0sIHgsIHkpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Rm91bmRQYXRjaGVzKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXRjaGVzRm91bmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhdGNoID0gcGF0Y2hlc0ZvdW5kW2ldO1xuICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UmVjdChwYXRjaC5wb3MsIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LFxuICAgICAgICAgICAgICAgIHsgY29sb3I6ICcjOTlmZjAwJywgbGluZVdpZHRoOiAyIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGNoZXNGb3VuZDtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aG9zZSBjb25uZWN0ZWQgYXJlYXMgd2hpY2ggY29udGFpbiBhdCBsZWFzdCA2IHBhdGNoZXNcbiAqIGFuZCByZXR1cm5zIHRoZW0gb3JkZXJlZCBERVNDIGJ5IHRoZSBudW1iZXIgb2YgY29udGFpbmVkIHBhdGNoZXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhMYWJlbFxuICovXG5mdW5jdGlvbiBmaW5kQmlnZ2VzdENvbm5lY3RlZEFyZWFzKG1heExhYmVsKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IHN1bTtcbiAgICBsZXQgbGFiZWxIaXN0ID0gW107XG4gICAgbGV0IHRvcExhYmVscyA9IFtdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG1heExhYmVsOyBpKyspIHtcbiAgICAgICAgbGFiZWxIaXN0LnB1c2goMCk7XG4gICAgfVxuICAgIHN1bSA9IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aDtcbiAgICB3aGlsZSAoc3VtLS0pIHtcbiAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW3N1bV0gPiAwKSB7XG4gICAgICAgICAgICBsYWJlbEhpc3RbX3BhdGNoTGFiZWxHcmlkLmRhdGFbc3VtXSAtIDFdKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsYWJlbEhpc3QgPSBsYWJlbEhpc3QubWFwKCh2YWwsIGlkeCkgPT4gKHtcbiAgICAgICAgdmFsLFxuICAgICAgICBsYWJlbDogaWR4ICsgMSxcbiAgICB9KSk7XG5cbiAgICBsYWJlbEhpc3Quc29ydCgoYSwgYikgPT4gYi52YWwgLSBhLnZhbCk7XG5cbiAgICAvLyBleHRyYWN0IHRvcCBhcmVhcyB3aXRoIGF0IGxlYXN0IDYgcGF0Y2hlcyBwcmVzZW50XG4gICAgdG9wTGFiZWxzID0gbGFiZWxIaXN0LmZpbHRlcigoZWwpID0+IGVsLnZhbCA+PSA1KTtcblxuICAgIHJldHVybiB0b3BMYWJlbHM7XG59XG5cbi8qKlxuICpcbiAqL1xuZnVuY3Rpb24gZmluZEJveGVzKHRvcExhYmVscywgbWF4TGFiZWwpIHtcbiAgICBsZXQgaTtcbiAgICBsZXQgajtcbiAgICBsZXQgc3VtO1xuICAgIGNvbnN0IHBhdGNoZXMgPSBbXTtcbiAgICBsZXQgcGF0Y2g7XG4gICAgbGV0IGJveDtcbiAgICBjb25zdCBib3hlcyA9IFtdO1xuICAgIGNvbnN0IGhzdiA9IFswLCAxLCAxXTtcbiAgICBjb25zdCByZ2IgPSBbMCwgMCwgMF07XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9wTGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN1bSA9IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aDtcbiAgICAgICAgcGF0Y2hlcy5sZW5ndGggPSAwO1xuICAgICAgICB3aGlsZSAoc3VtLS0pIHtcbiAgICAgICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtzdW1dID09PSB0b3BMYWJlbHNbaV0ubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBwYXRjaCA9IF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbc3VtXTtcbiAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJveCA9IGJveEZyb21QYXRjaGVzKHBhdGNoZXMpO1xuICAgICAgICBpZiAoYm94KSB7XG4gICAgICAgICAgICBib3hlcy5wdXNoKGJveCk7XG5cbiAgICAgICAgICAgIC8vIGRyYXcgcGF0Y2gtbGFiZWxzIGlmIHJlcXVlc3RlZFxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dSZW1haW5pbmdQYXRjaExhYmVscykge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBwYXRjaGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoID0gcGF0Y2hlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaHN2WzBdID0gKHRvcExhYmVsc1tpXS5sYWJlbCAvIChtYXhMYWJlbCArIDEpKSAqIDM2MDtcbiAgICAgICAgICAgICAgICAgICAgaHN2MnJnYihoc3YsIHJnYik7XG4gICAgICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgY29sb3I6IGByZ2IoJHtyZ2Iuam9pbignLCcpfSlgLCBsaW5lV2lkdGg6IDIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib3hlcztcbn1cblxuLyoqXG4gKiBGaW5kIHNpbWlsYXIgbW9tZW50cyAodmlhIGNsdXN0ZXIpXG4gKiBAcGFyYW0ge09iamVjdH0gbW9tZW50c1xuICovXG5mdW5jdGlvbiBzaW1pbGFyTW9tZW50cyhtb21lbnRzKSB7XG4gICAgY29uc3QgY2x1c3RlcnMgPSBjbHVzdGVyKG1vbWVudHMsIDAuOTApO1xuICAgIGNvbnN0IHRvcENsdXN0ZXIgPSB0b3BHZW5lcmljKGNsdXN0ZXJzLCAxLCAoZSkgPT4gZS5nZXRQb2ludHMoKS5sZW5ndGgpO1xuICAgIGxldCBwb2ludHMgPSBbXTsgY29uc3RcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgaWYgKHRvcENsdXN0ZXIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHBvaW50cyA9IHRvcENsdXN0ZXJbMF0uaXRlbS5nZXRQb2ludHMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBvaW50c1tpXS5wb2ludCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc2tlbGV0b25pemUoeCwgeSkge1xuICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIuc3ViSW1hZ2VBc0NvcHkoX3N1YkltYWdlV3JhcHBlciwgaW1hZ2VSZWYoeCwgeSkpO1xuICAgIF9za2VsZXRvbml6ZXIuc2tlbGV0b25pemUoKTtcblxuICAgIC8vIFNob3cgc2tlbGV0b24gaWYgcmVxdWVzdGVkXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dTa2VsZXRvbikge1xuICAgICAgICBfc2tlbEltYWdlV3JhcHBlci5vdmVybGF5KF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSwgMzYwLCBpbWFnZVJlZih4LCB5KSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3RzIGFuZCBkZXNjcmliZXMgdGhvc2UgcGF0Y2hlcyB3aGljaCBzZWVtIHRvIGNvbnRhaW4gYSBiYXJjb2RlIHBhdHRlcm5cbiAqIEBwYXJhbSB7QXJyYXl9IG1vbWVudHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXRjaFBvcyxcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybnMge0FycmF5fSBsaXN0IG9mIHBhdGNoZXNcbiAqL1xuZnVuY3Rpb24gZGVzY3JpYmVQYXRjaChtb21lbnRzLCBwYXRjaFBvcywgeCwgeSkge1xuICAgIGxldCBrO1xuICAgIGxldCBhdmc7XG4gICAgY29uc3QgZWxpZ2libGVNb21lbnRzID0gW107XG4gICAgbGV0IG1hdGNoaW5nTW9tZW50cztcbiAgICBsZXQgcGF0Y2g7XG4gICAgY29uc3QgcGF0Y2hlc0ZvdW5kID0gW107XG4gICAgY29uc3QgbWluQ29tcG9uZW50V2VpZ2h0ID0gTWF0aC5jZWlsKF9wYXRjaFNpemUueCAvIDMpO1xuXG4gICAgaWYgKG1vbWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgLy8gb25seSBjb2xsZWN0IG1vbWVudHMgd2hpY2gncyBhcmVhIGNvdmVycyBhdCBsZWFzdCBtaW5Db21wb25lbnRXZWlnaHQgcGl4ZWxzLlxuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbW9tZW50cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgaWYgKG1vbWVudHNba10ubTAwID4gbWluQ29tcG9uZW50V2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZWxpZ2libGVNb21lbnRzLnB1c2gobW9tZW50c1trXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBhdCBsZWFzdCAyIG1vbWVudHMgYXJlIGZvdW5kIHdoaWNoIGhhdmUgYXQgbGVhc3QgbWluQ29tcG9uZW50V2VpZ2h0cyBjb3ZlcmVkXG4gICAgICAgIGlmIChlbGlnaWJsZU1vbWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIG1hdGNoaW5nTW9tZW50cyA9IHNpbWlsYXJNb21lbnRzKGVsaWdpYmxlTW9tZW50cyk7XG4gICAgICAgICAgICBhdmcgPSAwO1xuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBzaW1pbGFyaXR5IG9mIHRoZSBtb21lbnRzXG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbWF0Y2hpbmdNb21lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgYXZnICs9IG1hdGNoaW5nTW9tZW50c1trXS5yYWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9ubHkgdHdvIG9mIHRoZSBtb21lbnRzIGFyZSBhbGxvd2VkIG5vdCB0byBmaXQgaW50byB0aGUgZXF1YXRpb25cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgcGF0Y2ggdG8gdGhlIHNldFxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nTW9tZW50cy5sZW5ndGggPiAxXG4gICAgICAgICAgICAgICAgICAgICYmIG1hdGNoaW5nTW9tZW50cy5sZW5ndGggPj0gKGVsaWdpYmxlTW9tZW50cy5sZW5ndGggLyA0KSAqIDNcbiAgICAgICAgICAgICAgICAgICAgJiYgbWF0Y2hpbmdNb21lbnRzLmxlbmd0aCA+IG1vbWVudHMubGVuZ3RoIC8gNCkge1xuICAgICAgICAgICAgICAgIGF2ZyAvPSBtYXRjaGluZ01vbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHBhdGNoID0ge1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogcGF0Y2hQb3NbMV0gKiBfbnVtUGF0Y2hlcy54ICsgcGF0Y2hQb3NbMF0sXG4gICAgICAgICAgICAgICAgICAgIHBvczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGJveDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCwgeV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCArIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54LCB5XSksXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLmNsb25lKFt4ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLngsIHkgKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCwgeSArIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS55XSksXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudHM6IG1hdGNoaW5nTW9tZW50cyxcbiAgICAgICAgICAgICAgICAgICAgcmFkOiBhdmcsXG4gICAgICAgICAgICAgICAgICAgIHZlYzogdmVjMi5jbG9uZShbTWF0aC5jb3MoYXZnKSwgTWF0aC5zaW4oYXZnKV0pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcGF0Y2hlc0ZvdW5kLnB1c2gocGF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXRjaGVzRm91bmQ7XG59XG5cbi8qKlxuICogZmluZHMgcGF0Y2hlcyB3aGljaCBhcmUgY29ubmVjdGVkIGFuZCBzaGFyZSB0aGUgc2FtZSBvcmllbnRhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHBhdGNoZXNGb3VuZFxuICovXG5mdW5jdGlvbiByYXN0ZXJpemVBbmd1bGFyU2ltaWxhcml0eShwYXRjaGVzRm91bmQpIHtcbiAgICBsZXQgbGFiZWwgPSAwO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IDAuOTU7XG4gICAgbGV0IGN1cnJJZHggPSAwO1xuICAgIGxldCBqO1xuICAgIGxldCBwYXRjaDtcbiAgICBjb25zdCBoc3YgPSBbMCwgMSwgMV07XG4gICAgY29uc3QgcmdiID0gWzAsIDAsIDBdO1xuXG4gICAgZnVuY3Rpb24gbm90WWV0UHJvY2Vzc2VkKCkge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbaV0gPT09IDAgJiYgX3BhdGNoR3JpZC5kYXRhW2ldID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wYXRjaExhYmVsR3JpZC5sZW5ndGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhY2UoY3VycmVudElkeCkge1xuICAgICAgICBsZXQgeDtcbiAgICAgICAgbGV0IHk7XG4gICAgICAgIGxldCBjdXJyZW50UGF0Y2g7XG4gICAgICAgIGxldCBpZHg7XG4gICAgICAgIGxldCBkaXI7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB7XG4gICAgICAgICAgICB4OiBjdXJyZW50SWR4ICUgX3BhdGNoTGFiZWxHcmlkLnNpemUueCxcbiAgICAgICAgICAgIHk6IChjdXJyZW50SWR4IC8gX3BhdGNoTGFiZWxHcmlkLnNpemUueCkgfCAwLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgc2ltaWxhcml0eTtcblxuICAgICAgICBpZiAoY3VycmVudElkeCA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgY3VycmVudFBhdGNoID0gX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtjdXJyZW50SWR4XTtcbiAgICAgICAgICAgIC8vIGFzc2lnbiBsYWJlbFxuICAgICAgICAgICAgX3BhdGNoTGFiZWxHcmlkLmRhdGFbY3VycmVudElkeF0gPSBsYWJlbDtcbiAgICAgICAgICAgIGZvciAoZGlyID0gMDsgZGlyIDwgVHJhY2VyLnNlYXJjaERpcmVjdGlvbnMubGVuZ3RoOyBkaXIrKykge1xuICAgICAgICAgICAgICAgIHkgPSBjdXJyZW50LnkgKyBUcmFjZXIuc2VhcmNoRGlyZWN0aW9uc1tkaXJdWzBdO1xuICAgICAgICAgICAgICAgIHggPSBjdXJyZW50LnggKyBUcmFjZXIuc2VhcmNoRGlyZWN0aW9uc1tkaXJdWzFdO1xuICAgICAgICAgICAgICAgIGlkeCA9IHkgKiBfcGF0Y2hMYWJlbEdyaWQuc2l6ZS54ICsgeDtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIGlmIHBhdGNoIGVtcHR5XG4gICAgICAgICAgICAgICAgaWYgKF9wYXRjaEdyaWQuZGF0YVtpZHhdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wYXRjaExhYmVsR3JpZC5kYXRhW2lkeF0gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW2lkeF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2ltaWxhcml0eSA9IE1hdGguYWJzKHZlYzIuZG90KF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbaWR4XS52ZWMsIGN1cnJlbnRQYXRjaC52ZWMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpbWlsYXJpdHkgPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwcmVwYXJlIGZvciBmaW5kaW5nIHRoZSByaWdodCBwYXRjaGVzXG4gICAgQXJyYXlIZWxwZXIuaW5pdChfcGF0Y2hHcmlkLmRhdGEsIDApO1xuICAgIEFycmF5SGVscGVyLmluaXQoX3BhdGNoTGFiZWxHcmlkLmRhdGEsIDApO1xuICAgIEFycmF5SGVscGVyLmluaXQoX2ltYWdlVG9QYXRjaEdyaWQuZGF0YSwgbnVsbCk7XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgcGF0Y2hlc0ZvdW5kLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhdGNoID0gcGF0Y2hlc0ZvdW5kW2pdO1xuICAgICAgICBfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW3BhdGNoLmluZGV4XSA9IHBhdGNoO1xuICAgICAgICBfcGF0Y2hHcmlkLmRhdGFbcGF0Y2guaW5kZXhdID0gMTtcbiAgICB9XG5cbiAgICAvLyByYXN0ZXJpemUgdGhlIHBhdGNoZXMgZm91bmQgdG8gZGV0ZXJtaW5lIGFyZWFcbiAgICBfcGF0Y2hHcmlkLnplcm9Cb3JkZXIoKTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICAgIHdoaWxlICgoY3VycklkeCA9IG5vdFlldFByb2Nlc3NlZCgpKSA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICBsYWJlbCsrO1xuICAgICAgICB0cmFjZShjdXJySWR4KTtcbiAgICB9XG5cbiAgICAvLyBkcmF3IHBhdGNoLWxhYmVscyBpZiByZXF1ZXN0ZWRcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd1BhdGNoTGFiZWxzKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW2pdID4gMCAmJiBfcGF0Y2hMYWJlbEdyaWQuZGF0YVtqXSA8PSBsYWJlbCkge1xuICAgICAgICAgICAgICAgIHBhdGNoID0gX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtqXTtcbiAgICAgICAgICAgICAgICBoc3ZbMF0gPSAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbal0gLyAobGFiZWwgKyAxKSkgKiAzNjA7XG4gICAgICAgICAgICAgICAgaHN2MnJnYihoc3YsIHJnYik7XG4gICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UmVjdChwYXRjaC5wb3MsIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LFxuICAgICAgICAgICAgICAgICAgICB7IGNvbG9yOiBgcmdiKCR7cmdiLmpvaW4oJywnKX0pYCwgbGluZVdpZHRoOiAyIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhYmVsO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgaW5pdChpbnB1dEltYWdlV3JhcHBlciwgY29uZmlnKSB7XG4gICAgICAgIF9jb25maWcgPSBjb25maWc7XG4gICAgICAgIF9pbnB1dEltYWdlV3JhcHBlciA9IGlucHV0SW1hZ2VXcmFwcGVyO1xuXG4gICAgICAgIGluaXRCdWZmZXJzKCk7XG4gICAgICAgIGluaXRDYW52YXMoKTtcbiAgICB9LFxuXG4gICAgbG9jYXRlKCkge1xuICAgICAgICBpZiAoX2NvbmZpZy5oYWxmU2FtcGxlKSB7XG4gICAgICAgICAgICBoYWxmU2FtcGxlKF9pbnB1dEltYWdlV3JhcHBlciwgX2N1cnJlbnRJbWFnZVdyYXBwZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYmluYXJpemVJbWFnZSgpO1xuICAgICAgICBjb25zdCBwYXRjaGVzRm91bmQgPSBmaW5kUGF0Y2hlcygpO1xuICAgICAgICAvLyByZXR1cm4gdW5sZXNzIDUlIG9yIG1vcmUgcGF0Y2hlcyBhcmUgZm91bmRcbiAgICAgICAgaWYgKHBhdGNoZXNGb3VuZC5sZW5ndGggPCBfbnVtUGF0Y2hlcy54ICogX251bVBhdGNoZXMueSAqIDAuMDUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmFzdGVycml6ZSBhcmVhIGJ5IGNvbXBhcmluZyBhbmd1bGFyIHNpbWlsYXJpdHk7XG4gICAgICAgIGNvbnN0IG1heExhYmVsID0gcmFzdGVyaXplQW5ndWxhclNpbWlsYXJpdHkocGF0Y2hlc0ZvdW5kKTtcbiAgICAgICAgaWYgKG1heExhYmVsIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWFyY2ggZm9yIGFyZWEgd2l0aCB0aGUgbW9zdCBwYXRjaGVzIChiaWdnZXN0IGNvbm5lY3RlZCBhcmVhKVxuICAgICAgICBjb25zdCB0b3BMYWJlbHMgPSBmaW5kQmlnZ2VzdENvbm5lY3RlZEFyZWFzKG1heExhYmVsKTtcbiAgICAgICAgaWYgKHRvcExhYmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYm94ZXMgPSBmaW5kQm94ZXModG9wTGFiZWxzLCBtYXhMYWJlbCk7XG4gICAgICAgIHJldHVybiBib3hlcztcbiAgICB9LFxuXG4gICAgY2hlY2tJbWFnZUNvbnN0cmFpbnRzKGlucHV0U3RyZWFtLCBjb25maWcpIHtcbiAgICAgICAgbGV0IHBhdGNoU2l6ZTtcbiAgICAgICAgbGV0IHdpZHRoID0gaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKTtcbiAgICAgICAgbGV0IGhlaWdodCA9IGlucHV0U3RyZWFtLmdldEhlaWdodCgpO1xuICAgICAgICBjb25zdCB0aGlzSGFsZlNhbXBsZSA9IGNvbmZpZy5oYWxmU2FtcGxlID8gMC41IDogMTtcbiAgICAgICAgbGV0IGFyZWE7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHdpZHRoIGFuZCBoZWlnaHQgYmFzZWQgb24gYXJlYVxuICAgICAgICBpZiAoaW5wdXRTdHJlYW0uZ2V0Q29uZmlnKCkuYXJlYSkge1xuICAgICAgICAgICAgYXJlYSA9IGNvbXB1dGVJbWFnZUFyZWEod2lkdGgsIGhlaWdodCwgaW5wdXRTdHJlYW0uZ2V0Q29uZmlnKCkuYXJlYSk7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5zZXRUb3BSaWdodCh7IHg6IGFyZWEuc3gsIHk6IGFyZWEuc3kgfSk7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5zZXRDYW52YXNTaXplKHsgeDogd2lkdGgsIHk6IGhlaWdodCB9KTtcbiAgICAgICAgICAgIHdpZHRoID0gYXJlYS5zdztcbiAgICAgICAgICAgIGhlaWdodCA9IGFyZWEuc2g7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzaXplID0ge1xuICAgICAgICAgICAgeDogTWF0aC5mbG9vcih3aWR0aCAqIHRoaXNIYWxmU2FtcGxlKSxcbiAgICAgICAgICAgIHk6IE1hdGguZmxvb3IoaGVpZ2h0ICogdGhpc0hhbGZTYW1wbGUpLFxuICAgICAgICB9O1xuXG4gICAgICAgIHBhdGNoU2l6ZSA9IGNhbGN1bGF0ZVBhdGNoU2l6ZShjb25maWcucGF0Y2hTaXplLCBzaXplKTtcbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFBhdGNoLVNpemU6ICR7SlNPTi5zdHJpbmdpZnkocGF0Y2hTaXplKX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0U3RyZWFtLnNldFdpZHRoKE1hdGguZmxvb3IoTWF0aC5mbG9vcihzaXplLnggLyBwYXRjaFNpemUueCkgKiAoMSAvIHRoaXNIYWxmU2FtcGxlKSAqIHBhdGNoU2l6ZS54KSk7XG4gICAgICAgIGlucHV0U3RyZWFtLnNldEhlaWdodChNYXRoLmZsb29yKE1hdGguZmxvb3Ioc2l6ZS55IC8gcGF0Y2hTaXplLnkpICogKDEgLyB0aGlzSGFsZlNhbXBsZSkgKiBwYXRjaFNpemUueSkpO1xuXG4gICAgICAgIGlmICgoaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSAlIHBhdGNoU2l6ZS54KSA9PT0gMCAmJiAoaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkgJSBwYXRjaFNpemUueSkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSBkaW1lbnNpb25zIGRvIG5vdCBjb21wbHkgd2l0aCB0aGUgY3VycmVudCBzZXR0aW5nczogV2lkdGggKCR7XG4gICAgICAgICAgICB3aWR0aH0gKWFuZCBoZWlnaHQgKCR7aGVpZ2h0XG4gICAgICAgIH0pIG11c3QgYSBtdWx0aXBsZSBvZiAke3BhdGNoU2l6ZS54fWApO1xuICAgIH0sXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgbmV4dFRpY2s6IG5leHRUaWNrIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3Ncbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuXG4iLCJ2YXIgYXJyYXlXaXRoSG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5TGltaXRcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgbm9uSXRlcmFibGVSZXN0ID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVSZXN0XCIpO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5OyIsInZhciBhcnJheVdpdGhvdXRIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aG91dEhvbGVzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIG5vbkl0ZXJhYmxlU3ByZWFkID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVTcHJlYWRcIik7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90b0NvbnN1bWFibGVBcnJheTsiLCJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNUb0dlbmVyYXRvcjsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBkZXRlcm1pbmFudDogcmVxdWlyZSgnLi9kZXRlcm1pbmFudCcpXG4gICwgdHJhbnNwb3NlOiByZXF1aXJlKCcuL3RyYW5zcG9zZScpXG4gICwgbXVsdGlwbHk6IHJlcXVpcmUoJy4vbXVsdGlwbHknKVxuICAsIGlkZW50aXR5OiByZXF1aXJlKCcuL2lkZW50aXR5JylcbiAgLCBhZGpvaW50OiByZXF1aXJlKCcuL2Fkam9pbnQnKVxuICAsIHJvdGF0ZTogcmVxdWlyZSgnLi9yb3RhdGUnKVxuICAsIGludmVydDogcmVxdWlyZSgnLi9pbnZlcnQnKVxuICAsIGNyZWF0ZTogcmVxdWlyZSgnLi9jcmVhdGUnKVxuICAsIHNjYWxlOiByZXF1aXJlKCcuL3NjYWxlJylcbiAgLCBjb3B5OiByZXF1aXJlKCcuL2NvcHknKVxuICAsIGZyb2I6IHJlcXVpcmUoJy4vZnJvYicpXG4gICwgbGR1OiByZXF1aXJlKCcuL2xkdScpXG59XG4iLCJ2YXIgaW90YSA9IHJlcXVpcmUoXCJpb3RhLWFycmF5XCIpXG52YXIgaXNCdWZmZXIgPSByZXF1aXJlKFwiaXMtYnVmZmVyXCIpXG5cbnZhciBoYXNUeXBlZEFycmF5cyAgPSAoKHR5cGVvZiBGbG9hdDY0QXJyYXkpICE9PSBcInVuZGVmaW5lZFwiKVxuXG5mdW5jdGlvbiBjb21wYXJlMXN0KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gLSBiWzBdXG59XG5cbmZ1bmN0aW9uIG9yZGVyKCkge1xuICB2YXIgc3RyaWRlID0gdGhpcy5zdHJpZGVcbiAgdmFyIHRlcm1zID0gbmV3IEFycmF5KHN0cmlkZS5sZW5ndGgpXG4gIHZhciBpXG4gIGZvcihpPTA7IGk8dGVybXMubGVuZ3RoOyArK2kpIHtcbiAgICB0ZXJtc1tpXSA9IFtNYXRoLmFicyhzdHJpZGVbaV0pLCBpXVxuICB9XG4gIHRlcm1zLnNvcnQoY29tcGFyZTFzdClcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSh0ZXJtcy5sZW5ndGgpXG4gIGZvcihpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gdGVybXNbaV1bMV1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVDb25zdHJ1Y3RvcihkdHlwZSwgZGltZW5zaW9uKSB7XG4gIHZhciBjbGFzc05hbWUgPSBbXCJWaWV3XCIsIGRpbWVuc2lvbiwgXCJkXCIsIGR0eXBlXS5qb2luKFwiXCIpXG4gIGlmKGRpbWVuc2lvbiA8IDApIHtcbiAgICBjbGFzc05hbWUgPSBcIlZpZXdfTmlsXCIgKyBkdHlwZVxuICB9XG4gIHZhciB1c2VHZXR0ZXJzID0gKGR0eXBlID09PSBcImdlbmVyaWNcIilcblxuICBpZihkaW1lbnNpb24gPT09IC0xKSB7XG4gICAgLy9TcGVjaWFsIGNhc2UgZm9yIHRyaXZpYWwgYXJyYXlzXG4gICAgdmFyIGNvZGUgPVxuICAgICAgXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSl7dGhpcy5kYXRhPWE7fTtcXFxudmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGU7XFxcbnByb3RvLmR0eXBlPSdcIitkdHlwZStcIic7XFxcbnByb3RvLmluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIC0xfTtcXFxucHJvdG8uc2l6ZT0wO1xcXG5wcm90by5kaW1lbnNpb249LTE7XFxcbnByb3RvLnNoYXBlPXByb3RvLnN0cmlkZT1wcm90by5vcmRlcj1bXTtcXFxucHJvdG8ubG89cHJvdG8uaGk9cHJvdG8udHJhbnNwb3NlPXByb3RvLnN0ZXA9XFxcbmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhKTt9O1xcXG5wcm90by5nZXQ9cHJvdG8uc2V0PWZ1bmN0aW9uKCl7fTtcXFxucHJvdG8ucGljaz1mdW5jdGlvbigpe3JldHVybiBudWxsfTtcXFxucmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoYSl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoYSk7fVwiXG4gICAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihjb2RlKVxuICAgIHJldHVybiBwcm9jZWR1cmUoKVxuICB9IGVsc2UgaWYoZGltZW5zaW9uID09PSAwKSB7XG4gICAgLy9TcGVjaWFsIGNhc2UgZm9yIDBkIGFycmF5c1xuICAgIHZhciBjb2RlID1cbiAgICAgIFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiKGEsZCkge1xcXG50aGlzLmRhdGEgPSBhO1xcXG50aGlzLm9mZnNldCA9IGRcXFxufTtcXFxudmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGU7XFxcbnByb3RvLmR0eXBlPSdcIitkdHlwZStcIic7XFxcbnByb3RvLmluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub2Zmc2V0fTtcXFxucHJvdG8uZGltZW5zaW9uPTA7XFxcbnByb3RvLnNpemU9MTtcXFxucHJvdG8uc2hhcGU9XFxcbnByb3RvLnN0cmlkZT1cXFxucHJvdG8ub3JkZXI9W107XFxcbnByb3RvLmxvPVxcXG5wcm90by5oaT1cXFxucHJvdG8udHJhbnNwb3NlPVxcXG5wcm90by5zdGVwPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9jb3B5KCkge1xcXG5yZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsdGhpcy5vZmZzZXQpXFxcbn07XFxcbnByb3RvLnBpY2s9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3BpY2soKXtcXFxucmV0dXJuIFRyaXZpYWxBcnJheSh0aGlzLmRhdGEpO1xcXG59O1xcXG5wcm90by52YWx1ZU9mPXByb3RvLmdldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfZ2V0KCl7XFxcbnJldHVybiBcIisodXNlR2V0dGVycyA/IFwidGhpcy5kYXRhLmdldCh0aGlzLm9mZnNldClcIiA6IFwidGhpcy5kYXRhW3RoaXMub2Zmc2V0XVwiKStcblwifTtcXFxucHJvdG8uc2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zZXQodil7XFxcbnJldHVybiBcIisodXNlR2V0dGVycyA/IFwidGhpcy5kYXRhLnNldCh0aGlzLm9mZnNldCx2KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdPXZcIikrXCJcXFxufTtcXFxucmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoYSxiLGMsZCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoYSxkKX1cIlxuICAgIHZhciBwcm9jZWR1cmUgPSBuZXcgRnVuY3Rpb24oXCJUcml2aWFsQXJyYXlcIiwgY29kZSlcbiAgICByZXR1cm4gcHJvY2VkdXJlKENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdWzBdKVxuICB9XG5cbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIl1cblxuICAvL0NyZWF0ZSBjb25zdHJ1Y3RvciBmb3Igdmlld1xuICB2YXIgaW5kaWNlcyA9IGlvdGEoZGltZW5zaW9uKVxuICB2YXIgYXJncyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiaVwiK2kgfSlcbiAgdmFyIGluZGV4X3N0ciA9IFwidGhpcy5vZmZzZXQrXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICAgIHJldHVybiBcInRoaXMuc3RyaWRlW1wiICsgaSArIFwiXSppXCIgKyBpXG4gICAgICB9KS5qb2luKFwiK1wiKVxuICB2YXIgc2hhcGVBcmcgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJiXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpXG4gIHZhciBzdHJpZGVBcmcgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJjXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpXG4gIGNvZGUucHVzaChcbiAgICBcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIihhLFwiICsgc2hhcGVBcmcgKyBcIixcIiArIHN0cmlkZUFyZyArIFwiLGQpe3RoaXMuZGF0YT1hXCIsXG4gICAgICBcInRoaXMuc2hhcGU9W1wiICsgc2hhcGVBcmcgKyBcIl1cIixcbiAgICAgIFwidGhpcy5zdHJpZGU9W1wiICsgc3RyaWRlQXJnICsgXCJdXCIsXG4gICAgICBcInRoaXMub2Zmc2V0PWR8MH1cIixcbiAgICBcInZhciBwcm90bz1cIitjbGFzc05hbWUrXCIucHJvdG90eXBlXCIsXG4gICAgXCJwcm90by5kdHlwZT0nXCIrZHR5cGUrXCInXCIsXG4gICAgXCJwcm90by5kaW1lbnNpb249XCIrZGltZW5zaW9uKVxuXG4gIC8vdmlldy5zaXplOlxuICBjb2RlLnB1c2goXCJPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sJ3NpemUnLHtnZXQ6ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3NpemUoKXtcXFxucmV0dXJuIFwiK2luZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwidGhpcy5zaGFwZVtcIitpK1wiXVwiIH0pLmpvaW4oXCIqXCIpLFxuXCJ9fSlcIilcblxuICAvL3ZpZXcub3JkZXI6XG4gIGlmKGRpbWVuc2lvbiA9PT0gMSkge1xuICAgIGNvZGUucHVzaChcInByb3RvLm9yZGVyPVswXVwiKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywnb3JkZXInLHtnZXQ6XCIpXG4gICAgaWYoZGltZW5zaW9uIDwgNCkge1xuICAgICAgY29kZS5wdXNoKFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX29yZGVyKCl7XCIpXG4gICAgICBpZihkaW1lbnNpb24gPT09IDIpIHtcbiAgICAgICAgY29kZS5wdXNoKFwicmV0dXJuIChNYXRoLmFicyh0aGlzLnN0cmlkZVswXSk+TWF0aC5hYnModGhpcy5zdHJpZGVbMV0pKT9bMSwwXTpbMCwxXX19KVwiKVxuICAgICAgfSBlbHNlIGlmKGRpbWVuc2lvbiA9PT0gMykge1xuICAgICAgICBjb2RlLnB1c2goXG5cInZhciBzMD1NYXRoLmFicyh0aGlzLnN0cmlkZVswXSksczE9TWF0aC5hYnModGhpcy5zdHJpZGVbMV0pLHMyPU1hdGguYWJzKHRoaXMuc3RyaWRlWzJdKTtcXFxuaWYoczA+czEpe1xcXG5pZihzMT5zMil7XFxcbnJldHVybiBbMiwxLDBdO1xcXG59ZWxzZSBpZihzMD5zMil7XFxcbnJldHVybiBbMSwyLDBdO1xcXG59ZWxzZXtcXFxucmV0dXJuIFsxLDAsMl07XFxcbn1cXFxufWVsc2UgaWYoczA+czIpe1xcXG5yZXR1cm4gWzIsMCwxXTtcXFxufWVsc2UgaWYoczI+czEpe1xcXG5yZXR1cm4gWzAsMSwyXTtcXFxufWVsc2V7XFxcbnJldHVybiBbMCwyLDFdO1xcXG59fX0pXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUucHVzaChcIk9SREVSfSlcIilcbiAgICB9XG4gIH1cblxuICAvL3ZpZXcuc2V0KGkwLCAuLi4sIHYpOlxuICBjb2RlLnB1c2goXG5cInByb3RvLnNldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc2V0KFwiK2FyZ3Muam9pbihcIixcIikrXCIsdil7XCIpXG4gIGlmKHVzZUdldHRlcnMpIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhLnNldChcIitpbmRleF9zdHIrXCIsdil9XCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YVtcIitpbmRleF9zdHIrXCJdPXZ9XCIpXG4gIH1cblxuICAvL3ZpZXcuZ2V0KGkwLCAuLi4pOlxuICBjb2RlLnB1c2goXCJwcm90by5nZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2dldChcIithcmdzLmpvaW4oXCIsXCIpK1wiKXtcIilcbiAgaWYodXNlR2V0dGVycykge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGEuZ2V0KFwiK2luZGV4X3N0citcIil9XCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YVtcIitpbmRleF9zdHIrXCJdfVwiKVxuICB9XG5cbiAgLy92aWV3LmluZGV4OlxuICBjb2RlLnB1c2goXG4gICAgXCJwcm90by5pbmRleD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfaW5kZXgoXCIsIGFyZ3Muam9pbigpLCBcIil7cmV0dXJuIFwiK2luZGV4X3N0citcIn1cIilcblxuICAvL3ZpZXcuaGkoKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uaGk9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2hpKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gW1wiKHR5cGVvZiBpXCIsaSxcIiE9PSdudW1iZXInfHxpXCIsaSxcIjwwKT90aGlzLnNoYXBlW1wiLCBpLCBcIl06aVwiLCBpLFwifDBcIl0uam9pbihcIlwiKVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInRoaXMuc3RyaWRlW1wiK2kgKyBcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLHRoaXMub2Zmc2V0KX1cIilcblxuICAvL3ZpZXcubG8oKTpcbiAgdmFyIGFfdmFycyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiYVwiK2krXCI9dGhpcy5zaGFwZVtcIitpK1wiXVwiIH0pXG4gIHZhciBjX3ZhcnMgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBcImNcIitpK1wiPXRoaXMuc3RyaWRlW1wiK2krXCJdXCIgfSlcbiAgY29kZS5wdXNoKFwicHJvdG8ubG89ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2xvKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3ZhciBiPXRoaXMub2Zmc2V0LGQ9MCxcIithX3ZhcnMuam9pbihcIixcIikrXCIsXCIrY192YXJzLmpvaW4oXCIsXCIpKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcblwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicmJmlcIitpK1wiPj0wKXtcXFxuZD1pXCIraStcInwwO1xcXG5iKz1jXCIraStcIipkO1xcXG5hXCIraStcIi09ZH1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiK2lcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJjXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGIpfVwiKVxuXG4gIC8vdmlldy5zdGVwKCk6XG4gIGNvZGUucHVzaChcInByb3RvLnN0ZXA9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3N0ZXAoXCIrYXJncy5qb2luKFwiLFwiKStcIil7dmFyIFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImFcIitpK1wiPXRoaXMuc2hhcGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIitpK1wiPXRoaXMuc3RyaWRlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixjPXRoaXMub2Zmc2V0LGQ9MCxjZWlsPU1hdGguY2VpbFwiKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcblwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicpe1xcXG5kPWlcIitpK1wifDA7XFxcbmlmKGQ8MCl7XFxcbmMrPWJcIitpK1wiKihhXCIraStcIi0xKTtcXFxuYVwiK2krXCI9Y2VpbCgtYVwiK2krXCIvZClcXFxufWVsc2V7XFxcbmFcIitpK1wiPWNlaWwoYVwiK2krXCIvZClcXFxufVxcXG5iXCIraStcIio9ZFxcXG59XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwicmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImFcIiArIGlcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJiXCIgKyBpXG4gICAgfSkuam9pbihcIixcIikrXCIsYyl9XCIpXG5cbiAgLy92aWV3LnRyYW5zcG9zZSgpOlxuICB2YXIgdFNoYXBlID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgdmFyIHRTdHJpZGUgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIHRTaGFwZVtpXSA9IFwiYVtpXCIraStcIl1cIlxuICAgIHRTdHJpZGVbaV0gPSBcImJbaVwiK2krXCJdXCJcbiAgfVxuICBjb2RlLnB1c2goXCJwcm90by50cmFuc3Bvc2U9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3RyYW5zcG9zZShcIithcmdzK1wiKXtcIitcbiAgICBhcmdzLm1hcChmdW5jdGlvbihuLGlkeCkgeyByZXR1cm4gbiArIFwiPShcIiArIG4gKyBcIj09PXVuZGVmaW5lZD9cIiArIGlkeCArIFwiOlwiICsgbiArIFwifDApXCJ9KS5qb2luKFwiO1wiKSxcbiAgICBcInZhciBhPXRoaXMuc2hhcGUsYj10aGlzLnN0cmlkZTtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrdFNoYXBlLmpvaW4oXCIsXCIpK1wiLFwiK3RTdHJpZGUuam9pbihcIixcIikrXCIsdGhpcy5vZmZzZXQpfVwiKVxuXG4gIC8vdmlldy5waWNrKCk6XG4gIGNvZGUucHVzaChcInByb3RvLnBpY2s9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3BpY2soXCIrYXJncytcIil7dmFyIGE9W10sYj1bXSxjPXRoaXMub2Zmc2V0XCIpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicmJmlcIitpK1wiPj0wKXtjPShjK3RoaXMuc3RyaWRlW1wiK2krXCJdKmlcIitpK1wiKXwwfWVsc2V7YS5wdXNoKHRoaXMuc2hhcGVbXCIraStcIl0pO2IucHVzaCh0aGlzLnN0cmlkZVtcIitpK1wiXSl9XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwidmFyIGN0b3I9Q1RPUl9MSVNUW2EubGVuZ3RoKzFdO3JldHVybiBjdG9yKHRoaXMuZGF0YSxhLGIsYyl9XCIpXG5cbiAgLy9BZGQgcmV0dXJuIHN0YXRlbWVudFxuICBjb2RlLnB1c2goXCJyZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihkYXRhLHNoYXBlLHN0cmlkZSxvZmZzZXQpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKGRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwic2hhcGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInN0cmlkZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsb2Zmc2V0KX1cIilcblxuICAvL0NvbXBpbGUgcHJvY2VkdXJlXG4gIHZhciBwcm9jZWR1cmUgPSBuZXcgRnVuY3Rpb24oXCJDVE9SX0xJU1RcIiwgXCJPUkRFUlwiLCBjb2RlLmpvaW4oXCJcXG5cIikpXG4gIHJldHVybiBwcm9jZWR1cmUoQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV0sIG9yZGVyKVxufVxuXG5mdW5jdGlvbiBhcnJheURUeXBlKGRhdGEpIHtcbiAgaWYoaXNCdWZmZXIoZGF0YSkpIHtcbiAgICByZXR1cm4gXCJidWZmZXJcIlxuICB9XG4gIGlmKGhhc1R5cGVkQXJyYXlzKSB7XG4gICAgc3dpdGNoKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSkge1xuICAgICAgY2FzZSBcIltvYmplY3QgRmxvYXQ2NEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJmbG9hdDY0XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiZmxvYXQzMlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQ4QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImludDhcIlxuICAgICAgY2FzZSBcIltvYmplY3QgSW50MTZBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50MTZcIlxuICAgICAgY2FzZSBcIltvYmplY3QgSW50MzJBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50MzJcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDhBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDhcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDE2QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQxNlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50MzJBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDMyXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50OF9jbGFtcGVkXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEJpZ0ludDY0QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImJpZ2ludDY0XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEJpZ1VpbnQ2NEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJiaWd1aW50NjRcIlxuICAgIH1cbiAgfVxuICBpZihBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIlxuICB9XG4gIHJldHVybiBcImdlbmVyaWNcIlxufVxuXG52YXIgQ0FDSEVEX0NPTlNUUlVDVE9SUyA9IHtcbiAgXCJmbG9hdDMyXCI6W10sXG4gIFwiZmxvYXQ2NFwiOltdLFxuICBcImludDhcIjpbXSxcbiAgXCJpbnQxNlwiOltdLFxuICBcImludDMyXCI6W10sXG4gIFwidWludDhcIjpbXSxcbiAgXCJ1aW50MTZcIjpbXSxcbiAgXCJ1aW50MzJcIjpbXSxcbiAgXCJhcnJheVwiOltdLFxuICBcInVpbnQ4X2NsYW1wZWRcIjpbXSxcbiAgXCJiaWdpbnQ2NFwiOiBbXSxcbiAgXCJiaWd1aW50NjRcIjogW10sXG4gIFwiYnVmZmVyXCI6W10sXG4gIFwiZ2VuZXJpY1wiOltdXG59XG5cbjsoZnVuY3Rpb24oKSB7XG4gIGZvcih2YXIgaWQgaW4gQ0FDSEVEX0NPTlNUUlVDVE9SUykge1xuICAgIENBQ0hFRF9DT05TVFJVQ1RPUlNbaWRdLnB1c2goY29tcGlsZUNvbnN0cnVjdG9yKGlkLCAtMSkpXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB3cmFwcGVkTkRBcnJheUN0b3IoZGF0YSwgc2hhcGUsIHN0cmlkZSwgb2Zmc2V0KSB7XG4gIGlmKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBjdG9yID0gQ0FDSEVEX0NPTlNUUlVDVE9SUy5hcnJheVswXVxuICAgIHJldHVybiBjdG9yKFtdKVxuICB9IGVsc2UgaWYodHlwZW9mIGRhdGEgPT09IFwibnVtYmVyXCIpIHtcbiAgICBkYXRhID0gW2RhdGFdXG4gIH1cbiAgaWYoc2hhcGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHNoYXBlID0gWyBkYXRhLmxlbmd0aCBdXG4gIH1cbiAgdmFyIGQgPSBzaGFwZS5sZW5ndGhcbiAgaWYoc3RyaWRlID09PSB1bmRlZmluZWQpIHtcbiAgICBzdHJpZGUgPSBuZXcgQXJyYXkoZClcbiAgICBmb3IodmFyIGk9ZC0xLCBzej0xOyBpPj0wOyAtLWkpIHtcbiAgICAgIHN0cmlkZVtpXSA9IHN6XG4gICAgICBzeiAqPSBzaGFwZVtpXVxuICAgIH1cbiAgfVxuICBpZihvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIG9mZnNldCA9IDBcbiAgICBmb3IodmFyIGk9MDsgaTxkOyArK2kpIHtcbiAgICAgIGlmKHN0cmlkZVtpXSA8IDApIHtcbiAgICAgICAgb2Zmc2V0IC09IChzaGFwZVtpXS0xKSpzdHJpZGVbaV1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGR0eXBlID0gYXJyYXlEVHlwZShkYXRhKVxuICB2YXIgY3Rvcl9saXN0ID0gQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV1cbiAgd2hpbGUoY3Rvcl9saXN0Lmxlbmd0aCA8PSBkKzEpIHtcbiAgICBjdG9yX2xpc3QucHVzaChjb21waWxlQ29uc3RydWN0b3IoZHR5cGUsIGN0b3JfbGlzdC5sZW5ndGgtMSkpXG4gIH1cbiAgdmFyIGN0b3IgPSBjdG9yX2xpc3RbZCsxXVxuICByZXR1cm4gY3RvcihkYXRhLCBzaGFwZSwgc3RyaWRlLCBvZmZzZXQpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHBlZE5EQXJyYXlDdG9yXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBldmVudExpc3RlbmVyKCkge1xuICAgICAgaWYgKGVycm9yTGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgdmFyIGVycm9yTGlzdGVuZXI7XG5cbiAgICAvLyBBZGRpbmcgYW4gZXJyb3IgbGlzdGVuZXIgaXMgbm90IG9wdGlvbmFsIGJlY2F1c2VcbiAgICAvLyBpZiBhbiBlcnJvciBpcyB0aHJvd24gb24gYW4gZXZlbnQgZW1pdHRlciB3ZSBjYW5ub3RcbiAgICAvLyBndWFyYW50ZWUgdGhhdCB0aGUgYWN0dWFsIGV2ZW50IHdlIGFyZSB3YWl0aW5nIHdpbGxcbiAgICAvLyBiZSBmaXJlZC4gVGhlIHJlc3VsdCBjb3VsZCBiZSBhIHNpbGVudCB3YXkgdG8gY3JlYXRlXG4gICAgLy8gbWVtb3J5IG9yIGZpbGUgZGVzY3JpcHRvciBsZWFrcywgd2hpY2ggaXMgc29tZXRoaW5nXG4gICAgLy8gd2Ugc2hvdWxkIGF2b2lkLlxuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBlcnJvckxpc3RlbmVyID0gZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCBldmVudExpc3RlbmVyKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9O1xuXG4gICAgICBlbWl0dGVyLm9uY2UoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgZW1pdHRlci5vbmNlKG5hbWUsIGV2ZW50TGlzdGVuZXIpO1xuICB9KTtcbn1cbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHBuYS5uZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHdyaXRhYmxlSHdtID0gb3B0aW9ucy53cml0YWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAod3JpdGFibGVId20gfHwgd3JpdGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSB3cml0YWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHBuYS5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHBuYS5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcG5hLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cbiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5lbmQoKTtcbiAgY2IoZXJyKTtcbn07IiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5XCIpO1xuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheTsiLCJmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXk7IiwibW9kdWxlLmV4cG9ydHMgPSAwLjAwMDAwMVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXG4gKlxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMilcbiAgICBvdXRbMF0gPSAwXG4gICAgb3V0WzFdID0gMFxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHN1YnRyYWN0XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBtdWx0aXBseVxuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGRpdmlkZVxuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBkaXN0YW5jZVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdXG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpXG59IiwibW9kdWxlLmV4cG9ydHMgPSBzcXVhcmVkRGlzdGFuY2VcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdXG4gICAgcmV0dXJuIHgqeCArIHkqeVxufSIsIm1vZHVsZS5leHBvcnRzID0gbGVuZ3RoXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xuZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdXG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpXG59IiwibW9kdWxlLmV4cG9ydHMgPSBzcXVhcmVkTGVuZ3RoXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xuZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIHJldHVybiB4KnggKyB5Knlcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IDAuMDAwMDAxXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMzXG4gKlxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMylcbiAgICBvdXRbMF0gPSAwXG4gICAgb3V0WzFdID0gMFxuICAgIG91dFsyXSA9IDBcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tVmFsdWVzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbmZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSwgeikge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDMpXG4gICAgb3V0WzBdID0geFxuICAgIG91dFsxXSA9IHlcbiAgICBvdXRbMl0gPSB6XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbm9ybWFsaXplO1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdXG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeSArIHoqelxuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKVxuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuXG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW5cbiAgICAgICAgb3V0WzJdID0gYVsyXSAqIGxlblxuICAgIH1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBkb3Q7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5mdW5jdGlvbiBkb3QoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl1cbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHN1YnRyYWN0O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXVxuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdXG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV1cbiAgICBvdXRbMl0gPSBhWzJdICogYlsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGRpdmlkZTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXVxuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdXG4gICAgb3V0WzJdID0gYVsyXSAvIGJbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBkaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdXG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopXG59IiwibW9kdWxlLmV4cG9ydHMgPSBzcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5mdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdXG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqelxufSIsIm1vZHVsZS5leHBvcnRzID0gbGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbmZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl1cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeilcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xuZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl1cbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciByZWFkYWJsZUh3bSA9IG9wdGlvbnMucmVhZGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHJlYWRhYmxlSHdtIHx8IHJlYWRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gcmVhZGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIGNiKGVycik7XG59O1xuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gICAgaWYgKGVyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHBuYS5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcG5hLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0geyBoYXNVbnBpcGVkOiBmYWxzZSB9O1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcG5hLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfVxuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xuICB2YXIgcmV0O1xuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXG4gICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcbiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YVxuLy8gY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHZhciByZXQgPSBwLmRhdGE7XG4gIG4gLT0gcmV0Lmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7XG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIgJiYgKCF0aGlzLl93cml0YWJsZVN0YXRlIHx8ICF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIF90aGlzLCBlcnIpO1xuICAgICAgaWYgKF90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3lcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaXMgYWRkZWQgd2hlbiBlbmRpbmcgb24gYSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJztcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSBjYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTtcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gICAgX3RoaXMyLmVtaXQoJ2Nsb3NlJyk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCJjb25zdCBDVlV0aWxzID0gcmVxdWlyZSgnLi4vY29tbW9uL2N2X3V0aWxzJyk7XG5jb25zdCBOZGFycmF5ID0gcmVxdWlyZSgnbmRhcnJheScpO1xuY29uc3QgSW50ZXJwMkQgPSByZXF1aXJlKCduZGFycmF5LWxpbmVhci1pbnRlcnBvbGF0ZScpLmQyO1xuXG5jb25zdCBGcmFtZUdyYWJiZXIgPSB7fTtcblxuRnJhbWVHcmFiYmVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChpbnB1dFN0cmVhbSkge1xuICAgIGNvbnN0IF90aGF0ID0ge307XG4gICAgY29uc3QgX3ZpZGVvU2l6ZSA9IENWVXRpbHMuaW1hZ2VSZWYoaW5wdXRTdHJlYW0uZ2V0UmVhbFdpZHRoKCksIGlucHV0U3RyZWFtLmdldFJlYWxIZWlnaHQoKSk7XG4gICAgY29uc3QgX2NhbnZhc1NpemUgPSBpbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCk7XG4gICAgY29uc3QgX3NpemUgPSBDVlV0aWxzLmltYWdlUmVmKGlucHV0U3RyZWFtLmdldFdpZHRoKCksIGlucHV0U3RyZWFtLmdldEhlaWdodCgpKTtcbiAgICBjb25zdCBfdG9wUmlnaHQgPSBpbnB1dFN0cmVhbS5nZXRUb3BSaWdodCgpO1xuICAgIGxldCBfZGF0YSA9IG5ldyBVaW50OEFycmF5KF9zaXplLnggKiBfc2l6ZS55KTtcbiAgICBjb25zdCBfZ3JheURhdGEgPSBuZXcgVWludDhBcnJheShfdmlkZW9TaXplLnggKiBfdmlkZW9TaXplLnkpO1xuICAgIGNvbnN0IF9jYW52YXNEYXRhID0gbmV3IFVpbnQ4QXJyYXkoX2NhbnZhc1NpemUueCAqIF9jYW52YXNTaXplLnkpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5ldy1jYXAgKi9cbiAgICBjb25zdCBfZ3JheUltYWdlQXJyYXkgPSBOZGFycmF5KF9ncmF5RGF0YSwgW192aWRlb1NpemUueSwgX3ZpZGVvU2l6ZS54XSkudHJhbnNwb3NlKDEsIDApO1xuICAgIGNvbnN0IF9jYW52YXNJbWFnZUFycmF5ID0gTmRhcnJheShfY2FudmFzRGF0YSwgW19jYW52YXNTaXplLnksIF9jYW52YXNTaXplLnhdKS50cmFuc3Bvc2UoMSwgMCk7XG4gICAgY29uc3QgX3RhcmdldEltYWdlQXJyYXkgPSBfY2FudmFzSW1hZ2VBcnJheVxuICAgICAgICAuaGkoX3RvcFJpZ2h0LnggKyBfc2l6ZS54LCBfdG9wUmlnaHQueSArIF9zaXplLnkpXG4gICAgICAgIC5sbyhfdG9wUmlnaHQueCwgX3RvcFJpZ2h0LnkpO1xuICAgIGNvbnN0IF9zdGVwU2l6ZVggPSBfdmlkZW9TaXplLnggLyBfY2FudmFzU2l6ZS54O1xuICAgIGNvbnN0IF9zdGVwU2l6ZVkgPSBfdmlkZW9TaXplLnkgLyBfY2FudmFzU2l6ZS55O1xuXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICBjb25zb2xlLmxvZygnRnJhbWVHcmFiYmVyJywgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgdmlkZW9TaXplOiBfZ3JheUltYWdlQXJyYXkuc2hhcGUsXG4gICAgICAgICAgICBjYW52YXNTaXplOiBfY2FudmFzSW1hZ2VBcnJheS5zaGFwZSxcbiAgICAgICAgICAgIHN0ZXBTaXplOiBbX3N0ZXBTaXplWCwgX3N0ZXBTaXplWV0sXG4gICAgICAgICAgICBzaXplOiBfdGFyZ2V0SW1hZ2VBcnJheS5zaGFwZSxcbiAgICAgICAgICAgIHRvcFJpZ2h0OiBfdG9wUmlnaHQsXG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIHRoZSBnaXZlbiBhcnJheSBhcyBmcmFtZS1idWZmZXJcbiAgICAgKi9cbiAgICBfdGhhdC5hdHRhY2hEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgX2RhdGEgPSBkYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB1c2VkIGZyYW1lLWJ1ZmZlclxuICAgICAqL1xuICAgIF90aGF0LmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIGZyYW1lIGZyb20gdGhlIGlucHV0LXN0cmVhbSBhbmQgcHV0cyBpbnRvIHRoZSBmcmFtZS1idWZmZXIuXG4gICAgICogVGhlIGltYWdlLWRhdGEgaXMgY29udmVydGVkIHRvIGdyYXktc2NhbGUgYW5kIHRoZW4gaGFsZi1zYW1wbGVkIGlmIGNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgX3RoYXQuZ3JhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZnJhbWUgPSBpbnB1dFN0cmVhbS5nZXRGcmFtZSgpO1xuXG4gICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgICAgdGhpcy5zY2FsZUFuZENyb3AoZnJhbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBfdGhhdC5zY2FsZUFuZENyb3AgPSBmdW5jdGlvbihmcmFtZSkge1xuICAgICAgICAvLyAxLiBjb21wdXRlIGZ1bGwtc2l6ZWQgZ3JheSBpbWFnZVxuICAgICAgICBDVlV0aWxzLmNvbXB1dGVHcmF5KGZyYW1lLmRhdGEsIF9ncmF5RGF0YSk7XG5cbiAgICAgICAgLy8gMi4gaW50ZXJwb2xhdGVcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBfY2FudmFzU2l6ZS55OyB5KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgX2NhbnZhc1NpemUueDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICAgICAgICBfY2FudmFzSW1hZ2VBcnJheS5zZXQoeCwgeSwgKEludGVycDJEKF9ncmF5SW1hZ2VBcnJheSwgeCAqIF9zdGVwU2l6ZVgsIHkgKiBfc3RlcFNpemVZKSkgfCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRhcmdldEltYWdlQXJyYXkgbXVzdCBiZSBlcXVhbCB0byB0YXJnZXRTaXplXG4gICAgICAgIGlmIChfdGFyZ2V0SW1hZ2VBcnJheS5zaGFwZVswXSAhPT0gX3NpemUueFxuICAgICAgICAgICAgfHwgX3RhcmdldEltYWdlQXJyYXkuc2hhcGVbMV0gIT09IF9zaXplLnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhcGVzIGRvIG5vdCBtYXRjaCEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIGNyb3BcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBfc2l6ZS55OyB5KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgX3NpemUueDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgX2RhdGFbeSAqIF9zaXplLnggKyB4XSA9IF90YXJnZXRJbWFnZUFycmF5LmdldCh4LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhhdC5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3NpemU7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhhdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnJhbWVHcmFiYmVyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVQU0lMT046IHJlcXVpcmUoJy4vZXBzaWxvbicpXG4gICwgY3JlYXRlOiByZXF1aXJlKCcuL2NyZWF0ZScpXG4gICwgY2xvbmU6IHJlcXVpcmUoJy4vY2xvbmUnKVxuICAsIGFuZ2xlOiByZXF1aXJlKCcuL2FuZ2xlJylcbiAgLCBmcm9tVmFsdWVzOiByZXF1aXJlKCcuL2Zyb21WYWx1ZXMnKVxuICAsIGNvcHk6IHJlcXVpcmUoJy4vY29weScpXG4gICwgc2V0OiByZXF1aXJlKCcuL3NldCcpXG4gICwgZXF1YWxzOiByZXF1aXJlKCcuL2VxdWFscycpXG4gICwgZXhhY3RFcXVhbHM6IHJlcXVpcmUoJy4vZXhhY3RFcXVhbHMnKVxuICAsIGFkZDogcmVxdWlyZSgnLi9hZGQnKVxuICAsIHN1YnRyYWN0OiByZXF1aXJlKCcuL3N1YnRyYWN0JylcbiAgLCBzdWI6IHJlcXVpcmUoJy4vc3ViJylcbiAgLCBtdWx0aXBseTogcmVxdWlyZSgnLi9tdWx0aXBseScpXG4gICwgbXVsOiByZXF1aXJlKCcuL211bCcpXG4gICwgZGl2aWRlOiByZXF1aXJlKCcuL2RpdmlkZScpXG4gICwgZGl2OiByZXF1aXJlKCcuL2RpdicpXG4gICwgbWluOiByZXF1aXJlKCcuL21pbicpXG4gICwgbWF4OiByZXF1aXJlKCcuL21heCcpXG4gICwgZmxvb3I6IHJlcXVpcmUoJy4vZmxvb3InKVxuICAsIGNlaWw6IHJlcXVpcmUoJy4vY2VpbCcpXG4gICwgcm91bmQ6IHJlcXVpcmUoJy4vcm91bmQnKVxuICAsIHNjYWxlOiByZXF1aXJlKCcuL3NjYWxlJylcbiAgLCBzY2FsZUFuZEFkZDogcmVxdWlyZSgnLi9zY2FsZUFuZEFkZCcpXG4gICwgZGlzdGFuY2U6IHJlcXVpcmUoJy4vZGlzdGFuY2UnKVxuICAsIGRpc3Q6IHJlcXVpcmUoJy4vZGlzdCcpXG4gICwgc3F1YXJlZERpc3RhbmNlOiByZXF1aXJlKCcuL3NxdWFyZWREaXN0YW5jZScpXG4gICwgc3FyRGlzdDogcmVxdWlyZSgnLi9zcXJEaXN0JylcbiAgLCBsZW5ndGg6IHJlcXVpcmUoJy4vbGVuZ3RoJylcbiAgLCBsZW46IHJlcXVpcmUoJy4vbGVuJylcbiAgLCBzcXVhcmVkTGVuZ3RoOiByZXF1aXJlKCcuL3NxdWFyZWRMZW5ndGgnKVxuICAsIHNxckxlbjogcmVxdWlyZSgnLi9zcXJMZW4nKVxuICAsIG5lZ2F0ZTogcmVxdWlyZSgnLi9uZWdhdGUnKVxuICAsIGludmVyc2U6IHJlcXVpcmUoJy4vaW52ZXJzZScpXG4gICwgbm9ybWFsaXplOiByZXF1aXJlKCcuL25vcm1hbGl6ZScpXG4gICwgZG90OiByZXF1aXJlKCcuL2RvdCcpXG4gICwgY3Jvc3M6IHJlcXVpcmUoJy4vY3Jvc3MnKVxuICAsIGxlcnA6IHJlcXVpcmUoJy4vbGVycCcpXG4gICwgcmFuZG9tOiByZXF1aXJlKCcuL3JhbmRvbScpXG4gICwgdHJhbnNmb3JtTWF0NDogcmVxdWlyZSgnLi90cmFuc2Zvcm1NYXQ0JylcbiAgLCB0cmFuc2Zvcm1NYXQzOiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDMnKVxuICAsIHRyYW5zZm9ybVF1YXQ6IHJlcXVpcmUoJy4vdHJhbnNmb3JtUXVhdCcpXG4gICwgcm90YXRlWDogcmVxdWlyZSgnLi9yb3RhdGVYJylcbiAgLCByb3RhdGVZOiByZXF1aXJlKCcuL3JvdGF0ZVknKVxuICAsIHJvdGF0ZVo6IHJlcXVpcmUoJy4vcm90YXRlWicpXG4gICwgZm9yRWFjaDogcmVxdWlyZSgnLi9mb3JFYWNoJylcbn1cbiIsImltcG9ydCBUcmFjZXIgZnJvbSAnLi90cmFjZXInO1xuXG4vKipcbiAqIGh0dHA6Ly93d3cuY29kZXByb2plY3QuY29tL1RpcHMvNDA3MTcyL0Nvbm5lY3RlZC1Db21wb25lbnQtTGFiZWxpbmctYW5kLVZlY3Rvcml6YXRpb25cbiAqL1xuY29uc3QgUmFzdGVyaXplciA9IHtcbiAgICBjcmVhdGVDb250b3VyMkQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXI6IG51bGwsXG4gICAgICAgICAgICBpbmRleDogbnVsbCxcbiAgICAgICAgICAgIGZpcnN0VmVydGV4OiBudWxsLFxuICAgICAgICAgICAgaW5zaWRlQ29udG91cnM6IG51bGwsXG4gICAgICAgICAgICBuZXh0cGVlcjogbnVsbCxcbiAgICAgICAgICAgIHByZXZwZWVyOiBudWxsLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgQ09OVE9VUl9ESVI6IHtcbiAgICAgICAgQ1dfRElSOiAwLFxuICAgICAgICBDQ1dfRElSOiAxLFxuICAgICAgICBVTktOT1dOX0RJUjogMixcbiAgICB9LFxuICAgIERJUjoge1xuICAgICAgICBPVVRTSURFX0VER0U6IC0zMjc2NyxcbiAgICAgICAgSU5TSURFX0VER0U6IC0zMjc2NixcbiAgICB9LFxuICAgIGNyZWF0ZShpbWFnZVdyYXBwZXIsIGxhYmVsV3JhcHBlcikge1xuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICAgICAgY29uc3QgbGFiZWxEYXRhID0gbGFiZWxXcmFwcGVyLmRhdGE7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICAgICAgY29uc3QgdHJhY2VyID0gVHJhY2VyLmNyZWF0ZShpbWFnZVdyYXBwZXIsIGxhYmVsV3JhcHBlcik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhc3Rlcml6ZShkZXB0aGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbG9yO1xuICAgICAgICAgICAgICAgIGxldCBiYztcbiAgICAgICAgICAgICAgICBsZXQgbGM7XG4gICAgICAgICAgICAgICAgbGV0IGxhYmVsaW5kZXg7XG4gICAgICAgICAgICAgICAgbGV0IGN4O1xuICAgICAgICAgICAgICAgIGxldCBjeTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvck1hcCA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCB2ZXJ0ZXg7XG4gICAgICAgICAgICAgICAgbGV0IHA7XG4gICAgICAgICAgICAgICAgbGV0IGNjO1xuICAgICAgICAgICAgICAgIGxldCBzYztcbiAgICAgICAgICAgICAgICBsZXQgcG9zO1xuICAgICAgICAgICAgICAgIGxldCBjb25uZWN0ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDAwOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JNYXBbaV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbG9yTWFwWzBdID0gaW1hZ2VEYXRhWzBdO1xuICAgICAgICAgICAgICAgIGNjID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKGN5ID0gMTsgY3kgPCBoZWlnaHQgLSAxOyBjeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yTWFwWzBdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGN4ID0gMTsgY3ggPCB3aWR0aCAtIDE7IGN4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IGN5ICogd2lkdGggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbERhdGFbcG9zXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gaW1hZ2VEYXRhW3Bvc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yICE9PSBiYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGMgPSBjb25uZWN0ZWRDb3VudCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvck1hcFtsY10gPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJjID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXggPSB0cmFjZXIuY29udG91clRyYWNpbmcoY3ksIGN4LCBsYywgY29sb3IsIFJhc3Rlcml6ZXIuRElSLk9VVFNJREVfRURHRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVydGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gbGM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IFJhc3Rlcml6ZXIuY3JlYXRlQ29udG91cjJEKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5kaXIgPSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNXX0RJUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmluZGV4ID0gbGFiZWxpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmZpcnN0VmVydGV4ID0gdmVydGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAubmV4dHBlZXIgPSBjYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmluc2lkZUNvbnRvdXJzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2MucHJldnBlZXIgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYyA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXggPSB0cmFjZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29udG91clRyYWNpbmcoY3ksIGN4LCBSYXN0ZXJpemVyLkRJUi5JTlNJREVfRURHRSwgY29sb3IsIGxhYmVsaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBSYXN0ZXJpemVyLmNyZWF0ZUNvbnRvdXIyRCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZmlyc3RWZXJ0ZXggPSB2ZXJ0ZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbnNpZGVDb250b3VycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRobGFiZWwgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5kaXIgPSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNDV19ESVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5kaXIgPSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNXX0RJUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbmRleCA9IGRlcHRobGFiZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MgPSBjYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKHNjICE9PSBudWxsKSAmJiBzYy5pbmRleCAhPT0gbGFiZWxpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYyA9IHNjLm5leHRwZWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5uZXh0cGVlciA9IHNjLmluc2lkZUNvbnRvdXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2MuaW5zaWRlQ29udG91cnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjLmluc2lkZUNvbnRvdXJzLnByZXZwZWVyID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYy5pbnNpZGVDb250b3VycyA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRhW3Bvc10gPSBsYWJlbGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGFiZWxEYXRhW3Bvc10gPT09IFJhc3Rlcml6ZXIuRElSLk9VVFNJREVfRURHRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBsYWJlbERhdGFbcG9zXSA9PT0gUmFzdGVyaXplci5ESVIuSU5TSURFX0VER0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxEYXRhW3Bvc10gPT09IFJhc3Rlcml6ZXIuRElSLklOU0lERV9FREdFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJjID0gaW1hZ2VEYXRhW3Bvc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmMgPSBjb2xvck1hcFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXggPSBsYWJlbERhdGFbcG9zXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yTWFwW2xhYmVsaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNjID0gY2M7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNjICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjLmluZGV4ID0gZGVwdGhsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgc2MgPSBzYy5uZXh0cGVlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2MsXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBjb25uZWN0ZWRDb3VudCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlYnVnOiB7XG4gICAgICAgICAgICAgICAgZHJhd0NvbnRvdXIoY2FudmFzLCBmaXJzdENvbnRvdXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcSA9IGZpcnN0Q29udG91cjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlxO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHA7XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JlZCc7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmVkJztcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcSA9IHBxLmluc2lkZUNvbnRvdXJzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gaXE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBpcS5uZXh0cGVlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHBxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBxID0gcHEubmV4dHBlZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gcHEuaW5zaWRlQ29udG91cnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChxLmRpcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmFzdGVyaXplci5DT05UT1VSX0RJUi5DV19ESVI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ0NXX0RJUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsdWUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuVU5LTk9XTl9ESVI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdncmVlbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gcS5maXJzdFZlcnRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocC54LCBwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwLngsIHAueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChwICE9PSBxLmZpcnN0VmVydGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBSYXN0ZXJpemVyO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbi8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuXG4vKiBAcHJlc2VydmUgQVNNIEJFR0lOICovXG5mdW5jdGlvbiBTa2VsZXRvbml6ZXIoc3RkbGliLCBmb3JlaWduLCBidWZmZXIpIHtcbiAgICAndXNlIGFzbSc7XG5cbiAgICBjb25zdCBpbWFnZXMgPSBuZXcgc3RkbGliLlVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBjb25zdCBzaXplID0gZm9yZWlnbi5zaXplIHwgMDtcbiAgICBjb25zdCB7IGltdWwgfSA9IHN0ZGxpYi5NYXRoO1xuXG4gICAgZnVuY3Rpb24gZXJvZGUoaW5JbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcbiAgICAgICAgaW5JbWFnZVB0ciB8PSAwO1xuICAgICAgICBvdXRJbWFnZVB0ciB8PSAwO1xuXG4gICAgICAgIGxldCB2ID0gMDtcbiAgICAgICAgbGV0IHUgPSAwO1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IHlTdGFydDEgPSAwO1xuICAgICAgICBsZXQgeVN0YXJ0MiA9IDA7XG4gICAgICAgIGxldCB4U3RhcnQxID0gMDtcbiAgICAgICAgbGV0IHhTdGFydDIgPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcblxuICAgICAgICBmb3IgKHYgPSAxOyAodiB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgdiA9ICh2ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0ICsgc2l6ZSkgfCAwO1xuICAgICAgICAgICAgZm9yICh1ID0gMTsgKHUgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHUgPSAodSArIDEpIHwgMCkge1xuICAgICAgICAgICAgICAgIHlTdGFydDEgPSAob2Zmc2V0IC0gc2l6ZSkgfCAwO1xuICAgICAgICAgICAgICAgIHlTdGFydDIgPSAob2Zmc2V0ICsgc2l6ZSkgfCAwO1xuICAgICAgICAgICAgICAgIHhTdGFydDEgPSAodSAtIDEpIHwgMDtcbiAgICAgICAgICAgICAgICB4U3RhcnQyID0gKHUgKyAxKSB8IDA7XG4gICAgICAgICAgICAgICAgc3VtID0gKChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDEgKyB4U3RhcnQyKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQxKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MiArIHhTdGFydDIpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICAgICAgICAgIGlmICgoc3VtIHwgMCkgPT0gKDUgfCAwKSkge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGFJbWFnZVB0ciwgYkltYWdlUHRyLCBvdXRJbWFnZVB0cikge1xuICAgICAgICBhSW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgYkltYWdlUHRyIHw9IDA7XG4gICAgICAgIG91dEltYWdlUHRyIHw9IDA7XG5cbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XG5cbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XG4gICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgbGVuZ3RoKSB8IDBdID0gKChpbWFnZXNbKGFJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApIC0gKGltYWdlc1soYkltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpdHdpc2VPcihhSW1hZ2VQdHIsIGJJbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcbiAgICAgICAgYUltYWdlUHRyIHw9IDA7XG4gICAgICAgIGJJbWFnZVB0ciB8PSAwO1xuICAgICAgICBvdXRJbWFnZVB0ciB8PSAwO1xuXG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9ICgoaW1hZ2VzWyhhSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSB8IChpbWFnZXNbKGJJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApKSB8IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb3VudE5vblplcm8oaW1hZ2VQdHIpIHtcbiAgICAgICAgaW1hZ2VQdHIgfD0gMDtcblxuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XG5cbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XG4gICAgICAgICAgICBzdW0gPSAoKHN1bSB8IDApICsgKGltYWdlc1soaW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChzdW0gfCAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0KGltYWdlUHRyLCB2YWx1ZSkge1xuICAgICAgICBpbWFnZVB0ciB8PSAwO1xuICAgICAgICB2YWx1ZSB8PSAwO1xuXG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlsYXRlKGluSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XG4gICAgICAgIGluSW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgb3V0SW1hZ2VQdHIgfD0gMDtcblxuICAgICAgICBsZXQgdiA9IDA7XG4gICAgICAgIGxldCB1ID0gMDtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGxldCB5U3RhcnQxID0gMDtcbiAgICAgICAgbGV0IHlTdGFydDIgPSAwO1xuICAgICAgICBsZXQgeFN0YXJ0MSA9IDA7XG4gICAgICAgIGxldCB4U3RhcnQyID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICAgICAgZm9yICh2ID0gMTsgKHYgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHYgPSAodiArIDEpIHwgMCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCArIHNpemUpIHwgMDtcbiAgICAgICAgICAgIGZvciAodSA9IDE7ICh1IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB1ID0gKHUgKyAxKSB8IDApIHtcbiAgICAgICAgICAgICAgICB5U3RhcnQxID0gKG9mZnNldCAtIHNpemUpIHwgMDtcbiAgICAgICAgICAgICAgICB5U3RhcnQyID0gKG9mZnNldCArIHNpemUpIHwgMDtcbiAgICAgICAgICAgICAgICB4U3RhcnQxID0gKHUgLSAxKSB8IDA7XG4gICAgICAgICAgICAgICAgeFN0YXJ0MiA9ICh1ICsgMSkgfCAwO1xuICAgICAgICAgICAgICAgIHN1bSA9ICgoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MSArIHhTdGFydDEpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MikgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQyICsgeFN0YXJ0MSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQyKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoKHN1bSB8IDApID4gKDAgfCAwKSkge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lbWNweShzcmNJbWFnZVB0ciwgZHN0SW1hZ2VQdHIpIHtcbiAgICAgICAgc3JjSW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgZHN0SW1hZ2VQdHIgfD0gMDtcblxuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcblxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1soZHN0SW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPSAoaW1hZ2VzWyhzcmNJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0JvcmRlcihpbWFnZVB0cikge1xuICAgICAgICBpbWFnZVB0ciB8PSAwO1xuXG4gICAgICAgIGxldCB4ID0gMDtcbiAgICAgICAgbGV0IHkgPSAwO1xuXG4gICAgICAgIGZvciAoeCA9IDA7ICh4IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB4ID0gKHggKyAxKSB8IDApIHtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyB4KSB8IDBdID0gMDtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyB5KSB8IDBdID0gMDtcbiAgICAgICAgICAgIHkgPSAoKHkgKyBzaXplKSAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyB5KSB8IDBdID0gMDtcbiAgICAgICAgICAgIHkgPSAoeSArIDEpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHggPSAwOyAoeCB8IDApIDwgKHNpemUgfCAwKTsgeCA9ICh4ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgeSkgfCAwXSA9IDA7XG4gICAgICAgICAgICB5ID0gKHkgKyAxKSB8IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBza2VsZXRvbml6ZSgpIHtcbiAgICAgICAgY29uc3Qgc3ViSW1hZ2VQdHIgPSAwO1xuICAgICAgICBsZXQgZXJvZGVkSW1hZ2VQdHIgPSAwO1xuICAgICAgICBsZXQgdGVtcEltYWdlUHRyID0gMDtcbiAgICAgICAgbGV0IHNrZWxJbWFnZVB0ciA9IDA7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBsZXQgZG9uZSA9IDA7XG5cbiAgICAgICAgZXJvZGVkSW1hZ2VQdHIgPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcbiAgICAgICAgdGVtcEltYWdlUHRyID0gKGVyb2RlZEltYWdlUHRyICsgZXJvZGVkSW1hZ2VQdHIpIHwgMDtcbiAgICAgICAgc2tlbEltYWdlUHRyID0gKHRlbXBJbWFnZVB0ciArIGVyb2RlZEltYWdlUHRyKSB8IDA7XG5cbiAgICAgICAgLy8gaW5pdCBza2VsLWltYWdlXG4gICAgICAgIGluaXQoc2tlbEltYWdlUHRyLCAwKTtcbiAgICAgICAgemVyb0JvcmRlcihzdWJJbWFnZVB0cik7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgZXJvZGUoc3ViSW1hZ2VQdHIsIGVyb2RlZEltYWdlUHRyKTtcbiAgICAgICAgICAgIGRpbGF0ZShlcm9kZWRJbWFnZVB0ciwgdGVtcEltYWdlUHRyKTtcbiAgICAgICAgICAgIHN1YnRyYWN0KHN1YkltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIsIHRlbXBJbWFnZVB0cik7XG4gICAgICAgICAgICBiaXR3aXNlT3Ioc2tlbEltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIsIHNrZWxJbWFnZVB0cik7XG4gICAgICAgICAgICBtZW1jcHkoZXJvZGVkSW1hZ2VQdHIsIHN1YkltYWdlUHRyKTtcbiAgICAgICAgICAgIHN1bSA9IGNvdW50Tm9uWmVybyhzdWJJbWFnZVB0cikgfCAwO1xuICAgICAgICAgICAgZG9uZSA9ICgoc3VtIHwgMCkgPT0gMCB8IDApO1xuICAgICAgICB9IHdoaWxlICghZG9uZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNrZWxldG9uaXplLFxuICAgIH07XG59XG4vKiBAcHJlc2VydmUgQVNNIEVORCAqL1xuZXhwb3J0IGRlZmF1bHQgU2tlbGV0b25pemVyO1xuLyogZXNsaW50LWVuYWJsZSBlcWVxZXEgKi9cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgcGF0aCAgICAgICAgICA9IHJlcXVpcmUoJ3BhdGgnKVxudmFyIG5kYXJyYXkgICAgICAgPSByZXF1aXJlKCduZGFycmF5JylcbnZhciBHaWZSZWFkZXIgICAgID0gcmVxdWlyZSgnb21nZ2lmJykuR2lmUmVhZGVyXG52YXIgcGFjayAgICAgICAgICA9IHJlcXVpcmUoJ25kYXJyYXktcGFjaycpXG52YXIgdGhyb3VnaCAgICAgICA9IHJlcXVpcmUoJ3Rocm91Z2gnKVxudmFyIHBhcnNlRGF0YVVSSSAgPSByZXF1aXJlKCdkYXRhLXVyaS10by1idWZmZXInKVxuXG5mdW5jdGlvbiBkZWZhdWx0SW1hZ2UodXJsLCBjYikge1xuICB2YXIgaW1nID0gbmV3IEltYWdlKClcbiAgaW1nLmNyb3NzT3JpZ2luID0gXCJBbm9ueW1vdXNcIlxuICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgY2FudmFzLndpZHRoID0gaW1nLndpZHRoXG4gICAgY2FudmFzLmhlaWdodCA9IGltZy5oZWlnaHRcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgY29udGV4dC5kcmF3SW1hZ2UoaW1nLCAwLCAwKVxuICAgIHZhciBwaXhlbHMgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbWcud2lkdGgsIGltZy5oZWlnaHQpXG4gICAgY2IobnVsbCwgbmRhcnJheShuZXcgVWludDhBcnJheShwaXhlbHMuZGF0YSksIFtpbWcud2lkdGgsIGltZy5oZWlnaHQsIDRdLCBbNCwgNCppbWcud2lkdGgsIDFdLCAwKSlcbiAgfVxuICBpbWcub25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgIGNiKGVycilcbiAgfVxuICBpbWcuc3JjID0gdXJsXG59XG5cbi8vQW5pbWF0ZWQgZ2lmIGxvYWRpbmdcbmZ1bmN0aW9uIGhhbmRsZUdpZihkYXRhLCBjYikge1xuICB2YXIgcmVhZGVyXG4gIHRyeSB7XG4gICAgcmVhZGVyID0gbmV3IEdpZlJlYWRlcihkYXRhKVxuICB9IGNhdGNoKGVycikge1xuICAgIGNiKGVycilcbiAgICByZXR1cm5cbiAgfVxuICBpZihyZWFkZXIubnVtRnJhbWVzKCkgPiAwKSB7XG4gICAgdmFyIG5zaGFwZSA9IFtyZWFkZXIubnVtRnJhbWVzKCksIHJlYWRlci5oZWlnaHQsIHJlYWRlci53aWR0aCwgNF1cbiAgICB2YXIgbmRhdGEgPSBuZXcgVWludDhBcnJheShuc2hhcGVbMF0gKiBuc2hhcGVbMV0gKiBuc2hhcGVbMl0gKiBuc2hhcGVbM10pXG4gICAgdmFyIHJlc3VsdCA9IG5kYXJyYXkobmRhdGEsIG5zaGFwZSlcbiAgICB0cnkge1xuICAgICAgZm9yKHZhciBpPTA7IGk8cmVhZGVyLm51bUZyYW1lcygpOyArK2kpIHtcbiAgICAgICAgcmVhZGVyLmRlY29kZUFuZEJsaXRGcmFtZVJHQkEoaSwgbmRhdGEuc3ViYXJyYXkoXG4gICAgICAgICAgcmVzdWx0LmluZGV4KGksIDAsIDAsIDApLFxuICAgICAgICAgIHJlc3VsdC5pbmRleChpKzEsIDAsIDAsIDApKSlcbiAgICAgIH1cbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgY2IoZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNiKG51bGwsIHJlc3VsdC50cmFuc3Bvc2UoMCwyLDEpKVxuICB9IGVsc2Uge1xuICAgIHZhciBuc2hhcGUgPSBbcmVhZGVyLmhlaWdodCwgcmVhZGVyLndpZHRoLCA0XVxuICAgIHZhciBuZGF0YSA9IG5ldyBVaW50OEFycmF5KG5zaGFwZVswXSAqIG5zaGFwZVsxXSAqIG5zaGFwZVsyXSlcbiAgICB2YXIgcmVzdWx0ID0gbmRhcnJheShuZGF0YSwgbnNoYXBlKVxuICAgIHRyeSB7XG4gICAgICByZWFkZXIuZGVjb2RlQW5kQmxpdEZyYW1lUkdCQSgwLCBuZGF0YSlcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgY2IoZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNiKG51bGwsIHJlc3VsdC50cmFuc3Bvc2UoMSwwKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBodHRwR2lmKHVybCwgY2IpIHtcbiAgdmFyIHhociAgICAgICAgICA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG4gIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpXG4gIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInXG4gIGlmKHhoci5vdmVycmlkZU1pbWVUeXBlKXtcbiAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZSgnYXBwbGljYXRpb24vYmluYXJ5JylcbiAgfVxuICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgIGNiKGVycilcbiAgfVxuICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYoeGhyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSlcbiAgICBoYW5kbGVHaWYoZGF0YSwgY2IpXG4gICAgcmV0dXJuXG4gIH1cbiAgeGhyLnNlbmQoKVxufVxuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKGJ1ZmZlcikge1xuICBpZihidWZmZXJbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBuID0gYnVmZmVyLmxlbmd0aFxuICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShuKVxuICAgIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgICAgcmVzdWx0W2ldID0gYnVmZmVyLmdldChpKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcilcbiAgfVxufVxuXG5mdW5jdGlvbiBkYXRhR2lmKHVybCwgY2IpIHtcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGJ1ZmZlciA9IHBhcnNlRGF0YVVSSSh1cmwpXG4gICAgICBpZihidWZmZXIpIHtcbiAgICAgICAgaGFuZGxlR2lmKGNvcHlCdWZmZXIoYnVmZmVyKSwgY2IpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYihuZXcgRXJyb3IoJ0Vycm9yIHBhcnNpbmcgZGF0YSBVUkknKSlcbiAgICAgIH1cbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgY2IoZXJyKVxuICAgIH1cbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQaXhlbHModXJsLCB0eXBlLCBjYikge1xuICBpZighY2IpIHtcbiAgICBjYiA9IHR5cGVcbiAgICB0eXBlID0gJydcbiAgfVxuICB2YXIgZXh0ID0gcGF0aC5leHRuYW1lKHVybClcbiAgc3dpdGNoKHR5cGUgfHwgZXh0LnRvVXBwZXJDYXNlKCkpIHtcbiAgICBjYXNlICcuR0lGJzpcbiAgICAgIGh0dHBHaWYodXJsLCBjYilcbiAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZihCdWZmZXIuaXNCdWZmZXIodXJsKSkge1xuICAgICAgICB1cmwgPSAnZGF0YTonICsgdHlwZSArICc7YmFzZTY0LCcgKyB1cmwudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgICB9XG4gICAgICBpZih1cmwuaW5kZXhPZignZGF0YTppbWFnZS9naWY7JykgPT09IDApIHtcbiAgICAgICAgZGF0YUdpZih1cmwsIGNiKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmYXVsdEltYWdlKHVybCwgY2IpXG4gICAgICB9XG4gIH1cbn0iLCIvKlxuICogdHlwZWRlZnMuanNcbiAqIE5vcm1hbGl6ZXMgYnJvd3Nlci1zcGVjaWZpYyBwcmVmaXhlcyBhbmQgcHJvdmlkZSBzb21lIGJhc2ljIHBvbHlmaWxsc1xuICovXG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgfHwgZnVuY3Rpb24gKC8qIGZ1bmN0aW9uIEZyYW1lUmVxdWVzdENhbGxiYWNrICovIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH0oKSk7XG4gICAgfVxufVxuXG5pZiAodHlwZW9mIE1hdGguaW11bCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbiAgICBNYXRoLmltdWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBjb25zdCBhaCA9IChhID4+PiAxNikgJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGFsID0gYSAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYmggPSAoYiA+Pj4gMTYpICYgMHhmZmZmO1xuICAgICAgICBjb25zdCBibCA9IGIgJiAweGZmZmY7XG4gICAgICAgIC8vIHRoZSBzaGlmdCBieSAwIGZpeGVzIHRoZSBzaWduIG9uIHRoZSBoaWdoIHBhcnRcbiAgICAgICAgLy8gdGhlIGZpbmFsIHwwIGNvbnZlcnRzIHRoZSB1bnNpZ25lZCB2YWx1ZSBpbnRvIGEgc2lnbmVkIHZhbHVlXG4gICAgICAgIHJldHVybiAoKGFsICogYmwpICsgKCgoYWggKiBibCArIGFsICogYmgpIDw8IDE2KSA+Pj4gMCkgfCAwKTtcbiAgICB9O1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tYml0d2lzZSAqL1xufVxuXG5pZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicpIHtcbiAgICBPYmplY3QuYXNzaWduID0gZnVuY3Rpb24gKHRhcmdldCkgeyAvLyAubGVuZ3RoIG9mIGZ1bmN0aW9uIGlzIDJcblxuJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIGlmICh0YXJnZXQgPT09IG51bGwpIHsgLy8gVHlwZUVycm9yIGlmIHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRvID0gT2JqZWN0KHRhcmdldCk7XG5cbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgICAgICAgIGNvbnN0IG5leHRTb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuXG4gICAgICAgICAgICBpZiAobmV4dFNvdXJjZSAhPT0gbnVsbCkgeyAvLyBTa2lwIG92ZXIgaWYgdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5leHRLZXkgaW4gbmV4dFNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBidWdzIHdoZW4gaGFzT3duUHJvcGVydHkgaXMgc2hhZG93ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuZXh0U291cmNlLCBuZXh0S2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9O1xufVxuIiwiZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhIb2xlczsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheUxpbWl0OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlUmVzdDsiLCJtb2R1bGUuZXhwb3J0cyA9IGNsb25lXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5mdW5jdGlvbiBjbG9uZShhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMilcbiAgICBvdXRbMF0gPSBhWzBdXG4gICAgb3V0WzFdID0gYVsxXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZyb21WYWx1ZXNcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbmZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDIpXG4gICAgb3V0WzBdID0geFxuICAgIG91dFsxXSA9IHlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBjb3B5XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzIgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdXG4gICAgb3V0WzFdID0gYVsxXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHNldFxuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2V0KG91dCwgeCwgeSkge1xuICAgIG91dFswXSA9IHhcbiAgICBvdXRbMV0gPSB5XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZXF1YWxzXG5cbnZhciBFUFNJTE9OID0gcmVxdWlyZSgnLi9lcHNpbG9uJylcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdXG4gIHZhciBhMSA9IGFbMV1cbiAgdmFyIGIwID0gYlswXVxuICB2YXIgYjEgPSBiWzFdXG4gIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBleGFjdEVxdWFsc1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgZXhhY3RseSBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMyfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBhZGRcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXVxuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zdWJ0cmFjdCcpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbXVsdGlwbHknKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RpdmlkZScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGludmVyc2VcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdXG4gIG91dFsxXSA9IDEuMCAvIGFbMV1cbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBtaW5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKVxuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbWF4XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSlcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJvdGF0ZVxuXG4vKipcbiAqIFJvdGF0ZXMgYSB2ZWMyIGJ5IGFuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIHRoZSBhbmdsZSBvZiByb3RhdGlvbiAoaW4gcmFkaWFucylcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgYW5nbGUpIHtcbiAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICBzID0gTWF0aC5zaW4oYW5nbGUpXG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdXG5cbiAgb3V0WzBdID0geCAqIGMgLSB5ICogc1xuICBvdXRbMV0gPSB4ICogcyArIHkgKiBjXG5cbiAgcmV0dXJuIG91dFxufVxuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZsb29yXG5cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKVxuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gY2VpbFxuXG4vKipcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjZWlsXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKVxuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSlcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByb3VuZFxuXG4vKipcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSlcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlXG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiXG4gICAgb3V0WzFdID0gYVsxXSAqIGJcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBzY2FsZUFuZEFkZFxuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzIncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpXG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0YW5jZScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3F1YXJlZERpc3RhbmNlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9sZW5ndGgnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NxdWFyZWRMZW5ndGgnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBuZWdhdGVcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBuZWdhdGUob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF1cbiAgICBvdXRbMV0gPSAtYVsxXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IG5vcm1hbGl6ZVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV1cbiAgICB2YXIgbGVuID0geCp4ICsgeSp5XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pXG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW5cbiAgICAgICAgb3V0WzFdID0gYVsxXSAqIGxlblxuICAgIH1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBkb3RcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbmZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV1cbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGNyb3NzXG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICogTm90ZSB0aGF0IHRoZSBjcm9zcyBwcm9kdWN0IG11c3QgYnkgZGVmaW5pdGlvbiBwcm9kdWNlIGEgM0QgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBjcm9zcyhvdXQsIGEsIGIpIHtcbiAgICB2YXIgeiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF1cbiAgICBvdXRbMF0gPSBvdXRbMV0gPSAwXG4gICAgb3V0WzJdID0gelxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGxlcnBcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgICB2YXIgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV1cbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KVxuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcmFuZG9tXG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDEuMFxuICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDIuMCAqIE1hdGguUElcbiAgICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHNjYWxlXG4gICAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiBzY2FsZVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybU1hdDJcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQyfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQyKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV1cbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybU1hdDJkXG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJkfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQyZChvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdXG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeSArIG1bNF1cbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybU1hdDNcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQzXG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0M30gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdXG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzNdICogeSArIG1bNl1cbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNF0gKiB5ICsgbVs3XVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybU1hdDRcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQ0XG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcwJ1xuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCBcbiAgICAgICAgeSA9IGFbMV1cbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVsxMl1cbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVsxM11cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoXG5cbnZhciB2ZWMgPSByZXF1aXJlKCcuL2NyZWF0ZScpKClcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjMnMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMi4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzJzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgIHZhciBpLCBsXG4gICAgaWYoIXN0cmlkZSkge1xuICAgICAgICBzdHJpZGUgPSAyXG4gICAgfVxuXG4gICAgaWYoIW9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSAwXG4gICAgfVxuICAgIFxuICAgIGlmKGNvdW50KSB7XG4gICAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aClcbiAgICB9IGVsc2Uge1xuICAgICAgICBsID0gYS5sZW5ndGhcbiAgICB9XG5cbiAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgIHZlY1swXSA9IGFbaV1cbiAgICAgICAgdmVjWzFdID0gYVtpKzFdXG4gICAgICAgIGZuKHZlYywgdmVjLCBhcmcpXG4gICAgICAgIGFbaV0gPSB2ZWNbMF1cbiAgICAgICAgYVtpKzFdID0gdmVjWzFdXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBhXG59IiwibW9kdWxlLmV4cG9ydHMgPSBsaW1pdDtcblxuLyoqXG4gKiBMaW1pdCB0aGUgbWFnbml0dWRlIG9mIHRoaXMgdmVjdG9yIHRvIHRoZSB2YWx1ZSB1c2VkIGZvciB0aGUgYG1heGBcbiAqIHBhcmFtZXRlci5cbiAqXG4gKiBAcGFyYW0gIHt2ZWMyfSB0aGUgdmVjdG9yIHRvIGxpbWl0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1heCB0aGUgbWF4aW11bSBtYWduaXR1ZGUgZm9yIHRoZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gbGltaXQob3V0LCBhLCBtYXgpIHtcbiAgdmFyIG1TcSA9IGFbMF0gKiBhWzBdICsgYVsxXSAqIGFbMV07XG5cbiAgaWYgKG1TcSA+IG1heCAqIG1heCkge1xuICAgIHZhciBuID0gTWF0aC5zcXJ0KG1TcSk7XG4gICAgb3V0WzBdID0gYVswXSAvIG4gKiBtYXg7XG4gICAgb3V0WzFdID0gYVsxXSAvIG4gKiBtYXg7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5mdW5jdGlvbiBjbG9uZShhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMylcbiAgICBvdXRbMF0gPSBhWzBdXG4gICAgb3V0WzFdID0gYVsxXVxuICAgIG91dFsyXSA9IGFbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBhbmdsZVxuXG52YXIgZnJvbVZhbHVlcyA9IHJlcXVpcmUoJy4vZnJvbVZhbHVlcycpXG52YXIgbm9ybWFsaXplID0gcmVxdWlyZSgnLi9ub3JtYWxpemUnKVxudmFyIGRvdCA9IHJlcXVpcmUoJy4vZG90JylcblxuLyoqXG4gKiBHZXQgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIDNEIHZlY3RvcnNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqL1xuZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICAgIHZhciB0ZW1wQSA9IGZyb21WYWx1ZXMoYVswXSwgYVsxXSwgYVsyXSlcbiAgICB2YXIgdGVtcEIgPSBmcm9tVmFsdWVzKGJbMF0sIGJbMV0sIGJbMl0pXG4gXG4gICAgbm9ybWFsaXplKHRlbXBBLCB0ZW1wQSlcbiAgICBub3JtYWxpemUodGVtcEIsIHRlbXBCKVxuIFxuICAgIHZhciBjb3NpbmUgPSBkb3QodGVtcEEsIHRlbXBCKVxuXG4gICAgaWYoY29zaW5lID4gMS4wKXtcbiAgICAgICAgcmV0dXJuIDBcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5hY29zKGNvc2luZSlcbiAgICB9ICAgICBcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gY29weTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgb3V0WzJdID0gYVsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHNldDtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBzZXQob3V0LCB4LCB5LCB6KSB7XG4gICAgb3V0WzBdID0geFxuICAgIG91dFsxXSA9IHlcbiAgICBvdXRbMl0gPSB6XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZXF1YWxzXG5cbnZhciBFUFNJTE9OID0gcmVxdWlyZSgnLi9lcHNpbG9uJylcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdXG4gIHZhciBhMSA9IGFbMV1cbiAgdmFyIGEyID0gYVsyXVxuICB2YXIgYjAgPSBiWzBdXG4gIHZhciBiMSA9IGJbMV1cbiAgdmFyIGIyID0gYlsyXVxuICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZXhhY3RFcXVhbHNcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGV4YWN0bHkgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBhZGQ7XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXVxuICAgIG91dFsyXSA9IGFbMl0gKyBiWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zdWJ0cmFjdCcpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbXVsdGlwbHknKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RpdmlkZScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IG1pbjtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKVxuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pXG4gICAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBtYXg7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSlcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKVxuICAgIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZmxvb3JcblxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pXG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSlcbiAgb3V0WzJdID0gTWF0aC5mbG9vcihhWzJdKVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNlaWxcblxuLyoqXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSlcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pXG4gIG91dFsyXSA9IE1hdGguY2VpbChhWzJdKVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJvdW5kXG5cbi8qKlxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKVxuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pXG4gIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSlcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBzY2FsZTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMzIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJcbiAgICBvdXRbMV0gPSBhWzFdICogYlxuICAgIG91dFsyXSA9IGFbMl0gKiBiXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gc2NhbGVBbmRBZGQ7XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMydzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSlcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSlcbiAgICBvdXRbMl0gPSBhWzJdICsgKGJbMl0gKiBzY2FsZSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3RhbmNlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcXVhcmVkRGlzdGFuY2UnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xlbmd0aCcpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3F1YXJlZExlbmd0aCcpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IG5lZ2F0ZTtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBuZWdhdGUob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF1cbiAgICBvdXRbMV0gPSAtYVsxXVxuICAgIG91dFsyXSA9IC1hWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gaW52ZXJzZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdXG4gIG91dFsxXSA9IDEuMCAvIGFbMV1cbiAgb3V0WzJdID0gMS4wIC8gYVsyXVxuICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBjcm9zcztcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBjcm9zcyhvdXQsIGEsIGIpIHtcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXVxuXG4gICAgb3V0WzBdID0gYXkgKiBieiAtIGF6ICogYnlcbiAgICBvdXRbMV0gPSBheiAqIGJ4IC0gYXggKiBielxuICAgIG91dFsyXSA9IGF4ICogYnkgLSBheSAqIGJ4XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbGVycDtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgICB2YXIgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV0sXG4gICAgICAgIGF6ID0gYVsyXVxuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpXG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSlcbiAgICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJhbmRvbTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiByYW5kb20ob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wXG5cbiAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAyLjAgKiBNYXRoLlBJXG4gICAgdmFyIHogPSAoTWF0aC5yYW5kb20oKSAqIDIuMCkgLSAxLjBcbiAgICB2YXIgelNjYWxlID0gTWF0aC5zcXJ0KDEuMC16KnopICogc2NhbGVcblxuICAgIG91dFswXSA9IE1hdGguY29zKHIpICogelNjYWxlXG4gICAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiB6U2NhbGVcbiAgICBvdXRbMl0gPSB6ICogc2NhbGVcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1NYXQ0O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDQuXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcbiAgICAgICAgdyA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XVxuICAgIHcgPSB3IHx8IDEuMFxuICAgIG91dFswXSA9IChtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSkgLyB3XG4gICAgb3V0WzFdID0gKG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdKSAvIHdcbiAgICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdKSAvIHdcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1NYXQzO1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDMuXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIHRoZSAzeDMgbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDMob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl1cbiAgICBvdXRbMF0gPSB4ICogbVswXSArIHkgKiBtWzNdICsgeiAqIG1bNl1cbiAgICBvdXRbMV0gPSB4ICogbVsxXSArIHkgKiBtWzRdICsgeiAqIG1bN11cbiAgICBvdXRbMl0gPSB4ICogbVsyXSArIHkgKiBtWzVdICsgeiAqIG1bOF1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1RdWF0O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1RdWF0KG91dCwgYSwgcSkge1xuICAgIC8vIGJlbmNobWFya3M6IGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tdHJhbnNmb3JtLXZlYzMtaW1wbGVtZW50YXRpb25zXG5cbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcbiAgICAgICAgcXggPSBxWzBdLCBxeSA9IHFbMV0sIHF6ID0gcVsyXSwgcXcgPSBxWzNdLFxuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG4gICAgICAgIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5LFxuICAgICAgICBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogeixcbiAgICAgICAgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHgsXG4gICAgICAgIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogelxuXG4gICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICAgIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXlcbiAgICBvdXRbMV0gPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6XG4gICAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeFxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJvdGF0ZVg7XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeC1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCBiLCBjKXtcbiAgICB2YXIgYnkgPSBiWzFdXG4gICAgdmFyIGJ6ID0gYlsyXVxuXG4gICAgLy8gVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgICB2YXIgcHkgPSBhWzFdIC0gYnlcbiAgICB2YXIgcHogPSBhWzJdIC0gYnpcblxuICAgIHZhciBzYyA9IE1hdGguc2luKGMpXG4gICAgdmFyIGNjID0gTWF0aC5jb3MoYylcblxuICAgIC8vIHBlcmZvcm0gcm90YXRpb24gYW5kIHRyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGJ5ICsgcHkgKiBjYyAtIHB6ICogc2NcbiAgICBvdXRbMl0gPSBieiArIHB5ICogc2MgKyBweiAqIGNjXG5cbiAgICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJvdGF0ZVk7XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeS1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCBiLCBjKXtcbiAgICB2YXIgYnggPSBiWzBdXG4gICAgdmFyIGJ6ID0gYlsyXVxuXG4gICAgLy8gdHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgICB2YXIgcHggPSBhWzBdIC0gYnhcbiAgICB2YXIgcHogPSBhWzJdIC0gYnpcbiAgICBcbiAgICB2YXIgc2MgPSBNYXRoLnNpbihjKVxuICAgIHZhciBjYyA9IE1hdGguY29zKGMpXG4gIFxuICAgIC8vIHBlcmZvcm0gcm90YXRpb24gYW5kIHRyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gICAgb3V0WzBdID0gYnggKyBweiAqIHNjICsgcHggKiBjY1xuICAgIG91dFsxXSA9IGFbMV1cbiAgICBvdXRbMl0gPSBieiArIHB6ICogY2MgLSBweCAqIHNjXG4gIFxuICAgIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlWjtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB6LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIGIsIGMpe1xuICAgIHZhciBieCA9IGJbMF1cbiAgICB2YXIgYnkgPSBiWzFdXG5cbiAgICAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gICAgdmFyIHB4ID0gYVswXSAtIGJ4XG4gICAgdmFyIHB5ID0gYVsxXSAtIGJ5XG4gIFxuICAgIHZhciBzYyA9IE1hdGguc2luKGMpXG4gICAgdmFyIGNjID0gTWF0aC5jb3MoYylcblxuICAgIC8vIHBlcmZvcm0gcm90YXRpb24gYW5kIHRyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gICAgb3V0WzBdID0gYnggKyBweCAqIGNjIC0gcHkgKiBzY1xuICAgIG91dFsxXSA9IGJ5ICsgcHggKiBzYyArIHB5ICogY2NcbiAgICBvdXRbMl0gPSBhWzJdXG4gIFxuICAgIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcblxudmFyIHZlYyA9IHJlcXVpcmUoJy4vY3JlYXRlJykoKVxuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMzcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMzLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjM3MgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2goYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgICAgIHZhciBpLCBsXG4gICAgICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgICAgIHN0cmlkZSA9IDNcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoY291bnQpIHtcbiAgICAgICAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSBhLmxlbmd0aFxuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgICAgdmVjWzBdID0gYVtpXSBcbiAgICAgICAgICAgIHZlY1sxXSA9IGFbaSsxXSBcbiAgICAgICAgICAgIHZlY1syXSA9IGFbaSsyXVxuICAgICAgICAgICAgZm4odmVjLCB2ZWMsIGFyZylcbiAgICAgICAgICAgIGFbaV0gPSB2ZWNbMF0gXG4gICAgICAgICAgICBhW2krMV0gPSB2ZWNbMV0gXG4gICAgICAgICAgICBhW2krMl0gPSB2ZWNbMl1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGFcbn0iLCJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZjsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXlcIik7XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRob3V0SG9sZXM7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXk7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQ7IiwidmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vZ2V0UHJvdG90eXBlT2ZcIik7XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc3VwZXJQcm9wQmFzZTsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcblxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSxcbiAgICAgIFByb21pc2VJbXBsXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiID8gbW9kdWxlLmV4cG9ydHMgOiB7fVxuKSk7XG5cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCB3ZSBjYW4gZXNjYXBlXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBkZXRlcm1pbmFudFxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MlxuICpcbiAqIEBhbGlhcyBtYXQyLmRldGVybWluYW50XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzJdICogYVsxXVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc3Bvc2VcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDJcbiAqXG4gKiBAYWxpYXMgbWF0Mi50cmFuc3Bvc2VcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICB2YXIgYTEgPSBhWzFdXG4gICAgb3V0WzFdID0gYVsyXVxuICAgIG91dFsyXSA9IGExXG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMl1cbiAgICBvdXRbMl0gPSBhWzFdXG4gICAgb3V0WzNdID0gYVszXVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBtdWx0aXBseVxuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDInc1xuICpcbiAqIEBhbGlhcyBtYXQyLm11bHRpcGx5XG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdXG4gIHZhciBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM11cbiAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjFcbiAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjFcbiAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjNcbiAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjNcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eVxuXG4vKipcbiAqIFNldCBhIG1hdDIgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBhbGlhcyBtYXQyLmlkZW50aXR5XG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMVxuICBvdXRbMV0gPSAwXG4gIG91dFsyXSA9IDBcbiAgb3V0WzNdID0gMVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFkam9pbnRcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDJcbiAqXG4gKiBAYWxpYXMgbWF0Mi5hZGpvaW50XG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIC8vIENhY2hpbmcgdGhpcyB2YWx1ZSBpcyBuZXNzZWNhcnkgaWYgb3V0ID09IGFcbiAgdmFyIGEwID0gIGFbMF1cbiAgb3V0WzBdID0gIGFbM11cbiAgb3V0WzFdID0gLWFbMV1cbiAgb3V0WzJdID0gLWFbMl1cbiAgb3V0WzNdID0gIGEwXG5cbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MiBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAYWxpYXMgbWF0Mi5yb3RhdGVcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdXG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKVxuICB2YXIgYyA9IE1hdGguY29zKHJhZClcbiAgb3V0WzBdID0gYTAgKiAgYyArIGEyICogc1xuICBvdXRbMV0gPSBhMSAqICBjICsgYTMgKiBzXG4gIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGNcbiAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogY1xuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGludmVydFxuXG4vKipcbiAqIEludmVydHMgYSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIuaW52ZXJ0XG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGEwID0gYVswXVxuICB2YXIgYTEgPSBhWzFdXG4gIHZhciBhMiA9IGFbMl1cbiAgdmFyIGEzID0gYVszXVxuICB2YXIgZGV0ID0gYTAgKiBhMyAtIGEyICogYTFcblxuICBpZiAoIWRldCkgcmV0dXJuIG51bGxcbiAgZGV0ID0gMS4wIC8gZGV0XG5cbiAgb3V0WzBdID0gIGEzICogZGV0XG4gIG91dFsxXSA9IC1hMSAqIGRldFxuICBvdXRbMl0gPSAtYTIgKiBkZXRcbiAgb3V0WzNdID0gIGEwICogZGV0XG5cbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJcbiAqXG4gKiBAYWxpYXMgbWF0Mi5jcmVhdGVcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoNClcbiAgb3V0WzBdID0gMVxuICBvdXRbMV0gPSAwXG4gIG91dFsyXSA9IDBcbiAgb3V0WzNdID0gMVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlXG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQyIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQGFsaWFzIG1hdDIuc2NhbGVcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKiovXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXVxuICB2YXIgdjAgPSB2WzBdLCB2MSA9IHZbMV1cbiAgb3V0WzBdID0gYTAgKiB2MFxuICBvdXRbMV0gPSBhMSAqIHYwXG4gIG91dFsyXSA9IGEyICogdjFcbiAgb3V0WzNdID0gYTMgKiB2MVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNvcHlcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MiB0byBhbm90aGVyXG4gKlxuICogQGFsaWFzIG1hdDIuY29weVxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdXG4gIG91dFsxXSA9IGFbMV1cbiAgb3V0WzJdID0gYVsyXVxuICBvdXRbM10gPSBhWzNdXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnJvYlxuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIuZnJvYlxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5mdW5jdGlvbiBmcm9iKGEpIHtcbiAgcmV0dXJuIE1hdGguc3FydChcbiAgICBNYXRoLnBvdyhhWzBdLCAyKSArXG4gICAgTWF0aC5wb3coYVsxXSwgMikgK1xuICAgIE1hdGgucG93KGFbMl0sIDIpICtcbiAgICBNYXRoLnBvdyhhWzNdLCAyKVxuICApXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGxkdVxuXG4vKipcbiAqIFJldHVybnMgTCwgRCBhbmQgVSBtYXRyaWNlcyAoTG93ZXIgdHJpYW5ndWxhciwgRGlhZ29uYWwgYW5kIFVwcGVyIHRyaWFuZ3VsYXIpIGJ5IGZhY3Rvcml6aW5nIHRoZSBpbnB1dCBtYXRyaXhcbiAqXG4gKiBAYWxpYXMgbWF0Mi5sZHVcbiAqIEBwYXJhbSB7bWF0Mn0gTCB0aGUgbG93ZXIgdHJpYW5ndWxhciBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gRCB0aGUgZGlhZ29uYWwgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IFUgdGhlIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGlucHV0IG1hdHJpeCB0byBmYWN0b3JpemVcbiAqL1xuZnVuY3Rpb24gbGR1KEwsIEQsIFUsIGEpIHtcbiAgTFsyXSA9IGFbMl0vYVswXVxuICBVWzBdID0gYVswXVxuICBVWzFdID0gYVsxXVxuICBVWzNdID0gYVszXSAtIExbMl0gKiBVWzFdXG4gIHJldHVybiBbTCwgRCwgVV1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIC5kaXJuYW1lLCAuYmFzZW5hbWUsIGFuZCAuZXh0bmFtZSBtZXRob2RzIGFyZSBleHRyYWN0ZWQgZnJvbSBOb2RlLmpzIHY4LjExLjEsXG4vLyBiYWNrcG9ydGVkIGFuZCB0cmFuc3BsaXRlZCB3aXRoIEJhYmVsLCB3aXRoIGJhY2t3YXJkcy1jb21wYXQgZml4ZXNcblxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJy4nO1xuICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgdmFyIGhhc1Jvb3QgPSBjb2RlID09PSA0NyAvKi8qLztcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiBoYXNSb290ID8gJy8nIDogJy4nO1xuICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHtcbiAgICAvLyByZXR1cm4gJy8vJztcbiAgICAvLyBCYWNrd2FyZHMtY29tcGF0IGZpeDpcbiAgICByZXR1cm4gJy8nO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBiYXNlbmFtZShwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG5cbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gcGF0aCBjb21wb25lbnRcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgZW5kID0gaSArIDE7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiAnJztcbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG59XG5cbi8vIFVzZXMgYSBtaXhlZCBhcHByb2FjaCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIGFzIGV4dCBiZWhhdmlvciBjaGFuZ2VkXG4vLyBpbiBuZXcgTm9kZS5qcyB2ZXJzaW9ucywgc28gb25seSBiYXNlbmFtZSgpIGFib3ZlIGlzIGJhY2twb3J0ZWQgaGVyZVxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uIChwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBiYXNlbmFtZShwYXRoKTtcbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIHZhciBzdGFydERvdCA9IC0xO1xuICB2YXIgc3RhcnRQYXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICB2YXIgcHJlRG90U3RhdGUgPSAwO1xuICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXG4gICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpXG4gICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSlcbiAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiBpb3RhKG4pIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShuKVxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSBpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlvdGEiLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiIsIi8vIChjKSBEZWFuIE1jTmFtZWUgPGRlYW5AZ21haWwuY29tPiwgMjAxMy5cbi8vXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGVhbm0vb21nZ2lmXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1Ncbi8vIElOIFRIRSBTT0ZUV0FSRS5cbi8vXG4vLyBvbWdnaWYgaXMgYSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIGEgR0lGIDg5YSBlbmNvZGVyIGFuZCBkZWNvZGVyLFxuLy8gaW5jbHVkaW5nIGFuaW1hdGlvbiBhbmQgY29tcHJlc3Npb24uICBJdCBkb2VzIG5vdCByZWx5IG9uIGFueSBzcGVjaWZpY1xuLy8gdW5kZXJseWluZyBzeXN0ZW0sIHNvIHNob3VsZCBydW4gaW4gdGhlIGJyb3dzZXIsIE5vZGUsIG9yIFBsYXNrLlxuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gR2lmV3JpdGVyKGJ1Ziwgd2lkdGgsIGhlaWdodCwgZ29wdHMpIHtcbiAgdmFyIHAgPSAwO1xuXG4gIHZhciBnb3B0cyA9IGdvcHRzID09PSB1bmRlZmluZWQgPyB7IH0gOiBnb3B0cztcbiAgdmFyIGxvb3BfY291bnQgPSBnb3B0cy5sb29wID09PSB1bmRlZmluZWQgPyBudWxsIDogZ29wdHMubG9vcDtcbiAgdmFyIGdsb2JhbF9wYWxldHRlID0gZ29wdHMucGFsZXR0ZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGdvcHRzLnBhbGV0dGU7XG5cbiAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDAgfHwgd2lkdGggPiA2NTUzNSB8fCBoZWlnaHQgPiA2NTUzNSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaWR0aC9IZWlnaHQgaW52YWxpZC5cIik7XG5cbiAgZnVuY3Rpb24gY2hlY2tfcGFsZXR0ZV9hbmRfbnVtX2NvbG9ycyhwYWxldHRlKSB7XG4gICAgdmFyIG51bV9jb2xvcnMgPSBwYWxldHRlLmxlbmd0aDtcbiAgICBpZiAobnVtX2NvbG9ycyA8IDIgfHwgbnVtX2NvbG9ycyA+IDI1NiB8fCAgbnVtX2NvbG9ycyAmIChudW1fY29sb3JzLTEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJJbnZhbGlkIGNvZGUvY29sb3IgbGVuZ3RoLCBtdXN0IGJlIHBvd2VyIG9mIDIgYW5kIDIgLi4gMjU2LlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bV9jb2xvcnM7XG4gIH1cblxuICAvLyAtIEhlYWRlci5cbiAgYnVmW3ArK10gPSAweDQ3OyBidWZbcCsrXSA9IDB4NDk7IGJ1ZltwKytdID0gMHg0NjsgIC8vIEdJRlxuICBidWZbcCsrXSA9IDB4Mzg7IGJ1ZltwKytdID0gMHgzOTsgYnVmW3ArK10gPSAweDYxOyAgLy8gODlhXG5cbiAgLy8gSGFuZGxpbmcgb2YgR2xvYmFsIENvbG9yIFRhYmxlIChwYWxldHRlKSBhbmQgYmFja2dyb3VuZCBpbmRleC5cbiAgdmFyIGdwX251bV9jb2xvcnNfcG93MiA9IDA7XG4gIHZhciBiYWNrZ3JvdW5kID0gMDtcbiAgaWYgKGdsb2JhbF9wYWxldHRlICE9PSBudWxsKSB7XG4gICAgdmFyIGdwX251bV9jb2xvcnMgPSBjaGVja19wYWxldHRlX2FuZF9udW1fY29sb3JzKGdsb2JhbF9wYWxldHRlKTtcbiAgICB3aGlsZSAoZ3BfbnVtX2NvbG9ycyA+Pj0gMSkgKytncF9udW1fY29sb3JzX3BvdzI7XG4gICAgZ3BfbnVtX2NvbG9ycyA9IDEgPDwgZ3BfbnVtX2NvbG9yc19wb3cyO1xuICAgIC0tZ3BfbnVtX2NvbG9yc19wb3cyO1xuICAgIGlmIChnb3B0cy5iYWNrZ3JvdW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJhY2tncm91bmQgPSBnb3B0cy5iYWNrZ3JvdW5kO1xuICAgICAgaWYgKGJhY2tncm91bmQgPj0gZ3BfbnVtX2NvbG9ycylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFja2dyb3VuZCBpbmRleCBvdXQgb2YgcmFuZ2UuXCIpO1xuICAgICAgLy8gVGhlIEdJRiBzcGVjIHN0YXRlcyB0aGF0IGEgYmFja2dyb3VuZCBpbmRleCBvZiAwIHNob3VsZCBiZSBpZ25vcmVkLCBzb1xuICAgICAgLy8gdGhpcyBpcyBwcm9iYWJseSBhIG1pc3Rha2UgYW5kIHlvdSByZWFsbHkgd2FudCB0byBzZXQgaXQgdG8gYW5vdGhlclxuICAgICAgLy8gc2xvdCBpbiB0aGUgcGFsZXR0ZS4gIEJ1dCBhY3R1YWxseSBpbiB0aGUgZW5kIG1vc3QgYnJvd3NlcnMsIGV0YyBlbmRcbiAgICAgIC8vIHVwIGlnbm9yaW5nIHRoaXMgYWxtb3N0IGNvbXBsZXRlbHkgKGluY2x1ZGluZyBmb3IgZGlzcG9zZSBiYWNrZ3JvdW5kKS5cbiAgICAgIGlmIChiYWNrZ3JvdW5kID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWNrZ3JvdW5kIGluZGV4IGV4cGxpY2l0bHkgcGFzc2VkIGFzIDAuXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIC0gTG9naWNhbCBTY3JlZW4gRGVzY3JpcHRvci5cbiAgLy8gTk9URShkZWFubSk6IHcvaCBhcHBhcmVudGx5IGlnbm9yZWQgYnkgaW1wbGVtZW50YXRpb25zLCBidXQgc2V0IGFueXdheS5cbiAgYnVmW3ArK10gPSB3aWR0aCAmIDB4ZmY7IGJ1ZltwKytdID0gd2lkdGggPj4gOCAmIDB4ZmY7XG4gIGJ1ZltwKytdID0gaGVpZ2h0ICYgMHhmZjsgYnVmW3ArK10gPSBoZWlnaHQgPj4gOCAmIDB4ZmY7XG4gIC8vIE5PVEU6IEluZGljYXRlcyAwLWJwcCBvcmlnaW5hbCBjb2xvciByZXNvbHV0aW9uICh1bnVzZWQ/KS5cbiAgYnVmW3ArK10gPSAoZ2xvYmFsX3BhbGV0dGUgIT09IG51bGwgPyAweDgwIDogMCkgfCAgLy8gR2xvYmFsIENvbG9yIFRhYmxlIEZsYWcuXG4gICAgICAgICAgICAgZ3BfbnVtX2NvbG9yc19wb3cyOyAgLy8gTk9URTogTm8gc29ydCBmbGFnICh1bnVzZWQ/KS5cbiAgYnVmW3ArK10gPSBiYWNrZ3JvdW5kOyAgLy8gQmFja2dyb3VuZCBDb2xvciBJbmRleC5cbiAgYnVmW3ArK10gPSAwOyAgLy8gUGl4ZWwgYXNwZWN0IHJhdGlvICh1bnVzZWQ/KS5cblxuICAvLyAtIEdsb2JhbCBDb2xvciBUYWJsZVxuICBpZiAoZ2xvYmFsX3BhbGV0dGUgIT09IG51bGwpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBnbG9iYWxfcGFsZXR0ZS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICB2YXIgcmdiID0gZ2xvYmFsX3BhbGV0dGVbaV07XG4gICAgICBidWZbcCsrXSA9IHJnYiA+PiAxNiAmIDB4ZmY7XG4gICAgICBidWZbcCsrXSA9IHJnYiA+PiA4ICYgMHhmZjtcbiAgICAgIGJ1ZltwKytdID0gcmdiICYgMHhmZjtcbiAgICB9XG4gIH1cblxuICBpZiAobG9vcF9jb3VudCAhPT0gbnVsbCkgeyAgLy8gTmV0c2NhcGUgYmxvY2sgZm9yIGxvb3BpbmcuXG4gICAgaWYgKGxvb3BfY291bnQgPCAwIHx8IGxvb3BfY291bnQgPiA2NTUzNSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvb3AgY291bnQgaW52YWxpZC5cIilcbiAgICAvLyBFeHRlbnNpb24gY29kZSwgbGFiZWwsIGFuZCBsZW5ndGguXG4gICAgYnVmW3ArK10gPSAweDIxOyBidWZbcCsrXSA9IDB4ZmY7IGJ1ZltwKytdID0gMHgwYjtcbiAgICAvLyBORVRTQ0FQRTIuMFxuICAgIGJ1ZltwKytdID0gMHg0ZTsgYnVmW3ArK10gPSAweDQ1OyBidWZbcCsrXSA9IDB4NTQ7IGJ1ZltwKytdID0gMHg1MztcbiAgICBidWZbcCsrXSA9IDB4NDM7IGJ1ZltwKytdID0gMHg0MTsgYnVmW3ArK10gPSAweDUwOyBidWZbcCsrXSA9IDB4NDU7XG4gICAgYnVmW3ArK10gPSAweDMyOyBidWZbcCsrXSA9IDB4MmU7IGJ1ZltwKytdID0gMHgzMDtcbiAgICAvLyBTdWItYmxvY2tcbiAgICBidWZbcCsrXSA9IDB4MDM7IGJ1ZltwKytdID0gMHgwMTtcbiAgICBidWZbcCsrXSA9IGxvb3BfY291bnQgJiAweGZmOyBidWZbcCsrXSA9IGxvb3BfY291bnQgPj4gOCAmIDB4ZmY7XG4gICAgYnVmW3ArK10gPSAweDAwOyAgLy8gVGVybWluYXRvci5cbiAgfVxuXG5cbiAgdmFyIGVuZGVkID0gZmFsc2U7XG5cbiAgdGhpcy5hZGRGcmFtZSA9IGZ1bmN0aW9uKHgsIHksIHcsIGgsIGluZGV4ZWRfcGl4ZWxzLCBvcHRzKSB7XG4gICAgaWYgKGVuZGVkID09PSB0cnVlKSB7IC0tcDsgZW5kZWQgPSBmYWxzZTsgfSAgLy8gVW4tZW5kLlxuXG4gICAgb3B0cyA9IG9wdHMgPT09IHVuZGVmaW5lZCA/IHsgfSA6IG9wdHM7XG5cbiAgICAvLyBUT0RPKGRlYW5tKTogQm91bmRzIGNoZWNrIHgsIHkuICBEbyB0aGV5IG5lZWQgdG8gYmUgd2l0aGluIHRoZSB2aXJ0dWFsXG4gICAgLy8gY2FudmFzIHdpZHRoL2hlaWdodCwgSSBpbWFnaW5lP1xuICAgIGlmICh4IDwgMCB8fCB5IDwgMCB8fCB4ID4gNjU1MzUgfHwgeSA+IDY1NTM1KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwieC95IGludmFsaWQuXCIpXG5cbiAgICBpZiAodyA8PSAwIHx8IGggPD0gMCB8fCB3ID4gNjU1MzUgfHwgaCA+IDY1NTM1KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2lkdGgvSGVpZ2h0IGludmFsaWQuXCIpXG5cbiAgICBpZiAoaW5kZXhlZF9waXhlbHMubGVuZ3RoIDwgdyAqIGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgZW5vdWdoIHBpeGVscyBmb3IgdGhlIGZyYW1lIHNpemUuXCIpO1xuXG4gICAgdmFyIHVzaW5nX2xvY2FsX3BhbGV0dGUgPSB0cnVlO1xuICAgIHZhciBwYWxldHRlID0gb3B0cy5wYWxldHRlO1xuICAgIGlmIChwYWxldHRlID09PSB1bmRlZmluZWQgfHwgcGFsZXR0ZSA9PT0gbnVsbCkge1xuICAgICAgdXNpbmdfbG9jYWxfcGFsZXR0ZSA9IGZhbHNlO1xuICAgICAgcGFsZXR0ZSA9IGdsb2JhbF9wYWxldHRlO1xuICAgIH1cblxuICAgIGlmIChwYWxldHRlID09PSB1bmRlZmluZWQgfHwgcGFsZXR0ZSA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3Qgc3VwcGx5IGVpdGhlciBhIGxvY2FsIG9yIGdsb2JhbCBwYWxldHRlLlwiKTtcblxuICAgIHZhciBudW1fY29sb3JzID0gY2hlY2tfcGFsZXR0ZV9hbmRfbnVtX2NvbG9ycyhwYWxldHRlKTtcblxuICAgIC8vIENvbXB1dGUgdGhlIG1pbl9jb2RlX3NpemUgKHBvd2VyIG9mIDIpLCBkZXN0cm95aW5nIG51bV9jb2xvcnMuXG4gICAgdmFyIG1pbl9jb2RlX3NpemUgPSAwO1xuICAgIHdoaWxlIChudW1fY29sb3JzID4+PSAxKSArK21pbl9jb2RlX3NpemU7XG4gICAgbnVtX2NvbG9ycyA9IDEgPDwgbWluX2NvZGVfc2l6ZTsgIC8vIE5vdyB3ZSBjYW4gZWFzaWx5IGdldCBpdCBiYWNrLlxuXG4gICAgdmFyIGRlbGF5ID0gb3B0cy5kZWxheSA9PT0gdW5kZWZpbmVkID8gMCA6IG9wdHMuZGVsYXk7XG5cbiAgICAvLyBGcm9tIHRoZSBzcGVjOlxuICAgIC8vICAgICAwIC0gICBObyBkaXNwb3NhbCBzcGVjaWZpZWQuIFRoZSBkZWNvZGVyIGlzXG4gICAgLy8gICAgICAgICAgIG5vdCByZXF1aXJlZCB0byB0YWtlIGFueSBhY3Rpb24uXG4gICAgLy8gICAgIDEgLSAgIERvIG5vdCBkaXNwb3NlLiBUaGUgZ3JhcGhpYyBpcyB0byBiZSBsZWZ0XG4gICAgLy8gICAgICAgICAgIGluIHBsYWNlLlxuICAgIC8vICAgICAyIC0gICBSZXN0b3JlIHRvIGJhY2tncm91bmQgY29sb3IuIFRoZSBhcmVhIHVzZWQgYnkgdGhlXG4gICAgLy8gICAgICAgICAgIGdyYXBoaWMgbXVzdCBiZSByZXN0b3JlZCB0byB0aGUgYmFja2dyb3VuZCBjb2xvci5cbiAgICAvLyAgICAgMyAtICAgUmVzdG9yZSB0byBwcmV2aW91cy4gVGhlIGRlY29kZXIgaXMgcmVxdWlyZWQgdG9cbiAgICAvLyAgICAgICAgICAgcmVzdG9yZSB0aGUgYXJlYSBvdmVyd3JpdHRlbiBieSB0aGUgZ3JhcGhpYyB3aXRoXG4gICAgLy8gICAgICAgICAgIHdoYXQgd2FzIHRoZXJlIHByaW9yIHRvIHJlbmRlcmluZyB0aGUgZ3JhcGhpYy5cbiAgICAvLyAgNC03IC0gICAgVG8gYmUgZGVmaW5lZC5cbiAgICAvLyBOT1RFKGRlYW5tKTogRGlzcG9zZSBiYWNrZ3JvdW5kIGRvZXNuJ3QgcmVhbGx5IHdvcmssIGFwcGFyZW50bHkgbW9zdFxuICAgIC8vIGJyb3dzZXJzIGlnbm9yZSB0aGUgYmFja2dyb3VuZCBwYWxldHRlIGluZGV4IGFuZCBjbGVhciB0byB0cmFuc3BhcmVuY3kuXG4gICAgdmFyIGRpc3Bvc2FsID0gb3B0cy5kaXNwb3NhbCA9PT0gdW5kZWZpbmVkID8gMCA6IG9wdHMuZGlzcG9zYWw7XG4gICAgaWYgKGRpc3Bvc2FsIDwgMCB8fCBkaXNwb3NhbCA+IDMpICAvLyA0LTcgaXMgcmVzZXJ2ZWQuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNwb3NhbCBvdXQgb2YgcmFuZ2UuXCIpO1xuXG4gICAgdmFyIHVzZV90cmFuc3BhcmVuY3kgPSBmYWxzZTtcbiAgICB2YXIgdHJhbnNwYXJlbnRfaW5kZXggPSAwO1xuICAgIGlmIChvcHRzLnRyYW5zcGFyZW50ICE9PSB1bmRlZmluZWQgJiYgb3B0cy50cmFuc3BhcmVudCAhPT0gbnVsbCkge1xuICAgICAgdXNlX3RyYW5zcGFyZW5jeSA9IHRydWU7XG4gICAgICB0cmFuc3BhcmVudF9pbmRleCA9IG9wdHMudHJhbnNwYXJlbnQ7XG4gICAgICBpZiAodHJhbnNwYXJlbnRfaW5kZXggPCAwIHx8IHRyYW5zcGFyZW50X2luZGV4ID49IG51bV9jb2xvcnMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zcGFyZW50IGNvbG9yIGluZGV4LlwiKTtcbiAgICB9XG5cbiAgICBpZiAoZGlzcG9zYWwgIT09IDAgfHwgdXNlX3RyYW5zcGFyZW5jeSB8fCBkZWxheSAhPT0gMCkge1xuICAgICAgLy8gLSBHcmFwaGljcyBDb250cm9sIEV4dGVuc2lvblxuICAgICAgYnVmW3ArK10gPSAweDIxOyBidWZbcCsrXSA9IDB4Zjk7ICAvLyBFeHRlbnNpb24gLyBMYWJlbC5cbiAgICAgIGJ1ZltwKytdID0gNDsgIC8vIEJ5dGUgc2l6ZS5cblxuICAgICAgYnVmW3ArK10gPSBkaXNwb3NhbCA8PCAyIHwgKHVzZV90cmFuc3BhcmVuY3kgPT09IHRydWUgPyAxIDogMCk7XG4gICAgICBidWZbcCsrXSA9IGRlbGF5ICYgMHhmZjsgYnVmW3ArK10gPSBkZWxheSA+PiA4ICYgMHhmZjtcbiAgICAgIGJ1ZltwKytdID0gdHJhbnNwYXJlbnRfaW5kZXg7ICAvLyBUcmFuc3BhcmVudCBjb2xvciBpbmRleC5cbiAgICAgIGJ1ZltwKytdID0gMDsgIC8vIEJsb2NrIFRlcm1pbmF0b3IuXG4gICAgfVxuXG4gICAgLy8gLSBJbWFnZSBEZXNjcmlwdG9yXG4gICAgYnVmW3ArK10gPSAweDJjOyAgLy8gSW1hZ2UgU2VwZXJhdG9yLlxuICAgIGJ1ZltwKytdID0geCAmIDB4ZmY7IGJ1ZltwKytdID0geCA+PiA4ICYgMHhmZjsgIC8vIExlZnQuXG4gICAgYnVmW3ArK10gPSB5ICYgMHhmZjsgYnVmW3ArK10gPSB5ID4+IDggJiAweGZmOyAgLy8gVG9wLlxuICAgIGJ1ZltwKytdID0gdyAmIDB4ZmY7IGJ1ZltwKytdID0gdyA+PiA4ICYgMHhmZjtcbiAgICBidWZbcCsrXSA9IGggJiAweGZmOyBidWZbcCsrXSA9IGggPj4gOCAmIDB4ZmY7XG4gICAgLy8gTk9URTogTm8gc29ydCBmbGFnICh1bnVzZWQ/KS5cbiAgICAvLyBUT0RPKGRlYW5tKTogU3VwcG9ydCBpbnRlcmxhY2UuXG4gICAgYnVmW3ArK10gPSB1c2luZ19sb2NhbF9wYWxldHRlID09PSB0cnVlID8gKDB4ODAgfCAobWluX2NvZGVfc2l6ZS0xKSkgOiAwO1xuXG4gICAgLy8gLSBMb2NhbCBDb2xvciBUYWJsZVxuICAgIGlmICh1c2luZ19sb2NhbF9wYWxldHRlID09PSB0cnVlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBwYWxldHRlLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgICAgdmFyIHJnYiA9IHBhbGV0dGVbaV07XG4gICAgICAgIGJ1ZltwKytdID0gcmdiID4+IDE2ICYgMHhmZjtcbiAgICAgICAgYnVmW3ArK10gPSByZ2IgPj4gOCAmIDB4ZmY7XG4gICAgICAgIGJ1ZltwKytdID0gcmdiICYgMHhmZjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwID0gR2lmV3JpdGVyT3V0cHV0TFpXQ29kZVN0cmVhbShcbiAgICAgICAgICAgIGJ1ZiwgcCwgbWluX2NvZGVfc2l6ZSA8IDIgPyAyIDogbWluX2NvZGVfc2l6ZSwgaW5kZXhlZF9waXhlbHMpO1xuXG4gICAgcmV0dXJuIHA7XG4gIH07XG5cbiAgdGhpcy5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoZW5kZWQgPT09IGZhbHNlKSB7XG4gICAgICBidWZbcCsrXSA9IDB4M2I7ICAvLyBUcmFpbGVyLlxuICAgICAgZW5kZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfTtcblxuICB0aGlzLmdldE91dHB1dEJ1ZmZlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gYnVmOyB9O1xuICB0aGlzLnNldE91dHB1dEJ1ZmZlciA9IGZ1bmN0aW9uKHYpIHsgYnVmID0gdjsgfTtcbiAgdGhpcy5nZXRPdXRwdXRCdWZmZXJQb3NpdGlvbiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcDsgfTtcbiAgdGhpcy5zZXRPdXRwdXRCdWZmZXJQb3NpdGlvbiA9IGZ1bmN0aW9uKHYpIHsgcCA9IHY7IH07XG59XG5cbi8vIE1haW4gY29tcHJlc3Npb24gcm91dGluZSwgcGFsZXR0ZSBpbmRleGVzIC0+IExaVyBjb2RlIHN0cmVhbS5cbi8vIHxpbmRleF9zdHJlYW18IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgZW50cnkuXG5mdW5jdGlvbiBHaWZXcml0ZXJPdXRwdXRMWldDb2RlU3RyZWFtKGJ1ZiwgcCwgbWluX2NvZGVfc2l6ZSwgaW5kZXhfc3RyZWFtKSB7XG4gIGJ1ZltwKytdID0gbWluX2NvZGVfc2l6ZTtcbiAgdmFyIGN1cl9zdWJibG9jayA9IHArKzsgIC8vIFBvaW50aW5nIGF0IHRoZSBsZW5ndGggZmllbGQuXG5cbiAgdmFyIGNsZWFyX2NvZGUgPSAxIDw8IG1pbl9jb2RlX3NpemU7XG4gIHZhciBjb2RlX21hc2sgPSBjbGVhcl9jb2RlIC0gMTtcbiAgdmFyIGVvaV9jb2RlID0gY2xlYXJfY29kZSArIDE7XG4gIHZhciBuZXh0X2NvZGUgPSBlb2lfY29kZSArIDE7XG5cbiAgdmFyIGN1cl9jb2RlX3NpemUgPSBtaW5fY29kZV9zaXplICsgMTsgIC8vIE51bWJlciBvZiBiaXRzIHBlciBjb2RlLlxuICB2YXIgY3VyX3NoaWZ0ID0gMDtcbiAgLy8gV2UgaGF2ZSBhdCBtb3N0IDEyLWJpdCBjb2Rlcywgc28gd2Ugc2hvdWxkIGhhdmUgdG8gaG9sZCBhIG1heCBvZiAxOVxuICAvLyBiaXRzIGhlcmUgKGFuZCB0aGVuIHdlIHdvdWxkIHdyaXRlIG91dCkuXG4gIHZhciBjdXIgPSAwO1xuXG4gIGZ1bmN0aW9uIGVtaXRfYnl0ZXNfdG9fYnVmZmVyKGJpdF9ibG9ja19zaXplKSB7XG4gICAgd2hpbGUgKGN1cl9zaGlmdCA+PSBiaXRfYmxvY2tfc2l6ZSkge1xuICAgICAgYnVmW3ArK10gPSBjdXIgJiAweGZmO1xuICAgICAgY3VyID4+PSA4OyBjdXJfc2hpZnQgLT0gODtcbiAgICAgIGlmIChwID09PSBjdXJfc3ViYmxvY2sgKyAyNTYpIHsgIC8vIEZpbmlzaGVkIGEgc3ViYmxvY2suXG4gICAgICAgIGJ1ZltjdXJfc3ViYmxvY2tdID0gMjU1O1xuICAgICAgICBjdXJfc3ViYmxvY2sgPSBwKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdF9jb2RlKGMpIHtcbiAgICBjdXIgfD0gYyA8PCBjdXJfc2hpZnQ7XG4gICAgY3VyX3NoaWZ0ICs9IGN1cl9jb2RlX3NpemU7XG4gICAgZW1pdF9ieXRlc190b19idWZmZXIoOCk7XG4gIH1cblxuICAvLyBJIGFtIG5vdCBhbiBleHBlcnQgb24gdGhlIHRvcGljLCBhbmQgSSBkb24ndCB3YW50IHRvIHdyaXRlIGEgdGhlc2lzLlxuICAvLyBIb3dldmVyLCBpdCBpcyBnb29kIHRvIG91dGxpbmUgaGVyZSB0aGUgYmFzaWMgYWxnb3JpdGhtIGFuZCB0aGUgZmV3IGRhdGFcbiAgLy8gc3RydWN0dXJlcyBhbmQgb3B0aW1pemF0aW9ucyBoZXJlIHRoYXQgbWFrZSB0aGlzIGltcGxlbWVudGF0aW9uIGZhc3QuXG4gIC8vIFRoZSBiYXNpYyBpZGVhIGJlaGluZCBMWlcgaXMgdG8gYnVpbGQgYSB0YWJsZSBvZiBwcmV2aW91c2x5IHNlZW4gcnVuc1xuICAvLyBhZGRyZXNzZWQgYnkgYSBzaG9ydCBpZCAoaGVyZWluIGNhbGxlZCBvdXRwdXQgY29kZSkuICBBbGwgZGF0YSBpc1xuICAvLyByZWZlcmVuY2VkIGJ5IGEgY29kZSwgd2hpY2ggcmVwcmVzZW50cyBvbmUgb3IgbW9yZSB2YWx1ZXMgZnJvbSB0aGVcbiAgLy8gb3JpZ2luYWwgaW5wdXQgc3RyZWFtLiAgQWxsIGlucHV0IGJ5dGVzIGNhbiBiZSByZWZlcmVuY2VkIGFzIHRoZSBzYW1lXG4gIC8vIHZhbHVlIGFzIGFuIG91dHB1dCBjb2RlLiAgU28gaWYgeW91IGRpZG4ndCB3YW50IGFueSBjb21wcmVzc2lvbiwgeW91XG4gIC8vIGNvdWxkIG1vcmUgb3IgbGVzcyBqdXN0IG91dHB1dCB0aGUgb3JpZ2luYWwgYnl0ZXMgYXMgY29kZXMgKHRoZXJlIGFyZVxuICAvLyBzb21lIGRldGFpbHMgdG8gdGhpcywgYnV0IGl0IGlzIHRoZSBpZGVhKS4gIEluIG9yZGVyIHRvIGFjaGlldmVcbiAgLy8gY29tcHJlc3Npb24sIHZhbHVlcyBncmVhdGVyIHRoZW4gdGhlIGlucHV0IHJhbmdlIChjb2RlcyBjYW4gYmUgdXAgdG9cbiAgLy8gMTItYml0IHdoaWxlIGlucHV0IG9ubHkgOC1iaXQpIHJlcHJlc2VudCBhIHNlcXVlbmNlIG9mIHByZXZpb3VzbHkgc2VlblxuICAvLyBpbnB1dHMuICBUaGUgZGVjb21wcmVzc29yIGlzIGFibGUgdG8gYnVpbGQgdGhlIHNhbWUgbWFwcGluZyB3aGlsZVxuICAvLyBkZWNvZGluZywgc28gdGhlcmUgaXMgYWx3YXlzIGEgc2hhcmVkIGNvbW1vbiBrbm93bGVkZ2UgYmV0d2VlbiB0aGVcbiAgLy8gZW5jb2RpbmcgYW5kIGRlY29kZXIsIHdoaWNoIGlzIGFsc28gaW1wb3J0YW50IGZvciBcInRpbWluZ1wiIGFzcGVjdHMgbGlrZVxuICAvLyBob3cgdG8gaGFuZGxlIHZhcmlhYmxlIGJpdCB3aWR0aCBjb2RlIGVuY29kaW5nLlxuICAvL1xuICAvLyBPbmUgb2J2aW91cyBidXQgdmVyeSBpbXBvcnRhbnQgY29uc2VxdWVuY2Ugb2YgdGhlIHRhYmxlIHN5c3RlbSBpcyB0aGVyZVxuICAvLyBpcyBhbHdheXMgYSB1bmlxdWUgaWQgKGF0IG1vc3QgMTItYml0cykgdG8gbWFwIHRoZSBydW5zLiAgJ0EnIG1pZ2h0IGJlXG4gIC8vIDQsIHRoZW4gJ0FBJyBtaWdodCBiZSAxMCwgJ0FBQScgMTEsICdBQUFBJyAxMiwgZXRjLiAgVGhpcyByZWxhdGlvbnNoaXBcbiAgLy8gY2FuIGJlIHVzZWQgZm9yIGFuIGVmZmVjaWVudCBsb29rdXAgc3RyYXRlZ3kgZm9yIHRoZSBjb2RlIG1hcHBpbmcuICBXZVxuICAvLyBuZWVkIHRvIGtub3cgaWYgYSBydW4gaGFzIGJlZW4gc2VlbiBiZWZvcmUsIGFuZCBiZSBhYmxlIHRvIG1hcCB0aGF0IHJ1blxuICAvLyB0byB0aGUgb3V0cHV0IGNvZGUuICBTaW5jZSB3ZSBzdGFydCB3aXRoIGtub3duIHVuaXF1ZSBpZHMgKGlucHV0IGJ5dGVzKSxcbiAgLy8gYW5kIHRoZW4gZnJvbSB0aG9zZSBidWlsZCBtb3JlIHVuaXF1ZSBpZHMgKHRhYmxlIGVudHJpZXMpLCB3ZSBjYW5cbiAgLy8gY29udGludWUgdGhpcyBjaGFpbiAoYWxtb3N0IGxpa2UgYSBsaW5rZWQgbGlzdCkgdG8gYWx3YXlzIGhhdmUgc21hbGxcbiAgLy8gaW50ZWdlciB2YWx1ZXMgdGhhdCByZXByZXNlbnQgdGhlIGN1cnJlbnQgYnl0ZSBjaGFpbnMgaW4gdGhlIGVuY29kZXIuXG4gIC8vIFRoaXMgbWVhbnMgaW5zdGVhZCBvZiB0cmFja2luZyB0aGUgaW5wdXQgYnl0ZXMgKEFBQUFCQ0QpIHRvIGtub3cgb3VyXG4gIC8vIGN1cnJlbnQgc3RhdGUsIHdlIGNhbiB0cmFjayB0aGUgdGFibGUgZW50cnkgZm9yIEFBQUFCQyAoaXQgaXMgZ3VhcmFudGVlZFxuICAvLyB0byBleGlzdCBieSB0aGUgbmF0dXJlIG9mIHRoZSBhbGdvcml0aG0pIGFuZCB0aGUgbmV4dCBjaGFyYWN0ZXIgRC5cbiAgLy8gVGhlcmVmb3IgdGhlIHR1cGxlIG9mICh0YWJsZV9lbnRyeSwgYnl0ZSkgaXMgZ3VhcmFudGVlZCB0byBhbHNvIGJlXG4gIC8vIHVuaXF1ZS4gIFRoaXMgYWxsb3dzIHVzIHRvIGNyZWF0ZSBhIHNpbXBsZSBsb29rdXAga2V5IGZvciBtYXBwaW5nIGlucHV0XG4gIC8vIHNlcXVlbmNlcyB0byBjb2RlcyAodGFibGUgaW5kaWNlcykgd2l0aG91dCBoYXZpbmcgdG8gc3RvcmUgb3Igc2VhcmNoXG4gIC8vIGFueSBvZiB0aGUgY29kZSBzZXF1ZW5jZXMuICBTbyBpZiAnQUFBQScgaGFzIGEgdGFibGUgZW50cnkgb2YgMTIsIHRoZVxuICAvLyB0dXBsZSBvZiAoJ0FBQUEnLCBLKSBmb3IgYW55IGlucHV0IGJ5dGUgSyB3aWxsIGJlIHVuaXF1ZSwgYW5kIGNhbiBiZSBvdXJcbiAgLy8ga2V5LiAgVGhpcyBsZWFkcyB0byBhIGludGVnZXIgdmFsdWUgYXQgbW9zdCAyMC1iaXRzLCB3aGljaCBjYW4gYWx3YXlzXG4gIC8vIGZpdCBpbiBhbiBTTUkgdmFsdWUgYW5kIGJlIHVzZWQgYXMgYSBmYXN0IHNwYXJzZSBhcnJheSAvIG9iamVjdCBrZXkuXG5cbiAgLy8gT3V0cHV0IGNvZGUgZm9yIHRoZSBjdXJyZW50IGNvbnRlbnRzIG9mIHRoZSBpbmRleCBidWZmZXIuXG4gIHZhciBpYl9jb2RlID0gaW5kZXhfc3RyZWFtWzBdICYgY29kZV9tYXNrOyAgLy8gTG9hZCBmaXJzdCBpbnB1dCBpbmRleC5cbiAgdmFyIGNvZGVfdGFibGUgPSB7IH07ICAvLyBLZXknZCBvbiBvdXIgMjAtYml0IFwidHVwbGVcIi5cblxuICBlbWl0X2NvZGUoY2xlYXJfY29kZSk7ICAvLyBTcGVjIHNheXMgZmlyc3QgY29kZSBzaG91bGQgYmUgYSBjbGVhciBjb2RlLlxuXG4gIC8vIEZpcnN0IGluZGV4IGFscmVhZHkgbG9hZGVkLCBwcm9jZXNzIHRoZSByZXN0IG9mIHRoZSBzdHJlYW0uXG4gIGZvciAodmFyIGkgPSAxLCBpbCA9IGluZGV4X3N0cmVhbS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgdmFyIGsgPSBpbmRleF9zdHJlYW1baV0gJiBjb2RlX21hc2s7XG4gICAgdmFyIGN1cl9rZXkgPSBpYl9jb2RlIDw8IDggfCBrOyAgLy8gKHByZXYsIGspIHVuaXF1ZSB0dXBsZS5cbiAgICB2YXIgY3VyX2NvZGUgPSBjb2RlX3RhYmxlW2N1cl9rZXldOyAgLy8gYnVmZmVyICsgay5cblxuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdG8gY3JlYXRlIGEgbmV3IGNvZGUgdGFibGUgZW50cnkuXG4gICAgaWYgKGN1cl9jb2RlID09PSB1bmRlZmluZWQpIHsgIC8vIFdlIGRvbid0IGhhdmUgYnVmZmVyICsgay5cbiAgICAgIC8vIEVtaXQgaW5kZXggYnVmZmVyICh3aXRob3V0IGspLlxuICAgICAgLy8gVGhpcyBpcyBhbiBpbmxpbmUgdmVyc2lvbiBvZiBlbWl0X2NvZGUsIGJlY2F1c2UgdGhpcyBpcyB0aGUgY29yZVxuICAgICAgLy8gd3JpdGluZyByb3V0aW5lIG9mIHRoZSBjb21wcmVzc29yIChhbmQgVjggY2Fubm90IGlubGluZSBlbWl0X2NvZGVcbiAgICAgIC8vIGJlY2F1c2UgaXQgaXMgYSBjbG9zdXJlIGhlcmUgaW4gYSBkaWZmZXJlbnQgY29udGV4dCkuICBBZGRpdGlvbmFsbHlcbiAgICAgIC8vIHdlIGNhbiBjYWxsIGVtaXRfYnl0ZV90b19idWZmZXIgbGVzcyBvZnRlbiwgYmVjYXVzZSB3ZSBjYW4gaGF2ZVxuICAgICAgLy8gMzAtYml0cyAoZnJvbSBvdXIgMzEtYml0IHNpZ25lZCBTTUkpLCBhbmQgd2Uga25vdyBvdXIgY29kZXMgd2lsbCBvbmx5XG4gICAgICAvLyBiZSAxMi1iaXRzLCBzbyBjYW4gc2FmZWx5IGhhdmUgMTgtYml0cyB0aGVyZSB3aXRob3V0IG92ZXJmbG93LlxuICAgICAgLy8gZW1pdF9jb2RlKGliX2NvZGUpO1xuICAgICAgY3VyIHw9IGliX2NvZGUgPDwgY3VyX3NoaWZ0O1xuICAgICAgY3VyX3NoaWZ0ICs9IGN1cl9jb2RlX3NpemU7XG4gICAgICB3aGlsZSAoY3VyX3NoaWZ0ID49IDgpIHtcbiAgICAgICAgYnVmW3ArK10gPSBjdXIgJiAweGZmO1xuICAgICAgICBjdXIgPj49IDg7IGN1cl9zaGlmdCAtPSA4O1xuICAgICAgICBpZiAocCA9PT0gY3VyX3N1YmJsb2NrICsgMjU2KSB7ICAvLyBGaW5pc2hlZCBhIHN1YmJsb2NrLlxuICAgICAgICAgIGJ1ZltjdXJfc3ViYmxvY2tdID0gMjU1O1xuICAgICAgICAgIGN1cl9zdWJibG9jayA9IHArKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV4dF9jb2RlID09PSA0MDk2KSB7ICAvLyBUYWJsZSBmdWxsLCBuZWVkIGEgY2xlYXIuXG4gICAgICAgIGVtaXRfY29kZShjbGVhcl9jb2RlKTtcbiAgICAgICAgbmV4dF9jb2RlID0gZW9pX2NvZGUgKyAxO1xuICAgICAgICBjdXJfY29kZV9zaXplID0gbWluX2NvZGVfc2l6ZSArIDE7XG4gICAgICAgIGNvZGVfdGFibGUgPSB7IH07XG4gICAgICB9IGVsc2UgeyAgLy8gVGFibGUgbm90IGZ1bGwsIGluc2VydCBhIG5ldyBlbnRyeS5cbiAgICAgICAgLy8gSW5jcmVhc2Ugb3VyIHZhcmlhYmxlIGJpdCBjb2RlIHNpemVzIGlmIG5lY2Vzc2FyeS4gIFRoaXMgaXMgYSBiaXRcbiAgICAgICAgLy8gdHJpY2t5IGFzIGl0IGlzIGJhc2VkIG9uIFwidGltaW5nXCIgYmV0d2VlbiB0aGUgZW5jb2RpbmcgYW5kXG4gICAgICAgIC8vIGRlY29kZXIuICBGcm9tIHRoZSBlbmNvZGVycyBwZXJzcGVjdGl2ZSB0aGlzIHNob3VsZCBoYXBwZW4gYWZ0ZXJcbiAgICAgICAgLy8gd2UndmUgYWxyZWFkeSBlbWl0dGVkIHRoZSBpbmRleCBidWZmZXIgYW5kIGFyZSBhYm91dCB0byBjcmVhdGUgdGhlXG4gICAgICAgIC8vIGZpcnN0IHRhYmxlIGVudHJ5IHRoYXQgd291bGQgb3ZlcmZsb3cgb3VyIGN1cnJlbnQgY29kZSBiaXQgc2l6ZS5cbiAgICAgICAgaWYgKG5leHRfY29kZSA+PSAoMSA8PCBjdXJfY29kZV9zaXplKSkgKytjdXJfY29kZV9zaXplO1xuICAgICAgICBjb2RlX3RhYmxlW2N1cl9rZXldID0gbmV4dF9jb2RlKys7ICAvLyBJbnNlcnQgaW50byBjb2RlIHRhYmxlLlxuICAgICAgfVxuXG4gICAgICBpYl9jb2RlID0gazsgIC8vIEluZGV4IGJ1ZmZlciB0byBzaW5nbGUgaW5wdXQgay5cbiAgICB9IGVsc2Uge1xuICAgICAgaWJfY29kZSA9IGN1cl9jb2RlOyAgLy8gSW5kZXggYnVmZmVyIHRvIHNlcXVlbmNlIGluIGNvZGUgdGFibGUuXG4gICAgfVxuICB9XG5cbiAgZW1pdF9jb2RlKGliX2NvZGUpOyAgLy8gVGhlcmUgd2lsbCBzdGlsbCBiZSBzb21ldGhpbmcgaW4gdGhlIGluZGV4IGJ1ZmZlci5cbiAgZW1pdF9jb2RlKGVvaV9jb2RlKTsgIC8vIEVuZCBPZiBJbmZvcm1hdGlvbi5cblxuICAvLyBGbHVzaCAvIGZpbmFsaXplIHRoZSBzdWItYmxvY2tzIHN0cmVhbSB0byB0aGUgYnVmZmVyLlxuICBlbWl0X2J5dGVzX3RvX2J1ZmZlcigxKTtcblxuICAvLyBGaW5pc2ggdGhlIHN1Yi1ibG9ja3MsIHdyaXRpbmcgb3V0IGFueSB1bmZpbmlzaGVkIGxlbmd0aHMgYW5kXG4gIC8vIHRlcm1pbmF0aW5nIHdpdGggYSBzdWItYmxvY2sgb2YgbGVuZ3RoIDAuICBJZiB3ZSBoYXZlIGFscmVhZHkgc3RhcnRlZFxuICAvLyBidXQgbm90IHlldCB1c2VkIGEgc3ViLWJsb2NrIGl0IGNhbiBqdXN0IGJlY29tZSB0aGUgdGVybWluYXRvci5cbiAgaWYgKGN1cl9zdWJibG9jayArIDEgPT09IHApIHsgIC8vIFN0YXJ0ZWQgYnV0IHVudXNlZC5cbiAgICBidWZbY3VyX3N1YmJsb2NrXSA9IDA7XG4gIH0gZWxzZSB7ICAvLyBTdGFydGVkIGFuZCB1c2VkLCB3cml0ZSBsZW5ndGggYW5kIGFkZGl0aW9uYWwgdGVybWluYXRvciBibG9jay5cbiAgICBidWZbY3VyX3N1YmJsb2NrXSA9IHAgLSBjdXJfc3ViYmxvY2sgLSAxO1xuICAgIGJ1ZltwKytdID0gMDtcbiAgfVxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gR2lmUmVhZGVyKGJ1Zikge1xuICB2YXIgcCA9IDA7XG5cbiAgLy8gLSBIZWFkZXIgKEdJRjg3YSBvciBHSUY4OWEpLlxuICBpZiAoYnVmW3ArK10gIT09IDB4NDcgfHwgICAgICAgICAgICBidWZbcCsrXSAhPT0gMHg0OSB8fCBidWZbcCsrXSAhPT0gMHg0NiB8fFxuICAgICAgYnVmW3ArK10gIT09IDB4MzggfHwgKGJ1ZltwKytdKzEgJiAweGZkKSAhPT0gMHgzOCB8fCBidWZbcCsrXSAhPT0gMHg2MSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgR0lGIDg3YS84OWEgaGVhZGVyLlwiKTtcbiAgfVxuXG4gIC8vIC0gTG9naWNhbCBTY3JlZW4gRGVzY3JpcHRvci5cbiAgdmFyIHdpZHRoID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICB2YXIgaGVpZ2h0ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICB2YXIgcGYwID0gYnVmW3ArK107ICAvLyA8UGFja2VkIEZpZWxkcz4uXG4gIHZhciBnbG9iYWxfcGFsZXR0ZV9mbGFnID0gcGYwID4+IDc7XG4gIHZhciBudW1fZ2xvYmFsX2NvbG9yc19wb3cyID0gcGYwICYgMHg3O1xuICB2YXIgbnVtX2dsb2JhbF9jb2xvcnMgPSAxIDw8IChudW1fZ2xvYmFsX2NvbG9yc19wb3cyICsgMSk7XG4gIHZhciBiYWNrZ3JvdW5kID0gYnVmW3ArK107XG4gIGJ1ZltwKytdOyAgLy8gUGl4ZWwgYXNwZWN0IHJhdGlvICh1bnVzZWQ/KS5cblxuICB2YXIgZ2xvYmFsX3BhbGV0dGVfb2Zmc2V0ID0gbnVsbDtcbiAgdmFyIGdsb2JhbF9wYWxldHRlX3NpemUgICA9IG51bGw7XG5cbiAgaWYgKGdsb2JhbF9wYWxldHRlX2ZsYWcpIHtcbiAgICBnbG9iYWxfcGFsZXR0ZV9vZmZzZXQgPSBwO1xuICAgIGdsb2JhbF9wYWxldHRlX3NpemUgPSBudW1fZ2xvYmFsX2NvbG9ycztcbiAgICBwICs9IG51bV9nbG9iYWxfY29sb3JzICogMzsgIC8vIFNlZWsgcGFzdCBwYWxldHRlLlxuICB9XG5cbiAgdmFyIG5vX2VvZiA9IHRydWU7XG5cbiAgdmFyIGZyYW1lcyA9IFsgXTtcblxuICB2YXIgZGVsYXkgPSAwO1xuICB2YXIgdHJhbnNwYXJlbnRfaW5kZXggPSBudWxsO1xuICB2YXIgZGlzcG9zYWwgPSAwOyAgLy8gMCAtIE5vIGRpc3Bvc2FsIHNwZWNpZmllZC5cbiAgdmFyIGxvb3BfY291bnQgPSBudWxsO1xuXG4gIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgd2hpbGUgKG5vX2VvZiAmJiBwIDwgYnVmLmxlbmd0aCkge1xuICAgIHN3aXRjaCAoYnVmW3ArK10pIHtcbiAgICAgIGNhc2UgMHgyMTogIC8vIEdyYXBoaWNzIENvbnRyb2wgRXh0ZW5zaW9uIEJsb2NrXG4gICAgICAgIHN3aXRjaCAoYnVmW3ArK10pIHtcbiAgICAgICAgICBjYXNlIDB4ZmY6ICAvLyBBcHBsaWNhdGlvbiBzcGVjaWZpYyBibG9ja1xuICAgICAgICAgICAgLy8gVHJ5IGlmIGl0J3MgYSBOZXRzY2FwZSBibG9jayAod2l0aCBhbmltYXRpb24gbG9vcCBjb3VudGVyKS5cbiAgICAgICAgICAgIGlmIChidWZbcCAgIF0gIT09IDB4MGIgfHwgIC8vIDIxIEZGIGFscmVhZHkgcmVhZCwgY2hlY2sgYmxvY2sgc2l6ZS5cbiAgICAgICAgICAgICAgICAvLyBORVRTQ0FQRTIuMFxuICAgICAgICAgICAgICAgIGJ1ZltwKzEgXSA9PSAweDRlICYmIGJ1ZltwKzIgXSA9PSAweDQ1ICYmIGJ1ZltwKzMgXSA9PSAweDU0ICYmXG4gICAgICAgICAgICAgICAgYnVmW3ArNCBdID09IDB4NTMgJiYgYnVmW3ArNSBdID09IDB4NDMgJiYgYnVmW3ArNiBdID09IDB4NDEgJiZcbiAgICAgICAgICAgICAgICBidWZbcCs3IF0gPT0gMHg1MCAmJiBidWZbcCs4IF0gPT0gMHg0NSAmJiBidWZbcCs5IF0gPT0gMHgzMiAmJlxuICAgICAgICAgICAgICAgIGJ1ZltwKzEwXSA9PSAweDJlICYmIGJ1ZltwKzExXSA9PSAweDMwICYmXG4gICAgICAgICAgICAgICAgLy8gU3ViLWJsb2NrXG4gICAgICAgICAgICAgICAgYnVmW3ArMTJdID09IDB4MDMgJiYgYnVmW3ArMTNdID09IDB4MDEgJiYgYnVmW3ArMTZdID09IDApIHtcbiAgICAgICAgICAgICAgcCArPSAxNDtcbiAgICAgICAgICAgICAgbG9vcF9jb3VudCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgICAgICAgcCsrOyAgLy8gU2tpcCB0ZXJtaW5hdG9yLlxuICAgICAgICAgICAgfSBlbHNlIHsgIC8vIFdlIGRvbid0IGtub3cgd2hhdCBpdCBpcywganVzdCB0cnkgdG8gZ2V0IHBhc3QgaXQuXG4gICAgICAgICAgICAgIHAgKz0gMTI7XG4gICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7ICAvLyBTZWVrIHRocm91Z2ggc3ViYmxvY2tzLlxuICAgICAgICAgICAgICAgIHZhciBibG9ja19zaXplID0gYnVmW3ArK107XG4gICAgICAgICAgICAgICAgLy8gQmFkIGJsb2NrIHNpemUgKGV4OiB1bmRlZmluZWQgZnJvbSBhbiBvdXQgb2YgYm91bmRzIHJlYWQpLlxuICAgICAgICAgICAgICAgIGlmICghKGJsb2NrX3NpemUgPj0gMCkpIHRocm93IEVycm9yKFwiSW52YWxpZCBibG9jayBzaXplXCIpO1xuICAgICAgICAgICAgICAgIGlmIChibG9ja19zaXplID09PSAwKSBicmVhazsgIC8vIDAgc2l6ZSBpcyB0ZXJtaW5hdG9yXG4gICAgICAgICAgICAgICAgcCArPSBibG9ja19zaXplO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHhmOTogIC8vIEdyYXBoaWNzIENvbnRyb2wgRXh0ZW5zaW9uXG4gICAgICAgICAgICBpZiAoYnVmW3ArK10gIT09IDB4NCB8fCBidWZbcCs0XSAhPT0gMClcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBncmFwaGljcyBleHRlbnNpb24gYmxvY2suXCIpO1xuICAgICAgICAgICAgdmFyIHBmMSA9IGJ1ZltwKytdO1xuICAgICAgICAgICAgZGVsYXkgPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgICAgICB0cmFuc3BhcmVudF9pbmRleCA9IGJ1ZltwKytdO1xuICAgICAgICAgICAgaWYgKChwZjEgJiAxKSA9PT0gMCkgdHJhbnNwYXJlbnRfaW5kZXggPSBudWxsO1xuICAgICAgICAgICAgZGlzcG9zYWwgPSBwZjEgPj4gMiAmIDB4NztcbiAgICAgICAgICAgIHArKzsgIC8vIFNraXAgdGVybWluYXRvci5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAweGZlOiAgLy8gQ29tbWVudCBFeHRlbnNpb24uXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkgeyAgLy8gU2VlayB0aHJvdWdoIHN1YmJsb2Nrcy5cbiAgICAgICAgICAgICAgdmFyIGJsb2NrX3NpemUgPSBidWZbcCsrXTtcbiAgICAgICAgICAgICAgLy8gQmFkIGJsb2NrIHNpemUgKGV4OiB1bmRlZmluZWQgZnJvbSBhbiBvdXQgb2YgYm91bmRzIHJlYWQpLlxuICAgICAgICAgICAgICBpZiAoIShibG9ja19zaXplID49IDApKSB0aHJvdyBFcnJvcihcIkludmFsaWQgYmxvY2sgc2l6ZVwiKTtcbiAgICAgICAgICAgICAgaWYgKGJsb2NrX3NpemUgPT09IDApIGJyZWFrOyAgLy8gMCBzaXplIGlzIHRlcm1pbmF0b3JcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYnVmLnNsaWNlKHAsIHArYmxvY2tfc2l6ZSkudG9TdHJpbmcoJ2FzY2lpJykpO1xuICAgICAgICAgICAgICBwICs9IGJsb2NrX3NpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJVbmtub3duIGdyYXBoaWMgY29udHJvbCBsYWJlbDogMHhcIiArIGJ1ZltwLTFdLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMHgyYzogIC8vIEltYWdlIERlc2NyaXB0b3IuXG4gICAgICAgIHZhciB4ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICB2YXIgeSA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgdmFyIHcgPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgIHZhciBoID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICB2YXIgcGYyID0gYnVmW3ArK107XG4gICAgICAgIHZhciBsb2NhbF9wYWxldHRlX2ZsYWcgPSBwZjIgPj4gNztcbiAgICAgICAgdmFyIGludGVybGFjZV9mbGFnID0gcGYyID4+IDYgJiAxO1xuICAgICAgICB2YXIgbnVtX2xvY2FsX2NvbG9yc19wb3cyID0gcGYyICYgMHg3O1xuICAgICAgICB2YXIgbnVtX2xvY2FsX2NvbG9ycyA9IDEgPDwgKG51bV9sb2NhbF9jb2xvcnNfcG93MiArIDEpO1xuICAgICAgICB2YXIgcGFsZXR0ZV9vZmZzZXQgPSBnbG9iYWxfcGFsZXR0ZV9vZmZzZXQ7XG4gICAgICAgIHZhciBwYWxldHRlX3NpemUgPSBnbG9iYWxfcGFsZXR0ZV9zaXplO1xuICAgICAgICB2YXIgaGFzX2xvY2FsX3BhbGV0dGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGxvY2FsX3BhbGV0dGVfZmxhZykge1xuICAgICAgICAgIHZhciBoYXNfbG9jYWxfcGFsZXR0ZSA9IHRydWU7XG4gICAgICAgICAgcGFsZXR0ZV9vZmZzZXQgPSBwOyAgLy8gT3ZlcnJpZGUgd2l0aCBsb2NhbCBwYWxldHRlLlxuICAgICAgICAgIHBhbGV0dGVfc2l6ZSA9IG51bV9sb2NhbF9jb2xvcnM7XG4gICAgICAgICAgcCArPSBudW1fbG9jYWxfY29sb3JzICogMzsgIC8vIFNlZWsgcGFzdCBwYWxldHRlLlxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGFfb2Zmc2V0ID0gcDtcblxuICAgICAgICBwKys7ICAvLyBjb2Rlc2l6ZVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHZhciBibG9ja19zaXplID0gYnVmW3ArK107XG4gICAgICAgICAgLy8gQmFkIGJsb2NrIHNpemUgKGV4OiB1bmRlZmluZWQgZnJvbSBhbiBvdXQgb2YgYm91bmRzIHJlYWQpLlxuICAgICAgICAgIGlmICghKGJsb2NrX3NpemUgPj0gMCkpIHRocm93IEVycm9yKFwiSW52YWxpZCBibG9jayBzaXplXCIpO1xuICAgICAgICAgIGlmIChibG9ja19zaXplID09PSAwKSBicmVhazsgIC8vIDAgc2l6ZSBpcyB0ZXJtaW5hdG9yXG4gICAgICAgICAgcCArPSBibG9ja19zaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgZnJhbWVzLnB1c2goe3g6IHgsIHk6IHksIHdpZHRoOiB3LCBoZWlnaHQ6IGgsXG4gICAgICAgICAgICAgICAgICAgICBoYXNfbG9jYWxfcGFsZXR0ZTogaGFzX2xvY2FsX3BhbGV0dGUsXG4gICAgICAgICAgICAgICAgICAgICBwYWxldHRlX29mZnNldDogcGFsZXR0ZV9vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICBwYWxldHRlX3NpemU6IHBhbGV0dGVfc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgIGRhdGFfb2Zmc2V0OiBkYXRhX29mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgIGRhdGFfbGVuZ3RoOiBwIC0gZGF0YV9vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVudF9pbmRleDogdHJhbnNwYXJlbnRfaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICBpbnRlcmxhY2VkOiAhIWludGVybGFjZV9mbGFnLFxuICAgICAgICAgICAgICAgICAgICAgZGVsYXk6IGRlbGF5LFxuICAgICAgICAgICAgICAgICAgICAgZGlzcG9zYWw6IGRpc3Bvc2FsfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDB4M2I6ICAvLyBUcmFpbGVyIE1hcmtlciAoZW5kIG9mIGZpbGUpLlxuICAgICAgICBub19lb2YgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZ2lmIGJsb2NrOiAweFwiICsgYnVmW3AtMV0udG9TdHJpbmcoMTYpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5udW1GcmFtZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnJhbWVzLmxlbmd0aDtcbiAgfTtcblxuICB0aGlzLmxvb3BDb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBsb29wX2NvdW50O1xuICB9O1xuXG4gIHRoaXMuZnJhbWVJbmZvID0gZnVuY3Rpb24oZnJhbWVfbnVtKSB7XG4gICAgaWYgKGZyYW1lX251bSA8IDAgfHwgZnJhbWVfbnVtID49IGZyYW1lcy5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGcmFtZSBpbmRleCBvdXQgb2YgcmFuZ2UuXCIpO1xuICAgIHJldHVybiBmcmFtZXNbZnJhbWVfbnVtXTtcbiAgfVxuXG4gIHRoaXMuZGVjb2RlQW5kQmxpdEZyYW1lQkdSQSA9IGZ1bmN0aW9uKGZyYW1lX251bSwgcGl4ZWxzKSB7XG4gICAgdmFyIGZyYW1lID0gdGhpcy5mcmFtZUluZm8oZnJhbWVfbnVtKTtcbiAgICB2YXIgbnVtX3BpeGVscyA9IGZyYW1lLndpZHRoICogZnJhbWUuaGVpZ2h0O1xuICAgIHZhciBpbmRleF9zdHJlYW0gPSBuZXcgVWludDhBcnJheShudW1fcGl4ZWxzKTsgIC8vIEF0IG1vc3QgOC1iaXQgaW5kaWNlcy5cbiAgICBHaWZSZWFkZXJMWldPdXRwdXRJbmRleFN0cmVhbShcbiAgICAgICAgYnVmLCBmcmFtZS5kYXRhX29mZnNldCwgaW5kZXhfc3RyZWFtLCBudW1fcGl4ZWxzKTtcbiAgICB2YXIgcGFsZXR0ZV9vZmZzZXQgPSBmcmFtZS5wYWxldHRlX29mZnNldDtcblxuICAgIC8vIE5PVEUoZGVhbm0pOiBJdCBzZWVtcyB0byBiZSBtdWNoIGZhc3RlciB0byBjb21wYXJlIGluZGV4IHRvIDI1NiB0aGFuXG4gICAgLy8gdG8gPT09IG51bGwuICBOb3Qgc3VyZSB3aHksIGJ1dCBDb21wYXJlU3R1Yl9FUV9TVFJJQ1Qgc2hvd3MgdXAgaGlnaCBpblxuICAgIC8vIHRoZSBwcm9maWxlLCBub3Qgc3VyZSBpZiBpdCdzIHJlbGF0ZWQgdG8gdXNpbmcgYSBVaW50OEFycmF5LlxuICAgIHZhciB0cmFucyA9IGZyYW1lLnRyYW5zcGFyZW50X2luZGV4O1xuICAgIGlmICh0cmFucyA9PT0gbnVsbCkgdHJhbnMgPSAyNTY7XG5cbiAgICAvLyBXZSBhcmUgcG9zc2libHkganVzdCBibGl0dGluZyB0byBhIHBvcnRpb24gb2YgdGhlIGVudGlyZSBmcmFtZS5cbiAgICAvLyBUaGF0IGlzIGEgc3VicmVjdCB3aXRoaW4gdGhlIGZyYW1lcmVjdCwgc28gdGhlIGFkZGl0aW9uYWwgcGl4ZWxzXG4gICAgLy8gbXVzdCBiZSBza2lwcGVkIG92ZXIgYWZ0ZXIgd2UgZmluaXNoZWQgYSBzY2FubGluZS5cbiAgICB2YXIgZnJhbWV3aWR0aCAgPSBmcmFtZS53aWR0aDtcbiAgICB2YXIgZnJhbWVzdHJpZGUgPSB3aWR0aCAtIGZyYW1ld2lkdGg7XG4gICAgdmFyIHhsZWZ0ICAgICAgID0gZnJhbWV3aWR0aDsgIC8vIE51bWJlciBvZiBzdWJyZWN0IHBpeGVscyBsZWZ0IGluIHNjYW5saW5lLlxuXG4gICAgLy8gT3V0cHV0IGluZGljaWVzIG9mIHRoZSB0b3AgbGVmdCBhbmQgYm90dG9tIHJpZ2h0IGNvcm5lcnMgb2YgdGhlIHN1YnJlY3QuXG4gICAgdmFyIG9wYmVnID0gKChmcmFtZS55ICogd2lkdGgpICsgZnJhbWUueCkgKiA0O1xuICAgIHZhciBvcGVuZCA9ICgoZnJhbWUueSArIGZyYW1lLmhlaWdodCkgKiB3aWR0aCArIGZyYW1lLngpICogNDtcbiAgICB2YXIgb3AgICAgPSBvcGJlZztcblxuICAgIHZhciBzY2Fuc3RyaWRlID0gZnJhbWVzdHJpZGUgKiA0O1xuXG4gICAgLy8gVXNlIHNjYW5zdHJpZGUgdG8gc2tpcCBwYXN0IHRoZSByb3dzIHdoZW4gaW50ZXJsYWNpbmcuICBUaGlzIGlzIHNraXBwaW5nXG4gICAgLy8gNyByb3dzIGZvciB0aGUgZmlyc3QgdHdvIHBhc3NlcywgdGhlbiAzIHRoZW4gMS5cbiAgICBpZiAoZnJhbWUuaW50ZXJsYWNlZCA9PT0gdHJ1ZSkge1xuICAgICAgc2NhbnN0cmlkZSArPSB3aWR0aCAqIDQgKiA3OyAgLy8gUGFzcyAxLlxuICAgIH1cblxuICAgIHZhciBpbnRlcmxhY2Vza2lwID0gODsgIC8vIFRyYWNraW5nIHRoZSByb3cgaW50ZXJ2YWwgaW4gdGhlIGN1cnJlbnQgcGFzcy5cblxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGluZGV4X3N0cmVhbS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICB2YXIgaW5kZXggPSBpbmRleF9zdHJlYW1baV07XG5cbiAgICAgIGlmICh4bGVmdCA9PT0gMCkgeyAgLy8gQmVnaW5uaW5nIG9mIG5ldyBzY2FuIGxpbmVcbiAgICAgICAgb3AgKz0gc2NhbnN0cmlkZTtcbiAgICAgICAgeGxlZnQgPSBmcmFtZXdpZHRoO1xuICAgICAgICBpZiAob3AgPj0gb3BlbmQpIHsgLy8gQ2F0Y2ggdGhlIHdyYXAgdG8gc3dpdGNoIHBhc3NlcyB3aGVuIGludGVybGFjaW5nLlxuICAgICAgICAgIHNjYW5zdHJpZGUgPSBmcmFtZXN0cmlkZSAqIDQgKyB3aWR0aCAqIDQgKiAoaW50ZXJsYWNlc2tpcC0xKTtcbiAgICAgICAgICAvLyBpbnRlcmxhY2Vza2lwIC8gMiAqIDQgaXMgaW50ZXJsYWNlc2tpcCA8PCAxLlxuICAgICAgICAgIG9wID0gb3BiZWcgKyAoZnJhbWV3aWR0aCArIGZyYW1lc3RyaWRlKSAqIChpbnRlcmxhY2Vza2lwIDw8IDEpO1xuICAgICAgICAgIGludGVybGFjZXNraXAgPj49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID09PSB0cmFucykge1xuICAgICAgICBvcCArPSA0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHIgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDNdO1xuICAgICAgICB2YXIgZyA9IGJ1ZltwYWxldHRlX29mZnNldCArIGluZGV4ICogMyArIDFdO1xuICAgICAgICB2YXIgYiA9IGJ1ZltwYWxldHRlX29mZnNldCArIGluZGV4ICogMyArIDJdO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSBiO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSBnO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSByO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSAyNTU7XG4gICAgICB9XG4gICAgICAtLXhsZWZ0O1xuICAgIH1cbiAgfTtcblxuICAvLyBJIHdpbGwgZ28gdG8gY29weSBhbmQgcGFzdGUgaGVsbCBvbmUgZGF5Li4uXG4gIHRoaXMuZGVjb2RlQW5kQmxpdEZyYW1lUkdCQSA9IGZ1bmN0aW9uKGZyYW1lX251bSwgcGl4ZWxzKSB7XG4gICAgdmFyIGZyYW1lID0gdGhpcy5mcmFtZUluZm8oZnJhbWVfbnVtKTtcbiAgICB2YXIgbnVtX3BpeGVscyA9IGZyYW1lLndpZHRoICogZnJhbWUuaGVpZ2h0O1xuICAgIHZhciBpbmRleF9zdHJlYW0gPSBuZXcgVWludDhBcnJheShudW1fcGl4ZWxzKTsgIC8vIEF0IG1vc3QgOC1iaXQgaW5kaWNlcy5cbiAgICBHaWZSZWFkZXJMWldPdXRwdXRJbmRleFN0cmVhbShcbiAgICAgICAgYnVmLCBmcmFtZS5kYXRhX29mZnNldCwgaW5kZXhfc3RyZWFtLCBudW1fcGl4ZWxzKTtcbiAgICB2YXIgcGFsZXR0ZV9vZmZzZXQgPSBmcmFtZS5wYWxldHRlX29mZnNldDtcblxuICAgIC8vIE5PVEUoZGVhbm0pOiBJdCBzZWVtcyB0byBiZSBtdWNoIGZhc3RlciB0byBjb21wYXJlIGluZGV4IHRvIDI1NiB0aGFuXG4gICAgLy8gdG8gPT09IG51bGwuICBOb3Qgc3VyZSB3aHksIGJ1dCBDb21wYXJlU3R1Yl9FUV9TVFJJQ1Qgc2hvd3MgdXAgaGlnaCBpblxuICAgIC8vIHRoZSBwcm9maWxlLCBub3Qgc3VyZSBpZiBpdCdzIHJlbGF0ZWQgdG8gdXNpbmcgYSBVaW50OEFycmF5LlxuICAgIHZhciB0cmFucyA9IGZyYW1lLnRyYW5zcGFyZW50X2luZGV4O1xuICAgIGlmICh0cmFucyA9PT0gbnVsbCkgdHJhbnMgPSAyNTY7XG5cbiAgICAvLyBXZSBhcmUgcG9zc2libHkganVzdCBibGl0dGluZyB0byBhIHBvcnRpb24gb2YgdGhlIGVudGlyZSBmcmFtZS5cbiAgICAvLyBUaGF0IGlzIGEgc3VicmVjdCB3aXRoaW4gdGhlIGZyYW1lcmVjdCwgc28gdGhlIGFkZGl0aW9uYWwgcGl4ZWxzXG4gICAgLy8gbXVzdCBiZSBza2lwcGVkIG92ZXIgYWZ0ZXIgd2UgZmluaXNoZWQgYSBzY2FubGluZS5cbiAgICB2YXIgZnJhbWV3aWR0aCAgPSBmcmFtZS53aWR0aDtcbiAgICB2YXIgZnJhbWVzdHJpZGUgPSB3aWR0aCAtIGZyYW1ld2lkdGg7XG4gICAgdmFyIHhsZWZ0ICAgICAgID0gZnJhbWV3aWR0aDsgIC8vIE51bWJlciBvZiBzdWJyZWN0IHBpeGVscyBsZWZ0IGluIHNjYW5saW5lLlxuXG4gICAgLy8gT3V0cHV0IGluZGljaWVzIG9mIHRoZSB0b3AgbGVmdCBhbmQgYm90dG9tIHJpZ2h0IGNvcm5lcnMgb2YgdGhlIHN1YnJlY3QuXG4gICAgdmFyIG9wYmVnID0gKChmcmFtZS55ICogd2lkdGgpICsgZnJhbWUueCkgKiA0O1xuICAgIHZhciBvcGVuZCA9ICgoZnJhbWUueSArIGZyYW1lLmhlaWdodCkgKiB3aWR0aCArIGZyYW1lLngpICogNDtcbiAgICB2YXIgb3AgICAgPSBvcGJlZztcblxuICAgIHZhciBzY2Fuc3RyaWRlID0gZnJhbWVzdHJpZGUgKiA0O1xuXG4gICAgLy8gVXNlIHNjYW5zdHJpZGUgdG8gc2tpcCBwYXN0IHRoZSByb3dzIHdoZW4gaW50ZXJsYWNpbmcuICBUaGlzIGlzIHNraXBwaW5nXG4gICAgLy8gNyByb3dzIGZvciB0aGUgZmlyc3QgdHdvIHBhc3NlcywgdGhlbiAzIHRoZW4gMS5cbiAgICBpZiAoZnJhbWUuaW50ZXJsYWNlZCA9PT0gdHJ1ZSkge1xuICAgICAgc2NhbnN0cmlkZSArPSB3aWR0aCAqIDQgKiA3OyAgLy8gUGFzcyAxLlxuICAgIH1cblxuICAgIHZhciBpbnRlcmxhY2Vza2lwID0gODsgIC8vIFRyYWNraW5nIHRoZSByb3cgaW50ZXJ2YWwgaW4gdGhlIGN1cnJlbnQgcGFzcy5cblxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGluZGV4X3N0cmVhbS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICB2YXIgaW5kZXggPSBpbmRleF9zdHJlYW1baV07XG5cbiAgICAgIGlmICh4bGVmdCA9PT0gMCkgeyAgLy8gQmVnaW5uaW5nIG9mIG5ldyBzY2FuIGxpbmVcbiAgICAgICAgb3AgKz0gc2NhbnN0cmlkZTtcbiAgICAgICAgeGxlZnQgPSBmcmFtZXdpZHRoO1xuICAgICAgICBpZiAob3AgPj0gb3BlbmQpIHsgLy8gQ2F0Y2ggdGhlIHdyYXAgdG8gc3dpdGNoIHBhc3NlcyB3aGVuIGludGVybGFjaW5nLlxuICAgICAgICAgIHNjYW5zdHJpZGUgPSBmcmFtZXN0cmlkZSAqIDQgKyB3aWR0aCAqIDQgKiAoaW50ZXJsYWNlc2tpcC0xKTtcbiAgICAgICAgICAvLyBpbnRlcmxhY2Vza2lwIC8gMiAqIDQgaXMgaW50ZXJsYWNlc2tpcCA8PCAxLlxuICAgICAgICAgIG9wID0gb3BiZWcgKyAoZnJhbWV3aWR0aCArIGZyYW1lc3RyaWRlKSAqIChpbnRlcmxhY2Vza2lwIDw8IDEpO1xuICAgICAgICAgIGludGVybGFjZXNraXAgPj49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID09PSB0cmFucykge1xuICAgICAgICBvcCArPSA0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHIgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDNdO1xuICAgICAgICB2YXIgZyA9IGJ1ZltwYWxldHRlX29mZnNldCArIGluZGV4ICogMyArIDFdO1xuICAgICAgICB2YXIgYiA9IGJ1ZltwYWxldHRlX29mZnNldCArIGluZGV4ICogMyArIDJdO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSByO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSBnO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSBiO1xuICAgICAgICBwaXhlbHNbb3ArK10gPSAyNTU7XG4gICAgICB9XG4gICAgICAtLXhsZWZ0O1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gR2lmUmVhZGVyTFpXT3V0cHV0SW5kZXhTdHJlYW0oY29kZV9zdHJlYW0sIHAsIG91dHB1dCwgb3V0cHV0X2xlbmd0aCkge1xuICB2YXIgbWluX2NvZGVfc2l6ZSA9IGNvZGVfc3RyZWFtW3ArK107XG5cbiAgdmFyIGNsZWFyX2NvZGUgPSAxIDw8IG1pbl9jb2RlX3NpemU7XG4gIHZhciBlb2lfY29kZSA9IGNsZWFyX2NvZGUgKyAxO1xuICB2YXIgbmV4dF9jb2RlID0gZW9pX2NvZGUgKyAxO1xuXG4gIHZhciBjdXJfY29kZV9zaXplID0gbWluX2NvZGVfc2l6ZSArIDE7ICAvLyBOdW1iZXIgb2YgYml0cyBwZXIgY29kZS5cbiAgLy8gTk9URTogVGhpcyBzaGFyZXMgdGhlIHNhbWUgbmFtZSBhcyB0aGUgZW5jb2RlciwgYnV0IGhhcyBhIGRpZmZlcmVudFxuICAvLyBtZWFuaW5nIGhlcmUuICBIZXJlIHRoaXMgbWFza3MgZWFjaCBjb2RlIGNvbWluZyBmcm9tIHRoZSBjb2RlIHN0cmVhbS5cbiAgdmFyIGNvZGVfbWFzayA9ICgxIDw8IGN1cl9jb2RlX3NpemUpIC0gMTtcbiAgdmFyIGN1cl9zaGlmdCA9IDA7XG4gIHZhciBjdXIgPSAwO1xuXG4gIHZhciBvcCA9IDA7ICAvLyBPdXRwdXQgcG9pbnRlci5cblxuICB2YXIgc3ViYmxvY2tfc2l6ZSA9IGNvZGVfc3RyZWFtW3ArK107XG5cbiAgLy8gVE9ETyhkZWFubSk6IFdvdWxkIHVzaW5nIGEgVHlwZWRBcnJheSBiZSBhbnkgZmFzdGVyPyAgQXQgbGVhc3QgaXQgd291bGRcbiAgLy8gc29sdmUgdGhlIGZhc3QgbW9kZSAvIGJhY2tpbmcgc3RvcmUgdW5jZXJ0YWludHkuXG4gIC8vIHZhciBjb2RlX3RhYmxlID0gQXJyYXkoNDA5Nik7XG4gIHZhciBjb2RlX3RhYmxlID0gbmV3IEludDMyQXJyYXkoNDA5Nik7ICAvLyBDYW4gYmUgc2lnbmVkLCB3ZSBvbmx5IHVzZSAyMCBiaXRzLlxuXG4gIHZhciBwcmV2X2NvZGUgPSBudWxsOyAgLy8gVHJhY2sgY29kZS0xLlxuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gUmVhZCB1cCB0byB0d28gYnl0ZXMsIG1ha2luZyBzdXJlIHdlIGFsd2F5cyAxMi1iaXRzIGZvciBtYXggc2l6ZWQgY29kZS5cbiAgICB3aGlsZSAoY3VyX3NoaWZ0IDwgMTYpIHtcbiAgICAgIGlmIChzdWJibG9ja19zaXplID09PSAwKSBicmVhazsgIC8vIE5vIG1vcmUgZGF0YSB0byBiZSByZWFkLlxuXG4gICAgICBjdXIgfD0gY29kZV9zdHJlYW1bcCsrXSA8PCBjdXJfc2hpZnQ7XG4gICAgICBjdXJfc2hpZnQgKz0gODtcblxuICAgICAgaWYgKHN1YmJsb2NrX3NpemUgPT09IDEpIHsgIC8vIE5ldmVyIGxldCBpdCBnZXQgdG8gMCB0byBob2xkIGxvZ2ljIGFib3ZlLlxuICAgICAgICBzdWJibG9ja19zaXplID0gY29kZV9zdHJlYW1bcCsrXTsgIC8vIE5leHQgc3ViYmxvY2suXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAtLXN1YmJsb2NrX3NpemU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETyhkZWFubSk6IFdlIHNob3VsZCBuZXZlciByZWFsbHkgZ2V0IGhlcmUsIHdlIHNob3VsZCBoYXZlIHJlY2VpdmVkXG4gICAgLy8gYW5kIEVPSS5cbiAgICBpZiAoY3VyX3NoaWZ0IDwgY3VyX2NvZGVfc2l6ZSlcbiAgICAgIGJyZWFrO1xuXG4gICAgdmFyIGNvZGUgPSBjdXIgJiBjb2RlX21hc2s7XG4gICAgY3VyID4+PSBjdXJfY29kZV9zaXplO1xuICAgIGN1cl9zaGlmdCAtPSBjdXJfY29kZV9zaXplO1xuXG4gICAgLy8gVE9ETyhkZWFubSk6IE1heWJlIHNob3VsZCBjaGVjayB0aGF0IHRoZSBmaXJzdCBjb2RlIHdhcyBhIGNsZWFyIGNvZGUsXG4gICAgLy8gYXQgbGVhc3QgdGhpcyBpcyB3aGF0IHlvdSdyZSBzdXBwb3NlZCB0byBkby4gIEJ1dCBhY3R1YWxseSBvdXIgZW5jb2RlclxuICAgIC8vIG5vdyBkb2Vzbid0IGVtaXQgYSBjbGVhciBjb2RlIGZpcnN0IGFueXdheS5cbiAgICBpZiAoY29kZSA9PT0gY2xlYXJfY29kZSkge1xuICAgICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgaGF2ZSB0byBjbGVhciB0aGUgdGFibGUuICBUaGlzIGNvdWxkIGJlIGEgZ29vZCBpZGVhXG4gICAgICAvLyBmb3IgZ3JlYXRlciBlcnJvciBjaGVja2luZywgYnV0IHdlIGRvbid0IHJlYWxseSBkbyBhbnkgYW55d2F5LiAgV2VcbiAgICAgIC8vIHdpbGwganVzdCB0cmFjayBpdCB3aXRoIG5leHRfY29kZSBhbmQgb3ZlcndyaXRlIG9sZCBlbnRyaWVzLlxuXG4gICAgICBuZXh0X2NvZGUgPSBlb2lfY29kZSArIDE7XG4gICAgICBjdXJfY29kZV9zaXplID0gbWluX2NvZGVfc2l6ZSArIDE7XG4gICAgICBjb2RlX21hc2sgPSAoMSA8PCBjdXJfY29kZV9zaXplKSAtIDE7XG5cbiAgICAgIC8vIERvbid0IHVwZGF0ZSBwcmV2X2NvZGUgP1xuICAgICAgcHJldl9jb2RlID0gbnVsbDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gZW9pX2NvZGUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFdlIGhhdmUgYSBzaW1pbGFyIHNpdHVhdGlvbiBhcyB0aGUgZGVjb2Rlciwgd2hlcmUgd2Ugd2FudCB0byBzdG9yZVxuICAgIC8vIHZhcmlhYmxlIGxlbmd0aCBlbnRyaWVzIChjb2RlIHRhYmxlIGVudHJpZXMpLCBidXQgd2Ugd2FudCB0byBkbyBpbiBhXG4gICAgLy8gZmFzdGVyIG1hbm5lciB0aGFuIGFuIGFycmF5IG9mIGFycmF5cy4gIFRoZSBjb2RlIGJlbG93IHN0b3JlcyBzb3J0IG9mIGFcbiAgICAvLyBsaW5rZWQgbGlzdCB3aXRoaW4gdGhlIGNvZGUgdGFibGUsIGFuZCB0aGVuIFwiY2hhc2VzXCIgdGhyb3VnaCBpdCB0b1xuICAgIC8vIGNvbnN0cnVjdCB0aGUgZGljdGlvbmFyeSBlbnRyaWVzLiAgV2hlbiBhIG5ldyBlbnRyeSBpcyBjcmVhdGVkLCBqdXN0IHRoZVxuICAgIC8vIGxhc3QgYnl0ZSBpcyBzdG9yZWQsIGFuZCB0aGUgcmVzdCAocHJlZml4KSBvZiB0aGUgZW50cnkgaXMgb25seVxuICAgIC8vIHJlZmVyZW5jZWQgYnkgaXRzIHRhYmxlIGVudHJ5LiAgVGhlbiB0aGUgY29kZSBjaGFzZXMgdGhyb3VnaCB0aGVcbiAgICAvLyBwcmVmaXhlcyB1bnRpbCBpdCByZWFjaGVzIGEgc2luZ2xlIGJ5dGUgY29kZS4gIFdlIGhhdmUgdG8gY2hhc2UgdHdpY2UsXG4gICAgLy8gZmlyc3QgdG8gY29tcHV0ZSB0aGUgbGVuZ3RoLCBhbmQgdGhlbiB0byBhY3R1YWxseSBjb3B5IHRoZSBkYXRhIHRvIHRoZVxuICAgIC8vIG91dHB1dCAoYmFja3dhcmRzLCBzaW5jZSB3ZSBrbm93IHRoZSBsZW5ndGgpLiAgVGhlIGFsdGVybmF0aXZlIHdvdWxkIGJlXG4gICAgLy8gc3RvcmluZyBzb21ldGhpbmcgaW4gYW4gaW50ZXJtZWRpYXRlIHN0YWNrLCBidXQgdGhhdCBkb2Vzbid0IG1ha2UgYW55XG4gICAgLy8gbW9yZSBzZW5zZS4gIEkgaW1wbGVtZW50ZWQgYW4gYXBwcm9hY2ggd2hlcmUgaXQgYWxzbyBzdG9yZWQgdGhlIGxlbmd0aFxuICAgIC8vIGluIHRoZSBjb2RlIHRhYmxlLCBhbHRob3VnaCBpdCdzIGEgYml0IHRyaWNreSBiZWNhdXNlIHlvdSBydW4gb3V0IG9mXG4gICAgLy8gYml0cyAoMTIgKyAxMiArIDgpLCBidXQgSSBkaWRuJ3QgbWVhc3VyZSBtdWNoIGltcHJvdmVtZW50cyAodGhlIHRhYmxlXG4gICAgLy8gZW50cmllcyBhcmUgZ2VuZXJhbGx5IG5vdCB0aGUgbG9uZykuICBFdmVuIHdoZW4gSSBjcmVhdGVkIGJlbmNobWFya3MgZm9yXG4gICAgLy8gdmVyeSBsb25nIHRhYmxlIGVudHJpZXMgdGhlIGNvbXBsZXhpdHkgZGlkIG5vdCBzZWVtIHdvcnRoIGl0LlxuICAgIC8vIFRoZSBjb2RlIHRhYmxlIHN0b3JlcyB0aGUgcHJlZml4IGVudHJ5IGluIDEyIGJpdHMgYW5kIHRoZW4gdGhlIHN1ZmZpeFxuICAgIC8vIGJ5dGUgaW4gOCBiaXRzLCBzbyBlYWNoIGVudHJ5IGlzIDIwIGJpdHMuXG5cbiAgICB2YXIgY2hhc2VfY29kZSA9IGNvZGUgPCBuZXh0X2NvZGUgPyBjb2RlIDogcHJldl9jb2RlO1xuXG4gICAgLy8gQ2hhc2Ugd2hhdCB3ZSB3aWxsIG91dHB1dCwgZWl0aGVyIHtDT0RFfSBvciB7Q09ERS0xfS5cbiAgICB2YXIgY2hhc2VfbGVuZ3RoID0gMDtcbiAgICB2YXIgY2hhc2UgPSBjaGFzZV9jb2RlO1xuICAgIHdoaWxlIChjaGFzZSA+IGNsZWFyX2NvZGUpIHtcbiAgICAgIGNoYXNlID0gY29kZV90YWJsZVtjaGFzZV0gPj4gODtcbiAgICAgICsrY2hhc2VfbGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciBrID0gY2hhc2U7XG5cbiAgICB2YXIgb3BfZW5kID0gb3AgKyBjaGFzZV9sZW5ndGggKyAoY2hhc2VfY29kZSAhPT0gY29kZSA/IDEgOiAwKTtcbiAgICBpZiAob3BfZW5kID4gb3V0cHV0X2xlbmd0aCkge1xuICAgICAgY29uc29sZS5sb2coXCJXYXJuaW5nLCBnaWYgc3RyZWFtIGxvbmdlciB0aGFuIGV4cGVjdGVkLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBbHJlYWR5IGhhdmUgdGhlIGZpcnN0IGJ5dGUgZnJvbSB0aGUgY2hhc2UsIG1pZ2h0IGFzIHdlbGwgd3JpdGUgaXQgZmFzdC5cbiAgICBvdXRwdXRbb3ArK10gPSBrO1xuXG4gICAgb3AgKz0gY2hhc2VfbGVuZ3RoO1xuICAgIHZhciBiID0gb3A7ICAvLyBUcmFjayBwb2ludGVyLCB3cml0aW5nIGJhY2t3YXJkcy5cblxuICAgIGlmIChjaGFzZV9jb2RlICE9PSBjb2RlKSAgLy8gVGhlIGNhc2Ugb2YgZW1pdHRpbmcge0NPREUtMX0gKyBrLlxuICAgICAgb3V0cHV0W29wKytdID0gaztcblxuICAgIGNoYXNlID0gY2hhc2VfY29kZTtcbiAgICB3aGlsZSAoY2hhc2VfbGVuZ3RoLS0pIHtcbiAgICAgIGNoYXNlID0gY29kZV90YWJsZVtjaGFzZV07XG4gICAgICBvdXRwdXRbLS1iXSA9IGNoYXNlICYgMHhmZjsgIC8vIFdyaXRlIGJhY2t3YXJkcy5cbiAgICAgIGNoYXNlID4+PSA4OyAgLy8gUHVsbCBkb3duIHRvIHRoZSBwcmVmaXggY29kZS5cbiAgICB9XG5cbiAgICBpZiAocHJldl9jb2RlICE9PSBudWxsICYmIG5leHRfY29kZSA8IDQwOTYpIHtcbiAgICAgIGNvZGVfdGFibGVbbmV4dF9jb2RlKytdID0gcHJldl9jb2RlIDw8IDggfCBrO1xuICAgICAgLy8gVE9ETyhkZWFubSk6IEZpZ3VyZSBvdXQgdGhpcyBjbGVhcmluZyB2cyBjb2RlIGdyb3d0aCBsb2dpYyBiZXR0ZXIuICBJXG4gICAgICAvLyBoYXZlIGFuIGZlZWxpbmcgdGhhdCBpdCBzaG91bGQganVzdCBoYXBwZW4gc29tZXdoZXJlIGVsc2UsIGZvciBub3cgaXRcbiAgICAgIC8vIGlzIGF3a3dhcmQgYmV0d2VlbiB3aGVuIHdlIGdyb3cgcGFzdCB0aGUgbWF4IGFuZCB0aGVuIGhpdCBhIGNsZWFyIGNvZGUuXG4gICAgICAvLyBGb3Igbm93IGp1c3QgY2hlY2sgaWYgd2UgaGl0IHRoZSBtYXggMTItYml0cyAodGhlbiBhIGNsZWFyIGNvZGUgc2hvdWxkXG4gICAgICAvLyBmb2xsb3csIGFsc28gb2YgY291cnNlIGVuY29kZWQgaW4gMTItYml0cykuXG4gICAgICBpZiAobmV4dF9jb2RlID49IGNvZGVfbWFzaysxICYmIGN1cl9jb2RlX3NpemUgPCAxMikge1xuICAgICAgICArK2N1cl9jb2RlX3NpemU7XG4gICAgICAgIGNvZGVfbWFzayA9IGNvZGVfbWFzayA8PCAxIHwgMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcmV2X2NvZGUgPSBjb2RlO1xuICB9XG5cbiAgaWYgKG9wICE9PSBvdXRwdXRfbGVuZ3RoKSB7XG4gICAgY29uc29sZS5sb2coXCJXYXJuaW5nLCBnaWYgc3RyZWFtIHNob3J0ZXIgdGhhbiBleHBlY3RlZC5cIik7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vLyBDb21tb25KUy5cbnRyeSB7IGV4cG9ydHMuR2lmV3JpdGVyID0gR2lmV3JpdGVyOyBleHBvcnRzLkdpZlJlYWRlciA9IEdpZlJlYWRlciB9IGNhdGNoKGUpIHt9XG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgbmRhcnJheSA9IHJlcXVpcmUoXCJuZGFycmF5XCIpXG52YXIgZG9fY29udmVydCA9IHJlcXVpcmUoXCIuL2RvQ29udmVydC5qc1wiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbnZlcnQoYXJyLCByZXN1bHQpIHtcbiAgdmFyIHNoYXBlID0gW10sIGMgPSBhcnIsIHN6ID0gMVxuICB3aGlsZShBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgc2hhcGUucHVzaChjLmxlbmd0aClcbiAgICBzeiAqPSBjLmxlbmd0aFxuICAgIGMgPSBjWzBdXG4gIH1cbiAgaWYoc2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5kYXJyYXkoKVxuICB9XG4gIGlmKCFyZXN1bHQpIHtcbiAgICByZXN1bHQgPSBuZGFycmF5KG5ldyBGbG9hdDY0QXJyYXkoc3opLCBzaGFwZSlcbiAgfVxuICBkb19jb252ZXJ0KHJlc3VsdCwgYXJyKVxuICByZXR1cm4gcmVzdWx0XG59XG4iLCJtb2R1bGUuZXhwb3J0cz1yZXF1aXJlKCdjd2lzZS1jb21waWxlcicpKHtcImFyZ3NcIjpbXCJhcnJheVwiLFwic2NhbGFyXCIsXCJpbmRleFwiXSxcInByZVwiOntcImJvZHlcIjpcInt9XCIsXCJhcmdzXCI6W10sXCJ0aGlzVmFyc1wiOltdLFwibG9jYWxWYXJzXCI6W119LFwiYm9keVwiOntcImJvZHlcIjpcIntcXG52YXIgX2lubGluZV8xX3Y9X2lubGluZV8xX2FyZzFfLF9pbmxpbmVfMV9pXFxuZm9yKF9pbmxpbmVfMV9pPTA7X2lubGluZV8xX2k8X2lubGluZV8xX2FyZzJfLmxlbmd0aC0xOysrX2lubGluZV8xX2kpIHtcXG5faW5saW5lXzFfdj1faW5saW5lXzFfdltfaW5saW5lXzFfYXJnMl9bX2lubGluZV8xX2ldXVxcbn1cXG5faW5saW5lXzFfYXJnMF89X2lubGluZV8xX3ZbX2lubGluZV8xX2FyZzJfW19pbmxpbmVfMV9hcmcyXy5sZW5ndGgtMV1dXFxufVwiLFwiYXJnc1wiOlt7XCJuYW1lXCI6XCJfaW5saW5lXzFfYXJnMF9cIixcImx2YWx1ZVwiOnRydWUsXCJydmFsdWVcIjpmYWxzZSxcImNvdW50XCI6MX0se1wibmFtZVwiOlwiX2lubGluZV8xX2FyZzFfXCIsXCJsdmFsdWVcIjpmYWxzZSxcInJ2YWx1ZVwiOnRydWUsXCJjb3VudFwiOjF9LHtcIm5hbWVcIjpcIl9pbmxpbmVfMV9hcmcyX1wiLFwibHZhbHVlXCI6ZmFsc2UsXCJydmFsdWVcIjp0cnVlLFwiY291bnRcIjo0fV0sXCJ0aGlzVmFyc1wiOltdLFwibG9jYWxWYXJzXCI6W1wiX2lubGluZV8xX2lcIixcIl9pbmxpbmVfMV92XCJdfSxcInBvc3RcIjp7XCJib2R5XCI6XCJ7fVwiLFwiYXJnc1wiOltdLFwidGhpc1ZhcnNcIjpbXSxcImxvY2FsVmFyc1wiOltdfSxcImZ1bmNOYW1lXCI6XCJjb252ZXJ0XCIsXCJibG9ja1NpemVcIjo2NH0pXG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgY3JlYXRlVGh1bmsgPSByZXF1aXJlKFwiLi9saWIvdGh1bmsuanNcIilcblxuZnVuY3Rpb24gUHJvY2VkdXJlKCkge1xuICB0aGlzLmFyZ1R5cGVzID0gW11cbiAgdGhpcy5zaGltQXJncyA9IFtdXG4gIHRoaXMuYXJyYXlBcmdzID0gW11cbiAgdGhpcy5hcnJheUJsb2NrSW5kaWNlcyA9IFtdXG4gIHRoaXMuc2NhbGFyQXJncyA9IFtdXG4gIHRoaXMub2Zmc2V0QXJncyA9IFtdXG4gIHRoaXMub2Zmc2V0QXJnSW5kZXggPSBbXVxuICB0aGlzLmluZGV4QXJncyA9IFtdXG4gIHRoaXMuc2hhcGVBcmdzID0gW11cbiAgdGhpcy5mdW5jTmFtZSA9IFwiXCJcbiAgdGhpcy5wcmUgPSBudWxsXG4gIHRoaXMuYm9keSA9IG51bGxcbiAgdGhpcy5wb3N0ID0gbnVsbFxuICB0aGlzLmRlYnVnID0gZmFsc2Vcbn1cblxuZnVuY3Rpb24gY29tcGlsZUN3aXNlKHVzZXJfYXJncykge1xuICAvL0NyZWF0ZSBwcm9jZWR1cmVcbiAgdmFyIHByb2MgPSBuZXcgUHJvY2VkdXJlKClcbiAgXG4gIC8vUGFyc2UgYmxvY2tzXG4gIHByb2MucHJlICAgID0gdXNlcl9hcmdzLnByZVxuICBwcm9jLmJvZHkgICA9IHVzZXJfYXJncy5ib2R5XG4gIHByb2MucG9zdCAgID0gdXNlcl9hcmdzLnBvc3RcblxuICAvL1BhcnNlIGFyZ3VtZW50c1xuICB2YXIgcHJvY19hcmdzID0gdXNlcl9hcmdzLmFyZ3Muc2xpY2UoMClcbiAgcHJvYy5hcmdUeXBlcyA9IHByb2NfYXJnc1xuICBmb3IodmFyIGk9MDsgaTxwcm9jX2FyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYXJnX3R5cGUgPSBwcm9jX2FyZ3NbaV1cbiAgICBpZihhcmdfdHlwZSA9PT0gXCJhcnJheVwiIHx8ICh0eXBlb2YgYXJnX3R5cGUgPT09IFwib2JqZWN0XCIgJiYgYXJnX3R5cGUuYmxvY2tJbmRpY2VzKSkge1xuICAgICAgcHJvYy5hcmdUeXBlc1tpXSA9IFwiYXJyYXlcIlxuICAgICAgcHJvYy5hcnJheUFyZ3MucHVzaChpKVxuICAgICAgcHJvYy5hcnJheUJsb2NrSW5kaWNlcy5wdXNoKGFyZ190eXBlLmJsb2NrSW5kaWNlcyA/IGFyZ190eXBlLmJsb2NrSW5kaWNlcyA6IDApXG4gICAgICBwcm9jLnNoaW1BcmdzLnB1c2goXCJhcnJheVwiICsgaSlcbiAgICAgIGlmKGkgPCBwcm9jLnByZS5hcmdzLmxlbmd0aCAmJiBwcm9jLnByZS5hcmdzW2ldLmNvdW50PjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGFyZ3NcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0uY291bnQ+MCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcG9zdCgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGFyZ3NcIilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoYXJnX3R5cGUgPT09IFwic2NhbGFyXCIpIHtcbiAgICAgIHByb2Muc2NhbGFyQXJncy5wdXNoKGkpXG4gICAgICBwcm9jLnNoaW1BcmdzLnB1c2goXCJzY2FsYXJcIiArIGkpXG4gICAgfSBlbHNlIGlmKGFyZ190eXBlID09PSBcImluZGV4XCIpIHtcbiAgICAgIHByb2MuaW5kZXhBcmdzLnB1c2goaSlcbiAgICAgIGlmKGkgPCBwcm9jLnByZS5hcmdzLmxlbmd0aCAmJiBwcm9jLnByZS5hcmdzW2ldLmNvdW50ID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcHJlKCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgaW5kZXhcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLmJvZHkuYXJncy5sZW5ndGggJiYgcHJvYy5ib2R5LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBib2R5KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBpbmRleFwiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MucG9zdC5hcmdzLmxlbmd0aCAmJiBwcm9jLnBvc3QuYXJnc1tpXS5jb3VudCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBpbmRleFwiKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZihhcmdfdHlwZSA9PT0gXCJzaGFwZVwiKSB7XG4gICAgICBwcm9jLnNoYXBlQXJncy5wdXNoKGkpXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5sdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgc2hhcGVcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLmJvZHkuYXJncy5sZW5ndGggJiYgcHJvYy5ib2R5LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBib2R5KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBzaGFwZVwiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MucG9zdC5hcmdzLmxlbmd0aCAmJiBwcm9jLnBvc3QuYXJnc1tpXS5sdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IHNoYXBlXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKHR5cGVvZiBhcmdfdHlwZSA9PT0gXCJvYmplY3RcIiAmJiBhcmdfdHlwZS5vZmZzZXQpIHtcbiAgICAgIHByb2MuYXJnVHlwZXNbaV0gPSBcIm9mZnNldFwiXG4gICAgICBwcm9jLm9mZnNldEFyZ3MucHVzaCh7IGFycmF5OiBhcmdfdHlwZS5hcnJheSwgb2Zmc2V0OmFyZ190eXBlLm9mZnNldCB9KVxuICAgICAgcHJvYy5vZmZzZXRBcmdJbmRleC5wdXNoKGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBVbmtub3duIGFyZ3VtZW50IHR5cGUgXCIgKyBwcm9jX2FyZ3NbaV0pXG4gICAgfVxuICB9XG4gIFxuICAvL01ha2Ugc3VyZSBhdCBsZWFzdCBvbmUgYXJyYXkgYXJndW1lbnQgd2FzIHNwZWNpZmllZFxuICBpZihwcm9jLmFycmF5QXJncy5sZW5ndGggPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBObyBhcnJheSBhcmd1bWVudHMgc3BlY2lmaWVkXCIpXG4gIH1cbiAgXG4gIC8vTWFrZSBzdXJlIGFyZ3VtZW50cyBhcmUgY29ycmVjdFxuICBpZihwcm9jLnByZS5hcmdzLmxlbmd0aCA+IHByb2NfYXJncy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIHByZSgpIGJsb2NrXCIpXG4gIH1cbiAgaWYocHJvYy5ib2R5LmFyZ3MubGVuZ3RoID4gcHJvY19hcmdzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBUb28gbWFueSBhcmd1bWVudHMgaW4gYm9keSgpIGJsb2NrXCIpXG4gIH1cbiAgaWYocHJvYy5wb3N0LmFyZ3MubGVuZ3RoID4gcHJvY19hcmdzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBUb28gbWFueSBhcmd1bWVudHMgaW4gcG9zdCgpIGJsb2NrXCIpXG4gIH1cblxuICAvL0NoZWNrIGRlYnVnIGZsYWdcbiAgcHJvYy5kZWJ1ZyA9ICEhdXNlcl9hcmdzLnByaW50Q29kZSB8fCAhIXVzZXJfYXJncy5kZWJ1Z1xuICBcbiAgLy9SZXRyaWV2ZSBuYW1lXG4gIHByb2MuZnVuY05hbWUgPSB1c2VyX2FyZ3MuZnVuY05hbWUgfHwgXCJjd2lzZVwiXG4gIFxuICAvL1JlYWQgaW4gYmxvY2sgc2l6ZVxuICBwcm9jLmJsb2NrU2l6ZSA9IHVzZXJfYXJncy5ibG9ja1NpemUgfHwgNjRcblxuICByZXR1cm4gY3JlYXRlVGh1bmsocHJvYylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21waWxlQ3dpc2VcbiIsIlwidXNlIHN0cmljdFwiXG5cbi8vIFRoZSBmdW5jdGlvbiBiZWxvdyBpcyBjYWxsZWQgd2hlbiBjb25zdHJ1Y3RpbmcgYSBjd2lzZSBmdW5jdGlvbiBvYmplY3QsIGFuZCBkb2VzIHRoZSBmb2xsb3dpbmc6XG4vLyBBIGZ1bmN0aW9uIG9iamVjdCBpcyBjb25zdHJ1Y3RlZCB3aGljaCBhY2NlcHRzIGFzIGFyZ3VtZW50IGEgY29tcGlsYXRpb24gZnVuY3Rpb24gYW5kIHJldHVybnMgYW5vdGhlciBmdW5jdGlvbi5cbi8vIEl0IGlzIHRoaXMgb3RoZXIgZnVuY3Rpb24gdGhhdCBpcyBldmVudHVhbGx5IHJldHVybmVkIGJ5IGNyZWF0ZVRodW5rLCBhbmQgdGhpcyBmdW5jdGlvbiBpcyB0aGUgb25lIHRoYXQgYWN0dWFsbHlcbi8vIGNoZWNrcyB3aGV0aGVyIGEgY2VydGFpbiBwYXR0ZXJuIG9mIGFyZ3VtZW50cyBoYXMgYWxyZWFkeSBiZWVuIHVzZWQgYmVmb3JlIGFuZCBjb21waWxlcyBuZXcgbG9vcHMgYXMgbmVlZGVkLlxuLy8gVGhlIGNvbXBpbGF0aW9uIHBhc3NlZCB0byB0aGUgZmlyc3QgZnVuY3Rpb24gb2JqZWN0IGlzIHVzZWQgZm9yIGNvbXBpbGluZyBuZXcgZnVuY3Rpb25zLlxuLy8gT25jZSB0aGlzIGZ1bmN0aW9uIG9iamVjdCBpcyBjcmVhdGVkLCBpdCBpcyBjYWxsZWQgd2l0aCBjb21waWxlIGFzIGFyZ3VtZW50LCB3aGVyZSB0aGUgZmlyc3QgYXJndW1lbnQgb2YgY29tcGlsZVxuLy8gaXMgYm91bmQgdG8gXCJwcm9jXCIgKGVzc2VudGlhbGx5IGNvbnRhaW5pbmcgYSBwcmVwcm9jZXNzZWQgdmVyc2lvbiBvZiB0aGUgdXNlciBhcmd1bWVudHMgdG8gY3dpc2UpLlxuLy8gU28gY3JlYXRlVGh1bmsgcm91Z2hseSB3b3JrcyBsaWtlIHRoaXM6XG4vLyBmdW5jdGlvbiBjcmVhdGVUaHVuayhwcm9jKSB7XG4vLyAgIHZhciB0aHVuayA9IGZ1bmN0aW9uKGNvbXBpbGVCb3VuZCkge1xuLy8gICAgIHZhciBDQUNIRUQgPSB7fVxuLy8gICAgIHJldHVybiBmdW5jdGlvbihhcnJheXMgYW5kIHNjYWxhcnMpIHtcbi8vICAgICAgIGlmIChkdHlwZSBhbmQgb3JkZXIgb2YgYXJyYXlzIGluIENBQ0hFRCkge1xuLy8gICAgICAgICB2YXIgZnVuYyA9IENBQ0hFRFtkdHlwZSBhbmQgb3JkZXIgb2YgYXJyYXlzXVxuLy8gICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgdmFyIGZ1bmMgPSBDQUNIRURbZHR5cGUgYW5kIG9yZGVyIG9mIGFycmF5c10gPSBjb21waWxlQm91bmQoZHR5cGUgYW5kIG9yZGVyIG9mIGFycmF5cylcbi8vICAgICAgIH1cbi8vICAgICAgIHJldHVybiBmdW5jKGFycmF5cyBhbmQgc2NhbGFycylcbi8vICAgICB9XG4vLyAgIH1cbi8vICAgcmV0dXJuIHRodW5rKGNvbXBpbGUuYmluZDEocHJvYykpXG4vLyB9XG5cbnZhciBjb21waWxlID0gcmVxdWlyZShcIi4vY29tcGlsZS5qc1wiKVxuXG5mdW5jdGlvbiBjcmVhdGVUaHVuayhwcm9jKSB7XG4gIHZhciBjb2RlID0gW1wiJ3VzZSBzdHJpY3QnXCIsIFwidmFyIENBQ0hFRD17fVwiXVxuICB2YXIgdmFycyA9IFtdXG4gIHZhciB0aHVua05hbWUgPSBwcm9jLmZ1bmNOYW1lICsgXCJfY3dpc2VfdGh1bmtcIlxuICBcbiAgLy9CdWlsZCB0aHVua1xuICBjb2RlLnB1c2goW1wicmV0dXJuIGZ1bmN0aW9uIFwiLCB0aHVua05hbWUsIFwiKFwiLCBwcm9jLnNoaW1BcmdzLmpvaW4oXCIsXCIpLCBcIil7XCJdLmpvaW4oXCJcIikpXG4gIHZhciB0eXBlc2lnID0gW11cbiAgdmFyIHN0cmluZ190eXBlc2lnID0gW11cbiAgdmFyIHByb2NfYXJncyA9IFtbXCJhcnJheVwiLHByb2MuYXJyYXlBcmdzWzBdLFwiLnNoYXBlLnNsaWNlKFwiLCAvLyBTbGljZSBzaGFwZSBzbyB0aGF0IHdlIG9ubHkgcmV0YWluIHRoZSBzaGFwZSBvdmVyIHdoaWNoIHdlIGl0ZXJhdGUgKHdoaWNoIGdldHMgcGFzc2VkIHRvIHRoZSBjd2lzZSBvcGVyYXRvciBhcyBTUykuXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KDAscHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSkscHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXTwwPyhcIixcIitwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdK1wiKVwiKTpcIilcIl0uam9pbihcIlwiKV1cbiAgdmFyIHNoYXBlTGVuZ3RoQ29uZGl0aW9ucyA9IFtdLCBzaGFwZUNvbmRpdGlvbnMgPSBbXVxuICAvLyBQcm9jZXNzIGFycmF5IGFyZ3VtZW50c1xuICBmb3IodmFyIGk9MDsgaTxwcm9jLmFycmF5QXJncy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBqID0gcHJvYy5hcnJheUFyZ3NbaV1cbiAgICB2YXJzLnB1c2goW1widFwiLCBqLCBcIj1hcnJheVwiLCBqLCBcIi5kdHlwZSxcIixcbiAgICAgICAgICAgICAgIFwiclwiLCBqLCBcIj1hcnJheVwiLCBqLCBcIi5vcmRlclwiXS5qb2luKFwiXCIpKVxuICAgIHR5cGVzaWcucHVzaChcInRcIiArIGopXG4gICAgdHlwZXNpZy5wdXNoKFwiclwiICsgailcbiAgICBzdHJpbmdfdHlwZXNpZy5wdXNoKFwidFwiK2opXG4gICAgc3RyaW5nX3R5cGVzaWcucHVzaChcInJcIitqK1wiLmpvaW4oKVwiKVxuICAgIHByb2NfYXJncy5wdXNoKFwiYXJyYXlcIiArIGogKyBcIi5kYXRhXCIpXG4gICAgcHJvY19hcmdzLnB1c2goXCJhcnJheVwiICsgaiArIFwiLnN0cmlkZVwiKVxuICAgIHByb2NfYXJncy5wdXNoKFwiYXJyYXlcIiArIGogKyBcIi5vZmZzZXR8MFwiKVxuICAgIGlmIChpPjApIHsgLy8gR2F0aGVyIGNvbmRpdGlvbnMgdG8gY2hlY2sgZm9yIHNoYXBlIGVxdWFsaXR5IChpZ25vcmluZyBibG9jayBpbmRpY2VzKVxuICAgICAgc2hhcGVMZW5ndGhDb25kaXRpb25zLnB1c2goXCJhcnJheVwiICsgcHJvYy5hcnJheUFyZ3NbMF0gKyBcIi5zaGFwZS5sZW5ndGg9PT1hcnJheVwiICsgaiArIFwiLnNoYXBlLmxlbmd0aCtcIiArIChNYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdKS1NYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldKSkpXG4gICAgICBzaGFwZUNvbmRpdGlvbnMucHVzaChcImFycmF5XCIgKyBwcm9jLmFycmF5QXJnc1swXSArIFwiLnNoYXBlW3NoYXBlSW5kZXgrXCIgKyBNYXRoLm1heCgwLHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF0pICsgXCJdPT09YXJyYXlcIiArIGogKyBcIi5zaGFwZVtzaGFwZUluZGV4K1wiICsgTWF0aC5tYXgoMCxwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldKSArIFwiXVwiKVxuICAgIH1cbiAgfVxuICAvLyBDaGVjayBmb3Igc2hhcGUgZXF1YWxpdHlcbiAgaWYgKHByb2MuYXJyYXlBcmdzLmxlbmd0aCA+IDEpIHtcbiAgICBjb2RlLnB1c2goXCJpZiAoIShcIiArIHNoYXBlTGVuZ3RoQ29uZGl0aW9ucy5qb2luKFwiICYmIFwiKSArIFwiKSkgdGhyb3cgbmV3IEVycm9yKCdjd2lzZTogQXJyYXlzIGRvIG5vdCBhbGwgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25hbGl0eSEnKVwiKVxuICAgIGNvZGUucHVzaChcImZvcih2YXIgc2hhcGVJbmRleD1hcnJheVwiICsgcHJvYy5hcnJheUFyZ3NbMF0gKyBcIi5zaGFwZS5sZW5ndGgtXCIgKyBNYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdKSArIFwiOyBzaGFwZUluZGV4LS0+MDspIHtcIilcbiAgICBjb2RlLnB1c2goXCJpZiAoIShcIiArIHNoYXBlQ29uZGl0aW9ucy5qb2luKFwiICYmIFwiKSArIFwiKSkgdGhyb3cgbmV3IEVycm9yKCdjd2lzZTogQXJyYXlzIGRvIG5vdCBhbGwgaGF2ZSB0aGUgc2FtZSBzaGFwZSEnKVwiKVxuICAgIGNvZGUucHVzaChcIn1cIilcbiAgfVxuICAvLyBQcm9jZXNzIHNjYWxhciBhcmd1bWVudHNcbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5zY2FsYXJBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgcHJvY19hcmdzLnB1c2goXCJzY2FsYXJcIiArIHByb2Muc2NhbGFyQXJnc1tpXSlcbiAgfVxuICAvLyBDaGVjayBmb3IgY2FjaGVkIGZ1bmN0aW9uIChhbmQgaWYgbm90IHByZXNlbnQsIGdlbmVyYXRlIGl0KVxuICB2YXJzLnB1c2goW1widHlwZT1bXCIsIHN0cmluZ190eXBlc2lnLmpvaW4oXCIsXCIpLCBcIl0uam9pbigpXCJdLmpvaW4oXCJcIikpXG4gIHZhcnMucHVzaChcInByb2M9Q0FDSEVEW3R5cGVdXCIpXG4gIGNvZGUucHVzaChcInZhciBcIiArIHZhcnMuam9pbihcIixcIikpXG4gIFxuICBjb2RlLnB1c2goW1wiaWYoIXByb2Mpe1wiLFxuICAgICAgICAgICAgIFwiQ0FDSEVEW3R5cGVdPXByb2M9Y29tcGlsZShbXCIsIHR5cGVzaWcuam9pbihcIixcIiksIFwiXSl9XCIsXG4gICAgICAgICAgICAgXCJyZXR1cm4gcHJvYyhcIiwgcHJvY19hcmdzLmpvaW4oXCIsXCIpLCBcIil9XCJdLmpvaW4oXCJcIikpXG5cbiAgaWYocHJvYy5kZWJ1Zykge1xuICAgIGNvbnNvbGUubG9nKFwiLS0tLS1HZW5lcmF0ZWQgdGh1bms6XFxuXCIgKyBjb2RlLmpvaW4oXCJcXG5cIikgKyBcIlxcbi0tLS0tLS0tLS1cIilcbiAgfVxuICBcbiAgLy9Db21waWxlIHRodW5rXG4gIHZhciB0aHVuayA9IG5ldyBGdW5jdGlvbihcImNvbXBpbGVcIiwgY29kZS5qb2luKFwiXFxuXCIpKVxuICByZXR1cm4gdGh1bmsoY29tcGlsZS5iaW5kKHVuZGVmaW5lZCwgcHJvYykpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlVGh1bmtcbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciB1bmlxID0gcmVxdWlyZShcInVuaXFcIilcblxuLy8gVGhpcyBmdW5jdGlvbiBnZW5lcmF0ZXMgdmVyeSBzaW1wbGUgbG9vcHMgYW5hbG9nb3VzIHRvIGhvdyB5b3UgdHlwaWNhbGx5IHRyYXZlcnNlIGFycmF5cyAodGhlIG91dGVybW9zdCBsb29wIGNvcnJlc3BvbmRzIHRvIHRoZSBzbG93ZXN0IGNoYW5naW5nIGluZGV4LCB0aGUgaW5uZXJtb3N0IGxvb3AgdG8gdGhlIGZhc3Rlc3QgY2hhbmdpbmcgaW5kZXgpXG4vLyBUT0RPOiBJZiB0d28gYXJyYXlzIGhhdmUgdGhlIHNhbWUgc3RyaWRlcyAoYW5kIG9mZnNldHMpIHRoZXJlIGlzIHBvdGVudGlhbCBmb3IgZGVjcmVhc2luZyB0aGUgbnVtYmVyIG9mIFwicG9pbnRlcnNcIiBhbmQgcmVsYXRlZCB2YXJpYWJsZXMuIFRoZSBkcmF3YmFjayBpcyB0aGF0IHRoZSB0eXBlIHNpZ25hdHVyZSB3b3VsZCBiZWNvbWUgbW9yZSBzcGVjaWZpYyBhbmQgdGhhdCB0aGVyZSB3b3VsZCB0aHVzIGJlIGxlc3MgcG90ZW50aWFsIGZvciBjYWNoaW5nLCBidXQgaXQgbWlnaHQgc3RpbGwgYmUgd29ydGggaXQsIGVzcGVjaWFsbHkgd2hlbiBkZWFsaW5nIHdpdGggbGFyZ2UgbnVtYmVycyBvZiBhcmd1bWVudHMuXG5mdW5jdGlvbiBpbm5lckZpbGwob3JkZXIsIHByb2MsIGJvZHkpIHtcbiAgdmFyIGRpbWVuc2lvbiA9IG9yZGVyLmxlbmd0aFxuICAgICwgbmFyZ3MgPSBwcm9jLmFycmF5QXJncy5sZW5ndGhcbiAgICAsIGhhc19pbmRleCA9IHByb2MuaW5kZXhBcmdzLmxlbmd0aD4wXG4gICAgLCBjb2RlID0gW11cbiAgICAsIHZhcnMgPSBbXVxuICAgICwgaWR4PTAsIHBpZHg9MCwgaSwgalxuICBmb3IoaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7IC8vIEl0ZXJhdGlvbiB2YXJpYWJsZXNcbiAgICB2YXJzLnB1c2goW1wiaVwiLGksXCI9MFwiXS5qb2luKFwiXCIpKVxuICB9XG4gIC8vQ29tcHV0ZSBzY2FuIGRlbHRhc1xuICBmb3Ioaj0wOyBqPG5hcmdzOyArK2opIHtcbiAgICBmb3IoaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICBwaWR4ID0gaWR4XG4gICAgICBpZHggPSBvcmRlcltpXVxuICAgICAgaWYoaSA9PT0gMCkgeyAvLyBUaGUgaW5uZXJtb3N0L2Zhc3Rlc3QgZGltZW5zaW9uJ3MgZGVsdGEgaXMgc2ltcGx5IGl0cyBzdHJpZGVcbiAgICAgICAgdmFycy5wdXNoKFtcImRcIixqLFwic1wiLGksXCI9dFwiLGosXCJwXCIsaWR4XS5qb2luKFwiXCIpKVxuICAgICAgfSBlbHNlIHsgLy8gRm9yIG90aGVyIGRpbWVuc2lvbnMgdGhlIGRlbHRhIGlzIGJhc2ljYWxseSB0aGUgc3RyaWRlIG1pbnVzIHNvbWV0aGluZyB3aGljaCBlc3NlbnRpYWxseSBcInJld2luZHNcIiB0aGUgcHJldmlvdXMgKG1vcmUgaW5uZXIpIGRpbWVuc2lvblxuICAgICAgICB2YXJzLnB1c2goW1wiZFwiLGosXCJzXCIsaSxcIj0odFwiLGosXCJwXCIsaWR4LFwiLXNcIixwaWR4LFwiKnRcIixqLFwicFwiLHBpZHgsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2YXJzLmxlbmd0aCA+IDApIHtcbiAgICBjb2RlLnB1c2goXCJ2YXIgXCIgKyB2YXJzLmpvaW4oXCIsXCIpKVxuICB9ICBcbiAgLy9TY2FuIGxvb3BcbiAgZm9yKGk9ZGltZW5zaW9uLTE7IGk+PTA7IC0taSkgeyAvLyBTdGFydCBhdCBsYXJnZXN0IHN0cmlkZSBhbmQgd29yayB5b3VyIHdheSBpbndhcmRzXG4gICAgaWR4ID0gb3JkZXJbaV1cbiAgICBjb2RlLnB1c2goW1wiZm9yKGlcIixpLFwiPTA7aVwiLGksXCI8c1wiLGlkeCxcIjsrK2lcIixpLFwiKXtcIl0uam9pbihcIlwiKSlcbiAgfVxuICAvL1B1c2ggYm9keSBvZiBpbm5lciBsb29wXG4gIGNvZGUucHVzaChib2R5KVxuICAvL0FkdmFuY2Ugc2NhbiBwb2ludGVyc1xuICBmb3IoaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgcGlkeCA9IGlkeFxuICAgIGlkeCA9IG9yZGVyW2ldXG4gICAgZm9yKGo9MDsgajxuYXJnczsgKytqKSB7XG4gICAgICBjb2RlLnB1c2goW1wicFwiLGosXCIrPWRcIixqLFwic1wiLGldLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIGlmKGhhc19pbmRleCkge1xuICAgICAgaWYoaSA+IDApIHtcbiAgICAgICAgY29kZS5wdXNoKFtcImluZGV4W1wiLHBpZHgsXCJdLT1zXCIscGlkeF0uam9pbihcIlwiKSlcbiAgICAgIH1cbiAgICAgIGNvZGUucHVzaChbXCIrK2luZGV4W1wiLGlkeCxcIl1cIl0uam9pbihcIlwiKSlcbiAgICB9XG4gICAgY29kZS5wdXNoKFwifVwiKVxuICB9XG4gIHJldHVybiBjb2RlLmpvaW4oXCJcXG5cIilcbn1cblxuLy8gR2VuZXJhdGUgXCJvdXRlclwiIGxvb3BzIHRoYXQgbG9vcCBvdmVyIGJsb2NrcyBvZiBkYXRhLCBhcHBseWluZyBcImlubmVyXCIgbG9vcHMgdG8gdGhlIGJsb2NrcyBieSBtYW5pcHVsYXRpbmcgdGhlIGxvY2FsIHZhcmlhYmxlcyBpbiBzdWNoIGEgd2F5IHRoYXQgdGhlIGlubmVyIGxvb3Agb25seSBcInNlZXNcIiB0aGUgY3VycmVudCBibG9jay5cbi8vIFRPRE86IElmIHRoaXMgaXMgdXNlZCwgdGhlbiB0aGUgcHJldmlvdXMgZGVjbGFyYXRpb24gKGRvbmUgYnkgZ2VuZXJhdGVDd2lzZU9wKSBvZiBzKiBpcyBlc3NlbnRpYWxseSB1bm5lY2Vzc2FyeS5cbi8vICAgICAgIEkgYmVsaWV2ZSB0aGUgcyogYXJlIG5vdCB1c2VkIGVsc2V3aGVyZSAoaW4gcGFydGljdWxhciwgSSBkb24ndCB0aGluayB0aGV5J3JlIHVzZWQgaW4gdGhlIHByZS9wb3N0IHBhcnRzIGFuZCBcInNoYXBlXCIgaXMgZGVmaW5lZCBpbmRlcGVuZGVudGx5KSwgc28gaXQgd291bGQgYmUgcG9zc2libGUgdG8gbWFrZSBkZWZpbmluZyB0aGUgcyogZGVwZW5kZW50IG9uIHdoYXQgbG9vcCBtZXRob2QgaXMgYmVpbmcgdXNlZC5cbmZ1bmN0aW9uIG91dGVyRmlsbChtYXRjaGVkLCBvcmRlciwgcHJvYywgYm9keSkge1xuICB2YXIgZGltZW5zaW9uID0gb3JkZXIubGVuZ3RoXG4gICAgLCBuYXJncyA9IHByb2MuYXJyYXlBcmdzLmxlbmd0aFxuICAgICwgYmxvY2tTaXplID0gcHJvYy5ibG9ja1NpemVcbiAgICAsIGhhc19pbmRleCA9IHByb2MuaW5kZXhBcmdzLmxlbmd0aCA+IDBcbiAgICAsIGNvZGUgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxuYXJnczsgKytpKSB7XG4gICAgY29kZS5wdXNoKFtcInZhciBvZmZzZXRcIixpLFwiPXBcIixpXS5qb2luKFwiXCIpKVxuICB9XG4gIC8vR2VuZXJhdGUgbG9vcHMgZm9yIHVubWF0Y2hlZCBkaW1lbnNpb25zXG4gIC8vIFRoZSBvcmRlciBpbiB3aGljaCB0aGVzZSBkaW1lbnNpb25zIGFyZSB0cmF2ZXJzZWQgaXMgZmFpcmx5IGFyYml0cmFyeSAoZnJvbSBzbWFsbCBzdHJpZGUgdG8gbGFyZ2Ugc3RyaWRlLCBmb3IgdGhlIGZpcnN0IGFyZ3VtZW50KVxuICAvLyBUT0RPOiBJdCB3b3VsZCBiZSBuaWNlIGlmIHRoZSBvcmRlciBpbiB3aGljaCB0aGVzZSBsb29wcyBhcmUgcGxhY2VkIHdvdWxkIGFsc28gYmUgc29tZWhvdyBcIm9wdGltYWxcIiAoYXQgdGhlIHZlcnkgbGVhc3Qgd2Ugc2hvdWxkIGNoZWNrIHRoYXQgaXQgcmVhbGx5IGRvZXNuJ3QgaHVydCB1cyBpZiB0aGV5J3JlIG5vdCkuXG4gIGZvcih2YXIgaT1tYXRjaGVkOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFtcImZvcih2YXIgalwiK2krXCI9U1NbXCIsIG9yZGVyW2ldLCBcIl18MDtqXCIsIGksIFwiPjA7KXtcIl0uam9pbihcIlwiKSkgLy8gSXRlcmF0ZSBiYWNrIHRvIGZyb250XG4gICAgY29kZS5wdXNoKFtcImlmKGpcIixpLFwiPFwiLGJsb2NrU2l6ZSxcIil7XCJdLmpvaW4oXCJcIikpIC8vIEVpdGhlciBkZWNyZWFzZSBqIGJ5IGJsb2NrU2l6ZSAocyA9IGJsb2NrU2l6ZSksIG9yIHNldCBpdCB0byB6ZXJvIChhZnRlciBzZXR0aW5nIHMgPSBqKS5cbiAgICBjb2RlLnB1c2goW1wic1wiLG9yZGVyW2ldLFwiPWpcIixpXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJqXCIsaSxcIj0wXCJdLmpvaW4oXCJcIikpXG4gICAgY29kZS5wdXNoKFtcIn1lbHNle3NcIixvcmRlcltpXSxcIj1cIixibG9ja1NpemVdLmpvaW4oXCJcIikpXG4gICAgY29kZS5wdXNoKFtcImpcIixpLFwiLT1cIixibG9ja1NpemUsXCJ9XCJdLmpvaW4oXCJcIikpXG4gICAgaWYoaGFzX2luZGV4KSB7XG4gICAgICBjb2RlLnB1c2goW1wiaW5kZXhbXCIsb3JkZXJbaV0sXCJdPWpcIixpXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgfVxuICBmb3IodmFyIGk9MDsgaTxuYXJnczsgKytpKSB7XG4gICAgdmFyIGluZGV4U3RyID0gW1wib2Zmc2V0XCIraV1cbiAgICBmb3IodmFyIGo9bWF0Y2hlZDsgajxkaW1lbnNpb247ICsraikge1xuICAgICAgaW5kZXhTdHIucHVzaChbXCJqXCIsaixcIip0XCIsaSxcInBcIixvcmRlcltqXV0uam9pbihcIlwiKSlcbiAgICB9XG4gICAgY29kZS5wdXNoKFtcInBcIixpLFwiPShcIixpbmRleFN0ci5qb2luKFwiK1wiKSxcIilcIl0uam9pbihcIlwiKSlcbiAgfVxuICBjb2RlLnB1c2goaW5uZXJGaWxsKG9yZGVyLCBwcm9jLCBib2R5KSlcbiAgZm9yKHZhciBpPW1hdGNoZWQ7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJ9XCIpXG4gIH1cbiAgcmV0dXJuIGNvZGUuam9pbihcIlxcblwiKVxufVxuXG4vL0NvdW50IHRoZSBudW1iZXIgb2YgY29tcGF0aWJsZSBpbm5lciBvcmRlcnNcbi8vIFRoaXMgaXMgdGhlIGxlbmd0aCBvZiB0aGUgbG9uZ2VzdCBjb21tb24gcHJlZml4IG9mIHRoZSBhcnJheXMgaW4gb3JkZXJzLlxuLy8gRWFjaCBhcnJheSBpbiBvcmRlcnMgbGlzdHMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGNvcnJlc3BvbmQgbmRhcnJheSBpbiBvcmRlciBvZiBpbmNyZWFzaW5nIHN0cmlkZS5cbi8vIFRoaXMgaXMgdGh1cyB0aGUgbWF4aW11bSBudW1iZXIgb2YgZGltZW5zaW9ucyB0aGF0IGNhbiBiZSBlZmZpY2llbnRseSB0cmF2ZXJzZWQgYnkgc2ltcGxlIG5lc3RlZCBsb29wcyBmb3IgYWxsIGFycmF5cy5cbmZ1bmN0aW9uIGNvdW50TWF0Y2hlcyhvcmRlcnMpIHtcbiAgdmFyIG1hdGNoZWQgPSAwLCBkaW1lbnNpb24gPSBvcmRlcnNbMF0ubGVuZ3RoXG4gIHdoaWxlKG1hdGNoZWQgPCBkaW1lbnNpb24pIHtcbiAgICBmb3IodmFyIGo9MTsgajxvcmRlcnMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmKG9yZGVyc1tqXVttYXRjaGVkXSAhPT0gb3JkZXJzWzBdW21hdGNoZWRdKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVkXG4gICAgICB9XG4gICAgfVxuICAgICsrbWF0Y2hlZFxuICB9XG4gIHJldHVybiBtYXRjaGVkXG59XG5cbi8vUHJvY2Vzc2VzIGEgYmxvY2sgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBkYXRhIHR5cGVzXG4vLyBSZXBsYWNlcyB2YXJpYWJsZSBuYW1lcyBieSBkaWZmZXJlbnQgb25lcywgZWl0aGVyIFwibG9jYWxcIiBvbmVzICh0aGF0IGFyZSB0aGVuIGZlcnJpZWQgaW4gYW5kIG91dCBvZiB0aGUgZ2l2ZW4gYXJyYXkpIG9yIG9uZXMgbWF0Y2hpbmcgdGhlIGFyZ3VtZW50cyB0aGF0IHRoZSBmdW5jdGlvbiBwZXJmb3JtaW5nIHRoZSB1bHRpbWF0ZSBsb29wIHdpbGwgYWNjZXB0LlxuZnVuY3Rpb24gcHJvY2Vzc0Jsb2NrKGJsb2NrLCBwcm9jLCBkdHlwZXMpIHtcbiAgdmFyIGNvZGUgPSBibG9jay5ib2R5XG4gIHZhciBwcmUgPSBbXVxuICB2YXIgcG9zdCA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPGJsb2NrLmFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY2FyZyA9IGJsb2NrLmFyZ3NbaV1cbiAgICBpZihjYXJnLmNvdW50IDw9IDApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoY2FyZy5uYW1lLCBcImdcIilcbiAgICB2YXIgcHRyU3RyID0gXCJcIlxuICAgIHZhciBhcnJOdW0gPSBwcm9jLmFycmF5QXJncy5pbmRleE9mKGkpXG4gICAgc3dpdGNoKHByb2MuYXJnVHlwZXNbaV0pIHtcbiAgICAgIGNhc2UgXCJvZmZzZXRcIjpcbiAgICAgICAgdmFyIG9mZkFyZ0luZGV4ID0gcHJvYy5vZmZzZXRBcmdJbmRleC5pbmRleE9mKGkpXG4gICAgICAgIHZhciBvZmZBcmcgPSBwcm9jLm9mZnNldEFyZ3Nbb2ZmQXJnSW5kZXhdXG4gICAgICAgIGFyck51bSA9IG9mZkFyZy5hcnJheVxuICAgICAgICBwdHJTdHIgPSBcIitxXCIgKyBvZmZBcmdJbmRleCAvLyBBZGRzIG9mZnNldCB0byB0aGUgXCJwb2ludGVyXCIgaW4gdGhlIGFycmF5XG4gICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgcHRyU3RyID0gXCJwXCIgKyBhcnJOdW0gKyBwdHJTdHJcbiAgICAgICAgdmFyIGxvY2FsU3RyID0gXCJsXCIgKyBpXG4gICAgICAgIHZhciBhcnJTdHIgPSBcImFcIiArIGFyck51bVxuICAgICAgICBpZiAocHJvYy5hcnJheUJsb2NrSW5kaWNlc1thcnJOdW1dID09PSAwKSB7IC8vIEFyZ3VtZW50IHRvIGJvZHkgaXMganVzdCBhIHNpbmdsZSB2YWx1ZSBmcm9tIHRoaXMgYXJyYXlcbiAgICAgICAgICBpZihjYXJnLmNvdW50ID09PSAxKSB7IC8vIEFyZ3VtZW50L2FycmF5IHVzZWQgb25seSBvbmNlKD8pXG4gICAgICAgICAgICBpZihkdHlwZXNbYXJyTnVtXSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICAgICAgICAgICAgaWYoY2FyZy5sdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpIC8vIElzIHRoaXMgbmVjZXNzYXJ5IGlmIHRoZSBhcmd1bWVudCBpcyBPTkxZIHVzZWQgYXMgYW4gbHZhbHVlPyAoa2VlcCBpbiBtaW5kIHRoYXQgd2UgY2FuIGhhdmUgYSArPSBzb21ldGhpbmcsIHNvIHdlIHdvdWxkIGFjdHVhbGx5IG5lZWQgdG8gY2hlY2sgY2FyZy5ydmFsdWUpXG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgbG9jYWxTdHIpXG4gICAgICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiLnNldChcIiwgcHRyU3RyLCBcIixcIiwgbG9jYWxTdHIsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgW2FyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBbYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl1cIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYoZHR5cGVzW2Fyck51bV0gPT09IFwiZ2VuZXJpY1wiKSB7XG4gICAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpIC8vIFRPRE86IENvdWxkIHdlIG9wdGltaXplIGJ5IGNoZWNraW5nIGZvciBjYXJnLnJ2YWx1ZT9cbiAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIGxvY2FsU3RyKVxuICAgICAgICAgICAgaWYoY2FyZy5sdmFsdWUpIHtcbiAgICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiLnNldChcIiwgcHRyU3RyLCBcIixcIiwgbG9jYWxTdHIsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZS5wdXNoKFtcInZhciBcIiwgbG9jYWxTdHIsIFwiPVwiLCBhcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXVwiXS5qb2luKFwiXCIpKSAvLyBUT0RPOiBDb3VsZCB3ZSBvcHRpbWl6ZSBieSBjaGVja2luZyBmb3IgY2FyZy5ydmFsdWU/XG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICAgIGlmKGNhcmcubHZhbHVlKSB7XG4gICAgICAgICAgICAgIHBvc3QucHVzaChbYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl09XCIsIGxvY2FsU3RyXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gQXJndW1lbnQgdG8gYm9keSBpcyBhIFwiYmxvY2tcIlxuICAgICAgICAgIHZhciByZVN0ckFyciA9IFtjYXJnLm5hbWVdLCBwdHJTdHJBcnIgPSBbcHRyU3RyXVxuICAgICAgICAgIGZvcih2YXIgaj0wOyBqPE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbYXJyTnVtXSk7IGorKykge1xuICAgICAgICAgICAgcmVTdHJBcnIucHVzaChcIlxcXFxzKlxcXFxbKFteXFxcXF1dKylcXFxcXVwiKVxuICAgICAgICAgICAgcHRyU3RyQXJyLnB1c2goXCIkXCIgKyAoaisxKSArIFwiKnRcIiArIGFyck51bSArIFwiYlwiICsgaikgLy8gTWF0Y2hlZCBpbmRleCB0aW1lcyBzdHJpZGVcbiAgICAgICAgICB9XG4gICAgICAgICAgcmUgPSBuZXcgUmVnRXhwKHJlU3RyQXJyLmpvaW4oXCJcIiksIFwiZ1wiKVxuICAgICAgICAgIHB0clN0ciA9IHB0clN0ckFyci5qb2luKFwiK1wiKVxuICAgICAgICAgIGlmKGR0eXBlc1thcnJOdW1dID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgICAgLyppZihjYXJnLmx2YWx1ZSkge1xuICAgICAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpIC8vIElzIHRoaXMgbmVjZXNzYXJ5IGlmIHRoZSBhcmd1bWVudCBpcyBPTkxZIHVzZWQgYXMgYW4gbHZhbHVlPyAoa2VlcCBpbiBtaW5kIHRoYXQgd2UgY2FuIGhhdmUgYSArPSBzb21ldGhpbmcsIHNvIHdlIHdvdWxkIGFjdHVhbGx5IG5lZWQgdG8gY2hlY2sgY2FyZy5ydmFsdWUpXG4gICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIGxvY2FsU3RyKVxuICAgICAgICAgICAgICBwb3N0LnB1c2goW2FyclN0ciwgXCIuc2V0KFwiLCBwdHJTdHIsIFwiLFwiLCBsb2NhbFN0cixcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFthcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IEdlbmVyaWMgYXJyYXlzIG5vdCBzdXBwb3J0ZWQgaW4gY29tYmluYXRpb24gd2l0aCBibG9ja3MhXCIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgZG9lcyBub3QgcHJvZHVjZSBhbnkgbG9jYWwgdmFyaWFibGVzLCBldmVuIGlmIHZhcmlhYmxlcyBhcmUgdXNlZCBtdWx0aXBsZSB0aW1lcy4gSXQgd291bGQgYmUgcG9zc2libGUgdG8gZG8gc28sIGJ1dCBpdCB3b3VsZCBjb21wbGljYXRlIHRoaW5ncyBxdWl0ZSBhIGJpdC5cbiAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFthcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgXCJZXCIgKyBwcm9jLnNjYWxhckFyZ3MuaW5kZXhPZihpKSlcbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwiaW5kZXhcIjpcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgXCJpbmRleFwiKVxuICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJzaGFwZVwiOlxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBcInNoYXBlXCIpXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gW3ByZS5qb2luKFwiXFxuXCIpLCBjb2RlLCBwb3N0LmpvaW4oXCJcXG5cIildLmpvaW4oXCJcXG5cIikudHJpbSgpXG59XG5cbmZ1bmN0aW9uIHR5cGVTdW1tYXJ5KGR0eXBlcykge1xuICB2YXIgc3VtbWFyeSA9IG5ldyBBcnJheShkdHlwZXMubGVuZ3RoKVxuICB2YXIgYWxsRXF1YWwgPSB0cnVlXG4gIGZvcih2YXIgaT0wOyBpPGR0eXBlcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciB0ID0gZHR5cGVzW2ldXG4gICAgdmFyIGRpZ2l0cyA9IHQubWF0Y2goL1xcZCsvKVxuICAgIGlmKCFkaWdpdHMpIHtcbiAgICAgIGRpZ2l0cyA9IFwiXCJcbiAgICB9IGVsc2Uge1xuICAgICAgZGlnaXRzID0gZGlnaXRzWzBdXG4gICAgfVxuICAgIGlmKHQuY2hhckF0KDApID09PSAwKSB7XG4gICAgICBzdW1tYXJ5W2ldID0gXCJ1XCIgKyB0LmNoYXJBdCgxKSArIGRpZ2l0c1xuICAgIH0gZWxzZSB7XG4gICAgICBzdW1tYXJ5W2ldID0gdC5jaGFyQXQoMCkgKyBkaWdpdHNcbiAgICB9XG4gICAgaWYoaSA+IDApIHtcbiAgICAgIGFsbEVxdWFsID0gYWxsRXF1YWwgJiYgc3VtbWFyeVtpXSA9PT0gc3VtbWFyeVtpLTFdXG4gICAgfVxuICB9XG4gIGlmKGFsbEVxdWFsKSB7XG4gICAgcmV0dXJuIHN1bW1hcnlbMF1cbiAgfVxuICByZXR1cm4gc3VtbWFyeS5qb2luKFwiXCIpXG59XG5cbi8vR2VuZXJhdGVzIGEgY3dpc2Ugb3BlcmF0b3JcbmZ1bmN0aW9uIGdlbmVyYXRlQ1dpc2VPcChwcm9jLCB0eXBlc2lnKSB7XG5cbiAgLy9Db21wdXRlIGRpbWVuc2lvblxuICAvLyBBcnJheXMgZ2V0IHB1dCBmaXJzdCBpbiB0eXBlc2lnLCBhbmQgdGhlcmUgYXJlIHR3byBlbnRyaWVzIHBlciBhcnJheSAoZHR5cGUgYW5kIG9yZGVyKSwgc28gdGhpcyBnZXRzIHRoZSBudW1iZXIgb2YgZGltZW5zaW9ucyBpbiB0aGUgZmlyc3QgYXJyYXkgYXJnLlxuICB2YXIgZGltZW5zaW9uID0gKHR5cGVzaWdbMV0ubGVuZ3RoIC0gTWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSkpfDBcbiAgdmFyIG9yZGVycyA9IG5ldyBBcnJheShwcm9jLmFycmF5QXJncy5sZW5ndGgpXG4gIHZhciBkdHlwZXMgPSBuZXcgQXJyYXkocHJvYy5hcnJheUFyZ3MubGVuZ3RoKVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLmFycmF5QXJncy5sZW5ndGg7ICsraSkge1xuICAgIGR0eXBlc1tpXSA9IHR5cGVzaWdbMippXVxuICAgIG9yZGVyc1tpXSA9IHR5cGVzaWdbMippKzFdXG4gIH1cbiAgXG4gIC8vRGV0ZXJtaW5lIHdoZXJlIGJsb2NrIGFuZCBsb29wIGluZGljZXMgc3RhcnQgYW5kIGVuZFxuICB2YXIgYmxvY2tCZWdpbiA9IFtdLCBibG9ja0VuZCA9IFtdIC8vIFRoZXNlIGluZGljZXMgYXJlIGV4cG9zZWQgYXMgYmxvY2tzXG4gIHZhciBsb29wQmVnaW4gPSBbXSwgbG9vcEVuZCA9IFtdIC8vIFRoZXNlIGluZGljZXMgYXJlIGl0ZXJhdGVkIG92ZXJcbiAgdmFyIGxvb3BPcmRlcnMgPSBbXSAvLyBvcmRlcnMgcmVzdHJpY3RlZCB0byB0aGUgbG9vcCBpbmRpY2VzXG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV08MCkge1xuICAgICAgbG9vcEJlZ2luLnB1c2goMClcbiAgICAgIGxvb3BFbmQucHVzaChkaW1lbnNpb24pXG4gICAgICBibG9ja0JlZ2luLnB1c2goZGltZW5zaW9uKVxuICAgICAgYmxvY2tFbmQucHVzaChkaW1lbnNpb24rcHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSlcbiAgICB9IGVsc2Uge1xuICAgICAgbG9vcEJlZ2luLnB1c2gocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSkgLy8gTm9uLW5lZ2F0aXZlXG4gICAgICBsb29wRW5kLnB1c2gocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXStkaW1lbnNpb24pXG4gICAgICBibG9ja0JlZ2luLnB1c2goMClcbiAgICAgIGJsb2NrRW5kLnB1c2gocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSlcbiAgICB9XG4gICAgdmFyIG5ld09yZGVyID0gW11cbiAgICBmb3IodmFyIGo9MDsgajxvcmRlcnNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChsb29wQmVnaW5baV08PW9yZGVyc1tpXVtqXSAmJiBvcmRlcnNbaV1bal08bG9vcEVuZFtpXSkge1xuICAgICAgICBuZXdPcmRlci5wdXNoKG9yZGVyc1tpXVtqXS1sb29wQmVnaW5baV0pIC8vIElmIHRoaXMgaXMgYSBsb29wIGluZGV4LCBwdXQgaXQgaW4gbmV3T3JkZXIsIHN1YnRyYWN0aW5nIGxvb3BCZWdpbiwgdG8gbWFrZSBzdXJlIHRoYXQgYWxsIGxvb3BPcmRlcnMgYXJlIHVzaW5nIGEgY29tbW9uIHNldCBvZiBpbmRpY2VzLlxuICAgICAgfVxuICAgIH1cbiAgICBsb29wT3JkZXJzLnB1c2gobmV3T3JkZXIpXG4gIH1cblxuICAvL0ZpcnN0IGNyZWF0ZSBhcmd1bWVudHMgZm9yIHByb2NlZHVyZVxuICB2YXIgYXJnbGlzdCA9IFtcIlNTXCJdIC8vIFNTIGlzIHRoZSBvdmVyYWxsIHNoYXBlIG92ZXIgd2hpY2ggd2UgaXRlcmF0ZVxuICB2YXIgY29kZSA9IFtcIid1c2Ugc3RyaWN0J1wiXVxuICB2YXIgdmFycyA9IFtdXG4gIFxuICBmb3IodmFyIGo9MDsgajxkaW1lbnNpb247ICsraikge1xuICAgIHZhcnMucHVzaChbXCJzXCIsIGosIFwiPVNTW1wiLCBqLCBcIl1cIl0uam9pbihcIlwiKSkgLy8gVGhlIGxpbWl0cyBmb3IgZWFjaCBkaW1lbnNpb24uXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBhcmdsaXN0LnB1c2goXCJhXCIraSkgLy8gQWN0dWFsIGRhdGEgYXJyYXlcbiAgICBhcmdsaXN0LnB1c2goXCJ0XCIraSkgLy8gU3RyaWRlc1xuICAgIGFyZ2xpc3QucHVzaChcInBcIitpKSAvLyBPZmZzZXQgaW4gdGhlIGFycmF5IGF0IHdoaWNoIHRoZSBkYXRhIHN0YXJ0cyAoYWxzbyB1c2VkIGZvciBpdGVyYXRpbmcgb3ZlciB0aGUgZGF0YSlcbiAgICBcbiAgICBmb3IodmFyIGo9MDsgajxkaW1lbnNpb247ICsraikgeyAvLyBVbnBhY2sgdGhlIHN0cmlkZXMgaW50byB2YXJzIGZvciBsb29waW5nXG4gICAgICB2YXJzLnB1c2goW1widFwiLGksXCJwXCIsaixcIj10XCIsaSxcIltcIixsb29wQmVnaW5baV0raixcIl1cIl0uam9pbihcIlwiKSlcbiAgICB9XG4gICAgXG4gICAgZm9yKHZhciBqPTA7IGo8TWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSk7ICsraikgeyAvLyBVbnBhY2sgdGhlIHN0cmlkZXMgaW50byB2YXJzIGZvciBibG9jayBpdGVyYXRpb25cbiAgICAgIHZhcnMucHVzaChbXCJ0XCIsaSxcImJcIixqLFwiPXRcIixpLFwiW1wiLGJsb2NrQmVnaW5baV0raixcIl1cIl0uam9pbihcIlwiKSlcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5zY2FsYXJBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgYXJnbGlzdC5wdXNoKFwiWVwiICsgaSlcbiAgfVxuICBpZihwcm9jLnNoYXBlQXJncy5sZW5ndGggPiAwKSB7XG4gICAgdmFycy5wdXNoKFwic2hhcGU9U1Muc2xpY2UoMClcIikgLy8gTWFrZXMgdGhlIHNoYXBlIG92ZXIgd2hpY2ggd2UgaXRlcmF0ZSBhdmFpbGFibGUgdG8gdGhlIHVzZXIgZGVmaW5lZCBmdW5jdGlvbnMgKHNvIHlvdSBjYW4gdXNlIHdpZHRoL2hlaWdodCBmb3IgZXhhbXBsZSlcbiAgfVxuICBpZihwcm9jLmluZGV4QXJncy5sZW5ndGggPiAwKSB7XG4gICAgLy8gUHJlcGFyZSBhbiBhcnJheSB0byBrZWVwIHRyYWNrIG9mIHRoZSAobG9naWNhbCkgaW5kaWNlcywgaW5pdGlhbGl6ZWQgdG8gZGltZW5zaW9uIHplcm9lcy5cbiAgICB2YXIgemVyb3MgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICAgIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICB6ZXJvc1tpXSA9IFwiMFwiXG4gICAgfVxuICAgIHZhcnMucHVzaChbXCJpbmRleD1bXCIsIHplcm9zLmpvaW4oXCIsXCIpLCBcIl1cIl0uam9pbihcIlwiKSlcbiAgfVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLm9mZnNldEFyZ3MubGVuZ3RoOyArK2kpIHsgLy8gT2Zmc2V0IGFyZ3VtZW50cyB1c2VkIGZvciBzdGVuY2lsIG9wZXJhdGlvbnNcbiAgICB2YXIgb2ZmX2FyZyA9IHByb2Mub2Zmc2V0QXJnc1tpXVxuICAgIHZhciBpbml0X3N0cmluZyA9IFtdXG4gICAgZm9yKHZhciBqPTA7IGo8b2ZmX2FyZy5vZmZzZXQubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmKG9mZl9hcmcub2Zmc2V0W2pdID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2UgaWYob2ZmX2FyZy5vZmZzZXRbal0gPT09IDEpIHtcbiAgICAgICAgaW5pdF9zdHJpbmcucHVzaChbXCJ0XCIsIG9mZl9hcmcuYXJyYXksIFwicFwiLCBqXS5qb2luKFwiXCIpKSAgICAgIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdF9zdHJpbmcucHVzaChbb2ZmX2FyZy5vZmZzZXRbal0sIFwiKnRcIiwgb2ZmX2FyZy5hcnJheSwgXCJwXCIsIGpdLmpvaW4oXCJcIikpXG4gICAgICB9XG4gICAgfVxuICAgIGlmKGluaXRfc3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFycy5wdXNoKFwicVwiICsgaSArIFwiPTBcIilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFycy5wdXNoKFtcInFcIiwgaSwgXCI9XCIsIGluaXRfc3RyaW5nLmpvaW4oXCIrXCIpXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgfVxuXG4gIC8vUHJlcGFyZSB0aGlzIHZhcmlhYmxlc1xuICB2YXIgdGhpc1ZhcnMgPSB1bmlxKFtdLmNvbmNhdChwcm9jLnByZS50aGlzVmFycylcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHByb2MuYm9keS50aGlzVmFycylcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHByb2MucG9zdC50aGlzVmFycykpXG4gIHZhcnMgPSB2YXJzLmNvbmNhdCh0aGlzVmFycylcbiAgaWYgKHZhcnMubGVuZ3RoID4gMCkge1xuICAgIGNvZGUucHVzaChcInZhciBcIiArIHZhcnMuam9pbihcIixcIikpXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJwXCIraStcInw9MFwiKVxuICB9XG4gIFxuICAvL0lubGluZSBwcmVsdWRlXG4gIGlmKHByb2MucHJlLmJvZHkubGVuZ3RoID4gMykge1xuICAgIGNvZGUucHVzaChwcm9jZXNzQmxvY2socHJvYy5wcmUsIHByb2MsIGR0eXBlcykpXG4gIH1cblxuICAvL1Byb2Nlc3MgYm9keVxuICB2YXIgYm9keSA9IHByb2Nlc3NCbG9jayhwcm9jLmJvZHksIHByb2MsIGR0eXBlcylcbiAgdmFyIG1hdGNoZWQgPSBjb3VudE1hdGNoZXMobG9vcE9yZGVycylcbiAgaWYobWF0Y2hlZCA8IGRpbWVuc2lvbikge1xuICAgIGNvZGUucHVzaChvdXRlckZpbGwobWF0Y2hlZCwgbG9vcE9yZGVyc1swXSwgcHJvYywgYm9keSkpIC8vIFRPRE86IFJhdGhlciB0aGFuIHBhc3NpbmcgbG9vcE9yZGVyc1swXSwgaXQgbWlnaHQgYmUgaW50ZXJlc3RpbmcgdG8gbG9vayBhdCBwYXNzaW5nIGFuIG9yZGVyIHRoYXQgcmVwcmVzZW50cyB0aGUgbWFqb3JpdHkgb2YgdGhlIGFyZ3VtZW50cyBmb3IgZXhhbXBsZS5cbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goaW5uZXJGaWxsKGxvb3BPcmRlcnNbMF0sIHByb2MsIGJvZHkpKVxuICB9XG5cbiAgLy9JbmxpbmUgZXBpbG9nXG4gIGlmKHByb2MucG9zdC5ib2R5Lmxlbmd0aCA+IDMpIHtcbiAgICBjb2RlLnB1c2gocHJvY2Vzc0Jsb2NrKHByb2MucG9zdCwgcHJvYywgZHR5cGVzKSlcbiAgfVxuICBcbiAgaWYocHJvYy5kZWJ1Zykge1xuICAgIGNvbnNvbGUubG9nKFwiLS0tLS1HZW5lcmF0ZWQgY3dpc2Ugcm91dGluZSBmb3IgXCIsIHR5cGVzaWcsIFwiOlxcblwiICsgY29kZS5qb2luKFwiXFxuXCIpICsgXCJcXG4tLS0tLS0tLS0tXCIpXG4gIH1cbiAgXG4gIHZhciBsb29wTmFtZSA9IFsocHJvYy5mdW5jTmFtZXx8XCJ1bm5hbWVkXCIpLCBcIl9jd2lzZV9sb29wX1wiLCBvcmRlcnNbMF0uam9pbihcInNcIiksXCJtXCIsbWF0Y2hlZCx0eXBlU3VtbWFyeShkdHlwZXMpXS5qb2luKFwiXCIpXG4gIHZhciBmID0gbmV3IEZ1bmN0aW9uKFtcImZ1bmN0aW9uIFwiLGxvb3BOYW1lLFwiKFwiLCBhcmdsaXN0LmpvaW4oXCIsXCIpLFwiKXtcIiwgY29kZS5qb2luKFwiXFxuXCIpLFwifSByZXR1cm4gXCIsIGxvb3BOYW1lXS5qb2luKFwiXCIpKVxuICByZXR1cm4gZigpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGdlbmVyYXRlQ1dpc2VPcFxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuZnVuY3Rpb24gdW5pcXVlX3ByZWQobGlzdCwgY29tcGFyZSkge1xuICB2YXIgcHRyID0gMVxuICAgICwgbGVuID0gbGlzdC5sZW5ndGhcbiAgICAsIGE9bGlzdFswXSwgYj1saXN0WzBdXG4gIGZvcih2YXIgaT0xOyBpPGxlbjsgKytpKSB7XG4gICAgYiA9IGFcbiAgICBhID0gbGlzdFtpXVxuICAgIGlmKGNvbXBhcmUoYSwgYikpIHtcbiAgICAgIGlmKGkgPT09IHB0cikge1xuICAgICAgICBwdHIrK1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgbGlzdFtwdHIrK10gPSBhXG4gICAgfVxuICB9XG4gIGxpc3QubGVuZ3RoID0gcHRyXG4gIHJldHVybiBsaXN0XG59XG5cbmZ1bmN0aW9uIHVuaXF1ZV9lcShsaXN0KSB7XG4gIHZhciBwdHIgPSAxXG4gICAgLCBsZW4gPSBsaXN0Lmxlbmd0aFxuICAgICwgYT1saXN0WzBdLCBiID0gbGlzdFswXVxuICBmb3IodmFyIGk9MTsgaTxsZW47ICsraSwgYj1hKSB7XG4gICAgYiA9IGFcbiAgICBhID0gbGlzdFtpXVxuICAgIGlmKGEgIT09IGIpIHtcbiAgICAgIGlmKGkgPT09IHB0cikge1xuICAgICAgICBwdHIrK1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgbGlzdFtwdHIrK10gPSBhXG4gICAgfVxuICB9XG4gIGxpc3QubGVuZ3RoID0gcHRyXG4gIHJldHVybiBsaXN0XG59XG5cbmZ1bmN0aW9uIHVuaXF1ZShsaXN0LCBjb21wYXJlLCBzb3J0ZWQpIHtcbiAgaWYobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbGlzdFxuICB9XG4gIGlmKGNvbXBhcmUpIHtcbiAgICBpZighc29ydGVkKSB7XG4gICAgICBsaXN0LnNvcnQoY29tcGFyZSlcbiAgICB9XG4gICAgcmV0dXJuIHVuaXF1ZV9wcmVkKGxpc3QsIGNvbXBhcmUpXG4gIH1cbiAgaWYoIXNvcnRlZCkge1xuICAgIGxpc3Quc29ydCgpXG4gIH1cbiAgcmV0dXJuIHVuaXF1ZV9lcShsaXN0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaXF1ZVxuIiwidmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5cbi8vIHRocm91Z2hcbi8vXG4vLyBhIHN0cmVhbSB0aGF0IGRvZXMgbm90aGluZyBidXQgcmUtZW1pdCB0aGUgaW5wdXQuXG4vLyB1c2VmdWwgZm9yIGFnZ3JlZ2F0aW5nIGEgc2VyaWVzIG9mIGNoYW5naW5nIGJ1dCBub3QgZW5kaW5nIHN0cmVhbXMgaW50byBvbmUgc3RyZWFtKVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0aHJvdWdoXG50aHJvdWdoLnRocm91Z2ggPSB0aHJvdWdoXG5cbi8vY3JlYXRlIGEgcmVhZGFibGUgd3JpdGFibGUgc3RyZWFtLlxuXG5mdW5jdGlvbiB0aHJvdWdoICh3cml0ZSwgZW5kLCBvcHRzKSB7XG4gIHdyaXRlID0gd3JpdGUgfHwgZnVuY3Rpb24gKGRhdGEpIHsgdGhpcy5xdWV1ZShkYXRhKSB9XG4gIGVuZCA9IGVuZCB8fCBmdW5jdGlvbiAoKSB7IHRoaXMucXVldWUobnVsbCkgfVxuXG4gIHZhciBlbmRlZCA9IGZhbHNlLCBkZXN0cm95ZWQgPSBmYWxzZSwgYnVmZmVyID0gW10sIF9lbmRlZCA9IGZhbHNlXG4gIHZhciBzdHJlYW0gPSBuZXcgU3RyZWFtKClcbiAgc3RyZWFtLnJlYWRhYmxlID0gc3RyZWFtLndyaXRhYmxlID0gdHJ1ZVxuICBzdHJlYW0ucGF1c2VkID0gZmFsc2VcblxuLy8gIHN0cmVhbS5hdXRvUGF1c2UgICA9ICEob3B0cyAmJiBvcHRzLmF1dG9QYXVzZSAgID09PSBmYWxzZSlcbiAgc3RyZWFtLmF1dG9EZXN0cm95ID0gIShvcHRzICYmIG9wdHMuYXV0b0Rlc3Ryb3kgPT09IGZhbHNlKVxuXG4gIHN0cmVhbS53cml0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgd3JpdGUuY2FsbCh0aGlzLCBkYXRhKVxuICAgIHJldHVybiAhc3RyZWFtLnBhdXNlZFxuICB9XG5cbiAgZnVuY3Rpb24gZHJhaW4oKSB7XG4gICAgd2hpbGUoYnVmZmVyLmxlbmd0aCAmJiAhc3RyZWFtLnBhdXNlZCkge1xuICAgICAgdmFyIGRhdGEgPSBidWZmZXIuc2hpZnQoKVxuICAgICAgaWYobnVsbCA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlbmQnKVxuICAgICAgZWxzZVxuICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGRhdGEpXG4gICAgfVxuICB9XG5cbiAgc3RyZWFtLnF1ZXVlID0gc3RyZWFtLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSkge1xuLy8gICAgY29uc29sZS5lcnJvcihlbmRlZClcbiAgICBpZihfZW5kZWQpIHJldHVybiBzdHJlYW1cbiAgICBpZihkYXRhID09PSBudWxsKSBfZW5kZWQgPSB0cnVlXG4gICAgYnVmZmVyLnB1c2goZGF0YSlcbiAgICBkcmFpbigpXG4gICAgcmV0dXJuIHN0cmVhbVxuICB9XG5cbiAgLy90aGlzIHdpbGwgYmUgcmVnaXN0ZXJlZCBhcyB0aGUgZmlyc3QgJ2VuZCcgbGlzdGVuZXJcbiAgLy9tdXN0IGNhbGwgZGVzdHJveSBuZXh0IHRpY2ssIHRvIG1ha2Ugc3VyZSB3ZSdyZSBhZnRlciBhbnlcbiAgLy9zdHJlYW0gcGlwZWQgZnJvbSBoZXJlLlxuICAvL3RoaXMgaXMgb25seSBhIHByb2JsZW0gaWYgZW5kIGlzIG5vdCBlbWl0dGVkIHN5bmNocm9ub3VzbHkuXG4gIC8vYSBuaWNlciB3YXkgdG8gZG8gdGhpcyBpcyB0byBtYWtlIHN1cmUgdGhpcyBpcyB0aGUgbGFzdCBsaXN0ZW5lciBmb3IgJ2VuZCdcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZVxuICAgIGlmKCFzdHJlYW0ud3JpdGFibGUgJiYgc3RyZWFtLmF1dG9EZXN0cm95KVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KClcbiAgICAgIH0pXG4gIH0pXG5cbiAgZnVuY3Rpb24gX2VuZCAoKSB7XG4gICAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2VcbiAgICBlbmQuY2FsbChzdHJlYW0pXG4gICAgaWYoIXN0cmVhbS5yZWFkYWJsZSAmJiBzdHJlYW0uYXV0b0Rlc3Ryb3kpXG4gICAgICBzdHJlYW0uZGVzdHJveSgpXG4gIH1cblxuICBzdHJlYW0uZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZihlbmRlZCkgcmV0dXJuXG4gICAgZW5kZWQgPSB0cnVlXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCkgc3RyZWFtLndyaXRlKGRhdGEpXG4gICAgX2VuZCgpIC8vIHdpbGwgZW1pdCBvciBxdWV1ZVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKGRlc3Ryb3llZCkgcmV0dXJuXG4gICAgZGVzdHJveWVkID0gdHJ1ZVxuICAgIGVuZGVkID0gdHJ1ZVxuICAgIGJ1ZmZlci5sZW5ndGggPSAwXG4gICAgc3RyZWFtLndyaXRhYmxlID0gc3RyZWFtLnJlYWRhYmxlID0gZmFsc2VcbiAgICBzdHJlYW0uZW1pdCgnY2xvc2UnKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZihzdHJlYW0ucGF1c2VkKSByZXR1cm5cbiAgICBzdHJlYW0ucGF1c2VkID0gdHJ1ZVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoc3RyZWFtLnBhdXNlZCkge1xuICAgICAgc3RyZWFtLnBhdXNlZCA9IGZhbHNlXG4gICAgICBzdHJlYW0uZW1pdCgncmVzdW1lJylcbiAgICB9XG4gICAgZHJhaW4oKVxuICAgIC8vbWF5IGhhdmUgYmVjb21lIHBhdXNlZCBhZ2FpbixcbiAgICAvL2FzIGRyYWluIGVtaXRzICdkYXRhJy5cbiAgICBpZighc3RyZWFtLnBhdXNlZClcbiAgICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpXG4gICAgcmV0dXJuIHN0cmVhbVxuICB9XG4gIHJldHVybiBzdHJlYW1cbn1cblxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcycpO1xuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8qIChpZ25vcmVkKSAqLyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBzcmMuY29weSh0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgIH1yZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChwKSB7XG4gICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7XG5cbmlmICh1dGlsICYmIHV0aWwuaW5zcGVjdCAmJiB1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIG1vZHVsZS5leHBvcnRzLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdXRpbC5pbnNwZWN0KHsgbGVuZ3RoOiB0aGlzLmxlbmd0aCB9KTtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyAnICsgb2JqO1xuICB9O1xufSIsIi8qIChpZ25vcmVkKSAqLyIsInZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQnVmZmVyLnByb3RvdHlwZSlcblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlRyYW5zZm9ybVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuUGFzc1Rocm91Z2hcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRhdGFVcmlUb0J1ZmZlcjtcblxuLyoqXG4gKiBSZXR1cm5zIGEgYEJ1ZmZlcmAgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBVUkkgYHVyaWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaSBEYXRhIFVSSSB0byB0dXJuIGludG8gYSBCdWZmZXIgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0J1ZmZlcn0gQnVmZmVyIGluc3RhbmNlIGZyb20gRGF0YSBVUklcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGF0YVVyaVRvQnVmZmVyICh1cmkpIHtcbiAgaWYgKCEvXmRhdGFcXDovaS50ZXN0KHVyaSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgdXJpYCBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgYSBEYXRhIFVSSSAobXVzdCBiZWdpbiB3aXRoIFwiZGF0YTpcIiknKTtcbiAgfVxuXG4gIC8vIHN0cmlwIG5ld2xpbmVzXG4gIHVyaSA9IHVyaS5yZXBsYWNlKC9cXHI/XFxuL2csICcnKTtcblxuICAvLyBzcGxpdCB0aGUgVVJJIHVwIGludG8gdGhlIFwibWV0YWRhdGFcIiBhbmQgdGhlIFwiZGF0YVwiIHBvcnRpb25zXG4gIHZhciBmaXJzdENvbW1hID0gdXJpLmluZGV4T2YoJywnKTtcbiAgaWYgKC0xID09PSBmaXJzdENvbW1hIHx8IGZpcnN0Q29tbWEgPD0gNCkgdGhyb3cgbmV3IFR5cGVFcnJvcignbWFsZm9ybWVkIGRhdGE6IFVSSScpO1xuXG4gIC8vIHJlbW92ZSB0aGUgXCJkYXRhOlwiIHNjaGVtZSBhbmQgcGFyc2UgdGhlIG1ldGFkYXRhXG4gIHZhciBtZXRhID0gdXJpLnN1YnN0cmluZyg1LCBmaXJzdENvbW1hKS5zcGxpdCgnOycpO1xuXG4gIHZhciBiYXNlNjQgPSBmYWxzZTtcbiAgdmFyIGNoYXJzZXQgPSAnVVMtQVNDSUknO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoJ2Jhc2U2NCcgPT0gbWV0YVtpXSkge1xuICAgICAgYmFzZTY0ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKDAgPT0gbWV0YVtpXS5pbmRleE9mKCdjaGFyc2V0PScpKSB7XG4gICAgICBjaGFyc2V0ID0gbWV0YVtpXS5zdWJzdHJpbmcoOCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZ2V0IHRoZSBlbmNvZGVkIGRhdGEgcG9ydGlvbiBhbmQgZGVjb2RlIFVSSS1lbmNvZGVkIGNoYXJzXG4gIHZhciBkYXRhID0gdW5lc2NhcGUodXJpLnN1YnN0cmluZyhmaXJzdENvbW1hICsgMSkpO1xuXG4gIHZhciBlbmNvZGluZyA9IGJhc2U2NCA/ICdiYXNlNjQnIDogJ2FzY2lpJztcbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIoZGF0YSwgZW5jb2RpbmcpO1xuXG4gIC8vIHNldCBgLnR5cGVgIHByb3BlcnR5IHRvIE1JTUUgdHlwZVxuICBidWZmZXIudHlwZSA9IG1ldGFbMF0gfHwgJ3RleHQvcGxhaW4nO1xuXG4gIC8vIHNldCB0aGUgYC5jaGFyc2V0YCBwcm9wZXJ0eVxuICBidWZmZXIuY2hhcnNldCA9IGNoYXJzZXQ7XG5cbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIGludGVycDFkKGFyciwgeCkge1xuICB2YXIgaXggPSBNYXRoLmZsb29yKHgpXG4gICAgLCBmeCA9IHggLSBpeFxuICAgICwgczAgPSAwIDw9IGl4ICAgJiYgaXggICA8IGFyci5zaGFwZVswXVxuICAgICwgczEgPSAwIDw9IGl4KzEgJiYgaXgrMSA8IGFyci5zaGFwZVswXVxuICAgICwgdzAgPSBzMCA/ICthcnIuZ2V0KGl4KSAgIDogMC4wXG4gICAgLCB3MSA9IHMxID8gK2Fyci5nZXQoaXgrMSkgOiAwLjBcbiAgcmV0dXJuICgxLjAtZngpKncwICsgZngqdzFcbn1cblxuZnVuY3Rpb24gaW50ZXJwMmQoYXJyLCB4LCB5KSB7XG4gIHZhciBpeCA9IE1hdGguZmxvb3IoeClcbiAgICAsIGZ4ID0geCAtIGl4XG4gICAgLCBzMCA9IDAgPD0gaXggICAmJiBpeCAgIDwgYXJyLnNoYXBlWzBdXG4gICAgLCBzMSA9IDAgPD0gaXgrMSAmJiBpeCsxIDwgYXJyLnNoYXBlWzBdXG4gICAgLCBpeSA9IE1hdGguZmxvb3IoeSlcbiAgICAsIGZ5ID0geSAtIGl5XG4gICAgLCB0MCA9IDAgPD0gaXkgICAmJiBpeSAgIDwgYXJyLnNoYXBlWzFdXG4gICAgLCB0MSA9IDAgPD0gaXkrMSAmJiBpeSsxIDwgYXJyLnNoYXBlWzFdXG4gICAgLCB3MDAgPSBzMCYmdDAgPyBhcnIuZ2V0KGl4ICAsaXkgICkgOiAwLjBcbiAgICAsIHcwMSA9IHMwJiZ0MSA/IGFyci5nZXQoaXggICxpeSsxKSA6IDAuMFxuICAgICwgdzEwID0gczEmJnQwID8gYXJyLmdldChpeCsxLGl5ICApIDogMC4wXG4gICAgLCB3MTEgPSBzMSYmdDEgPyBhcnIuZ2V0KGl4KzEsaXkrMSkgOiAwLjBcbiAgcmV0dXJuICgxLjAtZnkpICogKCgxLjAtZngpKncwMCArIGZ4KncxMCkgKyBmeSAqICgoMS4wLWZ4KSp3MDEgKyBmeCp3MTEpXG59XG5cbmZ1bmN0aW9uIGludGVycDNkKGFyciwgeCwgeSwgeikge1xuICB2YXIgaXggPSBNYXRoLmZsb29yKHgpXG4gICAgLCBmeCA9IHggLSBpeFxuICAgICwgczAgPSAwIDw9IGl4ICAgJiYgaXggICA8IGFyci5zaGFwZVswXVxuICAgICwgczEgPSAwIDw9IGl4KzEgJiYgaXgrMSA8IGFyci5zaGFwZVswXVxuICAgICwgaXkgPSBNYXRoLmZsb29yKHkpXG4gICAgLCBmeSA9IHkgLSBpeVxuICAgICwgdDAgPSAwIDw9IGl5ICAgJiYgaXkgICA8IGFyci5zaGFwZVsxXVxuICAgICwgdDEgPSAwIDw9IGl5KzEgJiYgaXkrMSA8IGFyci5zaGFwZVsxXVxuICAgICwgaXogPSBNYXRoLmZsb29yKHopXG4gICAgLCBmeiA9IHogLSBpelxuICAgICwgdTAgPSAwIDw9IGl6ICAgJiYgaXogICA8IGFyci5zaGFwZVsyXVxuICAgICwgdTEgPSAwIDw9IGl6KzEgJiYgaXorMSA8IGFyci5zaGFwZVsyXVxuICAgICwgdzAwMCA9IHMwJiZ0MCYmdTAgPyBhcnIuZ2V0KGl4LGl5LGl6KSAgICAgICA6IDAuMFxuICAgICwgdzAxMCA9IHMwJiZ0MSYmdTAgPyBhcnIuZ2V0KGl4LGl5KzEsaXopICAgICA6IDAuMFxuICAgICwgdzEwMCA9IHMxJiZ0MCYmdTAgPyBhcnIuZ2V0KGl4KzEsaXksaXopICAgICA6IDAuMFxuICAgICwgdzExMCA9IHMxJiZ0MSYmdTAgPyBhcnIuZ2V0KGl4KzEsaXkrMSxpeikgICA6IDAuMFxuICAgICwgdzAwMSA9IHMwJiZ0MCYmdTEgPyBhcnIuZ2V0KGl4LGl5LGl6KzEpICAgICA6IDAuMFxuICAgICwgdzAxMSA9IHMwJiZ0MSYmdTEgPyBhcnIuZ2V0KGl4LGl5KzEsaXorMSkgICA6IDAuMFxuICAgICwgdzEwMSA9IHMxJiZ0MCYmdTEgPyBhcnIuZ2V0KGl4KzEsaXksaXorMSkgICA6IDAuMFxuICAgICwgdzExMSA9IHMxJiZ0MSYmdTEgPyBhcnIuZ2V0KGl4KzEsaXkrMSxpeisxKSA6IDAuMFxuICByZXR1cm4gKDEuMC1meikgKiAoKDEuMC1meSkgKiAoKDEuMC1meCkqdzAwMCArIGZ4KncxMDApICsgZnkgKiAoKDEuMC1meCkqdzAxMCArIGZ4KncxMTApKSArIGZ6ICogKCgxLjAtZnkpICogKCgxLjAtZngpKncwMDEgKyBmeCp3MTAxKSArIGZ5ICogKCgxLjAtZngpKncwMTEgKyBmeCp3MTExKSlcbn1cblxuZnVuY3Rpb24gaW50ZXJwTmQoYXJyKSB7XG4gIHZhciBkID0gYXJyLnNoYXBlLmxlbmd0aHwwXG4gICAgLCBpeCA9IG5ldyBBcnJheShkKVxuICAgICwgZnggPSBuZXcgQXJyYXkoZClcbiAgICAsIHMwID0gbmV3IEFycmF5KGQpXG4gICAgLCBzMSA9IG5ldyBBcnJheShkKVxuICAgICwgaSwgdFxuICBmb3IoaT0wOyBpPGQ7ICsraSkge1xuICAgIHQgPSArYXJndW1lbnRzW2krMV1cbiAgICBpeFtpXSA9IE1hdGguZmxvb3IodClcbiAgICBmeFtpXSA9IHQgLSBpeFtpXVxuICAgIHMwW2ldID0gKDAgPD0gaXhbaV0gICAmJiBpeFtpXSAgIDwgYXJyLnNoYXBlW2ldKVxuICAgIHMxW2ldID0gKDAgPD0gaXhbaV0rMSAmJiBpeFtpXSsxIDwgYXJyLnNoYXBlW2ldKVxuICB9XG4gIHZhciByID0gMC4wLCBqLCB3LCBpZHhcbmlfbG9vcDpcbiAgZm9yKGk9MDsgaTwoMTw8ZCk7ICsraSkge1xuICAgIHcgPSAxLjBcbiAgICBpZHggPSBhcnIub2Zmc2V0XG4gICAgZm9yKGo9MDsgajxkOyArK2opIHtcbiAgICAgIGlmKGkgJiAoMTw8aikpIHtcbiAgICAgICAgaWYoIXMxW2pdKSB7XG4gICAgICAgICAgY29udGludWUgaV9sb29wXG4gICAgICAgIH1cbiAgICAgICAgdyAqPSBmeFtqXVxuICAgICAgICBpZHggKz0gYXJyLnN0cmlkZVtqXSAqIChpeFtqXSArIDEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZighczBbal0pIHtcbiAgICAgICAgICBjb250aW51ZSBpX2xvb3BcbiAgICAgICAgfVxuICAgICAgICB3ICo9IDEuMCAtIGZ4W2pdXG4gICAgICAgIGlkeCArPSBhcnIuc3RyaWRlW2pdICogaXhbal1cbiAgICAgIH1cbiAgICB9XG4gICAgciArPSB3ICogYXJyLmRhdGFbaWR4XVxuICB9XG4gIHJldHVybiByXG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKGFyciwgeCwgeSwgeikge1xuICBzd2l0Y2goYXJyLnNoYXBlLmxlbmd0aCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiAwLjBcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gaW50ZXJwMWQoYXJyLCB4KVxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBpbnRlcnAyZChhcnIsIHgsIHkpXG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGludGVycDNkKGFyciwgeCwgeSwgeilcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGludGVycE5kLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGludGVycG9sYXRlXG5tb2R1bGUuZXhwb3J0cy5kMSA9IGludGVycDFkXG5tb2R1bGUuZXhwb3J0cy5kMiA9IGludGVycDJkXG5tb2R1bGUuZXhwb3J0cy5kMyA9IGludGVycDNkXG4iLCJjb25zdCBCcmVzZW5oYW0gPSB7fTtcblxuY29uc3QgU2xvcGUgPSB7XG4gICAgRElSOiB7XG4gICAgICAgIFVQOiAxLFxuICAgICAgICBET1dOOiAtMSxcbiAgICB9LFxufTtcbi8qKlxuICogU2NhbnMgYSBsaW5lIG9mIHRoZSBnaXZlbiBpbWFnZSBmcm9tIHBvaW50IHAxIHRvIHAyIGFuZCByZXR1cm5zIGEgcmVzdWx0IG9iamVjdCBjb250YWluaW5nXG4gKiBncmF5LXNjYWxlIHZhbHVlcyAoMC0yNTUpIG9mIHRoZSB1bmRlcmx5aW5nIHBpeGVscyBpbiBhZGRpdGlvbiB0byB0aGUgbWluXG4gKiBhbmQgbWF4IHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZVdyYXBwZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMSBUaGUgc3RhcnQgcG9pbnQge3gseX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiBUaGUgZW5kIHBvaW50IHt4LHl9XG4gKiBAcmV0dXJucyB7bGluZSwgbWluLCBtYXh9XG4gKi9cbkJyZXNlbmhhbS5nZXRCYXJjb2RlTGluZSA9IGZ1bmN0aW9uIChpbWFnZVdyYXBwZXIsIHAxLCBwMikge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbiAgICBsZXQgeDAgPSBwMS54IHwgMDtcbiAgICBsZXQgeTAgPSBwMS55IHwgMDtcbiAgICBsZXQgeDEgPSBwMi54IHwgMDtcbiAgICBsZXQgeTEgPSBwMi55IHwgMDtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gICAgY29uc3Qgc3RlZXAgPSBNYXRoLmFicyh5MSAtIHkwKSA+IE1hdGguYWJzKHgxIC0geDApO1xuICAgIGxldCBlcnJvcjtcbiAgICBsZXQgeTtcbiAgICBsZXQgdG1wO1xuICAgIGxldCB4O1xuICAgIGNvbnN0IGxpbmUgPSBbXTtcbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgbGV0IHZhbDtcbiAgICBsZXQgbWluID0gMjU1O1xuICAgIGxldCBtYXggPSAwO1xuXG4gICAgZnVuY3Rpb24gcmVhZChhLCBiKSB7XG4gICAgICAgIHZhbCA9IGltYWdlRGF0YVtiICogd2lkdGggKyBhXTtcbiAgICAgICAgbWluID0gdmFsIDwgbWluID8gdmFsIDogbWluO1xuICAgICAgICBtYXggPSB2YWwgPiBtYXggPyB2YWwgOiBtYXg7XG4gICAgICAgIGxpbmUucHVzaCh2YWwpO1xuICAgIH1cblxuICAgIGlmIChzdGVlcCkge1xuICAgICAgICB0bXAgPSB4MDtcbiAgICAgICAgeDAgPSB5MDtcbiAgICAgICAgeTAgPSB0bXA7XG5cbiAgICAgICAgdG1wID0geDE7XG4gICAgICAgIHgxID0geTE7XG4gICAgICAgIHkxID0gdG1wO1xuICAgIH1cbiAgICBpZiAoeDAgPiB4MSkge1xuICAgICAgICB0bXAgPSB4MDtcbiAgICAgICAgeDAgPSB4MTtcbiAgICAgICAgeDEgPSB0bXA7XG5cbiAgICAgICAgdG1wID0geTA7XG4gICAgICAgIHkwID0geTE7XG4gICAgICAgIHkxID0gdG1wO1xuICAgIH1cbiAgICBjb25zdCBkZWx0YVggPSB4MSAtIHgwO1xuICAgIGNvbnN0IGRlbHRhWSA9IE1hdGguYWJzKHkxIC0geTApO1xuICAgIGVycm9yID0gKGRlbHRhWCAvIDIpIHwgMDtcbiAgICB5ID0geTA7XG4gICAgY29uc3QgeVN0ZXAgPSB5MCA8IHkxID8gMSA6IC0xO1xuICAgIGZvciAoeCA9IHgwOyB4IDwgeDE7IHgrKykge1xuICAgICAgICBpZiAoc3RlZXApIHtcbiAgICAgICAgICAgIHJlYWQoeSwgeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWFkKHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yIC09IGRlbHRhWTtcbiAgICAgICAgaWYgKGVycm9yIDwgMCkge1xuICAgICAgICAgICAgeSArPSB5U3RlcDtcbiAgICAgICAgICAgIGVycm9yICs9IGRlbHRhWDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIG1pbixcbiAgICAgICAgbWF4LFxuICAgIH07XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSByZXN1bHQgZnJvbSBnZXRCYXJjb2RlTGluZSBpbnRvIGEgYmluYXJ5IHJlcHJlc2VudGF0aW9uXG4gKiBhbHNvIGNvbnNpZGVyaW5nIHRoZSBmcmVxdWVuY3kgYW5kIHNsb3BlIG9mIHRoZSBzaWduYWwgZm9yIG1vcmUgcm9idXN0IHJlc3VsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXN1bHQge2xpbmUsIG1pbiwgbWF4fVxuICovXG5CcmVzZW5oYW0udG9CaW5hcnlMaW5lID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIGNvbnN0IHsgbWluIH0gPSByZXN1bHQ7XG4gICAgY29uc3QgeyBtYXggfSA9IHJlc3VsdDtcbiAgICBjb25zdCB7IGxpbmUgfSA9IHJlc3VsdDtcbiAgICBsZXQgc2xvcGU7XG4gICAgbGV0IHNsb3BlMjtcbiAgICBjb25zdCBjZW50ZXIgPSBtaW4gKyAobWF4IC0gbWluKSAvIDI7XG4gICAgY29uc3QgZXh0cmVtYSA9IFtdO1xuICAgIGxldCBjdXJyZW50RGlyO1xuICAgIGxldCBkaXI7XG4gICAgbGV0IHRocmVzaG9sZCA9IChtYXggLSBtaW4pIC8gMTI7XG4gICAgY29uc3QgclRocmVzaG9sZCA9IC10aHJlc2hvbGQ7XG4gICAgbGV0IGk7XG4gICAgbGV0IGo7XG5cbiAgICAvLyAxLiBmaW5kIGV4dHJlbWFcbiAgICBjdXJyZW50RGlyID0gbGluZVswXSA+IGNlbnRlciA/IFNsb3BlLkRJUi5VUCA6IFNsb3BlLkRJUi5ET1dOO1xuICAgIGV4dHJlbWEucHVzaCh7XG4gICAgICAgIHBvczogMCxcbiAgICAgICAgdmFsOiBsaW5lWzBdLFxuICAgIH0pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICBzbG9wZSA9IChsaW5lW2kgKyAxXSAtIGxpbmVbaV0pO1xuICAgICAgICBzbG9wZTIgPSAobGluZVtpICsgMl0gLSBsaW5lW2kgKyAxXSk7XG4gICAgICAgIGlmICgoc2xvcGUgKyBzbG9wZTIpIDwgclRocmVzaG9sZCAmJiBsaW5lW2kgKyAxXSA8IChjZW50ZXIgKiAxLjUpKSB7XG4gICAgICAgICAgICBkaXIgPSBTbG9wZS5ESVIuRE9XTjtcbiAgICAgICAgfSBlbHNlIGlmICgoc2xvcGUgKyBzbG9wZTIpID4gdGhyZXNob2xkICYmIGxpbmVbaSArIDFdID4gKGNlbnRlciAqIDAuNSkpIHtcbiAgICAgICAgICAgIGRpciA9IFNsb3BlLkRJUi5VUDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpciA9IGN1cnJlbnREaXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudERpciAhPT0gZGlyKSB7XG4gICAgICAgICAgICBleHRyZW1hLnB1c2goe1xuICAgICAgICAgICAgICAgIHBvczogaSxcbiAgICAgICAgICAgICAgICB2YWw6IGxpbmVbaV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN1cnJlbnREaXIgPSBkaXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXh0cmVtYS5wdXNoKHtcbiAgICAgICAgcG9zOiBsaW5lLmxlbmd0aCxcbiAgICAgICAgdmFsOiBsaW5lW2xpbmUubGVuZ3RoIC0gMV0sXG4gICAgfSk7XG5cbiAgICBmb3IgKGogPSBleHRyZW1hWzBdLnBvczsgaiA8IGV4dHJlbWFbMV0ucG9zOyBqKyspIHtcbiAgICAgICAgbGluZVtqXSA9IGxpbmVbal0gPiBjZW50ZXIgPyAwIDogMTtcbiAgICB9XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgZXh0cmVtYSBhbmQgY29udmVydCB0byBiaW5hcnkgYmFzZWQgb24gYXZnIGJldHdlZW4gbWlubWF4XG4gICAgZm9yIChpID0gMTsgaSA8IGV4dHJlbWEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChleHRyZW1hW2kgKyAxXS52YWwgPiBleHRyZW1hW2ldLnZhbCkge1xuICAgICAgICAgICAgdGhyZXNob2xkID0gKGV4dHJlbWFbaV0udmFsICsgKChleHRyZW1hW2kgKyAxXS52YWwgLSBleHRyZW1hW2ldLnZhbCkgLyAzKSAqIDIpIHwgMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IChleHRyZW1hW2kgKyAxXS52YWwgKyAoKGV4dHJlbWFbaV0udmFsIC0gZXh0cmVtYVtpICsgMV0udmFsKSAvIDMpKSB8IDA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGogPSBleHRyZW1hW2ldLnBvczsgaiA8IGV4dHJlbWFbaSArIDFdLnBvczsgaisrKSB7XG4gICAgICAgICAgICBsaW5lW2pdID0gbGluZVtqXSA+IHRocmVzaG9sZCA/IDAgOiAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgdGhyZXNob2xkLFxuICAgIH07XG59O1xuXG4vKipcbiAqIFVzZWQgZm9yIGRldmVsb3BtZW50IG9ubHlcbiAqL1xuQnJlc2VuaGFtLmRlYnVnID0ge1xuICAgIHByaW50RnJlcXVlbmN5KGxpbmUsIGNhbnZhcykge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjYW52YXMud2lkdGggPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSAyNTY7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnYmx1ZSc7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGksIDI1NSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKGksIDI1NSAtIGxpbmVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICBwcmludFBhdHRlcm4obGluZSwgY2FudmFzKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpOyBsZXRcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGxpbmUubGVuZ3RoO1xuICAgICAgICBjdHguZmlsbENvbG9yID0gJ2JsYWNrJztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaW5lW2ldID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGksIDAsIDEsIDEwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnJlc2VuaGFtO1xuIiwiaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xuXG5leHBvcnQgZW51bSBCYXJjb2RlRGlyZWN0aW9uIHtcbiAgICBGb3J3YXJkID0gMSxcbiAgICBSZXZlcnNlID0gLTEsXG59O1xuXG5leHBvcnQgdHlwZSBCYXJjb2RlUmVhZGVyVHlwZSA9IHN0cmluZztcbmV4cG9ydCB0eXBlIEJhcmNvZGVGb3JtYXQgPSBzdHJpbmc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFyY29kZVJlYWRlckNvbmZpZyB7XG4gICAgbm9ybWFsaXplQmFyU3BhY2VXaWR0aD86IGJvb2xlYW4sXG4gICAgc3VwcGxlbWVudHM/OiBBcnJheTxCYXJjb2RlUmVhZGVyVHlwZT4sXG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGVDb3JyZWN0aW9uIHtcbiAgICBiYXI6IG51bWJlcixcbiAgICBzcGFjZTogbnVtYmVyLFxufTtcblxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlUG9zaXRpb24ge1xuICAgIHN0YXJ0OiBudW1iZXIsXG4gICAgc3RhcnRDb3VudGVyPzogbnVtYmVyLFxuICAgIGVuZDogbnVtYmVyLFxuICAgIGVuZENvdW50ZXI/OiBudW1iZXIsXG4gICAgZXJyb3I/OiBudW1iZXIsXG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGVJbmZvIGV4dGVuZHMgQmFyY29kZVBvc2l0aW9uIHtcbiAgICBjb2RlOiBudW1iZXIsXG4gICAgY29ycmVjdGlvbj86IEJhcmNvZGVDb3JyZWN0aW9uLFxufTtcblxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlIHtcbiAgICBjb2RlOiBzdHJpbmcsXG4gICAgY29kZXNldD86IG51bWJlcixcbiAgICBjb3JyZWN0aW9uPzogQmFyY29kZUNvcnJlY3Rpb24sXG4gICAgZGVjb2RlZENvZGVzPzogQXJyYXk8c3RyaW5nIHwgQmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24+LFxuICAgIGRpcmVjdGlvbj86IEJhcmNvZGVEaXJlY3Rpb24sXG4gICAgZW5kOiBudW1iZXIsXG4gICAgZW5kSW5mbz86IEJhcmNvZGVQb3NpdGlvbixcbiAgICBmb3JtYXQ6IEJhcmNvZGVGb3JtYXQsXG4gICAgc3RhcnQ6IG51bWJlcixcbiAgICBzdGFydEluZm86IEJhcmNvZGVQb3NpdGlvbixcbiAgICBzdXBwbGVtZW50PzogQmFyY29kZSxcbn07XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBfcm93OiBBcnJheTxudW1iZXI+ID0gW107XG4gICAgY29uZmlnOiBCYXJjb2RlUmVhZGVyQ29uZmlnID0ge307XG4gICAgc3VwcGxlbWVudHM6IEFycmF5PEJhcmNvZGVSZWFkZXI+ID0gW107XG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwO1xuICAgIEZPUk1BVDogQmFyY29kZUZvcm1hdCA9ICd1bmtub3duJztcbiAgICBDT05GSUdfS0VZUzogQmFyY29kZVJlYWRlckNvbmZpZyA9IHt9O1xuICAgIC8vIFRPRE86IHNob3VsZCBhZGQgQUxQSEFCRVRIX1NUUklORywgQUxQSEFCRVQsIENIQVJBQ1RFUl9FTkNPRElOR1MgdG8gYmFzZSBjbGFzcywgaWYgdGhleVxuICAgIC8vIGFyZSB1c2VmdWwgaW4gbW9zdCByZWFkZXJzLlxuXG4gICAgYWJzdHJhY3QgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlcik6IEJhcmNvZGUgfCBudWxsO1xuXG4gICAgc3RhdGljIGdldCBFeGNlcHRpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBTdGFydE5vdEZvdW5kRXhjZXB0aW9uOiAnU3RhcnQtSW5mbyB3YXMgbm90IGZvdW5kIScsXG4gICAgICAgICAgICBDb2RlTm90Rm91bmRFeGNlcHRpb246ICdDb2RlIGNvdWxkIG5vdCBiZSBmb3VuZCEnLFxuICAgICAgICAgICAgUGF0dGVybk5vdEZvdW5kRXhjZXB0aW9uOiAnUGF0dGVybiBjb3VsZCBub3QgYmUgZm91bmQhJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZzogQmFyY29kZVJlYWRlckNvbmZpZywgc3VwcGxlbWVudHM/OiBBcnJheTxCYXJjb2RlUmVhZGVyPikge1xuXG4gICAgICAgIHRoaXMuX3JvdyA9IFtdO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgaWYgKHN1cHBsZW1lbnRzKSB7XG4gICAgICAgICAgICB0aGlzLnN1cHBsZW1lbnRzID0gc3VwcGxlbWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgX25leHRVbnNldChsaW5lOiBSZWFkb25seUFycmF5PG51bWJlcj4sIHN0YXJ0OiBudW1iZXIgPSAwKTogbnVtYmVyIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFsaW5lW2ldKSByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZS5sZW5ndGg7XG4gICAgfVxuXG4gICAgX21hdGNoUGF0dGVybihjb3VudGVyOiBSZWFkb25seUFycmF5PG51bWJlcj4sIGNvZGU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgbWF4U2luZ2xlRXJyb3I/OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICBsZXQgZXJyb3IgPSAwO1xuICAgICAgICBsZXQgc2luZ2xlRXJyb3IgPSAwO1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IG1vZHVsbyA9IDA7XG4gICAgICAgIGxldCBiYXJXaWR0aCA9IDA7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGxldCBzY2FsZWQgPSAwO1xuXG4gICAgICAgIG1heFNpbmdsZUVycm9yID0gbWF4U2luZ2xlRXJyb3IgfHwgdGhpcy5TSU5HTEVfQ09ERV9FUlJPUiB8fCAxO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IGNvdW50ZXJbaV07XG4gICAgICAgICAgICBtb2R1bG8gKz0gY29kZVtpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VtIDwgbW9kdWxvKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJhcldpZHRoID0gc3VtIC8gbW9kdWxvO1xuICAgICAgICBtYXhTaW5nbGVFcnJvciAqPSBiYXJXaWR0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudCA9IGNvdW50ZXJbaV07XG4gICAgICAgICAgICBzY2FsZWQgPSBjb2RlW2ldICogYmFyV2lkdGg7XG4gICAgICAgICAgICBzaW5nbGVFcnJvciA9IE1hdGguYWJzKGNvdW50IC0gc2NhbGVkKSAvIHNjYWxlZDtcbiAgICAgICAgICAgIGlmIChzaW5nbGVFcnJvciA+IG1heFNpbmdsZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvciArPSBzaW5nbGVFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3IgLyBtb2R1bG87XG4gICAgfVxuXG4gICAgX25leHRTZXQobGluZTogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBvZmZzZXQ6IG51bWJlciA9IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaW5lW2ldKSByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZS5sZW5ndGg7XG4gICAgfVxuXG4gICAgX2NvcnJlY3RCYXJzKGNvdW50ZXI6IEFycmF5PG51bWJlcj4sIGNvcnJlY3Rpb246IG51bWJlciwgaW5kaWNlczogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICBsZXQgbGVuZ3RoID0gaW5kaWNlcy5sZW5ndGg7XG4gICAgICAgIGxldCB0bXAgPSAwO1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHRtcCA9IGNvdW50ZXJbaW5kaWNlc1tsZW5ndGhdXSAqICgxIC0gKCgxIC0gY29ycmVjdGlvbikgLyAyKSk7XG4gICAgICAgICAgICBpZiAodG1wID4gMSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbaW5kaWNlc1tsZW5ndGhdXSA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlY29kZVBhdHRlcm4ocGF0dGVybjogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlUGF0dGVybicsIHBhdHRlcm4pO1xuICAgICAgICB0aGlzLl9yb3cgPSBwYXR0ZXJuO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlUGF0dGVybiBjYWxsaW5nIGRlY29kZScsIHR5cGVvZiB0aGlzLCB0aGlzLmNvbnN0cnVjdG9yLCB0aGlzLkZPUk1BVCwgSlNPTi5zdHJpbmdpZnkodGhpcykpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fZGVjb2RlKCk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaXJzdCByZXN1bHQ9JywgcmVzdWx0KTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2RlY29kZSgpO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldmVyc2VkIHJlc3VsdD0nLCByZXN1bHQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kaXJlY3Rpb24gPSBCYXJjb2RlRGlyZWN0aW9uLlJldmVyc2U7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gdGhpcy5fcm93Lmxlbmd0aCAtIHJlc3VsdC5zdGFydDtcbiAgICAgICAgICAgICAgICByZXN1bHQuZW5kID0gdGhpcy5fcm93Lmxlbmd0aCAtIHJlc3VsdC5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuZGlyZWN0aW9uID0gQmFyY29kZURpcmVjdGlvbi5Gb3J3YXJkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5mb3JtYXQgPSB0aGlzLkZPUk1BVDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nJywgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBfbWF0Y2hSYW5nZShzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgdmFsdWU6IG51bWJlcikge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgc3RhcnQgPSBzdGFydCA8IDAgPyAwIDogc3RhcnQ7XG4gICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIF9maWxsQ291bnRlcnMob2Zmc2V0OiBudW1iZXIgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93KSwgZW5kOiBudW1iZXIgPSB0aGlzLl9yb3cubGVuZ3RoLCBpc1doaXRlOiBib29sZWFuID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBjb3VudGVyczogQXJyYXk8bnVtYmVyPiA9IFtdO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG4gICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnRlcnM7XG4gICAgfVxuXG4gICAgX3RvQ291bnRlcnMoc3RhcnQ6IG51bWJlciwgY291bnRlcnM6IFVpbnQxNkFycmF5IHwgQXJyYXk8bnVtYmVyPikge1xuICAgICAgICBjb25zdCBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fcm93Lmxlbmd0aDtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSAhdGhpcy5fcm93W3N0YXJ0XTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuXG4gICAgICAgIEFycmF5SGVscGVyLmluaXQoY291bnRlcnMsIDApO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBudW1Db3VudGVycykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50ZXJzO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFyY29kZVJlYWRlcjtcbiIsImltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGVDb3JyZWN0aW9uLCBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUsIEJhcmNvZGVJbmZvIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNsYXNzIENvZGUxMjhSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBDT0RFX1NISUZUID0gOTg7XG4gICAgQ09ERV9DID0gOTk7XG4gICAgQ09ERV9CID0gMTAwO1xuICAgIENPREVfQSA9IDEwMTtcbiAgICBTVEFSVF9DT0RFX0EgPSAxMDM7XG4gICAgU1RBUlRfQ09ERV9CID0gMTA0O1xuICAgIFNUQVJUX0NPREVfQyA9IDEwNTtcbiAgICBTVE9QX0NPREUgPSAxMDY7XG4gICAgQ09ERV9QQVRURVJOID0gW1xuICAgICAgICAgICAgWzIsIDEsIDIsIDIsIDIsIDJdLFxuICAgICAgICAgICAgWzIsIDIsIDIsIDEsIDIsIDJdLFxuICAgICAgICAgICAgWzIsIDIsIDIsIDIsIDIsIDFdLFxuICAgICAgICAgICAgWzEsIDIsIDEsIDIsIDIsIDNdLFxuICAgICAgICAgICAgWzEsIDIsIDEsIDMsIDIsIDJdLFxuICAgICAgICAgICAgWzEsIDMsIDEsIDIsIDIsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDIsIDIsIDEsIDNdLFxuICAgICAgICAgICAgWzEsIDIsIDIsIDMsIDEsIDJdLFxuICAgICAgICAgICAgWzEsIDMsIDIsIDIsIDEsIDJdLFxuICAgICAgICAgICAgWzIsIDIsIDEsIDIsIDEsIDNdLFxuICAgICAgICAgICAgWzIsIDIsIDEsIDMsIDEsIDJdLFxuICAgICAgICAgICAgWzIsIDMsIDEsIDIsIDEsIDJdLFxuICAgICAgICAgICAgWzEsIDEsIDIsIDIsIDMsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDIsIDEsIDMsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDIsIDIsIDMsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDMsIDIsIDIsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDMsIDEsIDIsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDMsIDIsIDIsIDFdLFxuICAgICAgICAgICAgWzIsIDIsIDMsIDIsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDIsIDEsIDEsIDMsIDJdLFxuICAgICAgICAgICAgWzIsIDIsIDEsIDIsIDMsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDMsIDIsIDEsIDJdLFxuICAgICAgICAgICAgWzIsIDIsIDMsIDEsIDEsIDJdLFxuICAgICAgICAgICAgWzMsIDEsIDIsIDEsIDMsIDFdLFxuICAgICAgICAgICAgWzMsIDEsIDEsIDIsIDIsIDJdLFxuICAgICAgICAgICAgWzMsIDIsIDEsIDEsIDIsIDJdLFxuICAgICAgICAgICAgWzMsIDIsIDEsIDIsIDIsIDFdLFxuICAgICAgICAgICAgWzMsIDEsIDIsIDIsIDEsIDJdLFxuICAgICAgICAgICAgWzMsIDIsIDIsIDEsIDEsIDJdLFxuICAgICAgICAgICAgWzMsIDIsIDIsIDIsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDIsIDEsIDIsIDNdLFxuICAgICAgICAgICAgWzIsIDEsIDIsIDMsIDIsIDFdLFxuICAgICAgICAgICAgWzIsIDMsIDIsIDEsIDIsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDEsIDMsIDIsIDNdLFxuICAgICAgICAgICAgWzEsIDMsIDEsIDEsIDIsIDNdLFxuICAgICAgICAgICAgWzEsIDMsIDEsIDMsIDIsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDIsIDMsIDEsIDNdLFxuICAgICAgICAgICAgWzEsIDMsIDIsIDEsIDEsIDNdLFxuICAgICAgICAgICAgWzEsIDMsIDIsIDMsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDEsIDMsIDEsIDNdLFxuICAgICAgICAgICAgWzIsIDMsIDEsIDEsIDEsIDNdLFxuICAgICAgICAgICAgWzIsIDMsIDEsIDMsIDEsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDIsIDEsIDMsIDNdLFxuICAgICAgICAgICAgWzEsIDEsIDIsIDMsIDMsIDFdLFxuICAgICAgICAgICAgWzEsIDMsIDIsIDEsIDMsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDMsIDEsIDIsIDNdLFxuICAgICAgICAgICAgWzEsIDEsIDMsIDMsIDIsIDFdLFxuICAgICAgICAgICAgWzEsIDMsIDMsIDEsIDIsIDFdLFxuICAgICAgICAgICAgWzMsIDEsIDMsIDEsIDIsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDEsIDMsIDMsIDFdLFxuICAgICAgICAgICAgWzIsIDMsIDEsIDEsIDMsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDMsIDEsIDEsIDNdLFxuICAgICAgICAgICAgWzIsIDEsIDMsIDMsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDMsIDEsIDMsIDFdLFxuICAgICAgICAgICAgWzMsIDEsIDEsIDEsIDIsIDNdLFxuICAgICAgICAgICAgWzMsIDEsIDEsIDMsIDIsIDFdLFxuICAgICAgICAgICAgWzMsIDMsIDEsIDEsIDIsIDFdLFxuICAgICAgICAgICAgWzMsIDEsIDIsIDEsIDEsIDNdLFxuICAgICAgICAgICAgWzMsIDEsIDIsIDMsIDEsIDFdLFxuICAgICAgICAgICAgWzMsIDMsIDIsIDEsIDEsIDFdLFxuICAgICAgICAgICAgWzMsIDEsIDQsIDEsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDIsIDEsIDQsIDEsIDFdLFxuICAgICAgICAgICAgWzQsIDMsIDEsIDEsIDEsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDEsIDIsIDIsIDRdLFxuICAgICAgICAgICAgWzEsIDEsIDEsIDQsIDIsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDEsIDEsIDIsIDRdLFxuICAgICAgICAgICAgWzEsIDIsIDEsIDQsIDIsIDFdLFxuICAgICAgICAgICAgWzEsIDQsIDEsIDEsIDIsIDJdLFxuICAgICAgICAgICAgWzEsIDQsIDEsIDIsIDIsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDIsIDIsIDEsIDRdLFxuICAgICAgICAgICAgWzEsIDEsIDIsIDQsIDEsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDIsIDEsIDEsIDRdLFxuICAgICAgICAgICAgWzEsIDIsIDIsIDQsIDEsIDFdLFxuICAgICAgICAgICAgWzEsIDQsIDIsIDEsIDEsIDJdLFxuICAgICAgICAgICAgWzEsIDQsIDIsIDIsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDQsIDEsIDIsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDIsIDEsIDEsIDEsIDRdLFxuICAgICAgICAgICAgWzQsIDEsIDMsIDEsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDQsIDEsIDEsIDEsIDJdLFxuICAgICAgICAgICAgWzEsIDMsIDQsIDEsIDEsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDEsIDIsIDQsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDEsIDEsIDQsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDEsIDIsIDQsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDQsIDIsIDEsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDQsIDEsIDEsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDQsIDIsIDEsIDFdLFxuICAgICAgICAgICAgWzQsIDEsIDEsIDIsIDEsIDJdLFxuICAgICAgICAgICAgWzQsIDIsIDEsIDEsIDEsIDJdLFxuICAgICAgICAgICAgWzQsIDIsIDEsIDIsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDIsIDEsIDQsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDQsIDEsIDIsIDFdLFxuICAgICAgICAgICAgWzQsIDEsIDIsIDEsIDIsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDEsIDEsIDQsIDNdLFxuICAgICAgICAgICAgWzEsIDEsIDEsIDMsIDQsIDFdLFxuICAgICAgICAgICAgWzEsIDMsIDEsIDEsIDQsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDQsIDEsIDEsIDNdLFxuICAgICAgICAgICAgWzEsIDEsIDQsIDMsIDEsIDFdLFxuICAgICAgICAgICAgWzQsIDEsIDEsIDEsIDEsIDNdLFxuICAgICAgICAgICAgWzQsIDEsIDEsIDMsIDEsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDMsIDEsIDQsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDQsIDEsIDMsIDFdLFxuICAgICAgICAgICAgWzMsIDEsIDEsIDEsIDQsIDFdLFxuICAgICAgICAgICAgWzQsIDEsIDEsIDEsIDMsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDEsIDQsIDEsIDJdLFxuICAgICAgICAgICAgWzIsIDEsIDEsIDIsIDEsIDRdLFxuICAgICAgICAgICAgWzIsIDEsIDEsIDIsIDMsIDJdLFxuICAgICAgICAgICAgWzIsIDMsIDMsIDEsIDEsIDEsIDJdLFxuICAgICAgICBdO1xuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMC42NDtcbiAgICBBVkdfQ09ERV9FUlJPUiA9IDAuMzA7XG4gICAgRk9STUFUID0gJ2NvZGVfMTI4JztcbiAgICBNT0RVTEVfSU5ESUNFUyA9IHsgYmFyOiBbMCwgMiwgNF0sIHNwYWNlOiBbMSwgMywgNV0gfTtcblxuICAgIF9kZWNvZGVDb2RlKHN0YXJ0OiBudW1iZXIsIGNvcnJlY3Rpb24/OiBCYXJjb2RlQ29ycmVjdGlvbikge1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBzdGFydCxcbiAgICAgICAgICAgIGNvcnJlY3Rpb246IHtcbiAgICAgICAgICAgICAgICBiYXI6IDEsXG4gICAgICAgICAgICAgICAgc3BhY2U6IDEsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY291bnRlciA9IFswLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgICAgIGxldCBpc1doaXRlID0gIXRoaXMuX3Jvd1tvZmZzZXRdO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3JyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb3JyZWN0KGNvdW50ZXIsIGNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvZGUgPSAwOyBjb2RlIDwgdGhpcy5DT0RFX1BBVFRFUk4ubGVuZ3RoOyBjb2RlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHRoaXMuQ09ERV9QQVRURVJOW2NvZGVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3RNYXRjaC5jb2RlID09PSAtMSB8fCBiZXN0TWF0Y2guZXJyb3IgPiB0aGlzLkFWR19DT0RFX0VSUk9SKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5iYXIgPSB0aGlzLmNhbGN1bGF0ZUNvcnJlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTU9EVUxFX0lORElDRVMuYmFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb3JyZWN0aW9uLnNwYWNlID0gdGhpcy5jYWxjdWxhdGVDb3JyZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSwgY291bnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLk1PRFVMRV9JTkRJQ0VTLnNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfY29ycmVjdChjb3VudGVyOiBBcnJheTxudW1iZXI+LCBjb3JyZWN0aW9uOiBCYXJjb2RlQ29ycmVjdGlvbikge1xuICAgICAgICB0aGlzLl9jb3JyZWN0QmFycyhjb3VudGVyLCBjb3JyZWN0aW9uLmJhciwgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xuICAgICAgICB0aGlzLl9jb3JyZWN0QmFycyhjb3VudGVyLCBjb3JyZWN0aW9uLnNwYWNlLCB0aGlzLk1PRFVMRV9JTkRJQ0VTLnNwYWNlKTtcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogX2ZpbmRTdGFydCBhbmQgZGVjb2RlQ29kZSBzaGFyZSBzaW1pbGFyIGNvZGUsIGNhbiB3ZSByZS11c2Ugc29tZT9cbiAgICBfZmluZFN0YXJ0KCkge1xuICAgICAgICBjb25zdCBjb3VudGVyID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMCxcbiAgICAgICAgICAgIGNvcnJlY3Rpb246IHtcbiAgICAgICAgICAgICAgICBiYXI6IDEsXG4gICAgICAgICAgICAgICAgc3BhY2U6IDEsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgaXNXaGl0ZSA9IGZhbHNlO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1bSA9IGNvdW50ZXIucmVkdWNlKChwcmV2LCBuZXh0KSA9PiBwcmV2ICsgbmV4dCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvZGUgPSB0aGlzLlNUQVJUX0NPREVfQTsgY29kZSA8PSB0aGlzLlNUQVJUX0NPREVfQzsgY29kZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCB0aGlzLkNPREVfUEFUVEVSTltjb2RlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3RNYXRjaC5lcnJvciA8IHRoaXMuQVZHX0NPREVfRVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBzdW07XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb3JyZWN0aW9uLmJhciA9IHRoaXMuY2FsY3VsYXRlQ29ycmVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uc3BhY2UgPSB0aGlzLmNhbGN1bGF0ZUNvcnJlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTU9EVUxFX0lORElDRVMuc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls0XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbNV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuICAgICAgICBpZiAoc3RhcnRJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIC8vICAgICBkb25lID0gZmFsc2UsXG4gICAgICAgIC8vICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgLy8gICAgIG11bHRpcGxpZXIgPSAwLFxuICAgICAgICAvLyAgICAgY2hlY2tzdW0gPSAwLFxuICAgICAgICAvLyAgICAgY29kZXNldCxcbiAgICAgICAgLy8gICAgIHJhd1Jlc3VsdCA9IFtdLFxuICAgICAgICAvLyAgICAgZGVjb2RlZENvZGVzID0gW10sXG4gICAgICAgIC8vICAgICBzaGlmdE5leHQgPSBmYWxzZSxcbiAgICAgICAgLy8gICAgIHVuc2hpZnQsXG4gICAgICAgIC8vICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gdHJ1ZTtcblxuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBudWxsID0ge1xuICAgICAgICAgICAgY29kZTogc3RhcnRJbmZvLmNvZGUsXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBzdGFydEluZm8uZW5kLFxuICAgICAgICAgICAgY29ycmVjdGlvbjoge1xuICAgICAgICAgICAgICAgIGJhcjogc3RhcnRJbmZvLmNvcnJlY3Rpb24uYmFyLFxuICAgICAgICAgICAgICAgIHNwYWNlOiBzdGFydEluZm8uY29ycmVjdGlvbi5zcGFjZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGRlY29kZWRDb2RlcyA9IFtdO1xuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgbGV0IGNoZWNrc3VtID0gY29kZS5jb2RlO1xuICAgICAgICBsZXQgY29kZXNldCA9ICgoYzogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RBUlRfQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5DT0RFX0E7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUQVJUX0NPREVfQjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ09ERV9CO1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVEFSVF9DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkNPREVfQztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoY29kZS5jb2RlKTtcbiAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgbGV0IHNoaWZ0TmV4dCA9IGZhbHNlO1xuICAgICAgICBsZXQgdW5zaGlmdCA9IHNoaWZ0TmV4dDtcbiAgICAgICAgbGV0IHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSB0cnVlO1xuICAgICAgICBsZXQgbXVsdGlwbGllciA9IDA7XG4gICAgICAgIGxldCByYXdSZXN1bHQ6IEFycmF5PG51bWJlcj4gPSBbXTtcbiAgICAgICAgbGV0IHJlc3VsdDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPiA9IFtdOyAvLyBUT0RPOiBpIHRoaW5rIHRoaXMgc2hvdWxkIGJlIHN0cmluZyBvbmx5LCBidXQgaXQgY3JlYXRlcyBwcm9ibGVtcyBpZiBpdCBpc1xuXG4gICAgICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgICAgICAgdW5zaGlmdCA9IHNoaWZ0TmV4dDtcbiAgICAgICAgICAgIHNoaWZ0TmV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUoY29kZSEuZW5kLCBjb2RlIS5jb3JyZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChjb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmF3UmVzdWx0LnB1c2goY29kZS5jb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGllcisrO1xuICAgICAgICAgICAgICAgICAgICBjaGVja3N1bSArPSBtdWx0aXBsaWVyICogY29kZS5jb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZXNldCkge1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0E6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPCA2NCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgzMiArIGNvZGUuY29kZSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUuY29kZSA8IDk2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUuY29kZSAtIDY0KSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9TSElGVDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdE5leHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RPUF9DT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPCA5Nikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgzMiArIGNvZGUuY29kZSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX1NISUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdE5leHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0E6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9DO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RPUF9DT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA8IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlIDwgMTAgPyAnMCcgKyBjb2RlLmNvZGUgOiBjb2RlLmNvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9COlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVE9QX0NPREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bnNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgY29kZXNldCA9IGNvZGVzZXQgPT09IHRoaXMuQ09ERV9BID8gdGhpcy5DT0RFX0IgOiB0aGlzLkNPREVfQTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUuZW5kID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3JvdywgY29kZS5lbmQpO1xuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShjb2RlKSl7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoZWNrc3VtIC09IG11bHRpcGxpZXIgKiByYXdSZXN1bHRbcmF3UmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoY2hlY2tzdW0gJSAxMDMgIT09IHJhd1Jlc3VsdFtyYXdSZXN1bHQubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBsYXN0IGNvZGUgZnJvbSByZXN1bHQgKGNoZWNrc3VtKVxuICAgICAgICBpZiAocmVtb3ZlTGFzdENoYXJhY3Rlcikge1xuICAgICAgICAgICAgcmVzdWx0LnNwbGljZShyZXN1bHQubGVuZ3RoIC0gMSwgMSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBjb2RlLmVuZCxcbiAgICAgICAgICAgIGNvZGVzZXQ6IGNvZGVzZXQgYXMgbnVtYmVyLFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8sXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXM6IGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIGVuZEluZm86IGNvZGUsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVJbmZvKTogQmFyY29kZUluZm8gfCBudWxsIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQ7XG5cbiAgICAgICAgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHNlbGYuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuXG4gICAgY2FsY3VsYXRlQ29ycmVjdGlvbihleHBlY3RlZDogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBub3JtYWxpemVkOiBSZWFkb25seUFycmF5PG51bWJlcj4sIGluZGljZXM6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPik6IG51bWJlciB7XG4gICAgICAgIHZhciBsZW5ndGggPSBpbmRpY2VzLmxlbmd0aCxcbiAgICAgICAgICAgIHN1bU5vcm1hbGl6ZWQgPSAwLFxuICAgICAgICAgICAgc3VtRXhwZWN0ZWQgPSAwO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgc3VtRXhwZWN0ZWQgKz0gZXhwZWN0ZWRbaW5kaWNlc1tsZW5ndGhdXTtcbiAgICAgICAgICAgIHN1bU5vcm1hbGl6ZWQgKz0gbm9ybWFsaXplZFtpbmRpY2VzW2xlbmd0aF1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW1FeHBlY3RlZCAvIHN1bU5vcm1hbGl6ZWQ7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2RlMTI4UmVhZGVyO1xuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZVJlYWRlckNvbmZpZywgQmFyY29kZUluZm8sIEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IHsgbWVyZ2UgfSBmcm9tICdsb2Rhc2gnO1xuXG4vLyBjb25zdCBDT0RFX0xfU1RBUlQgPSAwO1xuY29uc3QgQ09ERV9HX1NUQVJUID0gMTA7XG5leHBvcnQgeyBDT0RFX0dfU1RBUlQgfTtcbmNvbnN0IFNUQVJUX1BBVFRFUk4gPSBbMSwgMSwgMV07XG5jb25zdCBNSURETEVfUEFUVEVSTiA9IFsxLCAxLCAxLCAxLCAxXTtcbmV4cG9ydCB7IE1JRERMRV9QQVRURVJOIH07XG5jb25zdCBFWFRFTlNJT05fU1RBUlRfUEFUVEVSTiA9IFsxLCAxLCAyXTtcbmNvbnN0IENPREVfUEFUVEVSTiA9IFtcbiAgICBbMywgMiwgMSwgMV0sXG4gICAgWzIsIDIsIDIsIDFdLFxuICAgIFsyLCAxLCAyLCAyXSxcbiAgICBbMSwgNCwgMSwgMV0sXG4gICAgWzEsIDEsIDMsIDJdLFxuICAgIFsxLCAyLCAzLCAxXSxcbiAgICBbMSwgMSwgMSwgNF0sXG4gICAgWzEsIDMsIDEsIDJdLFxuICAgIFsxLCAyLCAxLCAzXSxcbiAgICBbMywgMSwgMSwgMl0sXG4gICAgWzEsIDEsIDIsIDNdLFxuICAgIFsxLCAyLCAyLCAyXSxcbiAgICBbMiwgMiwgMSwgMl0sXG4gICAgWzEsIDEsIDQsIDFdLFxuICAgIFsyLCAzLCAxLCAxXSxcbiAgICBbMSwgMywgMiwgMV0sXG4gICAgWzQsIDEsIDEsIDFdLFxuICAgIFsyLCAxLCAzLCAxXSxcbiAgICBbMywgMSwgMiwgMV0sXG4gICAgWzIsIDEsIDEsIDNdLFxuXTtcbmNvbnN0IENPREVfRlJFUVVFTkNZID0gWzAsIDExLCAxMywgMTQsIDE5LCAyNSwgMjgsIDIxLCAyMiwgMjZdO1xuLy8gY29uc3QgU0lOR0xFX0NPREVfRVJST1IgPSAwLjcwO1xuY29uc3QgQVZHX0NPREVfRVJST1IgPSAwLjQ4O1xuXG5jbGFzcyBFQU5SZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnZWFuXzEzJztcbiAgICBTSU5HTEVfQ09ERV9FUlJPUiA9IDAuNzA7XG4gICAgU1RPUF9QQVRURVJOID0gWzEsIDEsIDFdOyAvLyBUT0RPOiBkb2VzIHRoaXMgbmVlZCB0byBiZSBpbiB0aGUgY2xhc3M/XG5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWc/OiBCYXJjb2RlUmVhZGVyQ29uZmlnLCBzdXBwbGVtZW50cz86IEFycmF5PEJhcmNvZGVSZWFkZXI+KSB7XG4gICAgICAgIHN1cGVyKG1lcmdlKHsgc3VwcGxlbWVudHM6IFtdIH0sIGNvbmZpZyksIHN1cHBsZW1lbnRzKTtcbiAgICB9XG4gICAgX2ZpbmRQYXR0ZXJuKHBhdHRlcm46IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgb2Zmc2V0OiBudW1iZXIsIGlzV2hpdGU6IGJvb2xlYW4sIHRyeUhhcmRlcjogYm9vbGVhbik6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IEFycmF5PG51bWJlcj4ocGF0dGVybi5sZW5ndGgpLmZpbGwoMCk7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaDogQmFyY29kZVBvc2l0aW9uID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlcHNpbG9uID0gQVZHX0NPREVfRVJST1I7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaW5kUGF0dGVybicsIHBhdHRlcm4sIG9mZnNldCwgaXNXaGl0ZSwgdHJ5SGFyZGVyLCBlcHNpbG9uKTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBpZiAoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oYCogbG9vcCBpPSR7b2Zmc2V0fSBsZW49JHt0aGlzLl9yb3cubGVuZ3RofSBpc1doaXRlPSR7aXNXaGl0ZX0gY291bnRlclBvcz0ke2NvdW50ZXJQb3N9YCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdICs9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgcGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBtYXRjaFBhdHRlcm4nLCBlcnJvciwgY291bnRlciwgcGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGVwc2lsb24gJiYgYmVzdE1hdGNoLmVycm9yICYmIGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBjb3VudGVyLnJlZHVjZSgoc3VtLCB2YWx1ZSkgPT4gc3VtICsgdmFsdWUsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIGJlc3RNYXRjaCcsIEpTT04uc3RyaW5naWZ5KGJlc3RNYXRjaCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHJ5SGFyZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoIC0gMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDJdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gYmVzdE1hdGNoJywgSlNPTi5zdHJpbmdpZnkoYmVzdE1hdGNoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQgPyBiZXN0TWF0Y2ggOiBudWxsO1xuICAgIH1cblxuICAgIC8vIFRPRE86IGZpbmRQYXR0ZXJuIGFuZCBkZWNvZGVDb2RlIGFwcGVhciB0byBzaGFyZSBxdWl0ZSBzaW1pbGFyIGNvZGUsIGNhbiBpdCBiZSByZWR1Y2VkP1xuICAgIF9kZWNvZGVDb2RlKHN0YXJ0OiBudW1iZXIsIGNvZGVyYW5nZT86IG51bWJlcik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVDb2RlJywgc3RhcnQsIGNvZGVyYW5nZSk7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHN0YXJ0O1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2g6IEJhcmNvZGVJbmZvID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogc3RhcnRcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IEFWR19DT0RFX0VSUk9SO1xuICAgICAgICBsZXQgaXNXaGl0ZSA9ICF0aGlzLl9yb3dbb2Zmc2V0XTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuXG4gICAgICAgIGlmICghY29kZXJhbmdlKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZSBiZWZvcmUgbGVuZ3RoJyk7XG4gICAgICAgICAgICBjb2RlcmFuZ2UgPSBDT0RFX1BBVFRFUk4ubGVuZ3RoO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGUgYWZ0ZXIgbGVuZ3RoJyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvZGUgPSAwOyBjb2RlIDwgY29kZXJhbmdlOyBjb2RlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIENPREVfUEFUVEVSTltjb2RlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaC5lcnJvciEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3RNYXRjaC5lcnJvciEgPiBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gYmVzdE1hdGNoJywgSlNPTi5zdHJpbmdpZnkoYmVzdE1hdGNoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kID8gYmVzdE1hdGNoIDogbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRTdGFydCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpbmRTdGFydCcpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBsZXQgc3RhcnRJbmZvOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgc3RhcnRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4oU1RBUlRfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogc3RhcnRJbmZvPScsIEpTT04uc3RyaW5naWZ5KHN0YXJ0SW5mbykpO1xuICAgICAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IHN0YXJ0SW5mby5zdGFydCAtIChzdGFydEluZm8uZW5kIC0gc3RhcnRJbmZvLnN0YXJ0KTtcblxuICAgICAgICAgICAgaWYgKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQsIHN0YXJ0SW5mby5zdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZyBzdGFydEluZm8nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0SW5mbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9mZnNldCA9IHN0YXJ0SW5mby5lbmQ7XG4gICAgICAgICAgICBzdGFydEluZm8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm5pbmcgbnVsbCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9jYWxjdWxhdGVGaXJzdERpZ2l0KGNvZGVGcmVxdWVuY3k6IG51bWJlcik6IG51bWJlciB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogY2FsY3VsYXRlRmlyc3REaWdpdCcsIGNvZGVGcmVxdWVuY3kpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENPREVfRlJFUVVFTkNZLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY29kZUZyZXF1ZW5jeSA9PT0gQ09ERV9GUkVRVUVOQ1lbaV0pIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nJywgaSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZGVjb2RlUGF5bG9hZChpbkNvZGU6IEJhcmNvZGVQb3NpdGlvbiwgcmVzdWx0OiBBcnJheTxudW1iZXI+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVQb3NpdGlvbj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlUGF5bG9hZCcsIGluQ29kZSwgcmVzdWx0LCBkZWNvZGVkQ29kZXMpO1xuICAgICAgICBsZXQgb3V0Q29kZTogQmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0geyAuLi5pbkNvZGUgfTtcbiAgICAgICAgbGV0IGNvZGVGcmVxdWVuY3kgPSAweDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgIG91dENvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKG91dENvZGUuZW5kKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVDb2RlPScsIG91dENvZGUpO1xuICAgICAgICAgICAgaWYgKCFvdXRDb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUgPj0gQ09ERV9HX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUgLT0gQ09ERV9HX1NUQVJUO1xuICAgICAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMSA8PCAoNSAtIGkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDAgPDwgKDUgLSBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlKTtcbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKG91dENvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmlyc3REaWdpdCA9IHRoaXMuX2NhbGN1bGF0ZUZpcnN0RGlnaXQoY29kZUZyZXF1ZW5jeSk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaXJzdERpZ2l0PScsIGZpcnN0RGlnaXQpO1xuICAgICAgICBpZiAoZmlyc3REaWdpdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KGZpcnN0RGlnaXQpO1xuXG4gICAgICAgIGxldCBtaWRkbGVQYXR0ZXJuID0gdGhpcy5fZmluZFBhdHRlcm4oTUlERExFX1BBVFRFUk4sIG91dENvZGUuZW5kLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaW5kUGF0dGVybj0nLCBKU09OLnN0cmluZ2lmeShtaWRkbGVQYXR0ZXJuKSk7XG5cbiAgICAgICAgaWYgKG1pZGRsZVBhdHRlcm4gPT09IG51bGwgfHwgIW1pZGRsZVBhdHRlcm4uZW5kKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2gobWlkZGxlUGF0dGVybik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgIG1pZGRsZVBhdHRlcm4gPSB0aGlzLl9kZWNvZGVDb2RlKG1pZGRsZVBhdHRlcm4hLmVuZCwgQ09ERV9HX1NUQVJUKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVDb2RlPScsIEpTT04uc3RyaW5naWZ5KG1pZGRsZVBhdHRlcm4pKTtcblxuICAgICAgICAgICAgaWYgKCFtaWRkbGVQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKG1pZGRsZVBhdHRlcm4pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKG1pZGRsZVBhdHRlcm4gYXMgQmFyY29kZUluZm8pLmNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGVuZCBjb2RlPScsIEpTT04uc3RyaW5naWZ5KG1pZGRsZVBhdHRlcm4pKTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGVuZCByZXN1bHQ9JywgSlNPTi5zdHJpbmdpZnkocmVzdWx0KSk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgZGVjb2RlZENvZGVzPScsIGRlY29kZWRDb2Rlcyk7XG4gICAgICAgIHJldHVybiBtaWRkbGVQYXR0ZXJuIGFzIEJhcmNvZGVJbmZvO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlJywgSlNPTi5zdHJpbmdpZnkoZW5kSW5mbykpO1xuICAgICAgICBjb25zdCB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArIChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpO1xuXG4gICAgICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCB0aGlzLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm5pbmcnLCBKU09OLnN0cmluZ2lmeShlbmRJbmZvKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZmluZEVuZChvZmZzZXQ6IG51bWJlciwgaXNXaGl0ZTogYm9vbGVhbik6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmluZEVuZCcsIG9mZnNldCwgaXNXaGl0ZSk7XG4gICAgICAgIGNvbnN0IGVuZEluZm8gPSB0aGlzLl9maW5kUGF0dGVybih0aGlzLlNUT1BfUEFUVEVSTiwgb2Zmc2V0LCBpc1doaXRlLCBmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuIGVuZEluZm8gIT09IG51bGwgPyB0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykgOiBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfY2hlY2tzdW0ocmVzdWx0OiBBcnJheTxudW1iZXI+KTogYm9vbGVhbiB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBfY2hlY2tzdW0nLCByZXN1bHQpO1xuICAgICAgICBsZXQgc3VtID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gcmVzdWx0Lmxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgICAgICBzdW0gKz0gcmVzdWx0W2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VtICo9IDM7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHJlc3VsdC5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICAgICAgc3VtICs9IHJlc3VsdFtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgY2hlY2tzdW0nLCBzdW0gJSAxMCA9PT0gMCk7XG4gICAgICAgIHJldHVybiBzdW0gJSAxMCA9PT0gMDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9kZWNvZGVFeHRlbnNpb25zKG9mZnNldDogbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBvZmZzZXQpO1xuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kUGF0dGVybihFWFRFTlNJT05fU1RBUlRfUEFUVEVSTiwgc3RhcnQsIGZhbHNlLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKHN0YXJ0SW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlRXh0ZW5zaW9ucycsIHRoaXMuc3VwcGxlbWVudHMpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogdGhlcmUgYXJlICcsIHRoaXMuc3VwcGxlbWVudHMubGVuZ3RoLCAnIHN1cHBsZW1lbnRzJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdXBwbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGV4dGVuc2lvbnMgbG9vcCcsIGksIHRoaXMuc3VwcGxlbWVudHNbaV0sIHRoaXMuc3VwcGxlbWVudHNbaV0uX2RlY29kZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnN1cHBsZW1lbnRzW2ldLl9kZWNvZGUodGhpcy5fcm93LCBzdGFydEluZm8uZW5kKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlIHJlc3VsdD0nLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5jb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHJlc3VsdC5lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ29kZXM6IHJlc3VsdC5kZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IHRoaXMuc3VwcGxlbWVudHNbaV0uRk9STUFULFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJyogZGVjb2RlRXh0ZW5zaW9ucyBlcnJvciBpbiAnLCB0aGlzLnN1cHBsZW1lbnRzW2ldLCAnOiAnLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGVuZCBkZWNvZGVFeHRlbnNpb25zJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGUnLCByb3cpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlJywgc3RhcnQpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXk8bnVtYmVyPigpO1xuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBuZXcgQXJyYXk8QmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24+KCk7XG4gICAgICAgIGxldCByZXN1bHRJbmZvOiBCYXJjb2RlIHwge30gPSB7fTtcbiAgICAgICAgbGV0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuXG4gICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlUG9zaXRpb24gfCBCYXJjb2RlSW5mbyB8IG51bGwgPSB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBzdGFydEluZm8uZW5kXG4gICAgICAgIH07XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuXG4gICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVQYXlsb2FkKGNvZGUsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcblxuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZSA9IHRoaXMuX2ZpbmRFbmQoY29kZS5lbmQsIGZhbHNlKTtcblxuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG5cbiAgICAgICAgLy8gQ2hlY2tzdW1cbiAgICAgICAgaWYgKCF0aGlzLl9jaGVja3N1bShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiB0aGlzLnN1cHBsZW1lbnRzPScsIHRoaXMuc3VwcGxlbWVudHMpO1xuICAgICAgICBpZiAodGhpcy5zdXBwbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBzdXBwbGVtZW50ID0gdGhpcy5fZGVjb2RlRXh0ZW5zaW9ucyhjb2RlLmVuZCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlRXh0ZW5zaW9ucyByZXR1cm5zJywgc3VwcGxlbWVudCk7XG4gICAgICAgICAgICBpZiAoIXN1cHBsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFzdXBwbGVtZW50LmRlY29kZWRDb2Rlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBsYXN0Q29kZSA9IHN1cHBsZW1lbnQuZGVjb2RlZENvZGVzW3N1cHBsZW1lbnQuZGVjb2RlZENvZGVzLmxlbmd0aCAtIDFdIGFzIEJhcmNvZGVJbmZvO1xuICAgICAgICAgICAgY29uc3QgZW5kSW5mbyA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogbGFzdENvZGUuc3RhcnQgKyAoKChsYXN0Q29kZS5lbmQgLSBsYXN0Q29kZS5zdGFydCkgLyAyKSB8IDApLFxuICAgICAgICAgICAgICAgIGVuZDogbGFzdENvZGUuZW5kXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHRJbmZvID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsZW1lbnQsXG4gICAgICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpICsgc3VwcGxlbWVudC5jb2RlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGNvZGUuZW5kLFxuICAgICAgICAgICAgc3RhcnRJbmZvLFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgLi4ucmVzdWx0SW5mbyxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFQU5SZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcblxuY29uc3QgQUxQSEFCRVRIX1NUUklORyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotLiAqJC8rJSc7XG5jb25zdCBBTFBIQUJFVCA9IG5ldyBVaW50MTZBcnJheShbLi4uQUxQSEFCRVRIX1NUUklOR10ubWFwKGNoYXIgPT4gY2hhci5jaGFyQ29kZUF0KDApKSk7XG5jb25zdCBDSEFSQUNURVJfRU5DT0RJTkdTID0gbmV3IFVpbnQxNkFycmF5KFtcbiAgICAweDAzNCwgMHgxMjEsIDB4MDYxLCAweDE2MCwgMHgwMzEsIDB4MTMwLCAweDA3MCwgMHgwMjUsIDB4MTI0LCAweDA2NCwgMHgxMDksIDB4MDQ5LFxuICAgIDB4MTQ4LCAweDAxOSwgMHgxMTgsIDB4MDU4LCAweDAwRCwgMHgxMEMsIDB4MDRDLCAweDAxQywgMHgxMDMsIDB4MDQzLCAweDE0MiwgMHgwMTMsIDB4MTEyLCAweDA1MiwgMHgwMDcsIDB4MTA2LFxuICAgIDB4MDQ2LCAweDAxNiwgMHgxODEsIDB4MEMxLCAweDFDMCwgMHgwOTEsIDB4MTkwLCAweDBEMCwgMHgwODUsIDB4MTg0LCAweDBDNCwgMHgwOTQsIDB4MEE4LCAweDBBMiwgMHgwOEEsIDB4MDJBLFxuXSk7XG5jb25zdCBBU1RFUklTSyA9IDB4MDk0O1xuXG5jbGFzcyBDb2RlMzlSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnY29kZV8zOSc7XG5cbiAgICBfZmluZFN0YXJ0KCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBwYXR0ZXJuU3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgVWludDE2QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBsZXQgaXNXaGl0ZSA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHN0YXJ0IHBhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RvUGF0dGVybihjb3VudGVyKSA9PT0gQVNURVJJU0spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdoaXRlU3BhY2VNdXN0U3RhcnQgPSBNYXRoLmZsb29yKE1hdGgubWF4KDAsIHBhdHRlcm5TdGFydCAtICgoaSAtIHBhdHRlcm5TdGFydCkgLyA0KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2Uod2hpdGVTcGFjZU11c3RTdGFydCwgcGF0dGVyblN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwYXR0ZXJuU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0YXJ0ICs9IGNvdW50ZXJbMF0gKyBjb3VudGVyWzFdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbN10gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzhdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfdG9QYXR0ZXJuKGNvdW50ZXJzOiBVaW50MTZBcnJheSkge1xuICAgICAgICBjb25zdCBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgbGV0IG1heE5hcnJvd1dpZHRoID0gMDtcbiAgICAgICAgbGV0IG51bVdpZGVCYXJzID0gbnVtQ291bnRlcnM7XG4gICAgICAgIGxldCB3aWRlQmFyV2lkdGggPSAwO1xuXG4gICAgICAgIHdoaWxlIChudW1XaWRlQmFycyA+IDMpIHtcbiAgICAgICAgICAgIG1heE5hcnJvd1dpZHRoID0gdGhpcy5fZmluZE5leHRXaWR0aChjb3VudGVycywgbWF4TmFycm93V2lkdGgpO1xuICAgICAgICAgICAgbnVtV2lkZUJhcnMgPSAwO1xuICAgICAgICAgICAgbGV0IHBhdHRlcm4gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJzW2ldID4gbWF4TmFycm93V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiB8PSAxIDw8IChudW1Db3VudGVycyAtIDEgLSBpKTtcbiAgICAgICAgICAgICAgICAgICAgbnVtV2lkZUJhcnMrKztcbiAgICAgICAgICAgICAgICAgICAgd2lkZUJhcldpZHRoICs9IGNvdW50ZXJzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG51bVdpZGVCYXJzID09PSAzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVycyAmJiBudW1XaWRlQmFycyA+IDA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlcnNbaV0gPiBtYXhOYXJyb3dXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtV2lkZUJhcnMtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY291bnRlcnNbaV0gKiAyKSA+PSB3aWRlQmFyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICBfZmluZE5leHRXaWR0aChjb3VudGVyczogVWludDE2QXJyYXksIGN1cnJlbnQ6IG51bWJlcikge1xuICAgICAgICBsZXQgbWluV2lkdGggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjb3VudGVyc1tpXSA8IG1pbldpZHRoICYmIGNvdW50ZXJzW2ldID4gY3VycmVudCkge1xuICAgICAgICAgICAgICAgIG1pbldpZHRoID0gY291bnRlcnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWluV2lkdGg7XG4gICAgfTtcblxuICAgIF9wYXR0ZXJuVG9DaGFyKHBhdHRlcm46IG51bWJlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENIQVJBQ1RFUl9FTkNPRElOR1MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChDSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoQUxQSEFCRVRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGxhc3RTdGFydDogbnVtYmVyLCBuZXh0U3RhcnQ6IG51bWJlciwgY291bnRlcnM6IFVpbnQxNkFycmF5KSB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm5TaXplID0gQXJyYXlIZWxwZXIuc3VtKGNvdW50ZXJzKTtcblxuICAgICAgICBjb25zdCB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBuZXh0U3RhcnQgLSBsYXN0U3RhcnQgLSBwYXR0ZXJuU2l6ZTtcbiAgICAgICAgaWYgKCh0cmFpbGluZ1doaXRlc3BhY2VFbmQgKiAzKSA+PSBwYXR0ZXJuU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyIHwgbnVsbCk6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgbGV0IGNvdW50ZXJzID0gbmV3IFVpbnQxNkFycmF5KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICAgICAgICBzdGFydCA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuXG4gICAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0U3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdywgc3RhcnQuZW5kKTtcblxuICAgICAgICBsZXQgZGVjb2RlZENoYXI7XG4gICAgICAgIGxldCBsYXN0U3RhcnQ6IG51bWJlcjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY291bnRlcnMgPSB0aGlzLl90b0NvdW50ZXJzKG5leHRTdGFydCwgY291bnRlcnMpIGFzIFVpbnQxNkFycmF5O1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHRoaXMuX3RvUGF0dGVybihjb3VudGVycyk7XG4gICAgICAgICAgICBpZiAocGF0dGVybiA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRDaGFyID0gdGhpcy5fcGF0dGVyblRvQ2hhcihwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChkZWNvZGVkQ2hhciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZENoYXIpO1xuICAgICAgICAgICAgbGFzdFN0YXJ0ID0gbmV4dFN0YXJ0O1xuICAgICAgICAgICAgbmV4dFN0YXJ0ICs9IEFycmF5SGVscGVyLnN1bShjb3VudGVycyk7XG4gICAgICAgICAgICBuZXh0U3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3JvdywgbmV4dFN0YXJ0KTtcbiAgICAgICAgfSB3aGlsZSAoZGVjb2RlZENoYXIgIT09ICcqJyk7XG4gICAgICAgIHJlc3VsdC5wb3AoKTtcblxuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UobGFzdFN0YXJ0LCBuZXh0U3RhcnQsIGNvdW50ZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBuZXh0U3RhcnQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0LFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2RlMzlSZWFkZXI7XG4iLCJpbXBvcnQgQ29kZTM5UmVhZGVyIGZyb20gJy4vY29kZV8zOV9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNvbnN0IHBhdHRlcm5zID0ge1xuICAgIElPUTogL1tJT1FdL2csXG4gICAgQVowOTogL1tBLVowLTldezE3fS8sXG59O1xuXG5jbGFzcyBDb2RlMzlWSU5SZWFkZXIgZXh0ZW5kcyBDb2RlMzlSZWFkZXIge1xuICAgIEZPUk1BVCA9ICdjb2RlXzM5X3Zpbic7XG5cbiAgICAvLyBUT0RPICh0aGlzIHdhcyB0b2RvIGluIG9yaWdpbmFsIHJlcG8sIG5vIHRleHQgd2FzIHRoZXJlLiBzb3JyeS4pXG4gICAgX2NoZWNrQ2hlY2tzdW0oY29kZTogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiAhIWNvZGU7XG4gICAgfVxuXG4gICAgLy8gQ3JpYmJlZCBmcm9tOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96eGluZy96eGluZy9ibG9iL21hc3Rlci9jb3JlL3NyYy9tYWluL2phdmEvY29tL2dvb2dsZS96eGluZy9jbGllbnQvcmVzdWx0L1ZJTlJlc3VsdFBhcnNlci5qYXZhXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuX2RlY29kZShyb3csIHN0YXJ0KTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvZGUgPSByZXN1bHQuY29kZTtcblxuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShwYXR0ZXJucy5JT1EsICcnKTtcblxuICAgICAgICBpZiAoIWNvZGUubWF0Y2gocGF0dGVybnMuQVowOSkpIHtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIEFaMDkgcGF0dGVybiBjb2RlOicsIGNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX2NoZWNrQ2hlY2tzdW0oY29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LmNvZGUgPSBjb2RlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvZGUzOVZJTlJlYWRlcjtcbiIsImltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGUsIEJhcmNvZGVQb3NpdGlvbiB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG4vLyBjb25zdCBBTFBIQUJFVEhfU1RSSU5HID0gJzAxMjM0NTY3ODktJDovLitBQkNEJztcbmNvbnN0IEFMUEhBQkVUID0gWzQ4LCA0OSwgNTAsIDUxLCA1MiwgNTMsIDU0LCA1NSwgNTYsIDU3LCA0NSwgMzYsIDU4LCA0NywgNDYsIDQzLCA2NSwgNjYsIDY3LCA2OF07XG5jb25zdCBDSEFSQUNURVJfRU5DT0RJTkdTID1cbiAgICBbMHgwMDMsIDB4MDA2LCAweDAwOSwgMHgwNjAsIDB4MDEyLCAweDA0MiwgMHgwMjEsIDB4MDI0LCAweDAzMCwgMHgwNDgsIDB4MDBjLCAweDAxOCxcbiAgICAgICAgMHgwNDUsIDB4MDUxLCAweDA1NCwgMHgwMTUsIDB4MDFBLCAweDAyOSwgMHgwMEIsIDB4MDBFXTtcbmNvbnN0IFNUQVJUX0VORCA9IFsweDAxQSwgMHgwMjksIDB4MDBCLCAweDAwRV07XG5jb25zdCBNSU5fRU5DT0RFRF9DSEFSUyA9IDQ7XG5jb25zdCBNQVhfQUNDRVBUQUJMRSA9IDIuMDtcbmNvbnN0IFBBRERJTkcgPSAxLjU7XG5cbmludGVyZmFjZSBUaHJlc2hvbGRTaXplIHtcbiAgICBzaXplOiBudW1iZXIsXG4gICAgY291bnRzOiBudW1iZXIsXG4gICAgbWluOiBudW1iZXIsXG4gICAgbWF4OiBudW1iZXIsXG59O1xuXG5pbnRlcmZhY2UgVGhyZXNob2xkIHtcbiAgICBzcGFjZToge1xuICAgICAgICBuYXJyb3c6IFRocmVzaG9sZFNpemUsXG4gICAgICAgIHdpZGU6IFRocmVzaG9sZFNpemUsXG4gICAgfSxcbiAgICBiYXI6IHtcbiAgICAgICAgbmFycm93OiBUaHJlc2hvbGRTaXplLFxuICAgICAgICB3aWRlOiBUaHJlc2hvbGRTaXplLFxuICAgIH0sXG59O1xuXG5jbGFzcyBOZXdDb2RhYmFyUmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgX2NvdW50ZXJzOiBBcnJheTxudW1iZXI+ID0gW107XG4gICAgRk9STUFUID0gJ2NvZGFiYXInO1xuXG4gICAgX2NvbXB1dGVBbHRlcm5hdGluZ1RocmVzaG9sZChvZmZzZXQ6IG51bWJlciwgZW5kOiBudW1iZXIpIHtcbiAgICAgICAgbGV0IG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIGxldCBtYXggPSAwO1xuICAgICAgICBsZXQgY291bnRlciA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IGVuZDsgaSArPSAyKSB7XG4gICAgICAgICAgICBjb3VudGVyID0gdGhpcy5fY291bnRlcnNbaV07XG4gICAgICAgICAgICBpZiAoY291bnRlciA+IG1heCkge1xuICAgICAgICAgICAgICAgIG1heCA9IGNvdW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY291bnRlciA8IG1pbikge1xuICAgICAgICAgICAgICAgIG1pbiA9IGNvdW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKChtaW4gKyBtYXgpIC8gMi4wKSB8IDA7XG4gICAgfTtcblxuICAgIF90b1BhdHRlcm4ob2Zmc2V0OiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSA3O1xuICAgICAgICBjb25zdCBlbmQgPSBvZmZzZXQgKyBudW1Db3VudGVycztcblxuICAgICAgICBpZiAoZW5kID4gdGhpcy5fY291bnRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBiYXJUaHJlc2hvbGQgPSB0aGlzLl9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQob2Zmc2V0LCBlbmQpO1xuICAgICAgICBjb25zdCBzcGFjZVRocmVzaG9sZCA9IHRoaXMuX2NvbXB1dGVBbHRlcm5hdGluZ1RocmVzaG9sZChvZmZzZXQgKyAxLCBlbmQpO1xuXG4gICAgICAgIGxldCBiaXRtYXNrID0gMSA8PCAobnVtQ291bnRlcnMgLSAxKTtcbiAgICAgICAgbGV0IHRocmVzaG9sZCA9IDA7XG4gICAgICAgIGxldCBwYXR0ZXJuID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IChpICYgMSkgPT09IDAgPyBiYXJUaHJlc2hvbGQgOiBzcGFjZVRocmVzaG9sZDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb3VudGVyc1tvZmZzZXQgKyBpXSA+IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gfD0gYml0bWFzaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpdG1hc2sgPj49IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICB9O1xuXG4gICAgX2lzU3RhcnRFbmQocGF0dGVybjogbnVtYmVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgU1RBUlRfRU5ELmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoU1RBUlRfRU5EW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBfc3VtQ291bnRlcnMoc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpIHtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSB0aGlzLl9jb3VudGVyc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH07XG5cbiAgICBfZmluZFN0YXJ0KCk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93KTtcbiAgICAgICAgbGV0IGVuZCA9IHN0YXJ0O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5fY291bnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLl90b1BhdHRlcm4oaSk7XG4gICAgICAgICAgICBpZiAocGF0dGVybiAhPT0gLTEgJiYgdGhpcy5faXNTdGFydEVuZChwYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IExvb2sgZm9yIHdoaXRlc3BhY2UgYWhlYWRcbiAgICAgICAgICAgICAgICBzdGFydCArPSB0aGlzLl9zdW1Db3VudGVycygwLCBpKTtcbiAgICAgICAgICAgICAgICBlbmQgPSBzdGFydCArIHRoaXMuX3N1bUNvdW50ZXJzKGksIGkgKyA4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgICAgICAgICBzdGFydENvdW50ZXI6IGksXG4gICAgICAgICAgICAgICAgICAgIGVuZENvdW50ZXI6IGkgKyA4LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgX3BhdHRlcm5Ub0NoYXIocGF0dGVybjogbnVtYmVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ0hBUkFDVEVSX0VOQ09ESU5HUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKENIQVJBQ1RFUl9FTkNPRElOR1NbaV0gPT09IHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShBTFBIQUJFVFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIF9jYWxjdWxhdGVQYXR0ZXJuTGVuZ3RoKG9mZnNldDogbnVtYmVyKSB7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBvZmZzZXQgKyA3OyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSB0aGlzLl9jb3VudGVyc1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfTtcblxuICAgIF92ZXJpZnlXaGl0ZXNwYWNlKHN0YXJ0Q291bnRlcjogbnVtYmVyLCBlbmRDb3VudGVyOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKChzdGFydENvdW50ZXIgLSAxIDw9IDApXG4gICAgICAgICAgICB8fCB0aGlzLl9jb3VudGVyc1tzdGFydENvdW50ZXIgLSAxXSA+PSAodGhpcy5fY2FsY3VsYXRlUGF0dGVybkxlbmd0aChzdGFydENvdW50ZXIpIC8gMi4wKSkge1xuICAgICAgICAgICAgaWYgKChlbmRDb3VudGVyICsgOCA+PSB0aGlzLl9jb3VudGVycy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5fY291bnRlcnNbZW5kQ291bnRlciArIDddID49ICh0aGlzLl9jYWxjdWxhdGVQYXR0ZXJuTGVuZ3RoKGVuZENvdW50ZXIpIC8gMi4wKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgX2NoYXJUb1BhdHRlcm4oY2hhcjogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGNoYXJDb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChBTFBIQUJFVFtpXSA9PT0gY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMHgwO1xuICAgIH07XG5cbiAgICBfdGhyZXNob2xkUmVzdWx0UGF0dGVybihyZXN1bHQ6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPiwgc3RhcnRDb3VudGVyOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgY2F0ZWdvcml6YXRpb246IFRocmVzaG9sZCA9IHtcbiAgICAgICAgICAgICAgICBzcGFjZToge1xuICAgICAgICAgICAgICAgICAgICBuYXJyb3c6IHsgc2l6ZTogMCwgY291bnRzOiAwLCBtaW46IDAsIG1heDogTnVtYmVyLk1BWF9WQUxVRSB9LFxuICAgICAgICAgICAgICAgICAgICB3aWRlOiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUUgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJhcjoge1xuICAgICAgICAgICAgICAgICAgICBuYXJyb3c6IHsgc2l6ZTogMCwgY291bnRzOiAwLCBtaW46IDAsIG1heDogTnVtYmVyLk1BWF9WQUxVRSB9LFxuICAgICAgICAgICAgICAgICAgICB3aWRlOiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUUgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgbGV0IHBvcyA9IHN0YXJ0Q291bnRlcjtcbiAgICAgICAgbGV0IHBhdHRlcm46IG51bWJlcjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMuX2NoYXJUb1BhdHRlcm4ocmVzdWx0W2ldKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSA2OyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtpbmQgPSAoaiAmIDEpID09PSAyID8gY2F0ZWdvcml6YXRpb24uYmFyIDogY2F0ZWdvcml6YXRpb24uc3BhY2U7XG4gICAgICAgICAgICAgICAgY29uc3QgY2F0ID0gKHBhdHRlcm4gJiAxKSA9PT0gMSA/IGtpbmQud2lkZSA6IGtpbmQubmFycm93O1xuICAgICAgICAgICAgICAgIGNhdC5zaXplICs9IHRoaXMuX2NvdW50ZXJzW3BvcyArIGpdO1xuICAgICAgICAgICAgICAgIGNhdC5jb3VudHMrKztcbiAgICAgICAgICAgICAgICBwYXR0ZXJuID4+PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IDg7XG4gICAgICAgIH1cblxuICAgICAgICAoWydzcGFjZScsICdiYXInXSBhcyBjb25zdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBjb25zdCBuZXdraW5kID0gY2F0ZWdvcml6YXRpb25ba2V5XTtcbiAgICAgICAgICAgIG5ld2tpbmQud2lkZS5taW4gPVxuICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKG5ld2tpbmQubmFycm93LnNpemUgLyBuZXdraW5kLm5hcnJvdy5jb3VudHMgKyBuZXdraW5kLndpZGUuc2l6ZSAvIG5ld2tpbmQud2lkZS5jb3VudHMpIC8gMik7XG4gICAgICAgICAgICBuZXdraW5kLm5hcnJvdy5tYXggPSBNYXRoLmNlaWwobmV3a2luZC53aWRlLm1pbik7XG4gICAgICAgICAgICBuZXdraW5kLndpZGUubWF4ID0gTWF0aC5jZWlsKChuZXdraW5kLndpZGUuc2l6ZSAqIE1BWF9BQ0NFUFRBQkxFICsgUEFERElORykgLyBuZXdraW5kLndpZGUuY291bnRzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNhdGVnb3JpemF0aW9uO1xuICAgIH07XG5cbiAgICBfdmFsaWRhdGVSZXN1bHQocmVzdWx0OiBSZWFkb25seUFycmF5PHN0cmluZz4sIHN0YXJ0Q291bnRlcjogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IHRocmVzaG9sZHMgPSB0aGlzLl90aHJlc2hvbGRSZXN1bHRQYXR0ZXJuKHJlc3VsdCwgc3RhcnRDb3VudGVyKTtcbiAgICAgICAgbGV0IHBvcyA9IHN0YXJ0Q291bnRlcjtcbiAgICAgICAgbGV0IHBhdHRlcm46IG51bWJlcjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMuX2NoYXJUb1BhdHRlcm4ocmVzdWx0W2ldKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSA2OyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtpbmQgPSAoaiAmIDEpID09PSAwID8gdGhyZXNob2xkcy5iYXIgOiB0aHJlc2hvbGRzLnNwYWNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhdCA9IChwYXR0ZXJuICYgMSkgPT09IDEgPyBraW5kLndpZGUgOiBraW5kLm5hcnJvdztcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5fY291bnRlcnNbcG9zICsgal07XG4gICAgICAgICAgICAgICAgaWYgKHNpemUgPCBjYXQubWluIHx8IHNpemUgPiBjYXQubWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0dGVybiA+Pj0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyIHwgbnVsbCk6IEJhcmNvZGUgfCBudWxsIHtcblxuICAgICAgICB0aGlzLl9jb3VudGVycyA9IHRoaXMuX2ZpbGxDb3VudGVycygpO1xuICAgICAgICBzdGFydCA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dFN0YXJ0ID0gc3RhcnQuc3RhcnRDb3VudGVyIGFzIG51bWJlcjtcblxuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICAgICAgbGV0IHBhdHRlcm46IG51bWJlcjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMuX3RvUGF0dGVybihuZXh0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVkQ2hhciA9IHRoaXMuX3BhdHRlcm5Ub0NoYXIocGF0dGVybik7XG4gICAgICAgICAgICBpZiAoZGVjb2RlZENoYXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcbiAgICAgICAgICAgIG5leHRTdGFydCArPSA4O1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAxICYmIHRoaXMuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAobmV4dFN0YXJ0IDwgdGhpcy5fY291bnRlcnMubGVuZ3RoKTtcblxuICAgICAgICAvLyB2ZXJpZnkgZW5kXG4gICAgICAgIGlmICgocmVzdWx0Lmxlbmd0aCAtIDIpIDwgTUlOX0VOQ09ERURfQ0hBUlMgfHwgIXRoaXMuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmVyaWZ5IGVuZCB3aGl0ZSBzcGFjZVxuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeVdoaXRlc3BhY2Uoc3RhcnQuc3RhcnRDb3VudGVyIGFzIG51bWJlciwgbmV4dFN0YXJ0IC0gOCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl92YWxpZGF0ZVJlc3VsdChyZXN1bHQsIHN0YXJ0LnN0YXJ0Q291bnRlciBhcyBudW1iZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHRTdGFydCA9IG5leHRTdGFydCA+IHRoaXMuX2NvdW50ZXJzLmxlbmd0aCA/IHRoaXMuX2NvdW50ZXJzLmxlbmd0aCA6IG5leHRTdGFydDtcbiAgICAgICAgY29uc3QgZW5kID0gc3RhcnQuc3RhcnQgKyB0aGlzLl9zdW1Db3VudGVycyhzdGFydC5zdGFydENvdW50ZXIgYXMgbnVtYmVyLCBuZXh0U3RhcnQgLSA4KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0LFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULCAvLyBUT0RPOiBpIHRoaW5rIGl0IHNob3VsZCBub3QgYmUgcmVxdWlyZWQgdG8gcmV0dXJuIGZvcm1hdCBmcm9tIHRoaXMsIGFzIGJhcmNvZGVfcmVhZGVyIGZvcmNlIHNldHMgdGhlIGZvcm1hdCBhbnl3YXlcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBOZXdDb2RhYmFyUmVhZGVyO1xuIiwiaW1wb3J0IEVBTlJlYWRlciBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNsYXNzIFVQQ1JlYWRlciBleHRlbmRzIEVBTlJlYWRlciB7XG4gICAgRk9STUFUID0gJ3VwY19hJztcbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBFQU5SZWFkZXIucHJvdG90eXBlLl9kZWNvZGUuY2FsbCh0aGlzKTtcblxuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5jb2RlICYmIHJlc3VsdC5jb2RlLmxlbmd0aCA9PT0gMTMgJiYgcmVzdWx0LmNvZGUuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb2RlID0gcmVzdWx0LmNvZGUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFVQQ1JlYWRlcjtcbiIsImltcG9ydCBFQU5SZWFkZXIsIHsgQ09ERV9HX1NUQVJULCBNSURETEVfUEFUVEVSTiB9IGZyb20gJy4vZWFuX3JlYWRlcic7XG5pbXBvcnQgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGVJbmZvIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNsYXNzIEVBTjhSZWFkZXIgZXh0ZW5kcyBFQU5SZWFkZXIge1xuICAgIEZPUk1BVCA9ICdlYW5fOCc7XG4gICAgcHJvdGVjdGVkIF9kZWNvZGVQYXlsb2FkKGluQ29kZTogQmFyY29kZVBvc2l0aW9uLCByZXN1bHQ6IEFycmF5PG51bWJlcj4sIGRlY29kZWRDb2RlczogQXJyYXk8QmFyY29kZVBvc2l0aW9uPik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwgPSBpbkNvZGU7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvZGUuZW5kLCBDT0RFX0dfU1RBUlQpO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoY29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSk7XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUgPSB0aGlzLl9maW5kUGF0dGVybihNSURETEVfUEFUVEVSTiwgY29kZS5lbmQsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb2RlLmVuZCwgQ09ERV9HX1NUQVJUKTtcbiAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoY29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29kZSBhcyBCYXJjb2RlSW5mbztcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBFQU44UmVhZGVyO1xuIiwiaW1wb3J0IEVBTlJlYWRlciwgeyBDT0RFX0dfU1RBUlQgfSBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5cbmNsYXNzIEVBTjJSZWFkZXIgZXh0ZW5kcyBFQU5SZWFkZXIge1xuICAgIEZPUk1BVCA9ICdlYW5fMic7XG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgaWYgKHJvdykge1xuICAgICAgICAgICAgdGhpcy5fcm93ID0gcm93O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvZGVGcmVxdWVuY3kgPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX3Jvdy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBbXTtcbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyICYmIG9mZnNldCA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvZGUuY29kZSAlIDEwKTtcbiAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPj0gQ09ERV9HX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAxIDw8ICgxIC0gaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBjb2RlLmVuZCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3Jvdywgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICE9PSAyIHx8IChwYXJzZUludChyZXN1bHQuam9pbignJykpICUgNCkgIT09IGNvZGVGcmVxdWVuY3kpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIGVuZDogKGNvZGUgYXMgQmFyY29kZUluZm8pLmVuZCxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyBhcyBCYXJjb2RlUG9zaXRpb24sXG4gICAgICAgICAgICBzdGFydDogKHN0YXJ0SW5mbyBhcyBCYXJjb2RlUG9zaXRpb24pLnN0YXJ0LFxuICAgICAgICB9O1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEVBTjJSZWFkZXI7XG4iLCJpbXBvcnQgRUFOUmVhZGVyLCB7IENPREVfR19TVEFSVCB9IGZyb20gJy4vZWFuX3JlYWRlcic7XG5pbXBvcnQgeyBCYXJjb2RlLCBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGVJbmZvIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNvbnN0IENIRUNLX0RJR0lUX0VOQ09ESU5HUyA9IFsyNCwgMjAsIDE4LCAxNywgMTIsIDYsIDMsIDEwLCA5LCA1XTtcblxuZnVuY3Rpb24gZGV0ZXJtaW5lQ2hlY2tEaWdpdChjb2RlRnJlcXVlbmN5OiBudW1iZXIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgaWYgKGNvZGVGcmVxdWVuY3kgPT09IENIRUNLX0RJR0lUX0VOQ09ESU5HU1tpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGV4dGVuc2lvbkNoZWNrc3VtKHJlc3VsdDogQXJyYXk8bnVtYmVyPikge1xuICAgIGNvbnN0IGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgbGV0IHN1bSA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgc3VtICs9IHJlc3VsdFtpXTtcbiAgICB9XG4gICAgc3VtICo9IDM7XG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgfVxuICAgIHN1bSAqPSAzO1xuICAgIHJldHVybiBzdW0gJSAxMDtcbn1cblxuY2xhc3MgRUFONVJlYWRlciBleHRlbmRzIEVBTlJlYWRlciB7XG4gICAgRk9STUFUID0gJ2Vhbl81JztcbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm93KSB7XG4gICAgICAgICAgICB0aGlzLl9yb3cgPSByb3c7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29kZUZyZXF1ZW5jeSA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSBzdGFydDtcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fcm93Lmxlbmd0aDtcbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDUgJiYgb2Zmc2V0IDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlICUgMTApO1xuICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA+PSBDT0RFX0dfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDEgPDwgKDQgLSBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIGNvZGUuZW5kKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93LCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggIT09IDUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dGVuc2lvbkNoZWNrc3VtKHJlc3VsdCkgIT09IGRldGVybWluZUNoZWNrRGlnaXQoY29kZUZyZXF1ZW5jeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIGVuZDogKGNvZGUgYXMgQmFyY29kZUluZm8pLmVuZCxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyBhcyBCYXJjb2RlUG9zaXRpb24sXG4gICAgICAgICAgICBzdGFydDogKHN0YXJ0SW5mbyBhcyBCYXJjb2RlUG9zaXRpb24pLnN0YXJ0LFxuICAgICAgICB9O1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEVBTjVSZWFkZXI7XG4iLCJpbXBvcnQgRUFOUmVhZGVyLCB7IENPREVfR19TVEFSVCB9IGZyb20gJy4vZWFuX3JlYWRlcic7XG5pbXBvcnQgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGVJbmZvIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNsYXNzIFVQQ0VSZWFkZXIgZXh0ZW5kcyBFQU5SZWFkZXIge1xuICAgIENPREVfRlJFUVVFTkNZID0gW1xuICAgICAgICBbIDU2LCA1MiwgNTAsIDQ5LCA0NCwgMzgsIDM1LCA0MiwgNDEsIDM3IF0sXG4gICAgICAgIFs3LCAxMSwgMTMsIDE0LCAxOSwgMjUsIDI4LCAyMSwgMjIsIDI2XV07XG4gICAgU1RPUF9QQVRURVJOID0gWzEgLyA2ICogNywgMSAvIDYgKiA3LCAxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3LCAxIC8gNiAqIDddO1xuICAgIEZPUk1BVCA9ICd1cGNfZSc7XG4gICAgcHJvdGVjdGVkIF9kZWNvZGVQYXlsb2FkKGluQ29kZTogQmFyY29kZVBvc2l0aW9uLCByZXN1bHQ6IEFycmF5PG51bWJlcj4sIGRlY29kZWRDb2RlczogQXJyYXk8QmFyY29kZVBvc2l0aW9uPik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIGxldCBvdXRDb2RlOiBCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwgPSB7IC4uLmluQ29kZSB9O1xuICAgICAgICBsZXQgY29kZUZyZXF1ZW5jeSA9IDB4MDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICAgICAgb3V0Q29kZSA9IHRoaXMuX2RlY29kZUNvZGUob3V0Q29kZS5lbmQpO1xuICAgICAgICAgICAgaWYgKCFvdXRDb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUgPj0gQ09ERV9HX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUgPSAob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSAtIENPREVfR19TVEFSVDtcbiAgICAgICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9ICgxIDw8ICg1IC0gaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUpO1xuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2gob3V0Q29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9kZXRlcm1pbmVQYXJpdHkoY29kZUZyZXF1ZW5jeSwgcmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dENvZGUgYXMgQmFyY29kZUluZm87XG4gICAgfTtcblxuICAgIF9kZXRlcm1pbmVQYXJpdHkoY29kZUZyZXF1ZW5jeTogbnVtYmVyLCByZXN1bHQ6IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgZm9yIChsZXQgbnJTeXN0ZW0gPSAwOyBuclN5c3RlbSA8IHRoaXMuQ09ERV9GUkVRVUVOQ1kubGVuZ3RoOyBuclN5c3RlbSsrKXtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5DT0RFX0ZSRVFVRU5DWVtuclN5c3RlbV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZUZyZXF1ZW5jeSA9PT0gdGhpcy5DT0RFX0ZSRVFVRU5DWVtuclN5c3RlbV1baV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnVuc2hpZnQobnJTeXN0ZW0pO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgX2NvbnZlcnRUb1VQQ0EocmVzdWx0OiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGxldCB1cGNhID0gW3Jlc3VsdFswXV07XG4gICAgICAgIGNvbnN0IGxhc3REaWdpdCA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMl07XG5cbiAgICAgICAgaWYgKGxhc3REaWdpdCA8PSAyKSB7XG4gICAgICAgICAgICB1cGNhID0gdXBjYS5jb25jYXQocmVzdWx0LnNsaWNlKDEsIDMpKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoW2xhc3REaWdpdCwgMCwgMCwgMCwgMF0pXG4gICAgICAgICAgICAgICAgLmNvbmNhdChyZXN1bHQuc2xpY2UoMywgNikpO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gMykge1xuICAgICAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCA0KSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KFswLCAwLCAwLCAwLCAwXSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KHJlc3VsdC5zbGljZSg0LCA2KSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdERpZ2l0ID09PSA0KSB7XG4gICAgICAgICAgICB1cGNhID0gdXBjYS5jb25jYXQocmVzdWx0LnNsaWNlKDEsIDUpKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoWzAsIDAsIDAsIDAsIDAsIHJlc3VsdFs1XV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCA2KSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KFswLCAwLCAwLCAwLCBsYXN0RGlnaXRdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwY2EucHVzaChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdKTtcbiAgICAgICAgcmV0dXJuIHVwY2E7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfY2hlY2tzdW0ocmVzdWx0OiBBcnJheTxudW1iZXI+KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBzdXBlci5fY2hlY2tzdW0odGhpcy5fY29udmVydFRvVVBDQShyZXN1bHQpKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRFbmQob2Zmc2V0OiBudW1iZXIsIGlzV2hpdGU6IGJvb2xlYW4pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9maW5kRW5kKG9mZnNldCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpIC8gMik7XG4gICAgICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCB0aGlzLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IFVQQ0VSZWFkZXI7XG4iLCIvLyBUT0RPOiBpMm9mNV9yZWFkZXIgYW5kIDJvZjVfcmVhZGVyIHNoYXJlIHZlcnkgc2ltaWxhciBjb2RlLCBtYWtlIHVzZSBvZiB0aGF0XG5cbmltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGVSZWFkZXJDb25maWcsIEJhcmNvZGVJbmZvLCBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCB7bWVyZ2V9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IE4gPSAxO1xuY29uc3QgVyA9IDM7XG5cbmNsYXNzIEkyb2Y1UmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgYmFyU3BhY2VSYXRpbyA9IFsxLCAxXTtcbiAgICBTSU5HTEVfQ09ERV9FUlJPUiA9IDAuNzg7XG4gICAgQVZHX0NPREVfRVJST1IgPSAwLjM4O1xuXG4gICAgU1RBUlRfUEFUVEVSTiA9IFtOLCBOLCBOLCBOXTtcbiAgICBTVE9QX1BBVFRFUk4gPSBbTiwgTiwgV107XG4gICAgQ09ERV9QQVRURVJOID0gW1xuICAgICAgICBbTiwgTiwgVywgVywgTl0sXG4gICAgICAgIFtXLCBOLCBOLCBOLCBXXSxcbiAgICAgICAgW04sIFcsIE4sIE4sIFddLFxuICAgICAgICBbVywgVywgTiwgTiwgTl0sXG4gICAgICAgIFtOLCBOLCBXLCBOLCBXXSxcbiAgICAgICAgW1csIE4sIFcsIE4sIE5dLFxuICAgICAgICBbTiwgVywgVywgTiwgTl0sXG4gICAgICAgIFtOLCBOLCBOLCBXLCBXXSxcbiAgICAgICAgW1csIE4sIE4sIFcsIE5dLFxuICAgICAgICBbTiwgVywgTiwgVywgTl0sXG4gICAgXTtcbiAgICBNQVhfQ09SUkVDVElPTl9GQUNUT1IgPSA1O1xuICAgIEZPUk1BVCA9ICdpMm9mNSc7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRzOiBCYXJjb2RlUmVhZGVyQ29uZmlnKSB7XG4gICAgICAgIHN1cGVyKG1lcmdlKHsgbm9ybWFsaXplQmFyU3BhY2VXaWR0aDogZmFsc2UgfSwgb3B0cykpO1xuICAgICAgICBpZiAob3B0cy5ub3JtYWxpemVCYXJTcGFjZVdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLlNJTkdMRV9DT0RFX0VSUk9SID0gMC4zODtcbiAgICAgICAgICAgIHRoaXMuQVZHX0NPREVfRVJST1IgPSAwLjA5O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uZmlnID0gb3B0cztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgX21hdGNoUGF0dGVybihjb3VudGVyOiBBcnJheTxudW1iZXI+LCBjb2RlOiBSZWFkb25seUFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLm5vcm1hbGl6ZUJhclNwYWNlV2lkdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ZXJTdW0gPSBbMCwgMF07XG4gICAgICAgICAgICBjb25zdCBjb2RlU3VtID0gWzAsIDBdO1xuICAgICAgICAgICAgY29uc3QgY29ycmVjdGlvbiA9IFswLCAwXTtcbiAgICAgICAgICAgIGNvbnN0IGNvcnJlY3Rpb25SYXRpbyA9IHRoaXMuTUFYX0NPUlJFQ1RJT05fRkFDVE9SO1xuICAgICAgICAgICAgY29uc3QgY29ycmVjdGlvblJhdGlvSW52ZXJzZSA9IDEgLyBjb3JyZWN0aW9uUmF0aW87XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJTdW1baSAlIDJdICs9IGNvdW50ZXJbaV07XG4gICAgICAgICAgICAgICAgY29kZVN1bVtpICUgMl0gKz0gY29kZVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvcnJlY3Rpb25bMF0gPSBjb2RlU3VtWzBdIC8gY291bnRlclN1bVswXTtcbiAgICAgICAgICAgIGNvcnJlY3Rpb25bMV0gPSBjb2RlU3VtWzFdIC8gY291bnRlclN1bVsxXTtcblxuICAgICAgICAgICAgY29ycmVjdGlvblswXSA9IE1hdGgubWF4KE1hdGgubWluKGNvcnJlY3Rpb25bMF0sIGNvcnJlY3Rpb25SYXRpbyksIGNvcnJlY3Rpb25SYXRpb0ludmVyc2UpO1xuICAgICAgICAgICAgY29ycmVjdGlvblsxXSA9IE1hdGgubWF4KE1hdGgubWluKGNvcnJlY3Rpb25bMV0sIGNvcnJlY3Rpb25SYXRpbyksIGNvcnJlY3Rpb25SYXRpb0ludmVyc2UpO1xuICAgICAgICAgICAgdGhpcy5iYXJTcGFjZVJhdGlvID0gY29ycmVjdGlvbjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbaV0gKj0gdGhpcy5iYXJTcGFjZVJhdGlvW2kgJSAyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmFyY29kZVJlYWRlci5wcm90b3R5cGUuX21hdGNoUGF0dGVybi5jYWxsKHRoaXMsIGNvdW50ZXIsIGNvZGUpO1xuICAgIH07XG5cbiAgICBfZmluZFBhdHRlcm4ocGF0dGVybjogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBvZmZzZXQ/OiBudW1iZXIsIGlzV2hpdGU6IGJvb2xlYW4gPSBmYWxzZSwgdHJ5SGFyZGVyOiBib29sZWFuID0gZmFsc2UpOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IEFycmF5PG51bWJlcj4ocGF0dGVybi5sZW5ndGgpLmZpbGwoMCk7XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSB0aGlzLkFWR19DT0RFX0VSUk9SO1xuXG4gICAgICAgIGlzV2hpdGUgPSBpc1doaXRlIHx8IGZhbHNlO1xuICAgICAgICB0cnlIYXJkZXIgPSB0cnlIYXJkZXIgfHwgZmFsc2U7XG5cbiAgICAgICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdW0gPSBjb3VudGVyLnJlZHVjZSgocHJldiwgbmV4dCkgPT4gcHJldiArIG5leHQsIDApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gc3VtO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cnlIYXJkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY291bnRlci5sZW5ndGggLSAyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIF9maW5kU3RhcnQoKSB7XG4gICAgICAgIGxldCBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgbGV0IHN0YXJ0SW5mbzogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGxldCBuYXJyb3dCYXJXaWR0aCA9IDE7XG5cbiAgICAgICAgd2hpbGUgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKHRoaXMuU1RBUlRfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFycm93QmFyV2lkdGggPSBNYXRoLmZsb29yKChzdGFydEluZm8uZW5kIC0gc3RhcnRJbmZvLnN0YXJ0KSAvIDQpO1xuICAgICAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IHN0YXJ0SW5mby5zdGFydCAtIG5hcnJvd0JhcldpZHRoICogMTA7XG4gICAgICAgICAgICBpZiAobGVhZGluZ1doaXRlc3BhY2VTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UobGVhZGluZ1doaXRlc3BhY2VTdGFydCwgc3RhcnRJbmZvLnN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCA9IHN0YXJ0SW5mby5lbmQ7XG4gICAgICAgICAgICBzdGFydEluZm8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVQb3NpdGlvbikge1xuICAgICAgICBjb25zdCB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArICgoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KSAvIDIpO1xuICAgICAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgdGhpcy5fcm93Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX2ZpbmRFbmQoKSB7XG4gICAgICAgIHRoaXMuX3Jvdy5yZXZlcnNlKCk7XG4gICAgICAgIGNvbnN0IGVuZEluZm8gPSB0aGlzLl9maW5kUGF0dGVybih0aGlzLlNUT1BfUEFUVEVSTik7XG4gICAgICAgIHRoaXMuX3Jvdy5yZXZlcnNlKCk7XG5cbiAgICAgICAgaWYgKGVuZEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV2ZXJzZSBudW1iZXJzXG4gICAgICAgIGNvbnN0IHRtcCA9IGVuZEluZm8uc3RhcnQ7XG4gICAgICAgIGVuZEluZm8uc3RhcnQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gZW5kSW5mby5lbmQ7XG4gICAgICAgIGVuZEluZm8uZW5kID0gdGhpcy5fcm93Lmxlbmd0aCAtIHRtcDtcblxuICAgICAgICByZXR1cm4gZW5kSW5mbyAhPT0gbnVsbCA/IHRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSA6IG51bGw7XG4gICAgfTtcblxuICAgIF9kZWNvZGVQYWlyKGNvdW50ZXJQYWlyOiBBcnJheTxBcnJheTxudW1iZXI+Pikge1xuICAgICAgICBjb25zdCBjb2RlczogQXJyYXk8QmFyY29kZUluZm8+ID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyUGFpci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUoY291bnRlclBhaXJbaV0pO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlcztcbiAgICB9O1xuXG4gICAgX2RlY29kZUNvZGUoY291bnRlcjogQXJyYXk8bnVtYmVyPik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSB0aGlzLkFWR19DT0RFX0VSUk9SO1xuXG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMCxcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKGxldCBjb2RlID0gMDsgY29kZSA8IHRoaXMuQ09ERV9QQVRURVJOLmxlbmd0aDsgY29kZSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCB0aGlzLkNPREVfUEFUVEVSTltjb2RlXSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlc3RNYXRjaC5lcnJvciA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIF9kZWNvZGVQYXlsb2FkKGNvdW50ZXJzOiBSZWFkb25seUFycmF5PG51bWJlcj4sIHJlc3VsdDogQXJyYXk8c3RyaW5nPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbj4pIHtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGNvbnN0IGNvdW50ZXJMZW5ndGggPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGNvdW50ZXJQYWlyID0gW1swLCAwLCAwLCAwLCAwXSwgWzAsIDAsIDAsIDAsIDBdXTtcbiAgICAgICAgbGV0IGNvZGVzOiBCYXJjb2RlSW5mb1tdIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKHBvcyA8IGNvdW50ZXJMZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY291bnRlclBhaXJbMF1baV0gPSBjb3VudGVyc1twb3NdICogdGhpcy5iYXJTcGFjZVJhdGlvWzBdO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQYWlyWzFdW2ldID0gY291bnRlcnNbcG9zICsgMV0gKiB0aGlzLmJhclNwYWNlUmF0aW9bMV07XG4gICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2RlcyA9IHRoaXMuX2RlY29kZVBhaXIoY291bnRlclBhaXIpO1xuICAgICAgICAgICAgaWYgKCFjb2Rlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvZGVzW2ldLmNvZGUgKyAnJyk7XG4gICAgICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlcztcbiAgICB9O1xuXG4gICAgX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnM6IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgcmV0dXJuIChjb3VudGVycy5sZW5ndGggJSAxMCA9PT0gMCk7XG4gICAgfTtcblxuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuICAgICAgICB2YXIgZGVjb2RlZENvZGVzID0gbmV3IEFycmF5PEJhcmNvZGVQb3NpdGlvbj4oKTtcblxuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKHN0YXJ0SW5mbyk7XG5cbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRFbmQoKTtcbiAgICAgICAgaWYgKCFlbmRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvdW50ZXJzID0gdGhpcy5fZmlsbENvdW50ZXJzKHN0YXJ0SW5mby5lbmQsIGVuZEluZm8uc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlDb3VudGVyTGVuZ3RoKGNvdW50ZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuX2RlY29kZVBheWxvYWQoY291bnRlcnMsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAlIDIgIT09IDAgfHxcbiAgICAgICAgICAgICAgICByZXN1bHQubGVuZ3RoIDwgNikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChlbmRJbmZvKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGVuZEluZm8uZW5kLFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8sXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXM6IGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgSTJvZjVSZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlLCBCYXJjb2RlSW5mbywgQmFyY29kZVBvc2l0aW9uIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNvbnN0IE4gPSAxO1xuY29uc3QgVyA9IDM7XG5jb25zdCBTVEFSVF9QQVRURVJOID0gW1csIE4sIFcsIE4sIE4sIE5dO1xuY29uc3QgU1RPUF9QQVRURVJOID0gW1csIE4sIE4sIE4sIFddO1xuY29uc3QgQ09ERV9QQVRURVJOID0gW1xuICAgIFtOLCBOLCBXLCBXLCBOXSxcbiAgICBbVywgTiwgTiwgTiwgV10sXG4gICAgW04sIFcsIE4sIE4sIFddLFxuICAgIFtXLCBXLCBOLCBOLCBOXSxcbiAgICBbTiwgTiwgVywgTiwgV10sXG4gICAgW1csIE4sIFcsIE4sIE5dLFxuICAgIFtOLCBXLCBXLCBOLCBOXSxcbiAgICBbTiwgTiwgTiwgVywgV10sXG4gICAgW1csIE4sIE4sIFcsIE5dLFxuICAgIFtOLCBXLCBOLCBXLCBOXSxcbl07XG5jb25zdCBTVEFSVF9QQVRURVJOX0xFTkdUSCA9IFNUQVJUX1BBVFRFUk4ucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsLCAwKTtcblxuY2xhc3MgVHdvT2ZGaXZlUmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgYmFyU3BhY2VSYXRpbyA9IFsxLCAxXTtcblxuICAgIEZPUk1BVCA9ICcyb2Y1JztcblxuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMC43ODtcblxuICAgIEFWR19DT0RFX0VSUk9SID0gMC4zMDtcblxuICAgIF9maW5kUGF0dGVybihwYXR0ZXJuOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG9mZnNldDogbnVtYmVyLCBpc1doaXRlID0gZmFsc2UsIHRyeUhhcmRlciA9IGZhbHNlKTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgY29uc3QgY291bnRlciA9IFtdO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGxldCBlcnJvciA9IDA7XG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSB0aGlzLkFWR19DT0RFX0VSUk9SO1xuXG4gICAgICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvdW50ZXJbaV0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY291bnRlci5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IGNvdW50ZXJbal07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgcGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLnN0YXJ0ID0gaSAtIHN1bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHJ5SGFyZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoIC0gMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDJdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIF9maW5kU3RhcnQoKSB7XG4gICAgICAgIGxldCBzdGFydEluZm8gPSBudWxsO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBsZXQgbmFycm93QmFyV2lkdGggPSAxO1xuICAgICAgICBsZXQgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IDA7XG5cbiAgICAgICAgd2hpbGUgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKFNUQVJUX1BBVFRFUk4sIG9mZnNldCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hcnJvd0JhcldpZHRoID0gTWF0aC5mbG9vcigoc3RhcnRJbmZvLmVuZCAtIHN0YXJ0SW5mby5zdGFydCkgLyBTVEFSVF9QQVRURVJOX0xFTkdUSCk7XG4gICAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID0gc3RhcnRJbmZvLnN0YXJ0IC0gbmFycm93QmFyV2lkdGggKiA1O1xuICAgICAgICAgICAgaWYgKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQsIHN0YXJ0SW5mby5zdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0SW5mbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSBzdGFydEluZm8uZW5kO1xuICAgICAgICAgICAgc3RhcnRJbmZvID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xuICAgIH1cblxuICAgIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbzogQmFyY29kZUluZm8pIHtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgX2ZpbmRFbmQoKSB7XG4gICAgICAgIC8vIFRPRE86IHJldmVyc2UsIGZvbGxvd2VkIGJ5IHNvbWUgY2FsY3MsIGZvbGxvd2VkIGJ5IGFub3RoZXIgcmV2ZXJzZT8gcmVhbGx5P1xuICAgICAgICB0aGlzLl9yb3cucmV2ZXJzZSgpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGNvbnN0IGVuZEluZm8gPSB0aGlzLl9maW5kUGF0dGVybihTVE9QX1BBVFRFUk4sIG9mZnNldCwgZmFsc2UsIHRydWUpO1xuICAgICAgICB0aGlzLl9yb3cucmV2ZXJzZSgpO1xuXG4gICAgICAgIGlmIChlbmRJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldmVyc2UgbnVtYmVyc1xuICAgICAgICBjb25zdCB0bXAgPSBlbmRJbmZvLnN0YXJ0O1xuICAgICAgICBlbmRJbmZvLnN0YXJ0ID0gdGhpcy5fcm93Lmxlbmd0aCAtIGVuZEluZm8uZW5kO1xuICAgICAgICBlbmRJbmZvLmVuZCA9IHRoaXMuX3Jvdy5sZW5ndGggLSB0bXA7XG5cbiAgICAgICAgcmV0dXJuIGVuZEluZm8gIT09IG51bGwgPyB0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykgOiBudWxsO1xuICAgIH1cblxuICAgIF92ZXJpZnlDb3VudGVyTGVuZ3RoKGNvdW50ZXJzOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIHJldHVybiAoY291bnRlcnMubGVuZ3RoICUgMTAgPT09IDApO1xuICAgIH1cblxuICAgIF9kZWNvZGVDb2RlKGNvdW50ZXI6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPikge1xuICAgICAgICBjb25zdCBlcHNpbG9uID0gdGhpcy5BVkdfQ09ERV9FUlJPUjtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAobGV0IGNvZGUgPSAwOyBjb2RlIDwgQ09ERV9QQVRURVJOLmxlbmd0aDsgY29kZSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBDT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiZXN0TWF0Y2guZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIF9kZWNvZGVQYXlsb2FkKGNvdW50ZXJzOiBSZWFkb25seUFycmF5PG51bWJlcj4sIHJlc3VsdDogQXJyYXk8c3RyaW5nPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlSW5mbz4pIHtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGNvbnN0IGNvdW50ZXJMZW5ndGggPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBbMCwgMCwgMCwgMCwgMF07XG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlSW5mbyB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlIChwb3MgPCBjb3VudGVyTGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbaV0gPSBjb3VudGVyc1twb3NdICogdGhpcy5iYXJTcGFjZVJhdGlvWzBdO1xuICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUoY291bnRlcik7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGAke2NvZGUuY29kZX1gKTtcbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cblxuXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG4gICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVuZEluZm8gPSB0aGlzLl9maW5kRW5kKCk7XG4gICAgICAgIGlmICghZW5kSW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb3VudGVycyA9IHRoaXMuX2ZpbGxDb3VudGVycyhzdGFydEluZm8uZW5kLCBlbmRJbmZvLnN0YXJ0LCBmYWxzZSk7XG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5Q291bnRlckxlbmd0aChjb3VudGVycykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlY29kZWRDb2RlcyA9IFtdO1xuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChzdGFydEluZm8pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICAgICAgICBjb25zdCBjb2RlID0gdGhpcy5fZGVjb2RlUGF5bG9hZChjb3VudGVycywgcmVzdWx0LCBkZWNvZGVkQ29kZXMpO1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoIDwgNSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChlbmRJbmZvKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGVuZEluZm8uZW5kLFxuICAgICAgICAgICAgc3RhcnRJbmZvLFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFR3b09mRml2ZVJlYWRlcjtcbiIsImltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xuXG5jb25zdCBBTFBIQUJFVEhfU1RSSU5HID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWi0uICQvKyVhYmNkKic7XG5jb25zdCBBTFBIQUJFVCA9IG5ldyBVaW50MTZBcnJheShbLi4uQUxQSEFCRVRIX1NUUklOR10ubWFwKGNoYXIgPT4gY2hhci5jaGFyQ29kZUF0KDApKSk7XG5jb25zdCBDSEFSQUNURVJfRU5DT0RJTkdTID0gbmV3IFVpbnQxNkFycmF5KFtcbiAgICAweDExNCwgMHgxNDgsIDB4MTQ0LCAweDE0MiwgMHgxMjgsIDB4MTI0LCAweDEyMiwgMHgxNTAsIDB4MTEyLCAweDEwQSxcbiAgICAweDFBOCwgMHgxQTQsIDB4MUEyLCAweDE5NCwgMHgxOTIsIDB4MThBLCAweDE2OCwgMHgxNjQsIDB4MTYyLCAweDEzNCxcbiAgICAweDExQSwgMHgxNTgsIDB4MTRDLCAweDE0NiwgMHgxMkMsIDB4MTE2LCAweDFCNCwgMHgxQjIsIDB4MUFDLCAweDFBNixcbiAgICAweDE5NiwgMHgxOUEsIDB4MTZDLCAweDE2NiwgMHgxMzYsIDB4MTNBLCAweDEyRSwgMHgxRDQsIDB4MUQyLCAweDFDQSxcbiAgICAweDE2RSwgMHgxNzYsIDB4MUFFLCAweDEyNiwgMHgxREEsIDB4MUQ2LCAweDEzMiwgMHgxNUUsXG5dKTtcbmNvbnN0IEFTVEVSSVNLID0gMHgxNUU7XG5cbmNsYXNzIENvZGU5M1JlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIEZPUk1BVCA9ICdjb2RlXzkzJztcbiAgICBfcGF0dGVyblRvQ2hhcihwYXR0ZXJuOiBudW1iZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDSEFSQUNURVJfRU5DT0RJTkdTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKEFMUEhBQkVUW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX3RvUGF0dGVybihjb3VudGVyczogVWludDE2QXJyYXkpIHtcbiAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHN1bSA9IGNvdW50ZXJzLnJlZHVjZSgocHJldiwgbmV4dCkgPT4gcHJldiArIG5leHQsIDApO1xuICAgICAgICBsZXQgcGF0dGVybiA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbm9ybWFsaXplZCA9IE1hdGgucm91bmQoY291bnRlcnNbaV0gKiA5IC8gc3VtKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkIDwgMSB8fCBub3JtYWxpemVkID4gNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoaSAmIDEpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub3JtYWxpemVkOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IChwYXR0ZXJuIDw8IDEpIHwgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gPDw9IG5vcm1hbGl6ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgfTtcblxuICAgIF9maW5kU3RhcnQoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgbGV0IHBhdHRlcm5TdGFydCA9IG9mZnNldDtcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBVaW50MTZBcnJheShbMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG4gICAgICAgIGxldCBpc1doaXRlID0gZmFsc2U7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgc3RhcnQgcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9QYXR0ZXJuKGNvdW50ZXIpID09PSBBU1RFUklTSykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2hpdGVTcGFjZU11c3RTdGFydCA9IE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgcGF0dGVyblN0YXJ0IC0gKChpIC0gcGF0dGVyblN0YXJ0KSAvIDQpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZSh3aGl0ZVNwYWNlTXVzdFN0YXJ0LCBwYXR0ZXJuU3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHBhdHRlcm5TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlclswXSArIGNvdW50ZXJbMV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls0XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbNV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIF92ZXJpZnlFbmQobGFzdFN0YXJ0OiBudW1iZXIsIG5leHRTdGFydDogbnVtYmVyKSB7XG4gICAgICAgIGlmIChsYXN0U3RhcnQgPT09IG5leHRTdGFydCB8fCAhdGhpcy5fcm93W25leHRTdGFydF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgX2RlY29kZUV4dGVuZGVkKGNoYXJBcnJheTogQXJyYXk8c3RyaW5nPikge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBjaGFyQXJyYXkubGVuZ3RoO1xuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGNoYXJBcnJheVtpXTtcbiAgICAgICAgICAgIGlmIChjaGFyID49ICdhJyAmJiBjaGFyIDw9ICdkJykge1xuICAgICAgICAgICAgICAgIGlmIChpID4gKGxlbmd0aCAtIDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hhciA9IGNoYXJBcnJheVsrK2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGFyQ29kZSA9IG5leHRDaGFyLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgbGV0IGRlY29kZWRDaGFyO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhciA+PSAnQScgJiYgbmV4dENoYXIgPD0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDY0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPj0gJ0EnICYmIG5leHRDaGFyIDw9ICdFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSAzOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID49ICdGJyAmJiBuZXh0Q2hhciA8PSAnSicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlIC0gMTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA+PSAnSycgJiYgbmV4dENoYXIgPD0gJ08nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSArIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ1AnICYmIG5leHRDaGFyIDw9ICdTJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgKyA0Myk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID49ICdUJyAmJiBuZXh0Q2hhciA8PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTI3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPj0gJ0EnICYmIG5leHRDaGFyIDw9ICdPJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSAzMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID09PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9ICc6JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPj0gJ0EnICYmIG5leHRDaGFyIDw9ICdaJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgKyAzMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJyogY29kZV85M19yZWFkZXIgX2RlY29kZUV4dGVuZGVkIGhpdCBkZWZhdWx0IGNhc2UsIHRoaXMgbWF5IGJlIGFuIGVycm9yJywgZGVjb2RlZENoYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgX21hdGNoQ2hlY2tDaGFyKGNoYXJBcnJheTogQXJyYXk8c3RyaW5nPiwgaW5kZXg6IG51bWJlciwgbWF4V2VpZ2h0OiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgYXJyYXlUb0NoZWNrID0gY2hhckFycmF5LnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYXJyYXlUb0NoZWNrLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgd2VpZ2h0ZWRTdW1zID0gYXJyYXlUb0NoZWNrLnJlZHVjZSgoc3VtLCBjaGFyLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3ZWlnaHQgPSAoKChpICogLTEpICsgKGxlbmd0aCAtIDEpKSAlIG1heFdlaWdodCkgKyAxO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBBTFBIQUJFVC5pbmRleE9mKGNoYXIuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtICsgKHdlaWdodCAqIHZhbHVlKTtcbiAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgY29uc3QgY2hlY2tDaGFyID0gQUxQSEFCRVRbKHdlaWdodGVkU3VtcyAlIDQ3KV07XG4gICAgICAgIHJldHVybiBjaGVja0NoYXIgPT09IGNoYXJBcnJheVtpbmRleF0uY2hhckNvZGVBdCgwKTtcbiAgICB9O1xuXG4gICAgX3ZlcmlmeUNoZWNrc3VtcyhjaGFyQXJyYXk6IEFycmF5PHN0cmluZz4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdGNoQ2hlY2tDaGFyKGNoYXJBcnJheSwgY2hhckFycmF5Lmxlbmd0aCAtIDIsIDIwKVxuICAgICAgICAgICAgJiYgdGhpcy5fbWF0Y2hDaGVja0NoYXIoY2hhckFycmF5LCBjaGFyQXJyYXkubGVuZ3RoIC0gMSwgMTUpO1xuICAgIH07XG5cbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyIHwgbnVsbCk6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY291bnRlcnMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDBdKTtcbiAgICAgICAgbGV0IHJlc3VsdDogQXJyYXk8c3RyaW5nPiB8IG51bGwgPSBbXTtcbiAgICAgICAgbGV0IG5leHRTdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBzdGFydC5lbmQpO1xuICAgICAgICBsZXQgbGFzdFN0YXJ0O1xuICAgICAgICBsZXQgZGVjb2RlZENoYXI6IHN0cmluZyB8IG51bGw7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvdW50ZXJzID0gdGhpcy5fdG9Db3VudGVycyhuZXh0U3RhcnQsIGNvdW50ZXJzKSBhcyBVaW50MTZBcnJheTtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLl90b1BhdHRlcm4oY291bnRlcnMpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkQ2hhciA9IHRoaXMuX3BhdHRlcm5Ub0NoYXIocGF0dGVybik7XG4gICAgICAgICAgICBpZiAoZGVjb2RlZENoYXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcbiAgICAgICAgICAgIGxhc3RTdGFydCA9IG5leHRTdGFydDtcbiAgICAgICAgICAgIG5leHRTdGFydCArPSBBcnJheUhlbHBlci5zdW0oY291bnRlcnMpO1xuICAgICAgICAgICAgbmV4dFN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIG5leHRTdGFydCk7XG4gICAgICAgIH0gd2hpbGUgKGRlY29kZWRDaGFyICE9PSAnKicpO1xuICAgICAgICByZXN1bHQucG9wKCk7XG5cbiAgICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5RW5kKGxhc3RTdGFydCwgbmV4dFN0YXJ0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeUNoZWNrc3VtcyhyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCByZXN1bHQubGVuZ3RoIC0gMik7XG4gICAgICAgIC8vIHllcywgdGhpcyBpcyBhbiBhc3NpZ24gaW5zaWRlIGFuIGlmLlxuICAgICAgICBpZiAoKHJlc3VsdCA9IHRoaXMuX2RlY29kZUV4dGVuZGVkKHJlc3VsdCkpID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnQuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IG5leHRTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnQsXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXM6IHJlc3VsdCxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG5cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvZGU5M1JlYWRlcjtcbiIsImltcG9ydCBDb2RlMzlSZWFkZXIgZnJvbSAnLi9jb2RlXzM5X3JlYWRlcic7XG5pbXBvcnQgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY29uc3QgcGF0dGVybnMgPSB7XG4gICAgQUVJTzogL1tBRUlPXS9nLFxuICAgIEFaMDk6IC9bQS1aMC05XS8sXG59O1xuXG5jb25zdCBjb2RlMzJzZXQgPSAnMDEyMzQ1Njc4OUJDREZHSEpLTE1OUFFSU1RVVldYWVonO1xuXG5jbGFzcyBDb2RlMzJSZWFkZXIgZXh0ZW5kcyBDb2RlMzlSZWFkZXIge1xuICAgIEZPUk1BVCA9ICdjb2RlXzMyX3JlYWRlcic7XG5cbiAgICBfZGVjb2RlQ29kZTMyKGNvZGU6IHN0cmluZykge1xuICAgICAgICBpZiAoL1teMC05QkNERkdISktMTU5QUVJTVFVWV1hZWl0vLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXMgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlcyA9IHJlcyAqIDMyICsgY29kZTMyc2V0LmluZGV4T2YoY29kZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvZGUzMiA9ICcnICsgcmVzO1xuICAgICAgICBpZiAoY29kZTMyLmxlbmd0aCA8IDkpIHtcbiAgICAgICAgICAgIGNvZGUzMiA9ICgnMDAwMDAwMDAwJyArIGNvZGUzMikuc2xpY2UoLTkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnQScgKyBjb2RlMzI7XG4gICAgfVxuXG4gICAgLy8gVE9ETyAodGhpcyB3YXMgdG9kbyBpbiBvcmlnaW5hbCByZXBvLCBubyB0ZXh0IHdhcyB0aGVyZS4gc29ycnkuKVxuICAgIF9jaGVja0NoZWNrc3VtKGNvZGU6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gISFjb2RlO1xuICAgIH1cblxuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLl9kZWNvZGUocm93LCBzdGFydCk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2RlID0gcmVzdWx0LmNvZGU7XG5cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocGF0dGVybnMuQUVJTywgJycpO1xuXG4gICAgICAgIGlmICghdGhpcy5fY2hlY2tDaGVja3N1bShjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29kZTMyID0gdGhpcy5fZGVjb2RlQ29kZTMyKGNvZGUpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFjb2RlMzIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXN1bHQuY29kZSA9IGNvZGUzMjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvZGUzMlJlYWRlcjtcbiIsImltcG9ydCBCcmVzZW5oYW0gZnJvbSAnLi9icmVzZW5oYW0nO1xuaW1wb3J0IEltYWdlRGVidWcgZnJvbSAnLi4vY29tbW9uL2ltYWdlX2RlYnVnJztcbmltcG9ydCBDb2RlMTI4UmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzEyOF9yZWFkZXInO1xuaW1wb3J0IEVBTlJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuX3JlYWRlcic7XG5pbXBvcnQgQ29kZTM5UmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzM5X3JlYWRlcic7XG5pbXBvcnQgQ29kZTM5VklOUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzM5X3Zpbl9yZWFkZXInO1xuaW1wb3J0IENvZGFiYXJSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGFiYXJfcmVhZGVyJztcbmltcG9ydCBVUENSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL3VwY19yZWFkZXInO1xuaW1wb3J0IEVBTjhSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl84X3JlYWRlcic7XG5pbXBvcnQgRUFOMlJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuXzJfcmVhZGVyJztcbmltcG9ydCBFQU41UmVhZGVyIGZyb20gJy4uL3JlYWRlci9lYW5fNV9yZWFkZXInO1xuaW1wb3J0IFVQQ0VSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL3VwY19lX3JlYWRlcic7XG5pbXBvcnQgSTJvZjVSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2kyb2Y1X3JlYWRlcic7XG5pbXBvcnQgVHdvT2ZGaXZlUmVhZGVyIGZyb20gJy4uL3JlYWRlci8yb2Y1X3JlYWRlcic7XG5pbXBvcnQgQ29kZTkzUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzkzX3JlYWRlcic7XG5pbXBvcnQgQ29kZTMyUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzMyX3JlYWRlcic7XG5cbmNvbnN0IFJFQURFUlMgPSB7XG4gICAgY29kZV8xMjhfcmVhZGVyOiBDb2RlMTI4UmVhZGVyLFxuICAgIGVhbl9yZWFkZXI6IEVBTlJlYWRlcixcbiAgICBlYW5fNV9yZWFkZXI6IEVBTjVSZWFkZXIsXG4gICAgZWFuXzJfcmVhZGVyOiBFQU4yUmVhZGVyLFxuICAgIGVhbl84X3JlYWRlcjogRUFOOFJlYWRlcixcbiAgICBjb2RlXzM5X3JlYWRlcjogQ29kZTM5UmVhZGVyLFxuICAgIGNvZGVfMzlfdmluX3JlYWRlcjogQ29kZTM5VklOUmVhZGVyLFxuICAgIGNvZGFiYXJfcmVhZGVyOiBDb2RhYmFyUmVhZGVyLFxuICAgIHVwY19yZWFkZXI6IFVQQ1JlYWRlcixcbiAgICB1cGNfZV9yZWFkZXI6IFVQQ0VSZWFkZXIsXG4gICAgaTJvZjVfcmVhZGVyOiBJMm9mNVJlYWRlcixcbiAgICAnMm9mNV9yZWFkZXInOiBUd29PZkZpdmVSZWFkZXIsXG4gICAgY29kZV85M19yZWFkZXI6IENvZGU5M1JlYWRlcixcbiAgICBjb2RlXzMyX3JlYWRlcjogQ29kZTMyUmVhZGVyLFxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIHJlZ2lzdGVyUmVhZGVyOiAobmFtZSwgcmVhZGVyKSA9PiB7XG4gICAgICAgIFJFQURFUlNbbmFtZV0gPSByZWFkZXI7XG4gICAgfSxcbiAgICBjcmVhdGUoY29uZmlnLCBpbnB1dEltYWdlV3JhcHBlcikge1xuICAgICAgICBjb25zdCBfY2FudmFzID0ge1xuICAgICAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICAgICAgZnJlcXVlbmN5OiBudWxsLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IG51bGwsXG4gICAgICAgICAgICAgICAgb3ZlcmxheTogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb206IHtcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IG51bGwsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogbnVsbCxcbiAgICAgICAgICAgICAgICBvdmVybGF5OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgX2JhcmNvZGVSZWFkZXJzID0gW107XG5cbiAgICAgICAgaW5pdENhbnZhcygpO1xuICAgICAgICBpbml0UmVhZGVycygpO1xuICAgICAgICBpbml0Q29uZmlnKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdENhbnZhcygpIHtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnN0ICRkZWJ1ZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNkZWJ1Zy5kZXRlY3Rpb24nKTtcbiAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5mcmVxdWVuY3kgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMuZnJlcXVlbmN5Jyk7XG4gICAgICAgICAgICAgICAgaWYgKCFfY2FudmFzLmRvbS5mcmVxdWVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5kb20uZnJlcXVlbmN5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLmZyZXF1ZW5jeS5jbGFzc05hbWUgPSAnZnJlcXVlbmN5JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGRlYnVnLmFwcGVuZENoaWxkKF9jYW52YXMuZG9tLmZyZXF1ZW5jeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2NhbnZhcy5jdHguZnJlcXVlbmN5ID0gX2NhbnZhcy5kb20uZnJlcXVlbmN5LmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5wYXR0ZXJuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignY2FudmFzLnBhdHRlcm5CdWZmZXInKTtcbiAgICAgICAgICAgICAgICBpZiAoIV9jYW52YXMuZG9tLnBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5kb20ucGF0dGVybiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5wYXR0ZXJuLmNsYXNzTmFtZSA9ICdwYXR0ZXJuQnVmZmVyJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGRlYnVnLmFwcGVuZENoaWxkKF9jYW52YXMuZG9tLnBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9jYW52YXMuY3R4LnBhdHRlcm4gPSBfY2FudmFzLmRvbS5wYXR0ZXJuLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5vdmVybGF5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignY2FudmFzLmRyYXdpbmdCdWZmZXInKTtcbiAgICAgICAgICAgICAgICBpZiAoX2NhbnZhcy5kb20ub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmN0eC5vdmVybGF5ID0gX2NhbnZhcy5kb20ub3ZlcmxheS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXRSZWFkZXJzKCkge1xuICAgICAgICAgICAgY29uZmlnLnJlYWRlcnMuZm9yRWFjaCgocmVhZGVyQ29uZmlnKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHJlYWRlcjtcbiAgICAgICAgICAgICAgICBsZXQgY29uZmlndXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgICAgIGxldCBzdXBwbGVtZW50cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWFkZXJDb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IHJlYWRlckNvbmZpZy5mb3JtYXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24gPSByZWFkZXJDb25maWcuY29uZmlnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlYWRlckNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gcmVhZGVyQ29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdCZWZvcmUgcmVnaXN0ZXJpbmcgcmVhZGVyOiAnLCByZWFkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbi5zdXBwbGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICBzdXBwbGVtZW50cyA9IGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdXBwbGVtZW50cy5tYXAoKHN1cHBsZW1lbnQpID0+IG5ldyBSRUFERVJTW3N1cHBsZW1lbnRdKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWFkZXJPYmogPSBuZXcgUkVBREVSU1tyZWFkZXJdKGNvbmZpZ3VyYXRpb24sIHN1cHBsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgX2JhcmNvZGVSZWFkZXJzLnB1c2gocmVhZGVyT2JqKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignKiBFcnJvciBjb25zdHJ1Y3RpbmcgcmVhZGVyICcsIHJlYWRlciwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZWdpc3RlcmVkIFJlYWRlcnM6ICR7X2JhcmNvZGVSZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKHJlYWRlcikgPT4gSlNPTi5zdHJpbmdpZnkoeyBmb3JtYXQ6IHJlYWRlci5GT1JNQVQsIGNvbmZpZzogcmVhZGVyLmNvbmZpZyB9KSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbml0Q29uZmlnKCkge1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlzID0gW3tcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogX2NhbnZhcy5kb20uZnJlcXVlbmN5LFxuICAgICAgICAgICAgICAgICAgICBwcm9wOiBjb25maWcuZGVidWcuc2hvd0ZyZXF1ZW5jeSxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IF9jYW52YXMuZG9tLnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgIHByb3A6IGNvbmZpZy5kZWJ1Zy5zaG93UGF0dGVybixcbiAgICAgICAgICAgICAgICB9XTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2aXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc1tpXS5wcm9wID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNbaV0ubm9kZS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc1tpXS5ub2RlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogZXh0ZW5kIHRoZSBsaW5lIG9uIGJvdGggZW5kc1xuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBsaW5lXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZ2V0RXh0ZW5kZWRMaW5lKGxpbmUsIGFuZ2xlLCBleHQpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGV4dGVuZExpbmUoYW1vdW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB5OiBhbW91bnQgKiBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICAgICAgICAgIHg6IGFtb3VudCAqIE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4gICAgICAgICAgICAgICAgbGluZVswXS55IC09IGV4dGVuc2lvbi55O1xuICAgICAgICAgICAgICAgIGxpbmVbMF0ueCAtPSBleHRlbnNpb24ueDtcbiAgICAgICAgICAgICAgICBsaW5lWzFdLnkgKz0gZXh0ZW5zaW9uLnk7XG4gICAgICAgICAgICAgICAgbGluZVsxXS54ICs9IGV4dGVuc2lvbi54O1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgaW5zaWRlIGltYWdlXG4gICAgICAgICAgICBleHRlbmRMaW5lKGV4dCk7XG4gICAgICAgICAgICB3aGlsZSAoZXh0ID4gMSAmJiAoIWlucHV0SW1hZ2VXcmFwcGVyLmluSW1hZ2VXaXRoQm9yZGVyKGxpbmVbMF0pXG4gICAgICAgICAgICAgICAgICAgIHx8ICFpbnB1dEltYWdlV3JhcHBlci5pbkltYWdlV2l0aEJvcmRlcihsaW5lWzFdKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBleHQgLT0gTWF0aC5jZWlsKGV4dCAvIDIpO1xuICAgICAgICAgICAgICAgIGV4dGVuZExpbmUoLWV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldExpbmUoYm94KSB7XG4gICAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICB4OiAoYm94WzFdWzBdIC0gYm94WzBdWzBdKSAvIDIgKyBib3hbMF1bMF0sXG4gICAgICAgICAgICAgICAgeTogKGJveFsxXVsxXSAtIGJveFswXVsxXSkgLyAyICsgYm94WzBdWzFdLFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHg6IChib3hbM11bMF0gLSBib3hbMl1bMF0pIC8gMiArIGJveFsyXVswXSxcbiAgICAgICAgICAgICAgICB5OiAoYm94WzNdWzFdIC0gYm94WzJdWzFdKSAvIDIgKyBib3hbMl1bMV0sXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHRyeURlY29kZShsaW5lKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgY29uc3QgYmFyY29kZUxpbmUgPSBCcmVzZW5oYW0uZ2V0QmFyY29kZUxpbmUoaW5wdXRJbWFnZVdyYXBwZXIsIGxpbmVbMF0sIGxpbmVbMV0pO1xuXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZWJ1Zy5zaG93RnJlcXVlbmN5KSB7XG4gICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChsaW5lLCB7IHg6ICd4JywgeTogJ3knIH0sIF9jYW52YXMuY3R4Lm92ZXJsYXksIHsgY29sb3I6ICdyZWQnLCBsaW5lV2lkdGg6IDMgfSk7XG4gICAgICAgICAgICAgICAgQnJlc2VuaGFtLmRlYnVnLnByaW50RnJlcXVlbmN5KGJhcmNvZGVMaW5lLmxpbmUsIF9jYW52YXMuZG9tLmZyZXF1ZW5jeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEJyZXNlbmhhbS50b0JpbmFyeUxpbmUoYmFyY29kZUxpbmUpO1xuXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZWJ1Zy5zaG93UGF0dGVybikge1xuICAgICAgICAgICAgICAgIEJyZXNlbmhhbS5kZWJ1Zy5wcmludFBhdHRlcm4oYmFyY29kZUxpbmUubGluZSwgX2NhbnZhcy5kb20ucGF0dGVybik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBfYmFyY29kZVJlYWRlcnMubGVuZ3RoICYmIHJlc3VsdCA9PT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX2JhcmNvZGVSZWFkZXJzW2ldLmRlY29kZVBhdHRlcm4oYmFyY29kZUxpbmUubGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvZGVSZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICBiYXJjb2RlTGluZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgc2xpY2VzIHRoZSBnaXZlbiBhcmVhIGFwYXJ0IGFuZCB0cmllcyB0byBkZXRlY3QgYSBiYXJjb2RlLXBhdHRlcm5cbiAgICAgICAgICogZm9yIGVhY2ggc2xpY2UuIEl0IHJldHVybnMgdGhlIGRlY29kZWQgYmFyY29kZSwgb3IgbnVsbCBpZiBub3RoaW5nIHdhcyBmb3VuZFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBib3hcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbGluZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUFuZ2xlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB0cnlEZWNvZGVCcnV0ZUZvcmNlKGJveCwgbGluZSwgbGluZUFuZ2xlKSB7XG4gICAgICAgICAgICBjb25zdCBzaWRlTGVuZ3RoID0gTWF0aC5zcXJ0KE1hdGgucG93KGJveFsxXVswXSAtIGJveFswXVswXSwgMikgKyBNYXRoLnBvdygoYm94WzFdWzFdIC0gYm94WzBdWzFdKSwgMikpO1xuICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICBjb25zdCBzbGljZXMgPSAxNjtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGRpcjtcbiAgICAgICAgICAgIGxldCBleHRlbnNpb247XG4gICAgICAgICAgICBjb25zdCB4ZGlyID0gTWF0aC5zaW4obGluZUFuZ2xlKTtcbiAgICAgICAgICAgIGNvbnN0IHlkaXIgPSBNYXRoLmNvcyhsaW5lQW5nbGUpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgc2xpY2VzICYmIHJlc3VsdCA9PT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gbW92ZSBsaW5lIHBlcnBlbmRpY3VsYXIgdG8gYW5nbGVcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWl4ZWQtb3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgZGlyID0gc2lkZUxlbmd0aCAvIHNsaWNlcyAqIGkgKiAoaSAlIDIgPT09IDAgPyAtMSA6IDEpO1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeTogZGlyICogeGRpcixcbiAgICAgICAgICAgICAgICAgICAgeDogZGlyICogeWRpcixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4gICAgICAgICAgICAgICAgbGluZVswXS55ICs9IGV4dGVuc2lvbi54O1xuICAgICAgICAgICAgICAgIGxpbmVbMF0ueCAtPSBleHRlbnNpb24ueTtcbiAgICAgICAgICAgICAgICBsaW5lWzFdLnkgKz0gZXh0ZW5zaW9uLng7XG4gICAgICAgICAgICAgICAgbGluZVsxXS54IC09IGV4dGVuc2lvbi55O1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRyeURlY29kZShsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRMaW5lTGVuZ3RoKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgICAgTWF0aC5wb3coTWF0aC5hYnMobGluZVsxXS55IC0gbGluZVswXS55KSwgMilcbiAgICAgICAgICAgICAgICArIE1hdGgucG93KE1hdGguYWJzKGxpbmVbMV0ueCAtIGxpbmVbMF0ueCksIDIpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRlY29kZUZyb21JbWFnZShpbWFnZVdyYXBwZXIpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBfYmFyY29kZVJlYWRlcnMubGVuZ3RoICYmIHJlc3VsdCA9PT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX2JhcmNvZGVSZWFkZXJzW2ldLmRlY29kZUltYWdlID8gX2JhcmNvZGVSZWFkZXJzW2ldLmRlY29kZUltYWdlKGltYWdlV3JhcHBlcikgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV2l0aCB0aGUgaGVscCBvZiB0aGUgY29uZmlndXJlZCByZWFkZXJzIChDb2RlMTI4IG9yIEVBTikgdGhpcyBmdW5jdGlvbiB0cmllcyB0byBkZXRlY3QgYVxuICAgICAgICAgKiB2YWxpZCBiYXJjb2RlIHBhdHRlcm4gd2l0aGluIHRoZSBnaXZlbiBhcmVhLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYm94IFRoZSBhcmVhIHRvIHNlYXJjaCBpblxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcmVzdWx0IHtjb2RlUmVzdWx0LCBsaW5lLCBhbmdsZSwgcGF0dGVybiwgdGhyZXNob2xkfVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlRnJvbUJvdW5kaW5nQm94KGJveCkge1xuICAgICAgICAgICAgbGV0IGxpbmU7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBfY2FudmFzLmN0eC5vdmVybGF5O1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcblxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuZGVidWcuZHJhd0JvdW5kaW5nQm94ICYmIGN0eCkge1xuICAgICAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGJveCwgeyB4OiAwLCB5OiAxIH0sIGN0eCwgeyBjb2xvcjogJ2JsdWUnLCBsaW5lV2lkdGg6IDIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaW5lID0gZ2V0TGluZShib3gpO1xuICAgICAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGdldExpbmVMZW5ndGgobGluZSk7XG4gICAgICAgICAgICBjb25zdCBsaW5lQW5nbGUgPSBNYXRoLmF0YW4yKGxpbmVbMV0ueSAtIGxpbmVbMF0ueSwgbGluZVsxXS54IC0gbGluZVswXS54KTtcbiAgICAgICAgICAgIGxpbmUgPSBnZXRFeHRlbmRlZExpbmUobGluZSwgbGluZUFuZ2xlLCBNYXRoLmZsb29yKGxpbmVMZW5ndGggKiAwLjEpKTtcbiAgICAgICAgICAgIGlmIChsaW5lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IHRyeURlY29kZShsaW5lKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnlEZWNvZGVCcnV0ZUZvcmNlKGJveCwgbGluZSwgbGluZUFuZ2xlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIHJlc3VsdCAmJiBjb25maWcuZGVidWcuZHJhd1NjYW5saW5lICYmIGN0eCkge1xuICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgobGluZSwgeyB4OiAneCcsIHk6ICd5JyB9LCBjdHgsIHsgY29sb3I6ICdyZWQnLCBsaW5lV2lkdGg6IDMgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29kZVJlc3VsdDogcmVzdWx0LmNvZGVSZXN1bHQsXG4gICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICBhbmdsZTogbGluZUFuZ2xlLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IHJlc3VsdC5iYXJjb2RlTGluZS5saW5lLFxuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogcmVzdWx0LmJhcmNvZGVMaW5lLnRocmVzaG9sZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVjb2RlRnJvbUJvdW5kaW5nQm94KGJveCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNvZGVGcm9tQm91bmRpbmdCb3hlcyhib3hlcykge1xuICAgICAgICAgICAgICAgIGxldCBpOyBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhcmNvZGVzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgeyBtdWx0aXBsZSB9ID0gY29uZmlnO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJveCA9IGJveGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmJveCA9IGJveDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcmNvZGVzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuY29kZVJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZXMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29kZUZyb21JbWFnZShpbnB1dEltYWdlV3JhcHBlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlY29kZUZyb21JbWFnZShpbnB1dEltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoUkVBREVSU1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCByZWdpc3RlciBleGlzdGluZyByZWFkZXInLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUkVBREVSU1tuYW1lXSA9IHJlYWRlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRSZWFkZXJzKHJlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBjb25maWcucmVhZGVycyA9IHJlYWRlcnM7XG4gICAgICAgICAgICAgICAgX2JhcmNvZGVSZWFkZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgaW5pdFJlYWRlcnMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbn07XG4iLCJ0eXBlIEV2ZW50TmFtZSA9IHN0cmluZztcblxuaW50ZXJmYWNlIFN1YnNjcmlwdGlvbiB7XG4gICAgYXN5bmM/OiBib29sZWFuO1xuICAgIGNhbGxiYWNrOiBGdW5jdGlvbjtcbiAgICBvbmNlPzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIEV2ZW50RGF0YSB7XG4gICAgc3Vic2NyaWJlcnM6IEFycmF5PFN1YnNjcmlwdGlvbj47XG59XG5cbmludGVyZmFjZSBFdmVudHMge1xuICAgIFtrZXk6IHN0cmluZ106IEV2ZW50RGF0YTtcbn1cblxuaW50ZXJmYWNlIEV2ZW50SW50ZXJmYWNlIHtcbiAgICBzdWJzY3JpYmUoZXZlbnQ6IEV2ZW50TmFtZSwgY2FsbGJhY2s6IEZ1bmN0aW9uIHwgU3Vic2NyaXB0aW9uLCBhc3luYz86IGJvb2xlYW4pOiB2b2lkO1xuICAgIHB1Ymxpc2goZXZlbnROYW1lOiBFdmVudE5hbWUsIGRhdGE/OiBuZXZlcik6IHZvaWQ7XG4gICAgb25jZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgdW5zdWJzY3JpYmUoZXZlbnROYW1lPzogRXZlbnROYW1lLCBjYWxsYmFjaz86IEZ1bmN0aW9uIHwgU3Vic2NyaXB0aW9uKTogdm9pZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIEV2ZW50SW50ZXJmYWNlKCk6IEV2ZW50SW50ZXJmYWNlIHtcbiAgICBsZXQgZXZlbnRzOiBFdmVudHMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGdldEV2ZW50KGV2ZW50TmFtZTogRXZlbnROYW1lKTogRXZlbnREYXRhIHtcbiAgICAgICAgaWYgKCFldmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgZXZlbnRzW2V2ZW50TmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcnM6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnRzW2V2ZW50TmFtZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJFdmVudHMoKTogdm9pZCB7XG4gICAgICAgIGV2ZW50cyA9IHt9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1Ymxpc2hTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24sIGRhdGE6IG5ldmVyKTogdm9pZCB7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5jYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgIH0sIDQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3N1YnNjcmliZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBsZXQgc3Vic2NyaXB0aW9uO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBhc3luYyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBjYWxsYmFjaztcbiAgICAgICAgICAgIGlmICghc3Vic2NyaXB0aW9uLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsYmFjayB3YXMgbm90IHNwZWNpZmllZCBvbiBvcHRpb25zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZXRFdmVudChldmVudCkuc3Vic2NyaWJlcnMucHVzaChzdWJzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnNjcmliZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICAgICAgcmV0dXJuIF9zdWJzY3JpYmUoZXZlbnQsIGNhbGxiYWNrLCBhc3luYyk7XG4gICAgICAgIH0sXG4gICAgICAgIHB1Ymxpc2goZXZlbnROYW1lOiBFdmVudE5hbWUsIGRhdGE/OiBuZXZlcik6IHZvaWQge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBnZXRFdmVudChldmVudE5hbWUpO1xuICAgICAgICAgICAgY29uc3QgeyBzdWJzY3JpYmVycyB9ID0gZXZlbnQ7XG5cbiAgICAgICAgICAgIC8vIFB1Ymxpc2ggb25lLXRpbWUgc3Vic2NyaXB0aW9uc1xuICAgICAgICAgICAgc3Vic2NyaWJlcnMuZmlsdGVyKChzdWJzY3JpYmVyKSA9PiAhIXN1YnNjcmliZXIub25jZSkuZm9yRWFjaCgoc3Vic2NyaWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIHB1Ymxpc2hTdWJzY3JpcHRpb24oc3Vic2NyaWJlciwgZGF0YSBhcyBuZXZlcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgc3Vic2NyaWJlclxuICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMgPSBzdWJzY3JpYmVycy5maWx0ZXIoKHN1YnNjcmliZXIpID0+ICFzdWJzY3JpYmVyLm9uY2UpO1xuXG4gICAgICAgICAgICAvLyBwdWJsaXNoIHRoZSByZXN0XG4gICAgICAgICAgICBldmVudC5zdWJzY3JpYmVycy5mb3JFYWNoKChzdWJzY3JpYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgcHVibGlzaFN1YnNjcmlwdGlvbihzdWJzY3JpYmVyLCBkYXRhIGFzIG5ldmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbmNlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiwgYXN5bmMgPSBmYWxzZSk6IHZvaWQge1xuICAgICAgICAgICAgX3N1YnNjcmliZShldmVudCwge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGFzeW5jLFxuICAgICAgICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zdWJzY3JpYmUoZXZlbnROYW1lPzogRXZlbnROYW1lLCBjYWxsYmFjaz86IEZ1bmN0aW9uIHwgU3Vic2NyaXB0aW9uKTogdm9pZCB7XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBnZXRFdmVudChldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChldmVudCAmJiBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdWJzY3JpYmVycyA9IGV2ZW50LnN1YnNjcmliZXJzLmZpbHRlcigoc3Vic2NyaWJlcikgPT4gc3Vic2NyaWJlci5jYWxsYmFjayAhPT0gY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN1YnNjcmliZXJzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGVhckV2ZW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59KCkpO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGVudW1lcmF0ZURldmljZXMoKTogUHJvbWlzZTxBcnJheTxNZWRpYURldmljZUluZm8+PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdlbnVtZXJhdGVEZXZpY2VzIGlzIG5vdCBkZWZpbmVkJykpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJNZWRpYShjb25zdHJhaW50czogTWVkaWFTdHJlYW1Db25zdHJhaW50cyk6IFByb21pc2U8TWVkaWFTdHJlYW0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdnZXRVc2VyTWVkaWEgaXMgbm90IGRlZmluZWQnKSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgcGljayB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBnZXRVc2VyTWVkaWEsIGVudW1lcmF0ZURldmljZXMgfSBmcm9tICcuLi9jb21tb24vbWVkaWFEZXZpY2VzJztcbmltcG9ydCB7IE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkIH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmxldCBzdHJlYW1SZWY6IE1lZGlhU3RyZWFtIHwgbnVsbDtcblxuZnVuY3Rpb24gd2FpdEZvclZpZGVvKHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbGV0IGF0dGVtcHRzID0gMTA7XG5cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tWaWRlbygpOiB2b2lkIHtcbiAgICAgICAgICAgIGlmIChhdHRlbXB0cyA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodmlkZW8udmlkZW9XaWR0aCA+IDEwICYmIHZpZGVvLnZpZGVvSGVpZ2h0ID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCogZGV2OiBjaGVja1ZpZGVvIGZvdW5kICR7dmlkZW8udmlkZW9XaWR0aH1weCB4ICR7dmlkZW8udmlkZW9IZWlnaHR9cHhgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2hlY2tWaWRlbywgNTAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1VuYWJsZSB0byBwbGF5IHZpZGVvIHN0cmVhbS4gSXMgd2ViY2FtIHdvcmtpbmc/JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0ZW1wdHMtLTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja1ZpZGVvKCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogVHJpZXMgdG8gYXR0YWNoIHRoZSBjYW1lcmEtc3RyZWFtIHRvIGEgZ2l2ZW4gdmlkZW8tZWxlbWVudFxuICogYW5kIGNhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoZSBjb250ZW50IGlzIHJlYWR5XG4gKiBAcGFyYW0ge09iamVjdH0gY29uc3RyYWludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSB2aWRlb1xuICovXG5hc3luYyBmdW5jdGlvbiBpbml0Q2FtZXJhKHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50LCBjb25zdHJhaW50czogTWVkaWFTdHJlYW1Db25zdHJhaW50cyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IGdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgc3RyZWFtUmVmID0gc3RyZWFtO1xuICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgnYXV0b3BsYXknLCAndHJ1ZScpO1xuICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgnbXV0ZWQnLCAndHJ1ZScpO1xuICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgncGxheXNpbmxpbmUnLCAndHJ1ZScpOyAvLyBub3QgbGlzdGVkIG9uIE1ETi4uLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHZpZGVvLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICB2aWRlby5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsICgpID0+IHtcbiAgICAgICAgdmlkZW8ucGxheSgpO1xuICAgIH0pO1xuICAgIHJldHVybiB3YWl0Rm9yVmlkZW8odmlkZW8pO1xufVxuXG5mdW5jdGlvbiBkZXByZWNhdGVkQ29uc3RyYWludHModmlkZW9Db25zdHJhaW50czogTWVkaWFUcmFja0NvbnN0cmFpbnRzV2l0aERlcHJlY2F0ZWQpOiBNZWRpYVRyYWNrQ29uc3RyYWludHMge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBwaWNrKHZpZGVvQ29uc3RyYWludHMsIFsnd2lkdGgnLCAnaGVpZ2h0JywgJ2ZhY2luZ01vZGUnLFxuICAgICAgICAnYXNwZWN0UmF0aW8nLCAnZGV2aWNlSWQnXSk7XG5cbiAgICBpZiAodHlwZW9mIHZpZGVvQ29uc3RyYWludHMubWluQXNwZWN0UmF0aW8gIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAmJiB2aWRlb0NvbnN0cmFpbnRzLm1pbkFzcGVjdFJhdGlvID4gMCkge1xuICAgICAgICBub3JtYWxpemVkLmFzcGVjdFJhdGlvID0gdmlkZW9Db25zdHJhaW50cy5taW5Bc3BlY3RSYXRpbztcbiAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IENvbnN0cmFpbnQgXFwnbWluQXNwZWN0UmF0aW9cXCcgaXMgZGVwcmVjYXRlZDsgVXNlIFxcJ2FzcGVjdFJhdGlvXFwnIGluc3RlYWQnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2aWRlb0NvbnN0cmFpbnRzLmZhY2luZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbm9ybWFsaXplZC5mYWNpbmdNb2RlID0gdmlkZW9Db25zdHJhaW50cy5mYWNpbmc7XG4gICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBDb25zdHJhaW50IFxcJ2ZhY2luZ1xcJyBpcyBkZXByZWNhdGVkLiBVc2UgXFwnZmFjaW5nTW9kZVxcJyBpbnN0ZWFkXFwnJyk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkO1xufVxuXG4vLyBUT0RPOiAjMTkyIEkgZG9uJ3QgdGhpbmsgdGhlcmUncyBhbnkgZ29vZCByZWFzb24gcGlja0NvbnN0cmFpbnRzIHNob3VsZCByZXR1cm4gYSBQcm9taXNlLFxuLy8gSSB0aGluayBpdCB3YXMganVzdCB0aGF0IHdheSBzbyBpdCBjb3VsZCBiZSBjaGFpbmVkIHRvIG90aGVyIGZ1bmN0aW9ucyB0aGF0IGRpZCByZXR1cm4gYSBQcm9taXNlLlxuLy8gVGhhdCdzIG5vdCBuZWNlc3Nhcnkgd2l0aCBhc3luYyBmdW5jdGlvbnMgYmVpbmcgYSB0aGluZywgc28gdGhhdCBzaG91bGQgYmUgZml4ZWQuXG5leHBvcnQgZnVuY3Rpb24gcGlja0NvbnN0cmFpbnRzKHZpZGVvQ29uc3RyYWludHM6IE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkID0ge30pOiBQcm9taXNlPE1lZGlhU3RyZWFtQ29uc3RyYWludHM+IHtcbiAgICBjb25zdCB2aWRlbyA9IGRlcHJlY2F0ZWRDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzKTtcblxuICAgIGlmICh2aWRlbyAmJiB2aWRlby5kZXZpY2VJZCAmJiB2aWRlby5mYWNpbmdNb2RlKSB7XG4gICAgICAgIGRlbGV0ZSB2aWRlby5mYWNpbmdNb2RlO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgYXVkaW86IGZhbHNlLCB2aWRlbyB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZW51bWVyYXRlVmlkZW9EZXZpY2VzKCk6IFByb21pc2U8QXJyYXk8TWVkaWFEZXZpY2VJbmZvPj4ge1xuICAgIGNvbnN0IGRldmljZXMgPSBhd2FpdCBlbnVtZXJhdGVEZXZpY2VzKCk7XG4gICAgcmV0dXJuIGRldmljZXMuZmlsdGVyKChkZXZpY2U6IE1lZGlhRGV2aWNlSW5mbykgPT4gZGV2aWNlLmtpbmQgPT09ICd2aWRlb2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIGdldEFjdGl2ZVRyYWNrKCk6IE1lZGlhU3RyZWFtVHJhY2sgfCBudWxsIHtcbiAgICBpZiAoIXN0cmVhbVJlZikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdHJhY2tzID0gc3RyZWFtUmVmLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgcmV0dXJuIHRyYWNrcyAmJiB0cmFja3M/Lmxlbmd0aCA/IHRyYWNrc1swXSA6IG51bGw7XG59XG5cbi8qKlxuICogVXNlZCBmb3IgYWNjZXNzaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBhY3RpdmUgc3RyZWFtIHRyYWNrIGFuZCBhdmFpbGFibGUgdmlkZW8gZGV2aWNlcy5cbiAqL1xuY29uc3QgUXVhZ2dhSlNDYW1lcmFBY2Nlc3MgPSB7XG4gICAgYXN5bmMgcmVxdWVzdCh2aWRlbzogSFRNTFZpZGVvRWxlbWVudCwgdmlkZW9Db25zdHJhaW50cz86IE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgY29uc3QgbmV3Q29uc3RyYWludHMgPSBhd2FpdCBwaWNrQ29uc3RyYWludHModmlkZW9Db25zdHJhaW50cyk7XG4gICAgICAgIHJldHVybiBpbml0Q2FtZXJhKHZpZGVvLCBuZXdDb25zdHJhaW50cyk7XG4gICAgfSxcbiAgICByZWxlYXNlKCk6IHZvaWQge1xuICAgICAgICAvLyBUT0RPOiBpIHdvbmRlciBpZiB0ZWxsaW5nIHRoZSBWaWRlbyBlbGVtZW50IHRvIHBhdXNlKCkgYmVmb3JlIGNhbGxpbmcgTWVkaWFTdHJlYW1UcmFjay5zdG9wKCkgd291bGQgYWxsZXZpYXRlIHNvbWUgb2YgdGhlIGlzc3VlcyB3aXRoIHRoZSBjYW1lcmEgYXBwZWFyaW5nIHRvIHN0YXkgb3BlbiBvbiBBbmRyb2lkIGV2ZW4gYWZ0ZXIgc3RvcHBpbmcuXG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IHN0cmVhbVJlZiAmJiBzdHJlYW1SZWYuZ2V0VmlkZW9UcmFja3MoKTtcbiAgICAgICAgaWYgKHRyYWNrcyAmJiB0cmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0cmFja3NbMF0uc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbVJlZiA9IG51bGw7XG4gICAgfSxcbiAgICBlbnVtZXJhdGVWaWRlb0RldmljZXMsXG4gICAgZ2V0QWN0aXZlU3RyZWFtTGFiZWwoKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSBnZXRBY3RpdmVUcmFjaygpO1xuICAgICAgICByZXR1cm4gdHJhY2sgPyB0cmFjay5sYWJlbCA6ICcnO1xuICAgIH0sXG4gICAgZ2V0QWN0aXZlVHJhY2ssXG59O1xuXG5leHBvcnQgZGVmYXVsdCBRdWFnZ2FKU0NhbWVyYUFjY2VzcztcbiIsImltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4uL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XG5pbXBvcnQge1xuICAgIFF1YWdnYUpTQ29kZVJlc3VsdCxcbiAgICBRdWFnZ2FKU1Jlc3VsdENvbGxlY3RvcixcbiAgICBRdWFnZ2FKU1Jlc3VsdENvbGxlY3RvckZpbHRlckZ1bmN0aW9uLFxuICAgIFhZU2l6ZSxcbiAgICBRdWFnZ2FJbWFnZURhdGEsXG59IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5mdW5jdGlvbiBjb250YWlucyhjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQsIGxpc3Q6IEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gbGlzdCAmJiBsaXN0LnNvbWUoKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGl0ZW0pIGFzIEFycmF5PGtleW9mIFF1YWdnYUpTQ29kZVJlc3VsdD47XG4gICAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KChrZXkpID0+IGl0ZW1ba2V5XSA9PT0gY29kZVJlc3VsdFtrZXldKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcGFzc2VzRmlsdGVyKFxuICAgIGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCxcbiAgICBmaWx0ZXI6IFF1YWdnYUpTUmVzdWx0Q29sbGVjdG9yRmlsdGVyRnVuY3Rpb24gfCB1bmRlZmluZWQsXG4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJyA/IGZpbHRlcihjb2RlUmVzdWx0KSA6IHRydWU7XG59XG5cbmludGVyZmFjZSBSZXN1bHRDb2xsZWN0b3Ige1xuICAgIGFkZFJlc3VsdDogKGRhdGE6IFF1YWdnYUltYWdlRGF0YSwgaW1hZ2VTaXplOiBYWVNpemUsIGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCkgPT4gdm9pZDtcbiAgICBnZXRSZXN1bHRzOiAoKSA9PiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgY3JlYXRlKGNvbmZpZzogUXVhZ2dhSlNSZXN1bHRDb2xsZWN0b3IpOiBSZXN1bHRDb2xsZWN0b3Ige1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJykgYXMgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuICAgICAgICBjb25zdCByZXN1bHRzOiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+ID0gW107XG4gICAgICAgIGxldCBjYXBhY2l0eSA9IGNvbmZpZy5jYXBhY2l0eSA/PyAyMDtcbiAgICAgICAgY29uc3QgY2FwdHVyZSA9IGNvbmZpZy5jYXB0dXJlID09PSB0cnVlO1xuXG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoZXNDb25zdHJhaW50cyhjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQpOiBib29sZWFuIHtcbiAgICAgICAgICAgIHJldHVybiAhIWNhcGFjaXR5XG4gICAgICAgICAgICAgICAgJiYgY29kZVJlc3VsdFxuICAgICAgICAgICAgICAgICYmICFjb250YWlucyhjb2RlUmVzdWx0LCBjb25maWcuYmxhY2tsaXN0IGFzIEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD4pXG4gICAgICAgICAgICAgICAgJiYgcGFzc2VzRmlsdGVyKGNvZGVSZXN1bHQsIGNvbmZpZy5maWx0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZFJlc3VsdChkYXRhOiBRdWFnZ2FJbWFnZURhdGEsIGltYWdlU2l6ZTogWFlTaXplLCBjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQpOiB2b2lkIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQ6IGFueSA9IHsgfTsgLy8gdGhpcyBpcyAnYW55JyB0byBhdm9pZCBoYXZpbmcgdG8gY29uc3RydWN0IGEgd2hvbGUgUXVhZ2dhSlNDb2RlUmVzdWx0IDp8XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNDb25zdHJhaW50cyhjb2RlUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICBjYXBhY2l0eS0tO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY29kZVJlc3VsdCA9IGNvZGVSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBpbWFnZVNpemUueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZVNpemUueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd0ltYWdlKGRhdGEsIGltYWdlU2l6ZSwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5mcmFtZSA9IGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UmVzdWx0cygpOiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbn07XG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5jb25zdCBEZXZDb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0ID0ge1xuICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgIG5hbWU6ICdMaXZlJyxcbiAgICAgICAgdHlwZTogJ0xpdmVTdHJlYW0nLFxuICAgICAgICBjb25zdHJhaW50czoge1xuICAgICAgICAgICAgd2lkdGg6IDY0MCxcbiAgICAgICAgICAgIGhlaWdodDogNDgwLFxuICAgICAgICAgICAgLy8gYXNwZWN0UmF0aW86IDY0MC80ODAsIC8vIG9wdGlvbmFsXG4gICAgICAgICAgICBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnLCAvLyBvciB1c2VyXG4gICAgICAgICAgICAvLyBkZXZpY2VJZDogXCIzODc0NTk4MzQ1NzM4NzU5ODM3NTk4Mzc1OTgzNFwiXG4gICAgICAgIH0sXG4gICAgICAgIGFyZWE6IHtcbiAgICAgICAgICAgIHRvcDogJzAlJyxcbiAgICAgICAgICAgIHJpZ2h0OiAnMCUnLFxuICAgICAgICAgICAgbGVmdDogJzAlJyxcbiAgICAgICAgICAgIGJvdHRvbTogJzAlJyxcbiAgICAgICAgfSxcbiAgICAgICAgc2luZ2xlQ2hhbm5lbDogZmFsc2UsIC8vIHRydWU6IG9ubHkgdGhlIHJlZCBjb2xvci1jaGFubmVsIGlzIHJlYWRcbiAgICB9LFxuICAgIGxvY2F0ZTogdHJ1ZSxcbiAgICBudW1PZldvcmtlcnM6IDAsXG4gICAgZGVjb2Rlcjoge1xuICAgICAgICByZWFkZXJzOiBbXG4gICAgICAgICAgICAnY29kZV8xMjhfcmVhZGVyJyxcbiAgICAgICAgXSxcbiAgICAgICAgZGVidWc6IHtcbiAgICAgICAgICAgIGRyYXdCb3VuZGluZ0JveDogZmFsc2UsXG4gICAgICAgICAgICBzaG93RnJlcXVlbmN5OiBmYWxzZSxcbiAgICAgICAgICAgIGRyYXdTY2FubGluZTogZmFsc2UsXG4gICAgICAgICAgICBzaG93UGF0dGVybjogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBsb2NhdG9yOiB7XG4gICAgICAgIGhhbGZTYW1wbGU6IHRydWUsXG4gICAgICAgIHBhdGNoU2l6ZTogJ21lZGl1bScsIC8vIHgtc21hbGwsIHNtYWxsLCBtZWRpdW0sIGxhcmdlLCB4LWxhcmdlXG4gICAgICAgIGRlYnVnOiB7XG4gICAgICAgICAgICBzaG93Q2FudmFzOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dQYXRjaGVzOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dGb3VuZFBhdGNoZXM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1NrZWxldG9uOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dMYWJlbHM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1BhdGNoTGFiZWxzOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dSZW1haW5pbmdQYXRjaExhYmVsczogZmFsc2UsXG4gICAgICAgICAgICBib3hGcm9tUGF0Y2hlczoge1xuICAgICAgICAgICAgICAgIHNob3dUcmFuc2Zvcm1lZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd1RyYW5zZm9ybWVkQm94OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93QkI6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgRGV2Q29uZmlnO1xuIiwiaW1wb3J0IHsgUXVhZ2dhSlNDb25maWdPYmplY3QgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcblxuY29uc3QgTm9kZUNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QgPSB7XG4gICAgaW5wdXRTdHJlYW06IHtcbiAgICAgICAgdHlwZTogJ0ltYWdlU3RyZWFtJyxcbiAgICAgICAgc2VxdWVuY2U6IGZhbHNlLFxuICAgICAgICBzaXplOiA4MDAsXG4gICAgICAgIGFyZWE6IHtcbiAgICAgICAgICAgIHRvcDogJzAlJyxcbiAgICAgICAgICAgIHJpZ2h0OiAnMCUnLFxuICAgICAgICAgICAgbGVmdDogJzAlJyxcbiAgICAgICAgICAgIGJvdHRvbTogJzAlJyxcbiAgICAgICAgfSxcbiAgICAgICAgc2luZ2xlQ2hhbm5lbDogZmFsc2UsIC8vIHRydWU6IG9ubHkgdGhlIHJlZCBjb2xvci1jaGFubmVsIGlzIHJlYWRcbiAgICB9LFxuICAgIGxvY2F0ZTogdHJ1ZSxcbiAgICBudW1PZldvcmtlcnM6IDAsXG4gICAgZGVjb2Rlcjoge1xuICAgICAgICByZWFkZXJzOiBbXG4gICAgICAgICAgICAnY29kZV8xMjhfcmVhZGVyJyxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIGxvY2F0b3I6IHtcbiAgICAgICAgaGFsZlNhbXBsZTogdHJ1ZSxcbiAgICAgICAgcGF0Y2hTaXplOiAnbWVkaXVtJywgLy8geC1zbWFsbCwgc21hbGwsIG1lZGl1bSwgbGFyZ2UsIHgtbGFyZ2VcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgTm9kZUNvbmZpZztcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmNvbnN0IFByb2RDb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0ID0ge1xuICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgIG5hbWU6ICdMaXZlJyxcbiAgICAgICAgdHlwZTogJ0xpdmVTdHJlYW0nLFxuICAgICAgICBjb25zdHJhaW50czoge1xuICAgICAgICAgICAgd2lkdGg6IDY0MCxcbiAgICAgICAgICAgIGhlaWdodDogNDgwLFxuICAgICAgICAgICAgLy8gYXNwZWN0UmF0aW86IDY0MC80ODAsIC8vIG9wdGlvbmFsXG4gICAgICAgICAgICBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnLCAvLyBvciB1c2VyXG4gICAgICAgICAgICAvLyBkZXZpY2VJZDogXCIzODc0NTk4MzQ1NzM4NzU5ODM3NTk4Mzc1OTgzNFwiXG4gICAgICAgIH0sXG4gICAgICAgIGFyZWE6IHtcbiAgICAgICAgICAgIHRvcDogJzAlJyxcbiAgICAgICAgICAgIHJpZ2h0OiAnMCUnLFxuICAgICAgICAgICAgbGVmdDogJzAlJyxcbiAgICAgICAgICAgIGJvdHRvbTogJzAlJyxcbiAgICAgICAgfSxcbiAgICAgICAgc2luZ2xlQ2hhbm5lbDogZmFsc2UsIC8vIHRydWU6IG9ubHkgdGhlIHJlZCBjb2xvci1jaGFubmVsIGlzIHJlYWRcbiAgICB9LFxuICAgIGxvY2F0ZTogdHJ1ZSxcbiAgICBudW1PZldvcmtlcnM6IDQsXG4gICAgZGVjb2Rlcjoge1xuICAgICAgICByZWFkZXJzOiBbXG4gICAgICAgICAgICAnY29kZV8xMjhfcmVhZGVyJyxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIGxvY2F0b3I6IHtcbiAgICAgICAgaGFsZlNhbXBsZTogdHJ1ZSxcbiAgICAgICAgcGF0Y2hTaXplOiAnbWVkaXVtJywgLy8geC1zbWFsbCwgc21hbGwsIG1lZGl1bSwgbGFyZ2UsIHgtbGFyZ2VcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgUHJvZENvbmZpZztcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5pbXBvcnQgRGV2Q29uZmlnIGZyb20gJy4vY29uZmlnLmRldic7XG5pbXBvcnQgTm9kZUNvbmZpZyBmcm9tICcuL2NvbmZpZy5ub2RlJztcbmltcG9ydCBQcm9kQ29uZmlnIGZyb20gJy4vY29uZmlnLnByb2QnO1xuXG4vLyBAdHMtaWdub3JlIC8vIFRPRE86IHRoaXMgcHJvZHVjZXMgYSBiaXphcnJlIHR5cGVzY3JpcHQgZXJyb3Jcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuY29uc3QgUXVhZ2dhQ29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCA9IEVOVi5kZXZlbG9wbWVudFxuICAgID8gRGV2Q29uZmlnXG4gICAgOiBFTlYubm9kZVxuICAgICAgICA/IE5vZGVDb25maWdcbiAgICAgICAgOiBQcm9kQ29uZmlnO1xuXG5leHBvcnQgZGVmYXVsdCBRdWFnZ2FDb25maWc7XG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gXCIuLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYVwiO1xuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tIFwiY29tbW9uL2ltYWdlX3dyYXBwZXJcIjtcblxuZXhwb3J0IGNsYXNzIFF1YWdnYUNvbnRleHQge1xuICAgIHB1YmxpYyBjb25maWc/OiBRdWFnZ2FKU0NvbmZpZ09iamVjdDtcblxuICAgIHB1YmxpYyBpbnB1dFN0cmVhbTogYW55O1xuXG4gICAgcHVibGljIGZyYW1lZ3JhYmJlcjogYW55O1xuXG4gICAgcHVibGljIGlucHV0SW1hZ2VXcmFwcGVyPzogSW1hZ2VXcmFwcGVyO1xuXG4gICAgcHVibGljIHN0b3BwZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHB1YmxpYyBib3hTaXplOiBhbnk7XG5cbiAgICBwdWJsaWMgcmVzdWx0Q29sbGVjdG9yOiBhbnk7XG5cbiAgICBwdWJsaWMgZGVjb2RlcjogYW55O1xuXG4gICAgcHVibGljIHdvcmtlclBvb2w6IGFueVtdID0gW107XG5cbiAgICBwdWJsaWMgb25VSVRocmVhZCA9IHRydWU7XG5cbiAgICBwdWJsaWMgcmVhZG9ubHkgY2FudmFzQ29udGFpbmVyID0gbmV3IENhbnZhc0NvbnRhaW5lcigpO1xufVxuXG5leHBvcnQgY2xhc3MgQ2FudmFzSW5mbyB7XG4gICAgaW1hZ2U6IGFueTtcbiAgICBvdmVybGF5OiBhbnk7XG59XG5cbmV4cG9ydCBjbGFzcyBDYW52YXNDb250YWluZXIge1xuICAgIHB1YmxpYyByZWFkb25seSBjdHg6IENhbnZhc0luZm87XG4gICAgcHVibGljIHJlYWRvbmx5IGRvbTogQ2FudmFzSW5mbztcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmN0eCA9IG5ldyBDYW52YXNJbmZvKCk7XG4gICAgICAgIHRoaXMuZG9tID0gbmV3IENhbnZhc0luZm8oKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBjbG9uZSB9IGZyb20gJ2dsLXZlYzInO1xuaW1wb3J0IHR5cGUgeyBJbnB1dFN0cmVhbSB9IGZyb20gJy4uL2lucHV0L2lucHV0X3N0cmVhbV9mYWN0b3J5JztcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSAnLi4vY29tbW9uL2ltYWdlX3dyYXBwZXInO1xuaW1wb3J0IEJhcmNvZGVMb2NhdG9yIGZyb20gJy4uL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yJztcblxudHlwZSBCdWZmZXJSZXR1cm4gPSB7XG4gICAgaW5wdXRJbWFnZVdyYXBwZXI6IEltYWdlV3JhcHBlcjtcbiAgICAvLyBib3hTaXplIHNob3VsZCBiZSBsaWtlIFtbIG51bWJlciwgbnVtYmVyXSwgLi4uXSBidXQgY2xvbmUncyBzaWduYXR1cmUgZG9lc24ndCBzZWVtIHRvIGFsbG93IHRoYXRcbiAgICBib3hTaXplOiBBcnJheTxBcnJheTxudW1iZXI+Pjtcbn07XG5cbi8vIFRPRE86IG5lZWQgdHlwZXNjcmlwdCBkZWYgZm9yIEJhcmNvZGVMb2NhdG9yXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbml0QnVmZmVycyhcbiAgICBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0sXG4gICAgaW1hZ2VXcmFwcGVyOiBJbWFnZVdyYXBwZXIgfCB1bmRlZmluZWQsXG4gICAgbG9jYXRvcjogYW55LFxuKTogQnVmZmVyUmV0dXJuIHtcbiAgICBjb25zdCBpbnB1dEltYWdlV3JhcHBlciA9IGltYWdlV3JhcHBlciB8fCBuZXcgSW1hZ2VXcmFwcGVyKHtcbiAgICAgICAgeDogaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSxcbiAgICAgICAgeTogaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCksXG4gICAgICAgIHR5cGU6ICdYWVNpemUnLFxuICAgIH0pO1xuXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgaW1hZ2Ugd3JhcHBlciBzaXplICR7aW5wdXRJbWFnZVdyYXBwZXIuc2l6ZX1gKTtcbiAgICB9XG4gICAgY29uc3QgYm94U2l6ZSA9IFtcbiAgICAgICAgY2xvbmUoWzAsIDBdKSxcbiAgICAgICAgY2xvbmUoWzAsIGlucHV0SW1hZ2VXcmFwcGVyLnNpemUueV0pLFxuICAgICAgICBjbG9uZShbaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS54LCBpbnB1dEltYWdlV3JhcHBlci5zaXplLnldKSxcbiAgICAgICAgY2xvbmUoW2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueCwgMF0pLFxuICAgIF07XG4gICAgQmFyY29kZUxvY2F0b3IuaW5pdChpbnB1dEltYWdlV3JhcHBlciwgbG9jYXRvcik7XG4gICAgcmV0dXJuIHsgaW5wdXRJbWFnZVdyYXBwZXIsIGJveFNpemUgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZpZXdQb3J0KHRhcmdldD86IEVsZW1lbnQgfCBzdHJpbmcpOiBFbGVtZW50IHwgbnVsbCB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIGFscmVhZHkgYSBET00gZWxlbWVudFxuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiB0YXJnZXQubm9kZU5hbWUgJiYgdGFyZ2V0Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIC8vIFVzZSAnI2ludGVyYWN0aXZlLnZpZXdwb3J0JyBhcyBhIGZhbGxiYWNrIHNlbGVjdG9yIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSlcbiAgICBjb25zdCBzZWxlY3RvciA9IHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gdGFyZ2V0IDogJyNpbnRlcmFjdGl2ZS52aWV3cG9ydCc7XG4gICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xufVxuIiwiaW1wb3J0IHsgUXVhZ2dhQ29udGV4dCwgQ2FudmFzQ29udGFpbmVyIH0gZnJvbSAnUXVhZ2dhQ29udGV4dCc7XG5pbXBvcnQgeyBYWVNpemUgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcbmltcG9ydCBnZXRWaWV3UG9ydCBmcm9tICcuL2dldFZpZXdQb3J0JztcblxuZnVuY3Rpb24gZmluZE9yQ3JlYXRlQ2FudmFzKHNlbGVjdG9yOiBzdHJpbmcsIGNsYXNzTmFtZTogc3RyaW5nKSB7XG4gICAgbGV0IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgfCBudWxsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgfVxuICAgIHJldHVybiBjYW52YXM7XG59XG5cbmZ1bmN0aW9uIGdldENhbnZhc0FuZENvbnRleHQoc2VsZWN0b3I6IHN0cmluZywgY2xhc3NOYW1lOiBzdHJpbmcpIHtcbiAgICBjb25zdCBjYW52YXMgPSBmaW5kT3JDcmVhdGVDYW52YXMoc2VsZWN0b3IsIGNsYXNzTmFtZSk7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHJldHVybiB7IGNhbnZhcywgY29udGV4dCB9O1xufVxuXG5mdW5jdGlvbiBpbml0Q2FudmFzZXMoY2FudmFzU2l6ZTogWFlTaXplKTogQ2FudmFzQ29udGFpbmVyIHwgbnVsbCB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBnZXRDYW52YXNBbmRDb250ZXh0KCdjYW52YXMuaW1nQnVmZmVyJywgJ2ltZ0J1ZmZlcicpO1xuICAgICAgICBjb25zdCBvdmVybGF5ID0gZ2V0Q2FudmFzQW5kQ29udGV4dCgnY2FudmFzLmRyYXdpbmdCdWZmZXInLCAnZHJhd2luZ0J1ZmZlcicpO1xuXG4gICAgICAgIGltYWdlLmNhbnZhcy53aWR0aCA9IG92ZXJsYXkuY2FudmFzLndpZHRoID0gY2FudmFzU2l6ZS54O1xuICAgICAgICBpbWFnZS5jYW52YXMuaGVpZ2h0ID0gb3ZlcmxheS5jYW52YXMuaGVpZ2h0ID0gY2FudmFzU2l6ZS55O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb206IHtcbiAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2UuY2FudmFzLFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG92ZXJsYXkuY2FudmFzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGN0eDoge1xuICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZS5jb250ZXh0LFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG92ZXJsYXkuY29udGV4dCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbml0Q2FudmFzKGNvbnRleHQ6IFF1YWdnYUNvbnRleHQpOiBDYW52YXNDb250YWluZXIgfCBudWxsIHtcbiAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdQb3J0KGNvbnRleHQ/LmNvbmZpZz8uaW5wdXRTdHJlYW0/LnRhcmdldCk7XG4gICAgY29uc3QgdHlwZSA9IGNvbnRleHQ/LmNvbmZpZz8uaW5wdXRTdHJlYW0/LnR5cGU7XG4gICAgaWYgKCF0eXBlKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBjb250YWluZXIgPSBpbml0Q2FudmFzZXMoY29udGV4dC5pbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCkpO1xuICAgIGlmICghY29udGFpbmVyKSByZXR1cm4geyBkb206IHsgaW1hZ2U6IG51bGwsIG92ZXJsYXk6IG51bGwgfSwgY3R4OiB7IGltYWdlOiBudWxsLCBvdmVybGF5OiBudWxsIH0gfTtcblxuICAgIGNvbnN0IHsgZG9tIH0gPSBjb250YWluZXI7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHZpZXdwb3J0KSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ0ltYWdlU3RyZWFtJyAmJiAhdmlld3BvcnQuY29udGFpbnMoZG9tLmltYWdlKSkge1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKGRvbS5pbWFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZpZXdwb3J0LmNvbnRhaW5zKGRvbS5vdmVybGF5KSkge1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKGRvbS5vdmVybGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udGFpbmVyO1xufVxuIiwiLy8gTk9URTogKFNPTUUgT0YpIFRISVMgSVMgQlJPV1NFUiBPTkxZIENPREUuICBOb2RlIGRvZXMgbm90IGhhdmUgJ2F0b2InIGJ1aWx0IGluLCBub3IgWE1MSHR0cFJlcXVlc3QuXG4vLyBIb3cgZXhhY3RseSBpcyB0aGlzIHNldCBvZiBmdW5jdGlvbnMgdXNlZCBpbiBRdWFnZ2E/IERvIHdlIG5lZWQgdGhlIGJyb3dzZXIgc3BlY2lmaWMgY29kZT8gRG8gd2Vcbi8vIG5lZWQgdG8gcG9ydCBhbnkgcGFydCBvZiB0aGlzIHRoYXQgZG9lc24ndCB3b3JrIGluIE5vZGUgdG8gbm9kZT9cblxuLy8gVGFncyBzY3JhcGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2V4aWYtanMvZXhpZi1qc1xuY29uc3QgRXhpZlRhZ3MgPSB7IDB4MDExMjogJ29yaWVudGF0aW9uJyB9O1xuZXhwb3J0IGNvbnN0IEF2YWlsYWJsZVRhZ3MgPSBPYmplY3Qua2V5cyhFeGlmVGFncykubWFwKChrZXkpID0+IEV4aWZUYWdzW2tleV0pO1xuXG5leHBvcnQgZnVuY3Rpb24gZmluZFRhZ3NJbk9iamVjdFVSTChzcmMsIHRhZ3MgPSBBdmFpbGFibGVUYWdzKSB7XG4gICAgaWYgKC9eYmxvYjovaS50ZXN0KHNyYykpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFVSTFRvQmxvYihzcmMpXG4gICAgICAgICAgICAudGhlbihyZWFkVG9CdWZmZXIpXG4gICAgICAgICAgICAudGhlbigoYnVmZmVyKSA9PiBmaW5kVGFnc0luQnVmZmVyKGJ1ZmZlciwgdGFncykpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFzZTY0VG9BcnJheUJ1ZmZlcihkYXRhVXJsKSB7XG4gICAgY29uc3QgYmFzZTY0ID0gZGF0YVVybC5yZXBsYWNlKC9eZGF0YTooW147XSspO2Jhc2U2NCwvZ21pLCAnJyk7XG4gICAgY29uc3QgYmluYXJ5ID0gYXRvYihiYXNlNjQpO1xuICAgIGNvbnN0IGxlbiA9IGJpbmFyeS5sZW5ndGg7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGxlbik7XG4gICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZpZXdbaV0gPSBiaW5hcnkuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gcmVhZFRvQnVmZmVyKGJsb2IpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG9iamVjdFVSTFRvQmxvYih1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBodHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIGh0dHAub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgaHR0cC5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICAgIGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGh0dHAucmVhZHlTdGF0ZSA9PT0gWE1MSHR0cFJlcXVlc3QuRE9ORSAmJiAoaHR0cC5zdGF0dXMgPT09IDIwMCB8fCBodHRwLnN0YXR1cyA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBodHRwLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIGh0dHAuc2VuZCgpO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZFRhZ3NJbkJ1ZmZlcihmaWxlLCBzZWxlY3RlZFRhZ3MgPSBBdmFpbGFibGVUYWdzKSB7XG4gICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoZmlsZSk7XG4gICAgY29uc3QgbGVuZ3RoID0gZmlsZS5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IGV4aWZUYWdzID0gc2VsZWN0ZWRUYWdzLnJlZHVjZSgocmVzdWx0LCBzZWxlY3RlZFRhZykgPT4ge1xuICAgICAgICBjb25zdCBleGlmVGFnID0gT2JqZWN0LmtleXMoRXhpZlRhZ3MpLmZpbHRlcigodGFnKSA9PiBFeGlmVGFnc1t0YWddID09PSBzZWxlY3RlZFRhZylbMF07XG4gICAgICAgIGlmIChleGlmVGFnKSB7XG4gICAgICAgICAgICByZXN1bHRbZXhpZlRhZ10gPSBzZWxlY3RlZFRhZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcbiAgICBsZXQgb2Zmc2V0ID0gMjtcbiAgICBsZXQgbWFya2VyO1xuXG4gICAgaWYgKChkYXRhVmlldy5nZXRVaW50OCgwKSAhPT0gMHhGRikgfHwgKGRhdGFWaWV3LmdldFVpbnQ4KDEpICE9PSAweEQ4KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KSAhPT0gMHhGRikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFya2VyID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgMSk7XG4gICAgICAgIGlmIChtYXJrZXIgPT09IDB4RTEpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRVhJRkRhdGEoZGF0YVZpZXcsIG9mZnNldCArIDQsIGV4aWZUYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gMiArIGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyAyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlYWRFWElGRGF0YShmaWxlLCBzdGFydCwgZXhpZlRhZ3MpIHtcbiAgICBpZiAoZ2V0U3RyaW5nRnJvbUJ1ZmZlcihmaWxlLCBzdGFydCwgNCkgIT09ICdFeGlmJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdGlmZk9mZnNldCA9IHN0YXJ0ICsgNjtcbiAgICBsZXQgYmlnRW5kO1xuXG4gICAgaWYgKGZpbGUuZ2V0VWludDE2KHRpZmZPZmZzZXQpID09PSAweDQ5NDkpIHtcbiAgICAgICAgYmlnRW5kID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChmaWxlLmdldFVpbnQxNih0aWZmT2Zmc2V0KSA9PT0gMHg0RDREKSB7XG4gICAgICAgIGJpZ0VuZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmaWxlLmdldFVpbnQxNih0aWZmT2Zmc2V0ICsgMiwgIWJpZ0VuZCkgIT09IDB4MDAyQSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RJRkRPZmZzZXQgPSBmaWxlLmdldFVpbnQzMih0aWZmT2Zmc2V0ICsgNCwgIWJpZ0VuZCk7XG4gICAgaWYgKGZpcnN0SUZET2Zmc2V0IDwgMHgwMDAwMDAwOCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdGFncyA9IHJlYWRUYWdzKGZpbGUsIHRpZmZPZmZzZXQsIHRpZmZPZmZzZXQgKyBmaXJzdElGRE9mZnNldCwgZXhpZlRhZ3MsIGJpZ0VuZCk7XG4gICAgcmV0dXJuIHRhZ3M7XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWdzKGZpbGUsIHRpZmZTdGFydCwgZGlyU3RhcnQsIHN0cmluZ3MsIGJpZ0VuZCkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBmaWxlLmdldFVpbnQxNihkaXJTdGFydCwgIWJpZ0VuZCk7XG4gICAgY29uc3QgdGFncyA9IHt9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzOyBpKyspIHtcbiAgICAgICAgY29uc3QgZW50cnlPZmZzZXQgPSBkaXJTdGFydCArIGkgKiAxMiArIDI7XG4gICAgICAgIGNvbnN0IHRhZyA9IHN0cmluZ3NbZmlsZS5nZXRVaW50MTYoZW50cnlPZmZzZXQsICFiaWdFbmQpXTtcbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgdGFnc1t0YWddID0gcmVhZFRhZ1ZhbHVlKGZpbGUsIGVudHJ5T2Zmc2V0LCB0aWZmU3RhcnQsIGRpclN0YXJ0LCBiaWdFbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWdzO1xufVxuXG5mdW5jdGlvbiByZWFkVGFnVmFsdWUoZmlsZSwgZW50cnlPZmZzZXQsIHRpZmZTdGFydCwgZGlyU3RhcnQsIGJpZ0VuZCkge1xuICAgIGNvbnN0IHR5cGUgPSBmaWxlLmdldFVpbnQxNihlbnRyeU9mZnNldCArIDIsICFiaWdFbmQpO1xuICAgIGNvbnN0IG51bVZhbHVlcyA9IGZpbGUuZ2V0VWludDMyKGVudHJ5T2Zmc2V0ICsgNCwgIWJpZ0VuZCk7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgaWYgKG51bVZhbHVlcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLmdldFVpbnQxNihlbnRyeU9mZnNldCArIDgsICFiaWdFbmQpO1xuICAgICAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRTdHJpbmdGcm9tQnVmZmVyKGJ1ZmZlciwgc3RhcnQsIGxlbmd0aCkge1xuICAgIGxldCBvdXRzdHIgPSAnJztcbiAgICBmb3IgKGxldCBuID0gc3RhcnQ7IG4gPCBzdGFydCArIGxlbmd0aDsgbisrKSB7XG4gICAgICAgIG91dHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZlci5nZXRVaW50OChuKSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRzdHI7XG59XG4iLCJpbXBvcnQgeyBmaW5kVGFnc0luT2JqZWN0VVJMIH0gZnJvbSAnLi9leGlmX2hlbHBlcic7XG5cbmNvbnN0IEltYWdlTG9hZGVyID0ge307XG5JbWFnZUxvYWRlci5sb2FkID0gZnVuY3Rpb24gKGRpcmVjdG9yeSwgY2FsbGJhY2ssIG9mZnNldCwgc2l6ZSwgc2VxdWVuY2UpIHtcbiAgICBjb25zdCBodG1sSW1hZ2VzU3JjQXJyYXkgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgY29uc3QgaHRtbEltYWdlc0FycmF5ID0gbmV3IEFycmF5KGh0bWxJbWFnZXNTcmNBcnJheS5sZW5ndGgpO1xuICAgIGxldCBpO1xuICAgIGxldCBpbWc7XG4gICAgbGV0IG51bTtcblxuICAgIGlmIChzZXF1ZW5jZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaHRtbEltYWdlc1NyY0FycmF5WzBdID0gZGlyZWN0b3J5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBodG1sSW1hZ2VzU3JjQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG51bSA9IChvZmZzZXQgKyBpKTtcbiAgICAgICAgICAgIGh0bWxJbWFnZXNTcmNBcnJheVtpXSA9IGAke2RpcmVjdG9yeX1pbWFnZS0keyhgMDAke251bX1gKS5zbGljZSgtMyl9LmpwZ2A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaHRtbEltYWdlc0FycmF5Lm5vdExvYWRlZCA9IFtdO1xuICAgIGh0bWxJbWFnZXNBcnJheS5hZGRJbWFnZSA9IGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgICBodG1sSW1hZ2VzQXJyYXkubm90TG9hZGVkLnB1c2goaW1hZ2UpO1xuICAgIH07XG4gICAgaHRtbEltYWdlc0FycmF5LmxvYWRlZCA9IGZ1bmN0aW9uIChsb2FkZWRJbWcpIHtcbiAgICAgICAgY29uc3Qgbm90bG9hZGVkSW1ncyA9IGh0bWxJbWFnZXNBcnJheS5ub3RMb2FkZWQ7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbm90bG9hZGVkSW1ncy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgaWYgKG5vdGxvYWRlZEltZ3NbeF0gPT09IGxvYWRlZEltZykge1xuICAgICAgICAgICAgICAgIG5vdGxvYWRlZEltZ3Muc3BsaWNlKHgsIDEpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaHRtbEltYWdlc1NyY0FycmF5Lmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltZ05hbWUgPSBodG1sSW1hZ2VzU3JjQXJyYXlbeV0uc3Vic3RyKGh0bWxJbWFnZXNTcmNBcnJheVt5XS5sYXN0SW5kZXhPZignLycpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvYWRlZEltZy5zcmMubGFzdEluZGV4T2YoaW1nTmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sSW1hZ2VzQXJyYXlbeV0gPSB7IGltZzogbG9hZGVkSW1nIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm90bG9hZGVkSW1ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSW1hZ2VzIGxvYWRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlcXVlbmNlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGZpbmRUYWdzSW5PYmplY3RVUkwoZGlyZWN0b3J5LCBbJ29yaWVudGF0aW9uJ10pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCh0YWdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sSW1hZ2VzQXJyYXlbMF0udGFncyA9IHRhZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhodG1sSW1hZ2VzQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhodG1sSW1hZ2VzQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soaHRtbEltYWdlc0FycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaHRtbEltYWdlc1NyY0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBodG1sSW1hZ2VzQXJyYXkuYWRkSW1hZ2UoaW1nKTtcbiAgICAgICAgYWRkT25sb2FkSGFuZGxlcihpbWcsIGh0bWxJbWFnZXNBcnJheSk7XG4gICAgICAgIGltZy5zcmMgPSBodG1sSW1hZ2VzU3JjQXJyYXlbaV07XG4gICAgfVxufTtcblxuZnVuY3Rpb24gYWRkT25sb2FkSGFuZGxlcihpbWcsIGh0bWxJbWFnZXNBcnJheSkge1xuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWxJbWFnZXNBcnJheS5sb2FkZWQodGhpcyk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgKEltYWdlTG9hZGVyKTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cblxuaW1wb3J0IEltYWdlTG9hZGVyIGZyb20gJy4uL2ltYWdlX2xvYWRlcic7XG5pbXBvcnQgeyBYWVNpemUsIFBvaW50IH0gZnJvbSAnLi4vLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5pbXBvcnQgeyBJbnB1dFN0cmVhbUZhY3RvcnksIElucHV0U3RyZWFtLCBFdmVudEhhbmRsZXJMaXN0IH0gZnJvbSAnLi9pbnB1dF9zdHJlYW0uZCc7XG5cbmNvbnN0IGlucHV0U3RyZWFtRmFjdG9yeTogSW5wdXRTdHJlYW1GYWN0b3J5ID0ge1xuICAgIGNyZWF0ZVZpZGVvU3RyZWFtKHZpZGVvKTogSW5wdXRTdHJlYW0ge1xuICAgICAgICBsZXQgX2NvbmZpZzogeyBzaXplOiBudW1iZXI7IHR5cGU6IHN0cmluZyB9IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNvbnN0IF9ldmVudE5hbWVzID0gWydjYW5yZWNvcmQnLCAnZW5kZWQnXTtcbiAgICAgICAgY29uc3QgX2V2ZW50SGFuZGxlcnM6IEV2ZW50SGFuZGxlckxpc3QgPSB7fTtcbiAgICAgICAgbGV0IF9jYWxjdWxhdGVkV2lkdGg6IG51bWJlcjtcbiAgICAgICAgbGV0IF9jYWxjdWxhdGVkSGVpZ2h0OiBudW1iZXI7XG4gICAgICAgIGNvbnN0IF90b3BSaWdodDogUG9pbnQgPSB7IHg6IDAsIHk6IDAsIHR5cGU6ICdQb2ludCcgfTtcbiAgICAgICAgY29uc3QgX2NhbnZhc1NpemU6IFhZU2l6ZSA9IHsgeDogMCwgeTogMCwgdHlwZTogJ1hZU2l6ZScgfTtcblxuICAgICAgICBmdW5jdGlvbiBpbml0U2l6ZSgpOiB2b2lkIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdmlkZW8udmlkZW9XaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHZpZGVvLnZpZGVvSGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgIF9jYWxjdWxhdGVkV2lkdGggPSBfY29uZmlnPy5zaXplID8gd2lkdGggLyBoZWlnaHQgPiAxID8gX2NvbmZpZy5zaXplIDogTWF0aC5mbG9vcigod2lkdGggLyBoZWlnaHQpICogX2NvbmZpZy5zaXplKSA6IHdpZHRoO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICBfY2FsY3VsYXRlZEhlaWdodCA9IF9jb25maWc/LnNpemUgPyB3aWR0aCAvIGhlaWdodCA+IDEgPyBNYXRoLmZsb29yKChoZWlnaHQgLyB3aWR0aCkgKiBfY29uZmlnLnNpemUpIDogX2NvbmZpZy5zaXplIDogaGVpZ2h0O1xuXG4gICAgICAgICAgICBfY2FudmFzU2l6ZS54ID0gX2NhbGN1bGF0ZWRXaWR0aDtcbiAgICAgICAgICAgIF9jYW52YXNTaXplLnkgPSBfY2FsY3VsYXRlZEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0gPSB7XG4gICAgICAgICAgICBnZXRSZWFsV2lkdGgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvLnZpZGVvV2lkdGg7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRSZWFsSGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWRlby52aWRlb0hlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFdpZHRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY2FsY3VsYXRlZFdpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY2FsY3VsYXRlZEhlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldFdpZHRoKHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgX2NhbGN1bGF0ZWRXaWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICAgICAgICAgIF9jYWxjdWxhdGVkSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0SW5wdXRTdHJlYW0oY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgIF9jb25maWcgPSBjb25maWc7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzcmMnLCAodHlwZW9mIGNvbmZpZy5zcmMgIT09ICd1bmRlZmluZWQnKSA/IGNvbmZpZy5zcmMgOiAnJyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBlbmRlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW8uZW5kZWQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRDb25maWcoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb25maWc7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmlkZW8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwYXVzZSgpIHtcbiAgICAgICAgICAgICAgICB2aWRlby5wYXVzZSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGxheSgpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgICAgICAgICAgdmlkZW8ucGxheSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0Q3VycmVudFRpbWUodGltZSkge1xuICAgICAgICAgICAgICAgIGlmIChfY29uZmlnPy50eXBlICE9PSAnTGl2ZVN0cmVhbScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2N1cnJlbnRUaW1lJywgdGltZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmLCBib29sKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9ldmVudE5hbWVzLmluZGV4T2YoZXZlbnQpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9ldmVudEhhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2V2ZW50SGFuZGxlcnNbZXZlbnRdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2V2ZW50SGFuZGxlcnNbZXZlbnRdLnB1c2goZik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZiwgYm9vbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2xlYXJFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICAgICAgICAgIF9ldmVudE5hbWVzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IF9ldmVudEhhbmRsZXJzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHRyaWdnZXIoZXZlbnROYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGo7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJzID0gX2V2ZW50SGFuZGxlcnNbZXZlbnROYW1lXTtcblxuICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICdjYW5yZWNvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRTaXplKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBoYW5kbGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnNbal0uYXBwbHkoaW5wdXRTdHJlYW0sIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0VG9wUmlnaHQodG9wUmlnaHQpIHtcbiAgICAgICAgICAgICAgICBfdG9wUmlnaHQueCA9IHRvcFJpZ2h0Lng7XG4gICAgICAgICAgICAgICAgX3RvcFJpZ2h0LnkgPSB0b3BSaWdodC55O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0VG9wUmlnaHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90b3BSaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldENhbnZhc1NpemUoc2l6ZSkge1xuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnggPSBzaXplLng7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IHNpemUueTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldENhbnZhc1NpemUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jYW52YXNTaXplO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0RnJhbWUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGlucHV0U3RyZWFtO1xuICAgIH0sXG4gICAgY3JlYXRlTGl2ZVN0cmVhbSh2aWRlbyk6IElucHV0U3RyZWFtIHtcbiAgICAgICAgaWYgKHZpZGVvKSB7XG4gICAgICAgICAgICB2aWRlby5zZXRBdHRyaWJ1dGUoJ2F1dG9wbGF5JywgJ3RydWUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aGF0ID0gaW5wdXRTdHJlYW1GYWN0b3J5LmNyZWF0ZVZpZGVvU3RyZWFtKHZpZGVvKTtcbiAgICAgICAgdGhhdC5lbmRlZCA9IGZ1bmN0aW9uIGVuZGVkKCk6IGZhbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfSxcbiAgICBjcmVhdGVJbWFnZVN0cmVhbSgpOiBJbnB1dFN0cmVhbSB7XG4gICAgICAgIGxldCBfY29uZmlnOiB7IHNpemU6IG51bWJlcjsgc2VxdWVuY2U6IGFueSB9IHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgICAgbGV0IGhlaWdodCA9IDA7XG4gICAgICAgIGxldCBmcmFtZUlkeCA9IDA7XG4gICAgICAgIGxldCBwYXVzZWQgPSB0cnVlO1xuICAgICAgICBsZXQgbG9hZGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBpbWdBcnJheTogYW55W10gfCBudWxsID0gbnVsbDtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAxO1xuICAgICAgICBsZXQgYmFzZVVybDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGxldCBlbmRlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgY2FsY3VsYXRlZFdpZHRoOiBudW1iZXI7XG4gICAgICAgIGxldCBjYWxjdWxhdGVkSGVpZ2h0OiBudW1iZXI7XG4gICAgICAgIGNvbnN0IF9ldmVudE5hbWVzID0gWydjYW5yZWNvcmQnLCAnZW5kZWQnXTtcbiAgICAgICAgY29uc3QgX2V2ZW50SGFuZGxlcnM6IEV2ZW50SGFuZGxlckxpc3QgPSB7fTtcbiAgICAgICAgY29uc3QgX3RvcFJpZ2h0OiBQb2ludCA9IHsgeDogMCwgeTogMCwgdHlwZTogJ1BvaW50JyB9O1xuICAgICAgICBjb25zdCBfY2FudmFzU2l6ZTogWFlTaXplID0geyB4OiAwLCB5OiAwLCB0eXBlOiAnWFlTaXplJyB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGxvYWRJbWFnZXMoKTogdm9pZCB7XG4gICAgICAgICAgICBsb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIEltYWdlTG9hZGVyLmxvYWQoYmFzZVVybCwgKGltZ3M6IEFycmF5PHsgdGFnczogYW55OyBpbWc6IEhUTUxJbWFnZUVsZW1lbnR9PikgPT4ge1xuICAgICAgICAgICAgICAgIGltZ0FycmF5ID0gaW1ncztcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgaWYgKGltZ3NbMF0udGFncyAmJiBpbWdzWzBdLnRhZ3Mub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGltZ3NbMF0udGFncy5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gaW1nc1swXS5pbWcuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGltZ3NbMF0uaW1nLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGltZ3NbMF0uaW1nLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGltZ3NbMF0uaW1nLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gaW1nc1swXS5pbWcud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGltZ3NbMF0uaW1nLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZFdpZHRoID0gX2NvbmZpZz8uc2l6ZSA/IHdpZHRoIC8gaGVpZ2h0ID4gMSA/IF9jb25maWcuc2l6ZSA6IE1hdGguZmxvb3IoKHdpZHRoIC8gaGVpZ2h0KSAqIF9jb25maWcuc2l6ZSkgOiB3aWR0aDtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkSGVpZ2h0ID0gX2NvbmZpZz8uc2l6ZSA/IHdpZHRoIC8gaGVpZ2h0ID4gMSA/IE1hdGguZmxvb3IoKGhlaWdodCAvIHdpZHRoKSAqIF9jb25maWcuc2l6ZSkgOiBfY29uZmlnLnNpemUgOiBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IGNhbGN1bGF0ZWRXaWR0aDtcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS55ID0gY2FsY3VsYXRlZEhlaWdodDtcbiAgICAgICAgICAgICAgICBsb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZyYW1lSWR4ID0gMDtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgICAgICBwdWJsaXNoRXZlbnQoJ2NhbnJlY29yZCcsIFtdKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0sIG9mZnNldCwgc2l6ZSwgX2NvbmZpZz8uc2VxdWVuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcHVibGlzaEV2ZW50KGV2ZW50TmFtZTogc3RyaW5nLCBhcmdzOiBBcnJheTxhbnk+KTogdm9pZCB7XG4gICAgICAgICAgICBsZXQgajtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJzID0gX2V2ZW50SGFuZGxlcnNbZXZlbnROYW1lXTtcblxuICAgICAgICAgICAgaWYgKGhhbmRsZXJzICYmIGhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyc1tqXS5hcHBseShpbnB1dFN0cmVhbSwgYXJncyBhcyBhbnkpOyAvLyBUT0RPOiB0eXBlc2NyaXB0IGNvbXBsYWlucyB0aGF0IGFueVtdIGlzIG5vdCB2YWxpZCBmb3IgYSBzZWNvbmQgYXJnIGZvciBhcHBseT8hXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogYW55IGNvZGUgc2hhcmVkIHdpdGggdGhlIGZpcnN0IElucHV0U3RyZWFtIGFib3ZlIHNob3VsZCBiZSBzaGFyZWQgbm90IGNvcGllZFxuICAgICAgICAvLyBUT0RPOiBwdWJsaXNoRXZlbnQgbmVlZHMgYWNjZXNzIHRvIGlucHV0U3RyZWFtLCBidXQgaW5wdXRTdHJlYW0gbmVlZHMgYWNjZXNzIHRvIHB1Ymxpc2hFdmVudFxuICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIHdoeSBpdCdzIGEgJ3ZhcicsIHNvIGl0IGhvaXN0cyBiYWNrLiAgVGhpcyBpcyB1Z2x5LCBhbmQgc2hvdWxkIGJlIGNoYW5nZWQuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby12YXIsdmFycy1vbi10b3BcbiAgICAgICAgdmFyIGlucHV0U3RyZWFtOiBJbnB1dFN0cmVhbSA9IHtcblxuICAgICAgICAgICAgdHJpZ2dlcjogcHVibGlzaEV2ZW50LFxuXG4gICAgICAgICAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlZFdpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVkSGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0V2lkdGgobmV3V2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkV2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldEhlaWdodChuZXdIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkSGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0UmVhbFdpZHRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFJlYWxIZWlnaHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldElucHV0U3RyZWFtKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICBfY29uZmlnID0gc3RyZWFtO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLnNlcXVlbmNlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgICAgICBiYXNlVXJsID0gc3RyZWFtLnNyYztcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgYmFzZVVybCA9IHN0cmVhbS5zcmM7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBzdHJlYW0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2FkSW1hZ2VzKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBlbmRlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kZWQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUoKSB7fSxcblxuICAgICAgICAgICAgZ2V0Q29uZmlnKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29uZmlnO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGF1c2UoKSB7XG4gICAgICAgICAgICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBsYXkoKSB7XG4gICAgICAgICAgICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRDdXJyZW50VGltZSh0aW1lKSB7XG4gICAgICAgICAgICAgICAgZnJhbWVJZHggPSB0aW1lO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZikge1xuICAgICAgICAgICAgICAgIGlmIChfZXZlbnROYW1lcy5pbmRleE9mKGV2ZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZXZlbnRIYW5kbGVyc1tldmVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XS5wdXNoKGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNsZWFyRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhfZXZlbnRIYW5kbGVycykuZm9yRWFjaCgoaW5kKSA9PiBkZWxldGUgX2V2ZW50SGFuZGxlcnNbaW5kXSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRUb3BSaWdodCh0b3BSaWdodCkge1xuICAgICAgICAgICAgICAgIF90b3BSaWdodC54ID0gdG9wUmlnaHQueDtcbiAgICAgICAgICAgICAgICBfdG9wUmlnaHQueSA9IHRvcFJpZ2h0Lnk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRUb3BSaWdodCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RvcFJpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0Q2FudmFzU2l6ZShjYW52YXNTaXplKSB7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IGNhbnZhc1NpemUueDtcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS55ID0gY2FudmFzU2l6ZS55O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0Q2FudmFzU2l6ZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NhbnZhc1NpemU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRGcmFtZSgpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJhbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWxvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXVzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IGltZ0FycmF5Py5bZnJhbWVJZHhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWVJZHggPCAoc2l6ZSAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZUlkeCsrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hFdmVudCgnZW5kZWQnLCBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaW5wdXRTdHJlYW07XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGlucHV0U3RyZWFtRmFjdG9yeTtcbiIsIi8vIFRPRE86IEl0J3MgcHJldHR5IGxpa2VseSB0aGF0IHRoaXMgc2hhcmVzIGNvZGUgd2l0aCB0aGUgYnJvd3NlciB2ZXJzaW9uLCBpbnZlc3RpZ2F0ZSB0aGF0XG5pbXBvcnQgR2V0UGl4ZWxzIGZyb20gJ2dldC1waXhlbHMnO1xuaW1wb3J0IHsgSW5wdXRTdHJlYW1GYWN0b3J5LCBJbnB1dFN0cmVhbSwgRXZlbnRIYW5kbGVyTGlzdCB9IGZyb20gJy4vaW5wdXRfc3RyZWFtLmQnO1xuaW1wb3J0IHsgUG9pbnQsIFhZU2l6ZSB9IGZyb20gJy4uLy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5jb25zdCBpbnB1dFN0cmVhbUZhY3Rvcnk6IElucHV0U3RyZWFtRmFjdG9yeSA9IHtcbiAgICBjcmVhdGVWaWRlb1N0cmVhbSgpOiBuZXZlciB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3JlYXRlVmlkZW9TdHJlYW0gbm90IGF2YWlsYWJsZScpO1xuICAgIH0sXG4gICAgY3JlYXRlTGl2ZVN0cmVhbSgpOiBuZXZlciB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3JlYXRlTGl2ZVN0cmVhbSBub3QgYXZhaWxhYmxlJyk7XG4gICAgfSxcbiAgICBjcmVhdGVJbWFnZVN0cmVhbSgpOiBJbnB1dFN0cmVhbSB7XG4gICAgICAgIGxldCBfY29uZmlnOiB7IG1pbWU6IHN0cmluZzsgc2l6ZTogbnVtYmVyOyBzcmM6IGFueSB9IHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgICAgbGV0IGhlaWdodCA9IDA7XG4gICAgICAgIGxldCBsb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gVE9ETzogZnJhbWUgc2hvdWxkIGJlIGEgdHlwZSBOZEFycmF5LCBidXQgTmRBcnJheSBkb2Vzbid0IGhhdmUgdHMgZGVmaW5pdGlvbnNcbiAgICAgICAgLy8gVE9ETzogdGhlcmUgaXMgYSB0cy1uZGFycmF5IHRoYXQgbWlnaHQgd29yaywgdGhvdWdoXG4gICAgICAgIGxldCBmcmFtZTogYW55ID0gbnVsbDtcbiAgICAgICAgbGV0IGJhc2VVcmw6IHN0cmluZztcbiAgICAgICAgY29uc3QgZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhbGN1bGF0ZWRXaWR0aDogbnVtYmVyO1xuICAgICAgICBsZXQgY2FsY3VsYXRlZEhlaWdodDogbnVtYmVyO1xuICAgICAgICBjb25zdCBfZXZlbnROYW1lcyA9IFsnY2FucmVjb3JkJywgJ2VuZGVkJ107XG4gICAgICAgIGNvbnN0IF9ldmVudEhhbmRsZXJzOiBFdmVudEhhbmRsZXJMaXN0ID0ge307XG4gICAgICAgIGNvbnN0IF90b3BSaWdodDogUG9pbnQgPSB7IHg6IDAsIHk6IDAsIHR5cGU6ICdQb2ludCcgfTtcbiAgICAgICAgY29uc3QgX2NhbnZhc1NpemU6IFhZU2l6ZSA9IHsgeDogMCwgeTogMCwgdHlwZTogJ1hZU2l6ZScgfTtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi8gLy8gZmFsc2UgZXNsaW50IGVycm9ycz8gd2VpcmQuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxldCBmcmFtZUlkeCA9IDA7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGV0IHBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgICAgICAgZnVuY3Rpb24gbG9hZEltYWdlcygpOiB2b2lkIHtcbiAgICAgICAgICAgIGxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xuICAgICAgICAgICAgR2V0UGl4ZWxzKGJhc2VVcmwsIF9jb25maWc/Lm1pbWUsIChlcnIsIHBpeGVscykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignKioqKiBxdWFnZ2EgbG9hZEltYWdlcyBlcnJvcjonLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Vycm9yIGRlY29kaW5nIHBpeGVscyBpbiBsb2FkSW1hZ2VzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnKiBJbnB1dFN0cmVhbU5vZGUgcGl4ZWxzLnNoYXBlJywgcGl4ZWxzLnNoYXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgIGZyYW1lID0gcGl4ZWxzO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgW3dpZHRoLCBoZWlnaHRdID0gcGl4ZWxzLnNoYXBlO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRXaWR0aCA9IF9jb25maWc/LnNpemVcbiAgICAgICAgICAgICAgICAgICAgPyB3aWR0aCAvIGhlaWdodCA+IDFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gX2NvbmZpZy5zaXplXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGguZmxvb3IoKHdpZHRoIC8gaGVpZ2h0KSAqIF9jb25maWcuc2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgOiB3aWR0aDtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkSGVpZ2h0ID0gX2NvbmZpZz8uc2l6ZVxuICAgICAgICAgICAgICAgICAgICA/IHdpZHRoIC8gaGVpZ2h0ID4gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBNYXRoLmZsb29yKChoZWlnaHQgLyB3aWR0aCkgKiBfY29uZmlnLnNpemUpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IF9jb25maWcuc2l6ZVxuICAgICAgICAgICAgICAgICAgICA6IGhlaWdodDtcblxuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnggPSBjYWxjdWxhdGVkV2lkdGg7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IGNhbGN1bGF0ZWRIZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgICAgICBwdWJsaXNoRXZlbnQoJ2NhbnJlY29yZCcsIFtdKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcHVibGlzaEV2ZW50KGV2ZW50TmFtZTogc3RyaW5nLCBhcmdzOiBBcnJheTxhbnk+KTogdm9pZCB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IF9ldmVudEhhbmRsZXJzW2V2ZW50TmFtZV07XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBoYW5kbGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzW2pdLmFwcGx5KGlucHV0U3RyZWFtLCBhcmdzIGFzIGFueSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhcix2YXJzLW9uLXRvcFxuICAgICAgICB2YXIgaW5wdXRTdHJlYW06IElucHV0U3RyZWFtID0ge1xuICAgICAgICAgICAgdHJpZ2dlcjogcHVibGlzaEV2ZW50LFxuXG4gICAgICAgICAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlZFdpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVkSGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0V2lkdGgodykge1xuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRXaWR0aCA9IHc7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRIZWlnaHQoaCkge1xuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRIZWlnaHQgPSBoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0UmVhbFdpZHRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFJlYWxIZWlnaHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldElucHV0U3RyZWFtKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICBfY29uZmlnID0gc3RyZWFtO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgYmFzZVVybCA9IF9jb25maWc/LnNyYztcbiAgICAgICAgICAgICAgICBzaXplID0gMTtcbiAgICAgICAgICAgICAgICBsb2FkSW1hZ2VzKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBlbmRlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kZWQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUoKSB7fSxcblxuICAgICAgICAgICAgZ2V0Q29uZmlnKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29uZmlnO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGF1c2UoKSB7XG4gICAgICAgICAgICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBsYXkoKSB7XG4gICAgICAgICAgICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRDdXJyZW50VGltZSh0aW1lKSB7XG4gICAgICAgICAgICAgICAgZnJhbWVJZHggPSB0aW1lO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZikge1xuICAgICAgICAgICAgICAgIGlmIChfZXZlbnROYW1lcy5pbmRleE9mKGV2ZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZXZlbnRIYW5kbGVyc1tldmVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XS5wdXNoKGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNsZWFyRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhfZXZlbnRIYW5kbGVycykuZm9yRWFjaCgoaW5kKSA9PiBkZWxldGUgX2V2ZW50SGFuZGxlcnNbaW5kXSk7XG4gICAgICAgICAgICB9LFxuXG5cbiAgICAgICAgICAgIHNldFRvcFJpZ2h0KHRvcFJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgX3RvcFJpZ2h0LnggPSB0b3BSaWdodC54O1xuICAgICAgICAgICAgICAgIF90b3BSaWdodC55ID0gdG9wUmlnaHQueTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFRvcFJpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdG9wUmlnaHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRDYW52YXNTaXplKHN6KSB7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IHN6Lng7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IHN6Lnk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRDYW52YXNTaXplKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY2FudmFzU2l6ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEZyYW1lKCkge1xuICAgICAgICAgICAgICAgIGlmICghbG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaW5wdXRTdHJlYW07XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGlucHV0U3RyZWFtRmFjdG9yeTtcbiIsImltcG9ydCBCcm93c2VySW5wdXRTdHJlYW0gZnJvbSAnLi9pbnB1dF9zdHJlYW0vaW5wdXRfc3RyZWFtX2Jyb3dzZXInO1xuaW1wb3J0IE5vZGVJbnB1dFN0cmVhbSBmcm9tICcuL2lucHV0X3N0cmVhbS9pbnB1dF9zdHJlYW1fbm9kZSc7XG5pbXBvcnQgdHlwZSB7IElucHV0U3RyZWFtIH0gZnJvbSAnLi9pbnB1dF9zdHJlYW0vaW5wdXRfc3RyZWFtLmQnO1xuXG5leHBvcnQgZGVmYXVsdCBCcm93c2VySW5wdXRTdHJlYW07XG5leHBvcnQgeyBOb2RlSW5wdXRTdHJlYW0gfTtcbmV4cG9ydCB0eXBlIHsgSW5wdXRTdHJlYW0gfTtcbiIsImltcG9ydCBOb2RlRnJhbWVHcmFiYmVyIGZyb20gJy4vZnJhbWVfZ3JhYmJlcl9ub2RlJztcblxuaW1wb3J0IHtcbiAgICBpbWFnZVJlZixcbiAgICBncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhLFxuICAgIGNvbXB1dGVHcmF5LFxufSBmcm9tICcuLi9jb21tb24vY3ZfdXRpbHMnO1xuXG5jb25zdCBUT19SQURJQU5TID0gTWF0aC5QSSAvIDE4MDtcblxuZnVuY3Rpb24gYWRqdXN0Q2FudmFzU2l6ZShjYW52YXMsIHRhcmdldFNpemUpIHtcbiAgICBpZiAoY2FudmFzLndpZHRoICE9PSB0YXJnZXRTaXplLngpIHtcbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IGNhbnZhcy1zaXplIG5lZWRzIHRvIGJlIGFkanVzdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FudmFzLndpZHRoID0gdGFyZ2V0U2l6ZS54O1xuICAgIH1cbiAgICBpZiAoY2FudmFzLmhlaWdodCAhPT0gdGFyZ2V0U2l6ZS55KSB7XG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBjYW52YXMtc2l6ZSBuZWVkcyB0byBiZSBhZGp1c3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0YXJnZXRTaXplLnk7XG4gICAgfVxufVxuXG5jb25zdCBGcmFtZUdyYWJiZXIgPSB7fTtcblxuRnJhbWVHcmFiYmVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChpbnB1dFN0cmVhbSwgY2FudmFzKSB7XG4gICAgY29uc3QgX3RoYXQgPSB7fTtcbiAgICBjb25zdCBfc3RyZWFtQ29uZmlnID0gaW5wdXRTdHJlYW0uZ2V0Q29uZmlnKCk7XG4gICAgY29uc3QgX3ZpZGVvU2l6ZSA9IGltYWdlUmVmKGlucHV0U3RyZWFtLmdldFJlYWxXaWR0aCgpLCBpbnB1dFN0cmVhbS5nZXRSZWFsSGVpZ2h0KCkpO1xuICAgIGNvbnN0IF9jYW52YXNTaXplID0gaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpO1xuICAgIGNvbnN0IF9zaXplID0gaW1hZ2VSZWYoaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSwgaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkpO1xuICAgIGNvbnN0IHRvcFJpZ2h0ID0gaW5wdXRTdHJlYW0uZ2V0VG9wUmlnaHQoKTtcbiAgICBjb25zdCBfc3ggPSB0b3BSaWdodC54O1xuICAgIGNvbnN0IF9zeSA9IHRvcFJpZ2h0Lnk7XG4gICAgbGV0IF9jYW52YXM7XG4gICAgbGV0IF9jdHggPSBudWxsO1xuICAgIGxldCBfZGF0YSA9IG51bGw7XG5cbiAgICBfY2FudmFzID0gY2FudmFzIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIF9jYW52YXMud2lkdGggPSBfY2FudmFzU2l6ZS54O1xuICAgIF9jYW52YXMuaGVpZ2h0ID0gX2NhbnZhc1NpemUueTtcbiAgICBfY3R4ID0gX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIF9kYXRhID0gbmV3IFVpbnQ4QXJyYXkoX3NpemUueCAqIF9zaXplLnkpO1xuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0ZyYW1lR3JhYmJlcicsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHNpemU6IF9zaXplLFxuICAgICAgICAgICAgdG9wUmlnaHQsXG4gICAgICAgICAgICB2aWRlb1NpemU6IF92aWRlb1NpemUsXG4gICAgICAgICAgICBjYW52YXNTaXplOiBfY2FudmFzU2l6ZSxcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgdGhlIGdpdmVuIGFycmF5IGFzIGZyYW1lLWJ1ZmZlclxuICAgICAqL1xuICAgIF90aGF0LmF0dGFjaERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBfZGF0YSA9IGRhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVzZWQgZnJhbWUtYnVmZmVyXG4gICAgICovXG4gICAgX3RoYXQuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9kYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGEgZnJhbWUgZnJvbSB0aGUgaW5wdXQtc3RyZWFtIGFuZCBwdXRzIGludG8gdGhlIGZyYW1lLWJ1ZmZlci5cbiAgICAgKiBUaGUgaW1hZ2UtZGF0YSBpcyBjb252ZXJ0ZWQgdG8gZ3JheS1zY2FsZSBhbmQgdGhlbiBoYWxmLXNhbXBsZWQgaWYgY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBfdGhhdC5ncmFiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBkb0hhbGZTYW1wbGUgPSBfc3RyZWFtQ29uZmlnLmhhbGZTYW1wbGU7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gaW5wdXRTdHJlYW0uZ2V0RnJhbWUoKTtcbiAgICAgICAgbGV0IGRyYXdhYmxlID0gZnJhbWU7XG4gICAgICAgIGxldCBkcmF3QW5nbGUgPSAwO1xuICAgICAgICBsZXQgY3R4RGF0YTtcbiAgICAgICAgaWYgKGRyYXdhYmxlKSB7XG4gICAgICAgICAgICBhZGp1c3RDYW52YXNTaXplKF9jYW52YXMsIF9jYW52YXNTaXplKTtcbiAgICAgICAgICAgIGlmIChfc3RyZWFtQ29uZmlnLnR5cGUgPT09ICdJbWFnZVN0cmVhbScpIHtcbiAgICAgICAgICAgICAgICBkcmF3YWJsZSA9IGZyYW1lLmltZztcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWUudGFncyAmJiBmcmFtZS50YWdzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZnJhbWUudGFncy5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdBbmdsZSA9IDkwICogVE9fUkFESUFOUztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3QW5nbGUgPSAtOTAgKiBUT19SQURJQU5TO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZHJhd0FuZ2xlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgX2N0eC50cmFuc2xhdGUoX2NhbnZhc1NpemUueCAvIDIsIF9jYW52YXNTaXplLnkgLyAyKTtcbiAgICAgICAgICAgICAgICBfY3R4LnJvdGF0ZShkcmF3QW5nbGUpO1xuICAgICAgICAgICAgICAgIF9jdHguZHJhd0ltYWdlKGRyYXdhYmxlLCAtX2NhbnZhc1NpemUueSAvIDIsIC1fY2FudmFzU2l6ZS54IC8gMiwgX2NhbnZhc1NpemUueSwgX2NhbnZhc1NpemUueCk7XG4gICAgICAgICAgICAgICAgX2N0eC5yb3RhdGUoLWRyYXdBbmdsZSk7XG4gICAgICAgICAgICAgICAgX2N0eC50cmFuc2xhdGUoLV9jYW52YXNTaXplLnggLyAyLCAtX2NhbnZhc1NpemUueSAvIDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfY3R4LmRyYXdJbWFnZShkcmF3YWJsZSwgMCwgMCwgX2NhbnZhc1NpemUueCwgX2NhbnZhc1NpemUueSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eERhdGEgPSBfY3R4LmdldEltYWdlRGF0YShfc3gsIF9zeSwgX3NpemUueCwgX3NpemUueSkuZGF0YTtcbiAgICAgICAgICAgIGlmIChkb0hhbGZTYW1wbGUpIHtcbiAgICAgICAgICAgICAgICBncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhKGN0eERhdGEsIF9zaXplLCBfZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVHcmF5KGN0eERhdGEsIF9kYXRhLCBfc3RyZWFtQ29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgX3RoYXQuZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zaXplO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoYXQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBGcmFtZUdyYWJiZXI7XG5leHBvcnQgeyBOb2RlRnJhbWVHcmFiYmVyIH07XG4iLCIvKiBXb3JrZXIgZnVuY3Rpb25zLiBUaGVzZSBhcmUgc3RyYWlnaHQgZnJvbSB0aGUgb3JpZ2luYWwgcXVhZ2dhLmpzIGZpbGUuXG4gKiBOb3QgcHJlc2VudGx5IHVzZWQsIGFzIHdvcmtlciBzdXBwb3J0IGlzIG5vbi1mdW5jdGlvbmFsLiAgS2VlcGluZyB0aGVtIGFyb3VuZCB0ZW1wb3JhcmlseVxuICogdG8gcmVmZXIgdG8gdW50aWwgaXQgaXMgcmUtaW1wbGVtZW50ZWQuIFdlIG1heSBiZSBhYmxlIHRvIGZpeC91c2Ugc29tZSBvZiB0aGlzLlxuICovXG5cbmltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0LCBRdWFnZ2FKU1JlYWRlckNvbmZpZyB9IGZyb20gXCIuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYVwiO1xuXG4vLyBUT0RPOiBuZWVkIGEgdHlwZXNjcmlwdCBpbnRlcmZhY2UgZm9yIEZyYW1lR3JhYmJlclxuXG5pbnRlcmZhY2UgUVdvcmtlclRocmVhZCB7XG4gICAgaW1hZ2VEYXRhOiBVaW50OEFycmF5O1xuICAgIGJ1c3k6IGJvb2xlYW47XG4gICAgd29ya2VyOiBXb3JrZXI7XG59XG5cbmxldCB3b3JrZXJQb29sOiBBcnJheTxRV29ya2VyVGhyZWFkPiA9IFtdO1xuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlV29ya2VycyhmcmFtZUdyYWJiZXI6IGFueSkge1xuICAgIGxldCBhdmFpbGFibGVXb3JrZXI6IFFXb3JrZXJUaHJlYWQ7XG4gICAgaWYgKHdvcmtlclBvb2wubGVuZ3RoKSB7XG4gICAgICAgIGF2YWlsYWJsZVdvcmtlciA9IHdvcmtlclBvb2wuZmlsdGVyKCh3b3JrZXJUaHJlYWQpID0+ICF3b3JrZXJUaHJlYWQuYnVzeSlbMF07XG4gICAgICAgIGlmIChhdmFpbGFibGVXb3JrZXIpIHtcbiAgICAgICAgICAgIGZyYW1lR3JhYmJlci5hdHRhY2hEYXRhKGF2YWlsYWJsZVdvcmtlci5pbWFnZURhdGEpO1xuICAgICAgICAgICAgaWYgKGZyYW1lR3JhYmJlci5ncmFiKCkpIHtcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVXb3JrZXIuYnVzeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlV29ya2VyLndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGNtZDogJ3Byb2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGE6IGF2YWlsYWJsZVdvcmtlci5pbWFnZURhdGEsXG4gICAgICAgICAgICAgICAgfSwgW2F2YWlsYWJsZVdvcmtlci5pbWFnZURhdGEuYnVmZmVyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29uZmlnRm9yV29ya2VyKGNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5jb25maWcsXG4gICAgICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgICAgICAuLi5jb25maWcuaW5wdXRTdHJlYW0sXG4gICAgICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuLy8gQHRzLWlnbm9yZVxuZnVuY3Rpb24gd29ya2VySW50ZXJmYWNlKGZhY3RvcnkpIHtcbiAgICBpZiAoZmFjdG9yeSkge1xuICAgICAgICB2YXIgUXVhZ2dhID0gZmFjdG9yeSgpLmRlZmF1bHQ7XG4gICAgICAgIGlmICghUXVhZ2dhKSB7XG4vLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsgJ2V2ZW50JzogJ2Vycm9yJywgbWVzc2FnZTogJ1F1YWdnYSBjb3VsZCBub3QgYmUgY3JlYXRlZCcgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4vLyBAdHMtaWdub3JlXG4gICAgdmFyIGltYWdlV3JhcHBlcjtcblxuLy8gQHRzLWlnbm9yZVxuICAgIGZ1bmN0aW9uIG9uUHJvY2Vzc2VkKHJlc3VsdCkge1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICdldmVudCc6ICdwcm9jZXNzZWQnLFxuLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaW1hZ2VEYXRhOiBpbWFnZVdyYXBwZXIuZGF0YSxcbiAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuLy8gQHRzLWlnbm9yZVxuICAgICAgICB9LCBbaW1hZ2VXcmFwcGVyLmRhdGEuYnVmZmVyXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd29ya2VySW50ZXJmYWNlUmVhZHkoKSB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgJ2V2ZW50JzogJ2luaXRpYWxpemVkJyxcbi8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGltYWdlRGF0YTogaW1hZ2VXcmFwcGVyLmRhdGEsXG4vLyBAdHMtaWdub3JlXG4gICAgICAgIH0sIFtpbWFnZVdyYXBwZXIuZGF0YS5idWZmZXJdKTtcbiAgICB9XG5cbi8vIEB0cy1pZ25vcmVcbiAgICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmRhdGEuY21kID09PSAnaW5pdCcpIHtcbiAgICAgICAgICAgIHZhciBjb25maWcgPSBlLmRhdGEuY29uZmlnO1xuICAgICAgICAgICAgY29uZmlnLm51bU9mV29ya2VycyA9IDA7XG4gICAgICAgICAgICBpbWFnZVdyYXBwZXIgPSBuZXcgUXVhZ2dhLkltYWdlV3JhcHBlcih7XG4gICAgICAgICAgICAgICAgeDogZS5kYXRhLnNpemUueCxcbiAgICAgICAgICAgICAgICB5OiBlLmRhdGEuc2l6ZS55LFxuICAgICAgICAgICAgfSwgbmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgUXVhZ2dhLmluaXQoY29uZmlnLCB3b3JrZXJJbnRlcmZhY2VSZWFkeSwgaW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgICAgIFF1YWdnYS5vblByb2Nlc3NlZChvblByb2Nlc3NlZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmNtZCA9PT0gJ3Byb2Nlc3MnKSB7XG4vLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpbWFnZVdyYXBwZXIuZGF0YSA9IG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpO1xuICAgICAgICAgICAgUXVhZ2dhLnN0YXJ0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmNtZCA9PT0gJ3NldFJlYWRlcnMnKSB7XG4gICAgICAgICAgICBRdWFnZ2Euc2V0UmVhZGVycyhlLmRhdGEucmVhZGVycyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmNtZCA9PT0gJ3JlZ2lzdGVyUmVhZGVyJykge1xuICAgICAgICAgICAgUXVhZ2dhLnJlZ2lzdGVyUmVhZGVyKGUuZGF0YS5uYW1lLCBlLmRhdGEucmVhZGVyKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlV29ya2VyQmxvYigpIHtcbiAgICB2YXIgYmxvYixcbiAgICAgICAgZmFjdG9yeVNvdXJjZTtcblxuICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKHR5cGVvZiBfX2ZhY3RvcnlTb3VyY2VfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBmYWN0b3J5U291cmNlID0gX19mYWN0b3J5U291cmNlX187IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICB9XG4gICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuICAgIGJsb2IgPSBuZXcgQmxvYihbJygnICsgd29ya2VySW50ZXJmYWNlLnRvU3RyaW5nKCkgKyAnKSgnICsgZmFjdG9yeVNvdXJjZSArICcpOyddLFxuICAgICAgICB7IHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnIH0pO1xuXG4gICAgcmV0dXJuIHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdFdvcmtlcihjb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0LCBpbnB1dFN0cmVhbTogYW55LCBjYjogRnVuY3Rpb24pIHtcbiAgICBjb25zdCBibG9iVVJMID0gZ2VuZXJhdGVXb3JrZXJCbG9iKCk7XG4gICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcihibG9iVVJMKTtcblxuICAgIGNvbnN0IHdvcmtlclRocmVhZDogUVdvcmtlclRocmVhZCA9IHtcbiAgICAgICAgd29ya2VyLFxuICAgICAgICBpbWFnZURhdGE6IG5ldyBVaW50OEFycmF5KGlucHV0U3RyZWFtLmdldFdpZHRoKCkgKiBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSksXG4gICAgICAgIGJ1c3k6IHRydWUsXG4gICAgfTtcblxuICAgIHdvcmtlclRocmVhZC53b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuZGF0YS5ldmVudCA9PT0gJ2luaXRpYWxpemVkJykge1xuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChibG9iVVJMKTtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC5idXN5ID0gZmFsc2U7XG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmltYWdlRGF0YSk7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1dvcmtlciBpbml0aWFsaXplZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2Iod29ya2VyVGhyZWFkKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEuZXZlbnQgPT09ICdwcm9jZXNzZWQnKSB7XG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmltYWdlRGF0YSk7XG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuYnVzeSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gVE9ETzogaG93IHRvIHRocmVhZCBwdWJsaXNoUmVzdWx0IGludG8gaGVyZT9cbiAgICAgICAgICAgIC8vIHB1Ymxpc2hSZXN1bHQoZS5kYXRhLnJlc3VsdCwgd29ya2VyVGhyZWFkLmltYWdlRGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmV2ZW50ID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1dvcmtlciBlcnJvcjogJyArIGUuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB3b3JrZXJUaHJlYWQud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgY21kOiAnaW5pdCcsXG4gICAgICAgIHNpemU6IHsgeDogaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSwgeTogaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkgfSxcbiAgICAgICAgaW1hZ2VEYXRhOiB3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhLFxuICAgICAgICBjb25maWc6IGNvbmZpZ0Zvcldvcmtlcihjb25maWcpLFxuICAgIH0sIFt3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhLmJ1ZmZlcl0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRqdXN0V29ya2VyUG9vbChjYXBhY2l0eTogbnVtYmVyLCBjb25maWc/OiBRdWFnZ2FKU0NvbmZpZ09iamVjdCwgaW5wdXRTdHJlYW0/OiBhbnksIGNiPzogRnVuY3Rpb24pIHtcbiAgICBjb25zdCBpbmNyZWFzZUJ5ID0gY2FwYWNpdHkgLSB3b3JrZXJQb29sLmxlbmd0aDtcbiAgICBpZiAoaW5jcmVhc2VCeSA9PT0gMCAmJiBjYikge1xuICAgICAgICBjYigpO1xuICAgIH0gZWxzZSBpZiAoaW5jcmVhc2VCeSA8IDApIHtcbiAgICAgICAgY29uc3Qgd29ya2Vyc1RvVGVybWluYXRlID0gd29ya2VyUG9vbC5zbGljZShpbmNyZWFzZUJ5KTtcbiAgICAgICAgd29ya2Vyc1RvVGVybWluYXRlLmZvckVhY2goZnVuY3Rpb24gKHdvcmtlclRocmVhZCkge1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLndvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnV29ya2VyIHRlcm1pbmF0ZWQhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB3b3JrZXJQb29sID0gd29ya2VyUG9vbC5zbGljZSgwLCBpbmNyZWFzZUJ5KTtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgd29ya2VySW5pdGlhbGl6ZWQgPSAod29ya2VyVGhyZWFkOiBRV29ya2VyVGhyZWFkKSA9PiB7XG4gICAgICAgICAgICB3b3JrZXJQb29sLnB1c2god29ya2VyVGhyZWFkKTtcbiAgICAgICAgICAgIGlmICh3b3JrZXJQb29sLmxlbmd0aCA+PSBjYXBhY2l0eSAmJiBjYikge1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmNyZWFzZUJ5OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpbml0V29ya2VyKGNvbmZpZywgaW5wdXRTdHJlYW0sIHdvcmtlckluaXRpYWxpemVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFJlYWRlcnMocmVhZGVyczogQXJyYXk8UXVhZ2dhSlNSZWFkZXJDb25maWc+KSB7XG4gICAgd29ya2VyUG9vbC5mb3JFYWNoKCh3b3JrZXJUaHJlYWQpID0+IHdvcmtlclRocmVhZC53b3JrZXIucG9zdE1lc3NhZ2UoeyBjbWQ6ICdzZXRSZWFkZXJzJywgcmVhZGVycyB9KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlclJlYWRlcihuYW1lOiBzdHJpbmcsIHJlYWRlcjogYW55KSB7XG4gICAgd29ya2VyUG9vbC5mb3JFYWNoKCh3b3JrZXJUaHJlYWQpID0+IHdvcmtlclRocmVhZC53b3JrZXIucG9zdE1lc3NhZ2UoeyBjbWQ6ICdyZWdpc3RlclJlYWRlcicsIG5hbWUsIHJlYWRlciB9KSk7XG59XG4iLCJpbXBvcnQgeyBJbnB1dFN0cmVhbVR5cGUgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcblxuLy8gVE9ETzogbmVlZCB0byBjcmVhdGUgYW4gSW5wdXRTdHJlYW0gdHlwZXNjcmlwdCBpbnRlcmZhY2UsIHNvIHdlIGRvbid0IGhhdmUgYW4gXCJhbnlcIiBpbiB0aGUgbmV4dCBsaW5lXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR1cElucHV0U3RyZWFtKHR5cGU6IElucHV0U3RyZWFtVHlwZSA9ICdMaXZlU3RyZWFtJywgdmlld3BvcnQ6IEVsZW1lbnQgfCBudWxsLCBJbnB1dFN0cmVhbTogYW55KSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ1ZpZGVvU3RyZWFtJzoge1xuICAgICAgICAgICAgY29uc3QgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2aWRlbyxcbiAgICAgICAgICAgICAgICBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0uY3JlYXRlVmlkZW9TdHJlYW0odmlkZW8pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdJbWFnZVN0cmVhbSc6XG4gICAgICAgICAgICByZXR1cm4geyBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0uY3JlYXRlSW1hZ2VTdHJlYW0oKSB9O1xuICAgICAgICBjYXNlICdMaXZlU3RyZWFtJzoge1xuICAgICAgICAgICAgbGV0IHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICB2aWRlbyA9IHZpZXdwb3J0LnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvJyk7XG4gICAgICAgICAgICAgICAgaWYgKCF2aWRlbykge1xuICAgICAgICAgICAgICAgICAgICB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKHZpZGVvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZpZGVvLFxuICAgICAgICAgICAgICAgIGlucHV0U3RyZWFtOiBJbnB1dFN0cmVhbS5jcmVhdGVMaXZlU3RyZWFtKHZpZGVvKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYCogc2V0dXBJbnB1dFN0cmVhbSBpbnZhbGlkIHR5cGUgJHt0eXBlfWApO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmlkZW86IG51bGwsIGlucHV0U3RyZWFtOiBudWxsIH07XG4gICAgfVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmV4cG9ydCB0eXBlIEJveCA9IEFycmF5PFsgbnVtYmVyLCBudW1iZXIgXT47XG5cbmV4cG9ydCB0eXBlIExpbmUgPSBbIFBvaW50LCBQb2ludCBdO1xuXG5leHBvcnQgZnVuY3Rpb24gbW92ZUJveChib3g6IEJveCwgeE9mZnNldDogbnVtYmVyLCB5T2Zmc2V0OiBudW1iZXIpOiB2b2lkIHtcbiAgICBsZXQgY29ybmVyID0gYm94Lmxlbmd0aDtcbiAgICB3aGlsZSAoY29ybmVyLS0pIHtcbiAgICAgICAgYm94W2Nvcm5lcl1bMF0gKz0geE9mZnNldDtcbiAgICAgICAgYm94W2Nvcm5lcl1bMV0gKz0geU9mZnNldDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb3ZlTGluZShsaW5lOiBMaW5lLCB4T2Zmc2V0OiBudW1iZXIsIHlPZmZzZXQ6IG51bWJlcik6IHZvaWQge1xuICAgIGxpbmVbMF0ueCArPSB4T2Zmc2V0O1xuICAgIGxpbmVbMF0ueSArPSB5T2Zmc2V0O1xuICAgIGxpbmVbMV0ueCArPSB4T2Zmc2V0O1xuICAgIGxpbmVbMV0ueSArPSB5T2Zmc2V0O1xufVxuIiwiaW1wb3J0IHsgY2xvbmUgfSBmcm9tICdnbC12ZWMyJztcbmltcG9ydCB7IFF1YWdnYUNvbnRleHQgfSBmcm9tICcuLi9RdWFnZ2FDb250ZXh0JztcbmltcG9ydCBfaW5pdEJ1ZmZlcnMgZnJvbSAnLi9pbml0QnVmZmVycyc7XG5pbXBvcnQgX2dldFZpZXdQb3J0IGZyb20gJy4vZ2V0Vmlld1BvcnQnO1xuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XG5pbXBvcnQgQmFyY29kZURlY29kZXIgZnJvbSAnLi4vZGVjb2Rlci9iYXJjb2RlX2RlY29kZXInO1xuaW1wb3J0IF9pbml0Q2FudmFzIGZyb20gJy4vaW5pdENhbnZhcyc7XG5pbXBvcnQgQmFyY29kZUxvY2F0b3IgZnJvbSAnLi4vbG9jYXRvci9iYXJjb2RlX2xvY2F0b3InO1xuaW1wb3J0IEJyb3dzZXJJbnB1dFN0cmVhbSwgeyBOb2RlSW5wdXRTdHJlYW0gfSBmcm9tICcuLi9pbnB1dC9pbnB1dF9zdHJlYW1fZmFjdG9yeSc7XG5pbXBvcnQgQnJvd3NlckZyYW1lR3JhYmJlciwgeyBOb2RlRnJhbWVHcmFiYmVyIH0gZnJvbSAnLi4vaW5wdXQvZnJhbWVfZ3JhYmJlcic7XG5pbXBvcnQgKiBhcyBRV29ya2VycyBmcm9tICcuL3F3b3JrZXInO1xuaW1wb3J0IHNldHVwSW5wdXRTdHJlYW0gZnJvbSAnLi9zZXR1cElucHV0U3RyZWFtJztcbmltcG9ydCBDYW1lcmFBY2Nlc3MgZnJvbSAnLi4vaW5wdXQvY2FtZXJhX2FjY2Vzcyc7XG5pbXBvcnQgeyBCYXJjb2RlSW5mbyB9IGZyb20gJy4uL3JlYWRlci9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgeyBtb3ZlTGluZSwgbW92ZUJveCB9IGZyb20gJy4vdHJhbnNmb3JtJztcbmltcG9ydCB7IFF1YWdnYUpTUmVzdWx0T2JqZWN0LCBRdWFnZ2FKU1JlYWRlckNvbmZpZyB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi9jb21tb24vZXZlbnRzJztcblxuY29uc3QgSW5wdXRTdHJlYW0gPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IE5vZGVJbnB1dFN0cmVhbSA6IEJyb3dzZXJJbnB1dFN0cmVhbTtcbmNvbnN0IEZyYW1lR3JhYmJlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gTm9kZUZyYW1lR3JhYmJlciA6IEJyb3dzZXJGcmFtZUdyYWJiZXI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YWdnYSB7XG4gICAgY29udGV4dDogUXVhZ2dhQ29udGV4dCA9IG5ldyBRdWFnZ2FDb250ZXh0KCk7XG5cbiAgICBpbml0QnVmZmVycyhpbWFnZVdyYXBwZXI/OiBJbWFnZVdyYXBwZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpbnB1dEltYWdlV3JhcHBlciwgYm94U2l6ZSB9ID0gX2luaXRCdWZmZXJzKFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLFxuICAgICAgICAgICAgaW1hZ2VXcmFwcGVyLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNvbmZpZy5sb2NhdG9yLFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXIgPSBpbnB1dEltYWdlV3JhcHBlcjtcbiAgICAgICAgdGhpcy5jb250ZXh0LmJveFNpemUgPSBib3hTaXplO1xuICAgIH1cblxuICAgIGluaXRpYWxpemVEYXRhKGltYWdlV3JhcHBlcj86IEltYWdlV3JhcHBlcik6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRCdWZmZXJzKGltYWdlV3JhcHBlcik7XG4gICAgICAgIHRoaXMuY29udGV4dC5kZWNvZGVyID0gQmFyY29kZURlY29kZXIuY3JlYXRlKHRoaXMuY29udGV4dC5jb25maWcuZGVjb2RlciwgdGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyKTtcbiAgICB9XG5cbiAgICBnZXRWaWV3UG9ydCgpOiBFbGVtZW50IHwgbnVsbCB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmNvbmZpZyB8fCAhdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB0YXJnZXQgfSA9IHRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW07XG4gICAgICAgIHJldHVybiBfZ2V0Vmlld1BvcnQodGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZWFkeShjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0ucGxheSgpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIGluaXRDYW52YXMoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IF9pbml0Q2FudmFzKHRoaXMuY29udGV4dCk7XG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjdHgsIGRvbSB9ID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZSA9IGRvbS5pbWFnZTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5kb20ub3ZlcmxheSA9IGRvbS5vdmVybGF5O1xuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmN0eC5pbWFnZSA9IGN0eC5pbWFnZTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5jdHgub3ZlcmxheSA9IGN0eC5vdmVybGF5O1xuICAgIH1cblxuICAgIGNhblJlY29yZCA9IChjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBCYXJjb2RlTG9jYXRvci5jaGVja0ltYWdlQ29uc3RyYWludHModGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLCB0aGlzLmNvbnRleHQuY29uZmlnPy5sb2NhdG9yKTtcbiAgICAgICAgdGhpcy5pbml0Q2FudmFzKCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIgPSBGcmFtZUdyYWJiZXIuY3JlYXRlKFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5kb20uaW1hZ2UsXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIFFXb3JrZXJzLmFkanVzdFdvcmtlclBvb2wodGhpcy5jb250ZXh0LmNvbmZpZy5udW1PZldvcmtlcnMsXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuY29uZmlnLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuY29uZmlnPy5udW1PZldvcmtlcnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplRGF0YSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlYWR5KGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpbml0SW5wdXRTdHJlYW0oY2FsbGJhY2s6IChlcnI/OiBFcnJvcikgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcgfHwgIXRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHR5cGU6IGlucHV0VHlwZSwgY29uc3RyYWludHMgfSA9IHRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW07XG4gICAgICAgIGNvbnN0IHsgdmlkZW8sIGlucHV0U3RyZWFtIH0gPSBzZXR1cElucHV0U3RyZWFtKGlucHV0VHlwZSwgdGhpcy5nZXRWaWV3UG9ydCgpLCBJbnB1dFN0cmVhbSk7XG5cbiAgICAgICAgaWYgKGlucHV0VHlwZSA9PT0gJ0xpdmVTdHJlYW0nICYmIHZpZGVvKSB7XG4gICAgICAgICAgICBDYW1lcmFBY2Nlc3MucmVxdWVzdCh2aWRlbywgY29uc3RyYWludHMpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gaW5wdXRTdHJlYW0udHJpZ2dlcignY2FucmVjb3JkJykpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IGNhbGxiYWNrKGVycikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXRTdHJlYW0uc2V0QXR0cmlidXRlKCdwcmVsb2FkJywgJ2F1dG8nKTtcbiAgICAgICAgaW5wdXRTdHJlYW0uc2V0SW5wdXRTdHJlYW0odGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbSk7XG4gICAgICAgIGlucHV0U3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnJlY29yZCcsIHRoaXMuY2FuUmVjb3JkLmJpbmQodW5kZWZpbmVkLCBjYWxsYmFjaykpO1xuXG4gICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSA9IGlucHV0U3RyZWFtO1xuICAgIH1cblxuICAgIGdldEJvdW5kaW5nQm94ZXMoKTogQXJyYXk8QXJyYXk8bnVtYmVyPj4gfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5jb25maWc/LmxvY2F0ZSA/IEJhcmNvZGVMb2NhdG9yLmxvY2F0ZSgpXG4gICAgICAgICAgICA6IFtbXG4gICAgICAgICAgICAgICAgY2xvbmUodGhpcy5jb250ZXh0LmJveFNpemVbMF0pLFxuICAgICAgICAgICAgICAgIGNsb25lKHRoaXMuY29udGV4dC5ib3hTaXplWzFdKSxcbiAgICAgICAgICAgICAgICBjbG9uZSh0aGlzLmNvbnRleHQuYm94U2l6ZVsyXSksXG4gICAgICAgICAgICAgICAgY2xvbmUodGhpcy5jb250ZXh0LmJveFNpemVbM10pLFxuICAgICAgICAgICAgXV07XG4gICAgfVxuXG4gICAgLy8gVE9ETzogbmVlZCBhIHR5cGVzY3JpcHQgdHlwZSBmb3IgcmVzdWx0IGhlcmUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbiAgICB0cmFuc2Zvcm1SZXN1bHQocmVzdWx0OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdG9wUmlnaHQgPSB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0uZ2V0VG9wUmlnaHQoKTtcbiAgICAgICAgY29uc3QgeE9mZnNldCA9IHRvcFJpZ2h0Lng7XG4gICAgICAgIGNvbnN0IHlPZmZzZXQgPSB0b3BSaWdodC55O1xuXG4gICAgICAgIGlmICh4T2Zmc2V0ID09PSAwICYmIHlPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQuYmFyY29kZXMpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IEJhcmNvZGVJbmZvIG1heSBub3QgYmUgdGhlIHJpZ2h0IHR5cGUgaGVyZS5cbiAgICAgICAgICAgIHJlc3VsdC5iYXJjb2Rlcy5mb3JFYWNoKChiYXJjb2RlOiBCYXJjb2RlSW5mbykgPT4gdGhpcy50cmFuc2Zvcm1SZXN1bHQoYmFyY29kZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5saW5lICYmIHJlc3VsdC5saW5lLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgbW92ZUxpbmUocmVzdWx0LmxpbmUsIHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5ib3gpIHtcbiAgICAgICAgICAgIG1vdmVCb3gocmVzdWx0LmJveCwgeE9mZnNldCwgeU9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0LmJveGVzICYmIHJlc3VsdC5ib3hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5ib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG1vdmVCb3gocmVzdWx0LmJveGVzW2ldLCB4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZFJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0LCBpbWFnZURhdGE6IEFycmF5PG51bWJlcj4pOiB2b2lkIHtcbiAgICAgICAgaWYgKCFpbWFnZURhdGEgfHwgIXRoaXMuY29udGV4dC5yZXN1bHRDb2xsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2hhdCBkYXRhIHN0cnVjdHVyZSBob2xkcyBhIFwiYmFyY29kZXNcIiByZXN1bHQsIGlmIGFueS4uLlxuICAgICAgICBpZiAocmVzdWx0LmJhcmNvZGVzKSB7XG4gICAgICAgICAgICByZXN1bHQuYmFyY29kZXMuZmlsdGVyKChiYXJjb2RlOiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCkgPT4gYmFyY29kZS5jb2RlUmVzdWx0KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChiYXJjb2RlOiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCkgPT4gdGhpcy5hZGRSZXN1bHQoYmFyY29kZSwgaW1hZ2VEYXRhKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmNvZGVSZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZXN1bHRDb2xsZWN0b3IuYWRkUmVzdWx0KFxuICAgICAgICAgICAgICAgIGltYWdlRGF0YSxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpLFxuICAgICAgICAgICAgICAgIHJlc3VsdC5jb2RlUmVzdWx0LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgaGFzQ29kZVJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhIShyZXN1bHQgJiYgKHJlc3VsdC5iYXJjb2Rlc1xuICAgICAgICAgICAgPyByZXN1bHQuYmFyY29kZXMuc29tZSgoYmFyY29kZSkgPT4gYmFyY29kZS5jb2RlUmVzdWx0KVxuICAgICAgICAgICAgOiByZXN1bHQuY29kZVJlc3VsdCkpO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG4gICAgcHVibGlzaFJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0IHwgbnVsbCA9IG51bGwsIGltYWdlRGF0YT86IGFueSk6IHZvaWQge1xuICAgICAgICBsZXQgcmVzdWx0VG9QdWJsaXNoOiBBcnJheTxRdWFnZ2FKU1Jlc3VsdE9iamVjdD4gfCBRdWFnZ2FKU1Jlc3VsdE9iamVjdCB8IG51bGwgPSByZXN1bHQ7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAmJiB0aGlzLmNvbnRleHQub25VSVRocmVhZCkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1SZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgIHRoaXMuYWRkUmVzdWx0KHJlc3VsdCwgaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIHJlc3VsdFRvUHVibGlzaCA9IHJlc3VsdC5iYXJjb2RlcyB8fCByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBFdmVudHMucHVibGlzaCgncHJvY2Vzc2VkJywgcmVzdWx0VG9QdWJsaXNoIGFzIG5ldmVyKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29kZVJlc3VsdChyZXN1bHQgYXMgUXVhZ2dhSlNSZXN1bHRPYmplY3QpKSB7XG4gICAgICAgICAgICBFdmVudHMucHVibGlzaCgnZGV0ZWN0ZWQnLCByZXN1bHRUb1B1Ymxpc2ggYXMgbmV2ZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9jYXRlQW5kRGVjb2RlKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBib3hlcyA9IHRoaXMuZ2V0Qm91bmRpbmdCb3hlcygpO1xuICAgICAgICBpZiAoYm94ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZVJlc3VsdCA9IHRoaXMuY29udGV4dC5kZWNvZGVyLmRlY29kZUZyb21Cb3VuZGluZ0JveGVzKGJveGVzKSB8fCB7fTtcbiAgICAgICAgICAgIGRlY29kZVJlc3VsdC5ib3hlcyA9IGJveGVzO1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVzdWx0KGRlY29kZVJlc3VsdCwgdGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyPy5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlUmVzdWx0ID0gdGhpcy5jb250ZXh0LmRlY29kZXIuZGVjb2RlRnJvbUltYWdlKHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICBpZiAoaW1hZ2VSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZXN1bHQoaW1hZ2VSZXN1bHQsIHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcj8uZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaFJlc3VsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlID0gKCk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0Lm9uVUlUaHJlYWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHdvcmtlcnNVcGRhdGVkID0gUVdvcmtlcnMudXBkYXRlV29ya2Vycyh0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyKTtcbiAgICAgICAgICAgIGlmICghd29ya2Vyc1VwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyLmF0dGFjaERhdGEodGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyPy5kYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlci5ncmFiKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF3b3JrZXJzVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2NhdGVBbmREZWNvZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIuYXR0YWNoRGF0YSh0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXI/LmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlci5ncmFiKCk7XG4gICAgICAgICAgICB0aGlzLmxvY2F0ZUFuZERlY29kZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHN0YXJ0Q29udGludW91c1VwZGF0ZSgpOiB2b2lkIHtcbiAgICAgICAgbGV0IG5leHQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICBjb25zdCBkZWxheSA9IDEwMDAgLyAodGhpcy5jb250ZXh0LmNvbmZpZz8uZnJlcXVlbmN5IHx8IDYwKTtcblxuICAgICAgICB0aGlzLmNvbnRleHQuc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCB7IGNvbnRleHQgfSA9IHRoaXM7XG5cbiAgICAgICAgY29uc3QgbmV3RnJhbWUgPSAodGltZXN0YW1wOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0IHx8IHRpbWVzdGFtcDtcbiAgICAgICAgICAgIGlmICghY29udGV4dC5zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVzdGFtcCA+PSBuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgKz0gZGVsYXk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobmV3RnJhbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIG5ld0ZyYW1lKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICB9XG5cbiAgICBzdGFydCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5vblVJVGhyZWFkICYmIHRoaXMuY29udGV4dC5jb25maWc/LmlucHV0U3RyZWFtPy50eXBlID09PSAnTGl2ZVN0cmVhbScpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRDb250aW51b3VzVXBkYXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RvcCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICBRV29ya2Vycy5hZGp1c3RXb3JrZXJQb29sKDApO1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmNvbmZpZz8uaW5wdXRTdHJlYW0gJiYgdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbS50eXBlID09PSAnTGl2ZVN0cmVhbScpIHtcbiAgICAgICAgICAgIENhbWVyYUFjY2Vzcy5yZWxlYXNlKCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0uY2xlYXJFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRSZWFkZXJzKHJlYWRlcnM6IEFycmF5PFF1YWdnYUpTUmVhZGVyQ29uZmlnPik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmRlY29kZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5kZWNvZGVyLnNldFJlYWRlcnMocmVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgUVdvcmtlcnMuc2V0UmVhZGVycyhyZWFkZXJzKTtcbiAgICB9XG5cbiAgICByZWdpc3RlclJlYWRlcihuYW1lOiBzdHJpbmcsIHJlYWRlcjogUXVhZ2dhSlNSZWFkZXJDb25maWcpOiB2b2lkIHtcbiAgICAgICAgQmFyY29kZURlY29kZXIucmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5kZWNvZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZGVjb2Rlci5yZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIFFXb3JrZXJzLnJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcik7XG4gICAgfVxufVxuIiwiaW1wb3J0IFR5cGVEZWZzIGZyb20gJy4vY29tbW9uL3R5cGVkZWZzJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuL2NvbW1vbi9pbWFnZV93cmFwcGVyJztcbmltcG9ydCBCYXJjb2RlRGVjb2RlciBmcm9tICcuL2RlY29kZXIvYmFyY29kZV9kZWNvZGVyJztcbmltcG9ydCBCYXJjb2RlUmVhZGVyIGZyb20gJy4vcmVhZGVyL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCBFdmVudHMgZnJvbSAnLi9jb21tb24vZXZlbnRzJztcbmltcG9ydCBDYW1lcmFBY2Nlc3MgZnJvbSAnLi9pbnB1dC9jYW1lcmFfYWNjZXNzJztcbmltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4vY29tbW9uL2ltYWdlX2RlYnVnJztcbmltcG9ydCBSZXN1bHRDb2xsZWN0b3IgZnJvbSAnLi9hbmFseXRpY3MvcmVzdWx0X2NvbGxlY3Rvcic7XG5pbXBvcnQgQ29uZmlnIGZyb20gJy4vY29uZmlnL2NvbmZpZyc7XG5pbXBvcnQgeyBtZXJnZSB9IGZyb20gJ2xvZGFzaCc7XG5cbmltcG9ydCBRdWFnZ2EgZnJvbSAnLi9xdWFnZ2EvcXVhZ2dhJztcblxuY29uc3QgaW5zdGFuY2UgPSBuZXcgUXVhZ2dhKCk7XG5jb25zdCBfY29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG5cbmNvbnN0IFF1YWdnYUpTU3RhdGljSW50ZXJmYWNlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uIChjb25maWcsIGNiLCBpbWFnZVdyYXBwZXIsIHF1YWdnYUluc3RhbmNlID0gaW5zdGFuY2UpIHtcbiAgICAgICAgbGV0IHByb21pc2U7XG4gICAgICAgIGlmICghY2IpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY2IgPSAoZXJyKSA9PiB7IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSgpOyB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcXVhZ2dhSW5zdGFuY2UuY29udGV4dC5jb25maWcgPSBtZXJnZSh7fSwgQ29uZmlnLCBjb25maWcpO1xuICAgICAgICAvLyBUT0RPICMxNzk6IHBlbmRpbmcgcmVzdHJ1Y3R1cmUgaW4gSXNzdWUgIzE3OSwgd2UgYXJlIHRlbXAgZGlzYWJsaW5nIHdvcmtlcnNcbiAgICAgICAgaWYgKHF1YWdnYUluc3RhbmNlLmNvbnRleHQuY29uZmlnLm51bU9mV29ya2VycyA+IDApIHtcbiAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLmNvbnRleHQuY29uZmlnLm51bU9mV29ya2VycyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltYWdlV3JhcHBlcikge1xuICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2UuY29udGV4dC5vblVJVGhyZWFkID0gZmFsc2U7XG4gICAgICAgICAgICBxdWFnZ2FJbnN0YW5jZS5pbml0aWFsaXplRGF0YShpbWFnZVdyYXBwZXIpO1xuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLmluaXRJbnB1dFN0cmVhbShjYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfSxcbiAgICBzdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnN0YW5jZS5zdGFydCgpO1xuICAgIH0sXG4gICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnN0YW5jZS5zdG9wKCk7XG4gICAgfSxcbiAgICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBfY29udGV4dC5zdG9wcGVkID0gdHJ1ZTtcbiAgICB9LFxuICAgIG9uRGV0ZWN0ZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrIHx8ICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicgJiYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ29iamVjdCcgfHwgIWNhbGxiYWNrLmNhbGxiYWNrKSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLm9uRGV0ZWN0ZWQgY2FsbGVkIHdpdGggaW52YWxpZCBjYWxsYmFjaywgaWdub3JpbmcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBFdmVudHMuc3Vic2NyaWJlKCdkZXRlY3RlZCcsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIG9mZkRldGVjdGVkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgRXZlbnRzLnVuc3Vic2NyaWJlKCdkZXRlY3RlZCcsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIG9uUHJvY2Vzc2VkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjayB8fCAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nICYmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdvYmplY3QnIHx8ICFjYWxsYmFjay5jYWxsYmFjaykpKSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5vblByb2Nlc3NlZCBjYWxsZWQgd2l0aCBpbnZhbGlkIGNhbGxiYWNrLCBpZ25vcmluZycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIEV2ZW50cy5zdWJzY3JpYmUoJ3Byb2Nlc3NlZCcsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIG9mZlByb2Nlc3NlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIEV2ZW50cy51bnN1YnNjcmliZSgncHJvY2Vzc2VkJywgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgc2V0UmVhZGVyczogZnVuY3Rpb24gKHJlYWRlcnMpIHtcbiAgICAgICAgaWYgKCFyZWFkZXJzKSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5zZXRSZWFkZXJzIGNhbGxlZCB3aXRoIG5vIHJlYWRlcnMsIGlnbm9yaW5nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2Uuc2V0UmVhZGVycyhyZWFkZXJzKTtcbiAgICB9LFxuICAgIHJlZ2lzdGVyUmVhZGVyOiBmdW5jdGlvbiAobmFtZSwgcmVhZGVyKSB7XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgY29uc29sZS50cmFjZSgnKiB3YXJuaW5nOiBRdWFnZ2EucmVnaXN0ZXJSZWFkZXIgY2FsbGVkIHdpdGggbm8gbmFtZSwgaWdub3JpbmcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlYWRlcikge1xuICAgICAgICAgICAgY29uc29sZS50cmFjZSgnKiB3YXJuaW5nOiBRdWFnZ2EucmVnaXN0ZXJSZWFkZXIgY2FsbGVkIHdpdGggbm8gcmVhZGVyLCBpZ25vcmluZycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLnJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcik7XG4gICAgfSxcbiAgICByZWdpc3RlclJlc3VsdENvbGxlY3RvcjogZnVuY3Rpb24gKHJlc3VsdENvbGxlY3Rvcikge1xuICAgICAgICBpZiAocmVzdWx0Q29sbGVjdG9yICYmIHR5cGVvZiByZXN1bHRDb2xsZWN0b3IuYWRkUmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBfY29udGV4dC5yZXN1bHRDb2xsZWN0b3IgPSByZXN1bHRDb2xsZWN0b3I7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldCBjYW52YXMoKSB7XG4gICAgICAgIHJldHVybiBfY29udGV4dC5jYW52YXNDb250YWluZXI7XG4gICAgfSxcbiAgICBkZWNvZGVTaW5nbGU6IGZ1bmN0aW9uIChjb25maWcsIHJlc3VsdENhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHF1YWdnYUluc3RhbmNlID0gbmV3IFF1YWdnYSgpO1xuICAgICAgICBjb25maWcgPSBtZXJnZSh7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbToge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdJbWFnZVN0cmVhbScsXG4gICAgICAgICAgICAgICAgc2VxdWVuY2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNpemU6IDgwMCxcbiAgICAgICAgICAgICAgICBzcmM6IGNvbmZpZy5zcmMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbnVtT2ZXb3JrZXJzOiAoRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZWJ1ZykgPyAwIDogMSxcbiAgICAgICAgICAgIGxvY2F0b3I6IHtcbiAgICAgICAgICAgICAgICBoYWxmU2FtcGxlOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIGNvbmZpZyk7XG4gICAgICAgIC8vIFRPRE8gIzE3NTogcmVzdHJ1Y3R1cmUgd29ya2VyIHN1cHBvcnQgc28gdGhhdCBpdCB3aWxsIHdvcmsgd2l0aCB0eXBlc2NyaXB0IHVzaW5nIHdvcmtlci1sb2FkZXJcbiAgICAgICAgLy8gaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9sb2FkZXJzL3dvcmtlci1sb2FkZXIvXG4gICAgICAgIGlmIChjb25maWcubnVtT2ZXb3JrZXJzID4gMCkge1xuICAgICAgICAgICAgY29uZmlnLm51bU9mV29ya2VycyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd29ya2VycyByZXF1aXJlIFdvcmtlciBhbmQgQmxvYiBzdXBwb3J0IHByZXNlbnRseSwgc28gaWYgbm8gQmxvYiBvciBXb3JrZXIgdGhlbiBzZXRcbiAgICAgICAgLy8gd29ya2VycyB0byAwLlxuICAgICAgICBpZiAoY29uZmlnLm51bU9mV29ya2VycyA+IDAgJiYgKHR5cGVvZiBCbG9iID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgV29ya2VyID09PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignKiBubyBXb3JrZXIgYW5kL29yIEJsb2Igc3VwcG9ydCAtIGZvcmNpbmcgbnVtT2ZXb3JrZXJzIHRvIDAnKTtcbiAgICAgICAgICAgIGNvbmZpZy5udW1PZldvcmtlcnMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdChjb25maWcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgRXZlbnRzLm9uY2UoJ3Byb2Nlc3NlZCcsIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdENhbGxiYWNrLmNhbGwobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgfSwgbnVsbCwgcXVhZ2dhSW5zdGFuY2UpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gYWRkIHRoZSB1c3VhbGx5IGV4cGVjdGVkIFwiZGVmYXVsdFwiIGZvciB1c2Ugd2l0aCByZXF1aXJlLCBidWlsZCBzdGVwIHdvbid0IGFsbG93IHVzIHRvXG4gICAgLy8gd3JpdGUgdG8gbW9kdWxlLmV4cG9ydHMgc28gZG8gaXQgaGVyZS5cbiAgICBnZXQgZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIFF1YWdnYUpTU3RhdGljSW50ZXJmYWNlO1xuICAgIH0sXG4gICAgQmFyY29kZVJlYWRlcixcbiAgICBDYW1lcmFBY2Nlc3MsXG4gICAgSW1hZ2VEZWJ1ZyxcbiAgICBJbWFnZVdyYXBwZXIsXG4gICAgUmVzdWx0Q29sbGVjdG9yLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgUXVhZ2dhSlNTdGF0aWNJbnRlcmZhY2U7XG4vLyBleHBvcnQgQmFyY29kZVJlYWRlciBhbmQgb3RoZXIgdXRpbGl0aWVzIGZvciBleHRlcm5hbCBwbHVnaW5zXG5leHBvcnQge1xuICAgIEJhcmNvZGVEZWNvZGVyLFxuICAgIEJhcmNvZGVSZWFkZXIsXG4gICAgQ2FtZXJhQWNjZXNzLFxuICAgIEltYWdlRGVidWcsXG4gICAgSW1hZ2VXcmFwcGVyLFxuICAgIFJlc3VsdENvbGxlY3Rvcixcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9